; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\jquant2.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jquant2.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\JPEG\jquant2.c]
                          THUMB

                          AREA ||i.compute_color||, CODE, READONLY, ALIGN=1

                  compute_color PROC
;;;499    LOCAL(void)
;;;500    compute_color (j_decompress_ptr cinfo, boxptr boxp, int icolor)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;501    /* Compute representative color for a box, put it in colormap[icolor] */
;;;502    {
;;;503      /* Current algorithm: mean weighted by pixels (not colors) */
;;;504      /* Note it is important to get the rounding correct! */
;;;505      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
;;;506      hist3d histogram = cquantize->histogram;
000004  f8d021cc          LDR      r2,[r0,#0x1cc]
000008  b086              SUB      sp,sp,#0x18           ;502
00000a  6992              LDR      r2,[r2,#0x18]
;;;507      histptr histp;
;;;508      int c0,c1,c2;
;;;509      int c0min,c0max,c1min,c1max,c2min,c2max;
;;;510      long count;
;;;511      long total = 0;
00000c  9205              STR      r2,[sp,#0x14]
;;;512      long c0total = 0;
;;;513      long c1total = 0;
;;;514      long c2total = 0;
00000e  e9d13400          LDRD     r3,r4,[r1,#0]
;;;515      
;;;516      c0min = boxp->c0min;  c0max = boxp->c0max;
;;;517      c1min = boxp->c1min;  c1max = boxp->c1max;
000012  9404              STR      r4,[sp,#0x10]
000014  688c              LDR      r4,[r1,#8]
000016  9403              STR      r4,[sp,#0xc]
000018  68cc              LDR      r4,[r1,#0xc]
00001a  2200              MOVS     r2,#0                 ;511
;;;518      c2min = boxp->c2min;  c2max = boxp->c2max;
00001c  9402              STR      r4,[sp,#8]
00001e  e9d1e704          LDRD     lr,r7,[r1,#0x10]      ;502
000022  4693              MOV      r11,r2                ;512
000024  4692              MOV      r10,r2                ;513
000026  4691              MOV      r9,r2                 ;514
000028  e02c              B        |L1.132|
                  |L1.42|
;;;519      
;;;520      for (c0 = c0min; c0 <= c0max; c0++)
;;;521        for (c1 = c1min; c1 <= c1max; c1++) {
00002a  9903              LDR      r1,[sp,#0xc]
00002c  e026              B        |L1.124|
                  |L1.46|
;;;522          histp = & histogram[c0][c1][c2min];
00002e  9c05              LDR      r4,[sp,#0x14]
000030  018d              LSLS     r5,r1,#6
000032  eb05054e          ADD      r5,r5,lr,LSL #1
000036  f8544023          LDR      r4,[r4,r3,LSL #2]
00003a  192e              ADDS     r6,r5,r4
;;;523          for (c2 = c2min; c2 <= c2max; c2++) {
00003c  2504              MOVS     r5,#4
;;;524    	if ((count = *histp++) != 0) {
;;;525    	  total += count;
;;;526    	  c0total += ((c0 << C0_SHIFT) + ((1<<C0_SHIFT)>>1)) * count;
00003e  eb0505c3          ADD      r5,r5,r3,LSL #3
;;;527    	  c1total += ((c1 << C1_SHIFT) + ((1<<C1_SHIFT)>>1)) * count;
000042  9501              STR      r5,[sp,#4]
000044  2502              MOVS     r5,#2
000046  eb050581          ADD      r5,r5,r1,LSL #2
00004a  4674              MOV      r4,lr                 ;523
00004c  9500              STR      r5,[sp,#0]            ;523
00004e  e012              B        |L1.118|
                  |L1.80|
000050  f8365b02          LDRH     r5,[r6],#2            ;524
000054  b175              CBZ      r5,|L1.116|
000056  f8ddc004          LDR      r12,[sp,#4]           ;526
00005a  442a              ADD      r2,r2,r5              ;525
00005c  fb0cbb05          MLA      r11,r12,r5,r11        ;526
000060  f8ddc000          LDR      r12,[sp,#0]
000064  fb0caa05          MLA      r10,r12,r5,r10
;;;528    	  c2total += ((c2 << C2_SHIFT) + ((1<<C2_SHIFT)>>1)) * count;
000068  f04f0c04          MOV      r12,#4
00006c  eb0c0cc4          ADD      r12,r12,r4,LSL #3
000070  fb0c9905          MLA      r9,r12,r5,r9
                  |L1.116|
000074  1c64              ADDS     r4,r4,#1
                  |L1.118|
000076  42bc              CMP      r4,r7                 ;523
000078  ddea              BLE      |L1.80|
00007a  1c49              ADDS     r1,r1,#1              ;523
                  |L1.124|
00007c  9c02              LDR      r4,[sp,#8]            ;521
00007e  42a1              CMP      r1,r4                 ;521
000080  ddd5              BLE      |L1.46|
000082  1c5b              ADDS     r3,r3,#1              ;521
                  |L1.132|
000084  9904              LDR      r1,[sp,#0x10]         ;520
000086  428b              CMP      r3,r1                 ;520
000088  ddcf              BLE      |L1.42|
;;;529    	}
;;;530          }
;;;531        }
;;;532      
;;;533      cinfo->colormap[0][icolor] = (JSAMPLE) ((c0total + (total>>1)) / total);
00008a  eb0b0162          ADD      r1,r11,r2,ASR #1
00008e  f8503f88          LDR      r3,[r0,#0x88]!
000092  fb91f1f2          SDIV     r1,r1,r2
000096  681c              LDR      r4,[r3,#0]
000098  9b08              LDR      r3,[sp,#0x20]
00009a  54e1              STRB     r1,[r4,r3]
;;;534      cinfo->colormap[1][icolor] = (JSAMPLE) ((c1total + (total>>1)) / total);
00009c  eb0a0162          ADD      r1,r10,r2,ASR #1
0000a0  6803              LDR      r3,[r0,#0]
0000a2  fb91f1f2          SDIV     r1,r1,r2
0000a6  685c              LDR      r4,[r3,#4]
0000a8  9b08              LDR      r3,[sp,#0x20]
0000aa  54e1              STRB     r1,[r4,r3]
;;;535      cinfo->colormap[2][icolor] = (JSAMPLE) ((c2total + (total>>1)) / total);
0000ac  eb090162          ADD      r1,r9,r2,ASR #1
0000b0  fb91f1f2          SDIV     r1,r1,r2
0000b4  6800              LDR      r0,[r0,#0]
0000b6  6882              LDR      r2,[r0,#8]
0000b8  9808              LDR      r0,[sp,#0x20]
0000ba  5411              STRB     r1,[r2,r0]
;;;536    }
0000bc  b009              ADD      sp,sp,#0x24
0000be  e8bd8ff0          POP      {r4-r11,pc}
;;;537    
                          ENDP


                          AREA ||i.fill_inverse_cmap||, CODE, READONLY, ALIGN=2

                  fill_inverse_cmap PROC
;;;855    LOCAL(void)
;;;856    fill_inverse_cmap (j_decompress_ptr cinfo, int c0, int c1, int c2)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;857    /* Fill the inverse-colormap entries in the update box that contains */
;;;858    /* histogram cell c0/c1/c2.  (Only that one cell MUST be filled, but */
;;;859    /* we can fill as many others as we wish.) */
;;;860    {
000004  4683              MOV      r11,r0
;;;861      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000006  f8d001cc          LDR      r0,[r0,#0x1cc]
;;;862      hist3d histogram = cquantize->histogram;
;;;863      int minc0, minc1, minc2;	/* lower left corner of update box */
;;;864      int ic0, ic1, ic2;
;;;865      register JSAMPLE * cptr;	/* pointer into bestcolor[] array */
;;;866      register histptr cachep;	/* pointer into main cache array */
;;;867      /* This array lists the candidate colormap indexes. */
;;;868      JSAMPLE colorlist[MAXNUMCOLORS];
;;;869      int numcolors;		/* number of candidate colors */
;;;870      /* This array holds the actually closest colormap index for each cell. */
;;;871      JSAMPLE bestcolor[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];
;;;872    
;;;873      /* Convert cell coordinates to update box ID */
;;;874      c0 >>= BOX_C0_LOG;
00000a  108f              ASRS     r7,r1,#2
;;;875      c1 >>= BOX_C1_LOG;
;;;876      c2 >>= BOX_C2_LOG;
00000c  109d              ASRS     r5,r3,#2
;;;877    
;;;878      /* Compute true coordinates of update box's origin corner.
;;;879       * Actually we compute the coordinates of the center of the corner
;;;880       * histogram cell, which are the lower bounds of the volume we care about.
;;;881       */
;;;882      minc0 = (c0 << BOX_C0_SHIFT) + ((1 << C0_SHIFT) >> 1);
00000e  6984              LDR      r4,[r0,#0x18]
000010  2004              MOVS     r0,#4
000012  10d6              ASRS     r6,r2,#3              ;875
000014  eb001a47          ADD      r10,r0,r7,LSL #5
;;;883      minc1 = (c1 << BOX_C1_SHIFT) + ((1 << C1_SHIFT) >> 1);
000018  2102              MOVS     r1,#2
;;;884      minc2 = (c2 << BOX_C2_SHIFT) + ((1 << C2_SHIFT) >> 1);
00001a  eb001845          ADD      r8,r0,r5,LSL #5
00001e  b0e3              SUB      sp,sp,#0x18c          ;860
000020  eb011146          ADD      r1,r1,r6,LSL #5       ;883
;;;885      
;;;886      /* Determine which colormap entries are close enough to be candidates
;;;887       * for the nearest entry to some cell in the update box.
;;;888       */
;;;889      numcolors = find_nearby_colors(cinfo, minc0, minc1, minc2, colorlist);
000024  a803              ADD      r0,sp,#0xc
000026  4689              MOV      r9,r1                 ;883
000028  460a              MOV      r2,r1
00002a  9000              STR      r0,[sp,#0]
00002c  4643              MOV      r3,r8
00002e  4651              MOV      r1,r10
000030  4658              MOV      r0,r11
000032  f7fffffe          BL       find_nearby_colors
;;;890    
;;;891      /* Determine the actually nearest colors. */
;;;892      find_best_colors(cinfo, minc0, minc1, minc2, numcolors, colorlist,
000036  aa43              ADD      r2,sp,#0x10c
000038  a903              ADD      r1,sp,#0xc
00003a  e88d0007          STM      sp,{r0-r2}
00003e  4643              MOV      r3,r8
000040  464a              MOV      r2,r9
000042  4651              MOV      r1,r10
000044  4658              MOV      r0,r11
000046  f7fffffe          BL       find_best_colors
;;;893    		   bestcolor);
;;;894    
;;;895      /* Save the best color numbers (plus 1) in the main cache array */
;;;896      c0 <<= BOX_C0_LOG;		/* convert ID back to base cell indexes */
;;;897      c1 <<= BOX_C1_LOG;
00004a  00f6              LSLS     r6,r6,#3
00004c  ea4f0c85          LSL      r12,r5,#2
000050  ea4f0987          LSL      r9,r7,#2              ;892
;;;898      c2 <<= BOX_C2_LOG;
;;;899      cptr = bestcolor;
000054  ad43              ADD      r5,sp,#0x10c
;;;900      for (ic0 = 0; ic0 < BOX_C0_ELEMS; ic0++) {
000056  2100              MOVS     r1,#0
                  |L2.88|
;;;901        for (ic1 = 0; ic1 < BOX_C1_ELEMS; ic1++) {
000058  2000              MOVS     r0,#0
;;;902          cachep = & histogram[c0+ic0][c1+ic1][c2];
00005a  eb090701          ADD      r7,r9,r1
                  |L2.94|
00005e  1832              ADDS     r2,r6,r0
000060  0192              LSLS     r2,r2,#6
000062  f8543027          LDR      r3,[r4,r7,LSL #2]
000066  eb02024c          ADD      r2,r2,r12,LSL #1
00006a  4413              ADD      r3,r3,r2
;;;903          for (ic2 = 0; ic2 < BOX_C2_ELEMS; ic2++) {
00006c  f05f0200          MOVS.W   r2,#0
                  |L2.112|
;;;904    	*cachep++ = (histcell) (GETJSAMPLE(*cptr++) + 1);
000070  f8158b01          LDRB     r8,[r5],#1
000074  1c52              ADDS     r2,r2,#1
000076  f1080801          ADD      r8,r8,#1
00007a  f8238b02          STRH     r8,[r3],#2
00007e  2a04              CMP      r2,#4                 ;903
000080  dbf6              BLT      |L2.112|
000082  1c40              ADDS     r0,r0,#1              ;903
000084  2808              CMP      r0,#8                 ;901
000086  dbea              BLT      |L2.94|
000088  1c49              ADDS     r1,r1,#1              ;901
00008a  2904              CMP      r1,#4                 ;900
00008c  dbe4              BLT      |L2.88|
;;;905          }
;;;906        }
;;;907      }
;;;908    }
00008e  b063              ADD      sp,sp,#0x18c
000090  e8bd8ff0          POP      {r4-r11,pc}
;;;909    
                          ENDP


                          AREA ||i.find_best_colors||, CODE, READONLY, ALIGN=1

                  find_best_colors PROC
;;;775    LOCAL(void)
;;;776    find_best_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;777    		  int numcolors, JSAMPLE colorlist[], JSAMPLE bestcolor[])
;;;778    /* Find the closest colormap entry for each cell in the update box,
;;;779     * given the list of candidate colors prepared by find_nearby_colors.
;;;780     * Return the indexes of the closest entries in the bestcolor[] array.
;;;781     * This routine uses Thomas' incremental distance calculation method to
;;;782     * find the distance from a colormap entry to successive cells in the box.
;;;783     */
;;;784    {
000004  f5ad7d02          SUB      sp,sp,#0x208
;;;785      int ic0, ic1, ic2;
;;;786      int i, icolor;
;;;787      register INT32 * bptr;	/* pointer into bestdist[] array */
;;;788      JSAMPLE * cptr;		/* pointer into bestcolor[] array */
;;;789      INT32 dist0, dist1;		/* initial distance values */
;;;790      register INT32 dist2;		/* current distance in inner loop */
;;;791      INT32 xx0, xx1;		/* distance increments */
;;;792      register INT32 xx2;
;;;793      INT32 inc0, inc1, inc2;	/* initial values for increments */
;;;794      /* This array holds the distance to the nearest-so-far color for each cell */
;;;795      INT32 bestdist[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];
;;;796    
;;;797      /* Initialize best-distance for each cell of the update box */
;;;798      bptr = bestdist;
000008  4668              MOV      r0,sp
;;;799      for (i = BOX_C0_ELEMS*BOX_C1_ELEMS*BOX_C2_ELEMS-1; i >= 0; i--)
00000a  217f              MOVS     r1,#0x7f
;;;800        *bptr++ = 0x7FFFFFFFL;
00000c  f06f4200          MVN      r2,#0x80000000
                  |L3.16|
000010  c004              STM      r0!,{r2}
000012  1e49              SUBS     r1,r1,#1
000014  d5fc              BPL      |L3.16|
;;;801      
;;;802      /* For each color selected by find_nearby_colors,
;;;803       * compute its distance to the center of each cell in the box.
;;;804       * If that's less than best-so-far, update best distance and color number.
;;;805       */
;;;806      
;;;807      /* Nominal steps between cell centers ("x" in Thomas article) */
;;;808    #define STEP_C0  ((1 << C0_SHIFT) * C0_SCALE)
;;;809    #define STEP_C1  ((1 << C1_SHIFT) * C1_SCALE)
;;;810    #define STEP_C2  ((1 << C2_SHIFT) * C2_SCALE)
;;;811      
;;;812      for (i = 0; i < numcolors; i++) {
000016  2000              MOVS     r0,#0
000018  e053              B        |L3.194|
                  |L3.26|
;;;813        icolor = GETJSAMPLE(colorlist[i]);
00001a  9890              LDR      r0,[sp,#0x240]
;;;814        /* Compute (square of) distance from minc0/c1/c2 to this color */
;;;815        inc0 = (minc0 - GETJSAMPLE(cinfo->colormap[0][icolor])) * C0_SCALE;
;;;816        dist0 = inc0*inc0;
;;;817        inc1 = (minc1 - GETJSAMPLE(cinfo->colormap[1][icolor])) * C1_SCALE;
;;;818        dist0 += inc1*inc1;
;;;819        inc2 = (minc2 - GETJSAMPLE(cinfo->colormap[2][icolor])) * C2_SCALE;
;;;820        dist0 += inc2*inc2;
;;;821        /* Form the initial difference increments */
;;;822        inc0 = inc0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;
;;;823        inc1 = inc1 * (2 * STEP_C1) + STEP_C1 * STEP_C1;
;;;824        inc2 = inc2 * (2 * STEP_C2) + STEP_C2 * STEP_C2;
;;;825        /* Now loop over all cells in box, updating distance per Thomas method */
;;;826        bptr = bestdist;
;;;827        cptr = bestcolor;
;;;828        xx0 = inc0;
;;;829        for (ic0 = BOX_C0_ELEMS-1; ic0 >= 0; ic0--) {
00001c  9e91              LDR      r6,[sp,#0x244]
00001e  f04f0903          MOV      r9,#3
000022  f810b00e          LDRB     r11,[r0,lr]           ;813
000026  9882              LDR      r0,[sp,#0x208]        ;815
000028  f8d01088          LDR      r1,[r0,#0x88]         ;815
00002c  6808              LDR      r0,[r1,#0]            ;815
00002e  684b              LDR      r3,[r1,#4]            ;817
000030  6889              LDR      r1,[r1,#8]            ;819
000032  f810200b          LDRB     r2,[r0,r11]           ;815
000036  9883              LDR      r0,[sp,#0x20c]        ;815
000038  f813300b          LDRB     r3,[r3,r11]           ;817
00003c  1a80              SUBS     r0,r0,r2              ;815
00003e  9a84              LDR      r2,[sp,#0x210]        ;817
000040  0040              LSLS     r0,r0,#1              ;815
000042  1ad2              SUBS     r2,r2,r3              ;817
000044  eb020342          ADD      r3,r2,r2,LSL #1       ;817
000048  f811200b          LDRB     r2,[r1,r11]           ;819
00004c  9985              LDR      r1,[sp,#0x214]        ;819
00004e  fb00f400          MUL      r4,r0,r0              ;816
000052  1a89              SUBS     r1,r1,r2              ;819
000054  fb034403          MLA      r4,r3,r3,r4           ;818
000058  f44f7280          MOV      r2,#0x100             ;822
00005c  eb021240          ADD      r2,r2,r0,LSL #5       ;822
000060  eb030043          ADD      r0,r3,r3,LSL #1       ;823
000064  2390              MOVS     r3,#0x90              ;823
000066  eb0300c0          ADD      r0,r3,r0,LSL #3       ;823
00006a  9080              STR      r0,[sp,#0x200]        ;824
00006c  fb014a01          MLA      r10,r1,r1,r4          ;820
000070  2040              MOVS     r0,#0x40              ;824
000072  eb001001          ADD      r0,r0,r1,LSL #4       ;824
000076  466c              MOV      r4,sp                 ;826
000078  9081              STR      r0,[sp,#0x204]        ;827
                  |L3.122|
;;;830          dist1 = dist0;
;;;831          xx1 = inc1;
;;;832          for (ic1 = BOX_C1_ELEMS-1; ic1 >= 0; ic1--) {
00007a  9d80              LDR      r5,[sp,#0x200]
00007c  4651              MOV      r1,r10                ;830
00007e  f04f0c07          MOV      r12,#7
                  |L3.130|
;;;833    	dist2 = dist1;
;;;834    	xx2 = inc2;
;;;835    	for (ic2 = BOX_C2_ELEMS-1; ic2 >= 0; ic2--) {
000082  9b81              LDR      r3,[sp,#0x204]
000084  4608              MOV      r0,r1                 ;833
000086  2703              MOVS     r7,#3
                  |L3.136|
;;;836    	  if (dist2 < *bptr) {
000088  f8d48000          LDR      r8,[r4,#0]
00008c  4580              CMP      r8,r0
00008e  dd02              BLE      |L3.150|
;;;837    	    *bptr = dist2;
;;;838    	    *cptr = (JSAMPLE) icolor;
000090  6020              STR      r0,[r4,#0]
000092  f886b000          STRB     r11,[r6,#0]
                  |L3.150|
;;;839    	  }
;;;840    	  dist2 += xx2;
000096  4418              ADD      r0,r0,r3
000098  3380              ADDS     r3,r3,#0x80
00009a  1d24              ADDS     r4,r4,#4
00009c  1c76              ADDS     r6,r6,#1
00009e  1e7f              SUBS     r7,r7,#1
0000a0  d5f2              BPL      |L3.136|
;;;841    	  xx2 += 2 * STEP_C2 * STEP_C2;
;;;842    	  bptr++;
;;;843    	  cptr++;
;;;844    	}
;;;845    	dist1 += xx1;
0000a2  4429              ADD      r1,r1,r5
0000a4  f5057590          ADD      r5,r5,#0x120
0000a8  f1bc0c01          SUBS     r12,r12,#1
0000ac  d5e9              BPL      |L3.130|
;;;846    	xx1 += 2 * STEP_C1 * STEP_C1;
;;;847          }
;;;848          dist0 += xx0;
0000ae  4492              ADD      r10,r10,r2
0000b0  f1a90001          SUB      r0,r9,#1              ;829
0000b4  f5027200          ADD      r2,r2,#0x200          ;829
0000b8  ea5f0900          MOVS     r9,r0                 ;829
0000bc  d5dd              BPL      |L3.122|
0000be  f10e0001          ADD      r0,lr,#1              ;812
                  |L3.194|
0000c2  998f              LDR      r1,[sp,#0x23c]        ;812
0000c4  4686              MOV      lr,r0                 ;812
0000c6  4288              CMP      r0,r1                 ;812
0000c8  dba7              BLT      |L3.26|
;;;849          xx0 += 2 * STEP_C0 * STEP_C0;
;;;850        }
;;;851      }
;;;852    }
0000ca  f50d7d06          ADD      sp,sp,#0x218
0000ce  e8bd8ff0          POP      {r4-r11,pc}
;;;853    
                          ENDP


                          AREA ||i.find_nearby_colors||, CODE, READONLY, ALIGN=2

                  find_nearby_colors PROC
;;;646    LOCAL(int)
;;;647    find_nearby_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;648    		    JSAMPLE colorlist[])
;;;649    /* Locate the colormap entries close enough to an update box to be candidates
;;;650     * for the nearest entry to some cell(s) in the update box.  The update box
;;;651     * is specified by the center coordinates of its first cell.  The number of
;;;652     * candidate colormap entries is returned, and their colormap indexes are
;;;653     * placed in colorlist[].
;;;654     * This routine uses Heckbert's "locally sorted search" criterion to select
;;;655     * the colors that need further consideration.
;;;656     */
;;;657    {
000004  f2ad4d0c          SUB      sp,sp,#0x40c
;;;658      int numcolors = cinfo->actual_number_of_colors;
;;;659      int maxc0, maxc1, maxc2;
;;;660      int centerc0, centerc1, centerc2;
;;;661      int i, x, ncolors;
;;;662      INT32 minmaxdist, min_dist, max_dist, tdist;
;;;663      INT32 mindist[MAXNUMCOLORS];	/* min distance to colormap entry i */
;;;664    
;;;665      /* Compute true coordinates of update box's upper corner and center.
;;;666       * Actually we compute the coordinates of the center of the upper-corner
;;;667       * histogram cell, which are the upper bounds of the volume we care about.
;;;668       * Note that since ">>" rounds down, the "center" values may be closer to
;;;669       * min than to max; hence comparisons to them must be "<=", not "<".
;;;670       */
;;;671      maxc0 = minc0 + ((1 << BOX_C0_SHIFT) - (1 << C0_SHIFT));
000008  f1010a18          ADD      r10,r1,#0x18
00000c  f8dd040c          LDR      r0,[sp,#0x40c]        ;658
;;;672      centerc0 = (minc0 + maxc0) >> 1;
;;;673      maxc1 = minc1 + ((1 << BOX_C1_SHIFT) - (1 << C1_SHIFT));
000010  f102091c          ADD      r9,r2,#0x1c
;;;674      centerc1 = (minc1 + maxc1) >> 1;
;;;675      maxc2 = minc2 + ((1 << BOX_C2_SHIFT) - (1 << C2_SHIFT));
000014  f1030718          ADD      r7,r3,#0x18
000018  f8d0c084          LDR      r12,[r0,#0x84]        ;672
00001c  eb01000a          ADD      r0,r1,r10             ;672
000020  1040              ASRS     r0,r0,#1              ;672
000022  f8cd0408          STR      r0,[sp,#0x408]        ;674
000026  eb020009          ADD      r0,r2,r9              ;674
00002a  1040              ASRS     r0,r0,#1              ;674
;;;676      centerc2 = (minc2 + maxc2) >> 1;
00002c  f8cd0404          STR      r0,[sp,#0x404]
000030  19d8              ADDS     r0,r3,r7
000032  1040              ASRS     r0,r0,#1
;;;677    
;;;678      /* For each color in colormap, find:
;;;679       *  1. its minimum squared-distance to any point in the update box
;;;680       *     (zero if color is within update box);
;;;681       *  2. its maximum squared-distance to any point in the update box.
;;;682       * Both of these can be found by considering only the corners of the box.
;;;683       * We save the minimum distance for each color in mindist[];
;;;684       * only the smallest maximum distance is of interest.
;;;685       */
;;;686      minmaxdist = 0x7FFFFFFFL;
000034  f06f4400          MVN      r4,#0x80000000
;;;687    
;;;688      for (i = 0; i < numcolors; i++) {
000038  2600              MOVS     r6,#0
00003a  f8cd0400          STR      r0,[sp,#0x400]        ;657
00003e  e060              B        |L4.258|
                  |L4.64|
;;;689        /* We compute the squared-c0-distance term, then add in the other two. */
;;;690        x = GETJSAMPLE(cinfo->colormap[0][i]);
000040  f8dd040c          LDR      r0,[sp,#0x40c]
000044  f8d0b088          LDR      r11,[r0,#0x88]
000048  f8db0000          LDR      r0,[r11,#0]
00004c  5d85              LDRB     r5,[r0,r6]
;;;691        if (x < minc0) {
00004e  428d              CMP      r5,r1
000050  da03              BGE      |L4.90|
;;;692          tdist = (x - minc0) * C0_SCALE;
000052  1a68              SUBS     r0,r5,r1
000054  0040              LSLS     r0,r0,#1
;;;693          min_dist = tdist*tdist;
000056  4340              MULS     r0,r0,r0
;;;694          tdist = (x - maxc0) * C0_SCALE;
;;;695          max_dist = tdist*tdist;
000058  e00b              B        |L4.114|
                  |L4.90|
;;;696        } else if (x > maxc0) {
00005a  4555              CMP      r5,r10
00005c  dd04              BLE      |L4.104|
;;;697          tdist = (x - maxc0) * C0_SCALE;
00005e  eba5000a          SUB      r0,r5,r10
000062  0040              LSLS     r0,r0,#1
;;;698          min_dist = tdist*tdist;
000064  4340              MULS     r0,r0,r0
;;;699          tdist = (x - minc0) * C0_SCALE;
;;;700          max_dist = tdist*tdist;
000066  e007              B        |L4.120|
                  |L4.104|
;;;701        } else {
;;;702          /* within cell range so no contribution to min_dist */
;;;703          min_dist = 0;
;;;704          if (x <= centerc0) {
000068  f8dd8408          LDR      r8,[sp,#0x408]
00006c  2000              MOVS     r0,#0                 ;703
00006e  4545              CMP      r5,r8
000070  dc02              BGT      |L4.120|
                  |L4.114|
;;;705    	tdist = (x - maxc0) * C0_SCALE;
000072  eba5050a          SUB      r5,r5,r10
;;;706    	max_dist = tdist*tdist;
000076  e000              B        |L4.122|
                  |L4.120|
;;;707          } else {
;;;708    	tdist = (x - minc0) * C0_SCALE;
000078  1a6d              SUBS     r5,r5,r1
                  |L4.122|
00007a  006d              LSLS     r5,r5,#1              ;705
00007c  fb05fe05          MUL      lr,r5,r5              ;706
;;;709    	max_dist = tdist*tdist;
;;;710          }
;;;711        }
;;;712    
;;;713        x = GETJSAMPLE(cinfo->colormap[1][i]);
000080  f8db5004          LDR      r5,[r11,#4]
000084  5dad              LDRB     r5,[r5,r6]
;;;714        if (x < minc1) {
000086  4295              CMP      r5,r2
000088  da06              BGE      |L4.152|
;;;715          tdist = (x - minc1) * C1_SCALE;
00008a  eba50802          SUB      r8,r5,r2
00008e  eb080848          ADD      r8,r8,r8,LSL #1
;;;716          min_dist += tdist*tdist;
000092  fb080008          MLA      r0,r8,r8,r0
;;;717          tdist = (x - maxc1) * C1_SCALE;
;;;718          max_dist += tdist*tdist;
000096  e00c              B        |L4.178|
                  |L4.152|
;;;719        } else if (x > maxc1) {
000098  454d              CMP      r5,r9
00009a  dd06              BLE      |L4.170|
;;;720          tdist = (x - maxc1) * C1_SCALE;
00009c  eba50809          SUB      r8,r5,r9
0000a0  eb080848          ADD      r8,r8,r8,LSL #1
;;;721          min_dist += tdist*tdist;
0000a4  fb080008          MLA      r0,r8,r8,r0
;;;722          tdist = (x - minc1) * C1_SCALE;
;;;723          max_dist += tdist*tdist;
0000a8  e006              B        |L4.184|
                  |L4.170|
;;;724        } else {
;;;725          /* within cell range so no contribution to min_dist */
;;;726          if (x <= centerc1) {
0000aa  f8dd8404          LDR      r8,[sp,#0x404]
0000ae  4545              CMP      r5,r8
0000b0  dc02              BGT      |L4.184|
                  |L4.178|
;;;727    	tdist = (x - maxc1) * C1_SCALE;
0000b2  eba50509          SUB      r5,r5,r9
;;;728    	max_dist += tdist*tdist;
0000b6  e000              B        |L4.186|
                  |L4.184|
;;;729          } else {
;;;730    	tdist = (x - minc1) * C1_SCALE;
0000b8  1aad              SUBS     r5,r5,r2
                  |L4.186|
0000ba  eb050545          ADD      r5,r5,r5,LSL #1       ;727
0000be  fb05ee05          MLA      lr,r5,r5,lr           ;728
;;;731    	max_dist += tdist*tdist;
;;;732          }
;;;733        }
;;;734    
;;;735        x = GETJSAMPLE(cinfo->colormap[2][i]);
0000c2  f8db5008          LDR      r5,[r11,#8]
0000c6  5dad              LDRB     r5,[r5,r6]
;;;736        if (x < minc2) {
0000c8  429d              CMP      r5,r3
0000ca  da04              BGE      |L4.214|
;;;737          tdist = (x - minc2) * C2_SCALE;
0000cc  eba50803          SUB      r8,r5,r3
;;;738          min_dist += tdist*tdist;
0000d0  fb080008          MLA      r0,r8,r8,r0
;;;739          tdist = (x - maxc2) * C2_SCALE;
;;;740          max_dist += tdist*tdist;
0000d4  e00a              B        |L4.236|
                  |L4.214|
;;;741        } else if (x > maxc2) {
0000d6  42bd              CMP      r5,r7
0000d8  dd04              BLE      |L4.228|
;;;742          tdist = (x - maxc2) * C2_SCALE;
0000da  eba50807          SUB      r8,r5,r7
;;;743          min_dist += tdist*tdist;
0000de  fb080008          MLA      r0,r8,r8,r0
;;;744          tdist = (x - minc2) * C2_SCALE;
;;;745          max_dist += tdist*tdist;
0000e2  e005              B        |L4.240|
                  |L4.228|
;;;746        } else {
;;;747          /* within cell range so no contribution to min_dist */
;;;748          if (x <= centerc2) {
0000e4  f8dd8400          LDR      r8,[sp,#0x400]
0000e8  4545              CMP      r5,r8
0000ea  dc01              BGT      |L4.240|
                  |L4.236|
;;;749    	tdist = (x - maxc2) * C2_SCALE;
0000ec  1bed              SUBS     r5,r5,r7
;;;750    	max_dist += tdist*tdist;
0000ee  e000              B        |L4.242|
                  |L4.240|
;;;751          } else {
;;;752    	tdist = (x - minc2) * C2_SCALE;
0000f0  1aed              SUBS     r5,r5,r3
                  |L4.242|
0000f2  fb05e505          MLA      r5,r5,r5,lr           ;750
;;;753    	max_dist += tdist*tdist;
;;;754          }
;;;755        }
;;;756    
;;;757        mindist[i] = min_dist;	/* save away the results */
0000f6  f84d0026          STR      r0,[sp,r6,LSL #2]
;;;758        if (max_dist < minmaxdist)
0000fa  42a5              CMP      r5,r4
0000fc  da00              BGE      |L4.256|
;;;759          minmaxdist = max_dist;
0000fe  462c              MOV      r4,r5
                  |L4.256|
000100  1c76              ADDS     r6,r6,#1
                  |L4.258|
000102  4566              CMP      r6,r12                ;688
000104  db9c              BLT      |L4.64|
;;;760      }
;;;761    
;;;762      /* Now we know that no cell in the update box is more than minmaxdist
;;;763       * away from some colormap entry.  Therefore, only colors that are
;;;764       * within minmaxdist of some part of the box need be considered.
;;;765       */
;;;766      ncolors = 0;
000106  2000              MOVS     r0,#0
;;;767      for (i = 0; i < numcolors; i++) {
000108  4601              MOV      r1,r0
00010a  466a              MOV      r2,sp                 ;663
00010c  e009              B        |L4.290|
;;;768        if (mindist[i] <= minmaxdist)
00010e  bf00              NOP      
                  |L4.272|
000110  f8523021          LDR      r3,[r2,r1,LSL #2]
000114  42a3              CMP      r3,r4
000116  dc03              BGT      |L4.288|
;;;769          colorlist[ncolors++] = (JSAMPLE) i;
000118  f8dd3440          LDR      r3,[sp,#0x440]
00011c  5419              STRB     r1,[r3,r0]
00011e  1c40              ADDS     r0,r0,#1
                  |L4.288|
000120  1c49              ADDS     r1,r1,#1
                  |L4.290|
000122  4561              CMP      r1,r12                ;767
000124  dbf4              BLT      |L4.272|
;;;770      }
;;;771      return ncolors;
;;;772    }
000126  f20d4d1c          ADD      sp,sp,#0x41c
00012a  e8bd8ff0          POP      {r4-r11,pc}
;;;773    
                          ENDP


                          AREA ||i.finish_pass1||, CODE, READONLY, ALIGN=1

                  finish_pass1 PROC
;;;1143   METHODDEF(void)
;;;1144   finish_pass1 (j_decompress_ptr cinfo)
000000  b510              PUSH     {r4,lr}
;;;1145   {
;;;1146     my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
;;;1147   
;;;1148     /* Select the representative colors and fill in cinfo->colormap */
;;;1149     cinfo->colormap = cquantize->sv_colormap;
000002  f8d041cc          LDR      r4,[r0,#0x1cc]
000006  6921              LDR      r1,[r4,#0x10]
;;;1150     select_colors(cinfo, cquantize->desired);
000008  f8c01088          STR      r1,[r0,#0x88]
00000c  6961              LDR      r1,[r4,#0x14]
00000e  f7fffffe          BL       select_colors
;;;1151     /* Force next pass to zero the color index table */
;;;1152     cquantize->needs_zeroed = TRUE;
000012  2001              MOVS     r0,#1
000014  61e0              STR      r0,[r4,#0x1c]
;;;1153   }
000016  bd10              POP      {r4,pc}
;;;1154   
                          ENDP


                          AREA ||i.finish_pass2||, CODE, READONLY, ALIGN=1

                  finish_pass2 PROC
;;;1156   METHODDEF(void)
;;;1157   finish_pass2 (j_decompress_ptr cinfo)
000000  4770              BX       lr
;;;1158   {
;;;1159     GUI_USE_PARA(cinfo);
;;;1160     /* no work */
;;;1161   }
;;;1162   
                          ENDP


                          AREA ||i.init_error_limit||, CODE, READONLY, ALIGN=2

                  init_error_limit PROC
;;;1108   LOCAL(void)
;;;1109   init_error_limit (j_decompress_ptr cinfo)
000000  b510              PUSH     {r4,lr}
;;;1110   /* Allocate and fill in the error_limiter table */
;;;1111   {
;;;1112     my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
;;;1113     int * table;
;;;1114     int in, out;
;;;1115   
;;;1116     table = (int *) (*cinfo->mem->alloc_small)
000002  6841              LDR      r1,[r0,#4]
000004  f8d041cc          LDR      r4,[r0,#0x1cc]
000008  f24072fc          MOV      r2,#0x7fc
00000c  680b              LDR      r3,[r1,#0]
00000e  2101              MOVS     r1,#1
000010  4798              BLX      r3
000012  f500707f          ADD      r0,r0,#0x3fc
;;;1117       ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE*2+1) * SIZEOF(int));
;;;1118     table += MAXJSAMPLE;		/* so can index -MAXJSAMPLE .. +MAXJSAMPLE */
;;;1119     cquantize->error_limiter = table;
;;;1120   
;;;1121   #define STEPSIZE ((MAXJSAMPLE+1)/16)
;;;1122     /* Map errors 1:1 up to +- MAXJSAMPLE/16 */
;;;1123     out = 0;
000016  2200              MOVS     r2,#0
;;;1124     for (in = 0; in < STEPSIZE; in++, out++) {
000018  4611              MOV      r1,r2
00001a  62a0              STR      r0,[r4,#0x28]
                  |L7.28|
;;;1125       table[in] = out; table[-in] = -out;
00001c  f8402021          STR      r2,[r0,r1,LSL #2]
000020  4253              RSBS     r3,r2,#0
000022  eba00481          SUB      r4,r0,r1,LSL #2
000026  1c49              ADDS     r1,r1,#1
000028  1c52              ADDS     r2,r2,#1
00002a  6023              STR      r3,[r4,#0]            ;1124
00002c  2910              CMP      r1,#0x10              ;1124
00002e  dbf5              BLT      |L7.28|
000030  e00b              B        |L7.74|
;;;1126     }
;;;1127     /* Map errors 1:2 up to +- 3*MAXJSAMPLE/16 */
;;;1128     for (; in < STEPSIZE*3; in++, out += (in&1) ? 0 : 1) {
;;;1129       table[in] = out; table[-in] = -out;
000032  bf00              NOP      
                  |L7.52|
000034  f8402021          STR      r2,[r0,r1,LSL #2]
000038  eba00481          SUB      r4,r0,r1,LSL #2
00003c  4253              RSBS     r3,r2,#0
00003e  1c49              ADDS     r1,r1,#1
000040  6023              STR      r3,[r4,#0]            ;1128
000042  f3410300          SBFX     r3,r1,#0,#1           ;1128
000046  441a              ADD      r2,r2,r3              ;1128
000048  1c52              ADDS     r2,r2,#1              ;1128
                  |L7.74|
00004a  2930              CMP      r1,#0x30              ;1128
00004c  dbf2              BLT      |L7.52|
00004e  4253              RSBS     r3,r2,#0              ;1125
                  |L7.80|
;;;1130     }
;;;1131     /* Clamp the rest to final out value (which is (MAXJSAMPLE+1)/8) */
;;;1132     for (; in <= MAXJSAMPLE; in++) {
000050  29ff              CMP      r1,#0xff
000052  dc06              BGT      |L7.98|
;;;1133       table[in] = out; table[-in] = -out;
000054  f8402021          STR      r2,[r0,r1,LSL #2]
000058  eba00481          SUB      r4,r0,r1,LSL #2
00005c  1c49              ADDS     r1,r1,#1
00005e  6023              STR      r3,[r4,#0]            ;1132
000060  e7f6              B        |L7.80|
                  |L7.98|
;;;1134     }
;;;1135   #undef STEPSIZE
;;;1136   }
000062  bd10              POP      {r4,pc}
;;;1137   
                          ENDP


                          AREA ||i.jinit_2pass_quantizer||, CODE, READONLY, ALIGN=2

                  jinit_2pass_quantizer PROC
;;;1245   GLOBAL(void)
;;;1246   jinit_2pass_quantizer (j_decompress_ptr cinfo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1247   {
000004  4604              MOV      r4,r0
;;;1248     my_cquantize_ptr cquantize;
;;;1249     int i;
;;;1250   
;;;1251     cquantize = (my_cquantize_ptr)
000006  6840              LDR      r0,[r0,#4]
000008  222c              MOVS     r2,#0x2c
00000a  2101              MOVS     r1,#1
00000c  6803              LDR      r3,[r0,#0]
00000e  4620              MOV      r0,r4
000010  4798              BLX      r3
;;;1252       (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;1253   				SIZEOF(my_cquantizer));
;;;1254     cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
;;;1255     cquantize->pub.start_pass = start_pass_2_quant;
000012  4936              LDR      r1,|L8.236|
000014  f8c401cc          STR      r0,[r4,#0x1cc]
;;;1256     cquantize->pub.new_color_map = new_color_map_2_quant;
000018  6001              STR      r1,[r0,#0]
;;;1257     cquantize->fserrors = NULL;	/* flag optional arrays not allocated */
00001a  2700              MOVS     r7,#0
;;;1258     cquantize->error_limiter = NULL;
00001c  6207              STR      r7,[r0,#0x20]
00001e  4934              LDR      r1,|L8.240|
;;;1259   
;;;1260     /* Make sure jdmaster didn't give me a case I can't handle */
;;;1261     if (cinfo->out_color_components != 3)
000020  6287              STR      r7,[r0,#0x28]
000022  4605              MOV      r5,r0                 ;1251
000024  60c1              STR      r1,[r0,#0xc]
000026  6fa0              LDR      r0,[r4,#0x78]
000028  2803              CMP      r0,#3
00002a  d006              BEQ      |L8.58|
;;;1262       ERREXIT(cinfo, JERR_NOTIMPL);
00002c  6821              LDR      r1,[r4,#0]
00002e  202f              MOVS     r0,#0x2f
000030  6148              STR      r0,[r1,#0x14]
000032  6820              LDR      r0,[r4,#0]
000034  6801              LDR      r1,[r0,#0]
000036  4620              MOV      r0,r4
000038  4788              BLX      r1
                  |L8.58|
;;;1263   
;;;1264     /* Allocate the histogram/inverse colormap storage */
;;;1265     cquantize->histogram = (hist3d) (*cinfo->mem->alloc_small)
00003a  6860              LDR      r0,[r4,#4]
00003c  2280              MOVS     r2,#0x80
00003e  2101              MOVS     r1,#1
000040  6803              LDR      r3,[r0,#0]
000042  4620              MOV      r0,r4
000044  4798              BLX      r3
;;;1266       ((j_common_ptr) cinfo, JPOOL_IMAGE, HIST_C0_ELEMS * SIZEOF(hist2d));
;;;1267     for (i = 0; i < HIST_C0_ELEMS; i++) {
000046  2600              MOVS     r6,#0
;;;1268       cquantize->histogram[i] = (hist2d) (*cinfo->mem->alloc_large)
000048  f44f5880          MOV      r8,#0x1000
00004c  61a8              STR      r0,[r5,#0x18]
                  |L8.78|
00004e  6860              LDR      r0,[r4,#4]
000050  4642              MOV      r2,r8
000052  2101              MOVS     r1,#1
000054  6843              LDR      r3,[r0,#4]
000056  4620              MOV      r0,r4
000058  4798              BLX      r3
00005a  69a9              LDR      r1,[r5,#0x18]
00005c  f8410026          STR      r0,[r1,r6,LSL #2]
000060  1c76              ADDS     r6,r6,#1
000062  2e20              CMP      r6,#0x20              ;1267
000064  dbf3              BLT      |L8.78|
;;;1269         ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;1270          HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));
;;;1271     }
;;;1272     cquantize->needs_zeroed = TRUE; /* histogram is garbage now */
000066  2001              MOVS     r0,#1
;;;1273   
;;;1274     /* Allocate storage for the completed colormap, if required.
;;;1275      * We do this now since it is FAR storage and may affect
;;;1276      * the memory manager's space calculations.
;;;1277      */
;;;1278     if (cinfo->enable_2pass_quant) {
000068  61e8              STR      r0,[r5,#0x1c]
00006a  6ee0              LDR      r0,[r4,#0x6c]
00006c  b318              CBZ      r0,|L8.182|
;;;1279       /* Make sure color count is acceptable */
;;;1280       int desired = cinfo->desired_number_of_colors;
;;;1281       /* Lower bound on # of colors ... somewhat arbitrary as long as > 0 */
;;;1282       if (desired < 8)
00006e  6e26              LDR      r6,[r4,#0x60]
000070  2e08              CMP      r6,#8
000072  da09              BGE      |L8.136|
;;;1283         ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 8);
000074  6821              LDR      r1,[r4,#0]
000076  2038              MOVS     r0,#0x38
000078  6148              STR      r0,[r1,#0x14]
00007a  6821              LDR      r1,[r4,#0]
00007c  2008              MOVS     r0,#8
00007e  6188              STR      r0,[r1,#0x18]
000080  6820              LDR      r0,[r4,#0]
000082  6801              LDR      r1,[r0,#0]
000084  4620              MOV      r0,r4
000086  4788              BLX      r1
                  |L8.136|
;;;1284       /* Make sure colormap indexes can be represented by JSAMPLEs */
;;;1285       if (desired > MAXNUMCOLORS)
000088  f44f7080          MOV      r0,#0x100
00008c  4286              CMP      r6,r0
00008e  dd08              BLE      |L8.162|
;;;1286         ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);
000090  6822              LDR      r2,[r4,#0]
000092  2139              MOVS     r1,#0x39
000094  6151              STR      r1,[r2,#0x14]
000096  6821              LDR      r1,[r4,#0]
000098  6188              STR      r0,[r1,#0x18]
00009a  6820              LDR      r0,[r4,#0]
00009c  6801              LDR      r1,[r0,#0]
00009e  4620              MOV      r0,r4
0000a0  4788              BLX      r1
                  |L8.162|
;;;1287       cquantize->sv_colormap = (*cinfo->mem->alloc_sarray)
0000a2  6860              LDR      r0,[r4,#4]
0000a4  2303              MOVS     r3,#3
0000a6  4632              MOV      r2,r6
0000a8  6887              LDR      r7,[r0,#8]
0000aa  2101              MOVS     r1,#1
0000ac  4620              MOV      r0,r4
0000ae  47b8              BLX      r7
0000b0  e9c50604          STRD     r0,r6,[r5,#0x10]
;;;1288         ((j_common_ptr) cinfo,JPOOL_IMAGE, (JDIMENSION) desired, (JDIMENSION) 3);
;;;1289       cquantize->desired = desired;
;;;1290     } else
0000b4  e000              B        |L8.184|
                  |L8.182|
;;;1291       cquantize->sv_colormap = NULL;
0000b6  612f              STR      r7,[r5,#0x10]
                  |L8.184|
;;;1292   
;;;1293     /* Only F-S dithering or no dithering is supported. */
;;;1294     /* If user asks for ordered dither, give him F-S. */
;;;1295     if (cinfo->dither_mode != JDITHER_NONE)
0000b8  f8940058          LDRB     r0,[r4,#0x58]
0000bc  2800              CMP      r0,#0
0000be  d012              BEQ      |L8.230|
;;;1296       cinfo->dither_mode = JDITHER_FS;
0000c0  2002              MOVS     r0,#2
0000c2  f8840058          STRB     r0,[r4,#0x58]
;;;1297   
;;;1298     /* Allocate Floyd-Steinberg workspace if necessary.
;;;1299      * This isn't really needed until pass 2, but again it is FAR storage.
;;;1300      * Although we will cope with a later change in dither_mode,
;;;1301      * we do not promise to honor max_memory_to_use if dither_mode changes.
;;;1302      */
;;;1303     if (cinfo->dither_mode == JDITHER_FS) {
;;;1304       cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
0000c6  6f20              LDR      r0,[r4,#0x70]
0000c8  1c80              ADDS     r0,r0,#2
0000ca  eb000040          ADD      r0,r0,r0,LSL #1
0000ce  0042              LSLS     r2,r0,#1
0000d0  6860              LDR      r0,[r4,#4]
0000d2  2101              MOVS     r1,#1
0000d4  6843              LDR      r3,[r0,#4]
0000d6  4620              MOV      r0,r4
0000d8  4798              BLX      r3
;;;1305         ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;1306          (size_t) ((cinfo->output_width + 2) * (3 * SIZEOF(FSERROR))));
;;;1307       /* Might as well create the error-limiting table too. */
;;;1308       init_error_limit(cinfo);
0000da  6228              STR      r0,[r5,#0x20]
0000dc  4620              MOV      r0,r4
0000de  e8bd41f0          POP      {r4-r8,lr}
0000e2  f7ffbffe          B.W      init_error_limit
                  |L8.230|
;;;1309     }
;;;1310   }
0000e6  e8bd81f0          POP      {r4-r8,pc}
;;;1311   
                          ENDP

0000ea  0000              DCW      0x0000
                  |L8.236|
                          DCD      start_pass_2_quant
                  |L8.240|
                          DCD      new_color_map_2_quant

                          AREA ||i.median_cut||, CODE, READONLY, ALIGN=2

                  median_cut PROC
;;;424    LOCAL(int)
;;;425    median_cut (j_decompress_ptr cinfo, boxptr boxlist, int numboxes,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;426    	    int desired_colors)
;;;427    /* Repeatedly select and split the largest box until we have enough boxes */
;;;428    {
000004  b081              SUB      sp,sp,#4
000006  461f              MOV      r7,r3
000008  4615              MOV      r5,r2
00000a  460c              MOV      r4,r1
;;;429      int n,lb;
;;;430      int c0,c1,c2,cmax;
;;;431      register boxptr b1,b2;
;;;432    
;;;433      while (numboxes < desired_colors) {
;;;434        /* Select box to split.
;;;435         * Current algorithm: by population for first half, then by volume.
;;;436         */
;;;437        if (numboxes*2 <= desired_colors) {
;;;438          b1 = find_biggest_color_pop(boxlist, numboxes);
;;;439        } else {
;;;440          b1 = find_biggest_volume(boxlist, numboxes);
;;;441        }
;;;442        if (b1 == NULL)		/* no splittable boxes left! */
;;;443          break;
;;;444        b2 = &boxlist[numboxes];	/* where new box will go */
;;;445        /* Copy the color bounds to the new box. */
;;;446        b2->c0max = b1->c0max; b2->c1max = b1->c1max; b2->c2max = b1->c2max;
;;;447        b2->c0min = b1->c0min; b2->c1min = b1->c1min; b2->c2min = b1->c2min;
;;;448        /* Choose which axis to split the box on.
;;;449         * Current algorithm: longest scaled axis.
;;;450         * See notes in update_box about scaling distances.
;;;451         */
;;;452        c0 = ((b1->c0max - b1->c0min) << C0_SHIFT) * C0_SCALE;
;;;453        c1 = ((b1->c1max - b1->c1min) << C1_SHIFT) * C1_SCALE;
;;;454        c2 = ((b1->c2max - b1->c2min) << C2_SHIFT) * C2_SCALE;
;;;455        /* We want to break any ties in favor of green, then red, blue last.
;;;456         * This code does the right thing for R,G,B or B,G,R color orders only.
;;;457         */
;;;458    #if RGB_RED == 0
;;;459        cmax = c1; n = 1;
;;;460        if (c0 > cmax) { cmax = c0; n = 0; }
;;;461        if (c2 > cmax) { n = 2; }
;;;462    #else
;;;463        cmax = c1; n = 1;
;;;464        if (c2 > cmax) { cmax = c2; n = 2; }
;;;465        if (c0 > cmax) { n = 0; }
;;;466    #endif
;;;467        /* Choose split point along selected axis, and update box bounds.
;;;468         * Current algorithm: split at halfway point.
;;;469         * (Since the box has been shrunk to minimum volume,
;;;470         * any split will produce two nonempty subboxes.)
;;;471         * Note that lb value is max for lower box, so must be < old max.
;;;472         */
;;;473        switch (n) {
;;;474        case 0:
;;;475          lb = (b1->c0max + b1->c0min) / 2;
;;;476          b1->c0max = lb;
;;;477          b2->c0min = lb+1;
;;;478          break;
;;;479        case 1:
;;;480          lb = (b1->c1max + b1->c1min) / 2;
;;;481          b1->c1max = lb;
;;;482          b2->c1min = lb+1;
;;;483          break;
;;;484        case 2:
;;;485          lb = (b1->c2max + b1->c2min) / 2;
;;;486          b1->c2max = lb;
;;;487          b2->c2min = lb+1;
;;;488          break;
;;;489        }
;;;490        /* Update stats for boxes */
;;;491        update_box(cinfo, b1);
;;;492        update_box(cinfo, b2);
;;;493        numboxes++;
00000c  e075              B        |L9.250|
00000e  bf00              NOP                            ;437
                  |L9.16|
000010  f04f0200          MOV      r2,#0                 ;437
000014  ebb70f45          CMP      r7,r5,LSL #1          ;437
000018  4620              MOV      r0,r4                 ;440
00001a  4611              MOV      r1,r2                 ;440
00001c  4613              MOV      r3,r2                 ;440
00001e  da0c              BGE      |L9.58|
000020  e015              B        |L9.78|
                  |L9.34|
000022  69c6              LDR      r6,[r0,#0x1c]         ;437
000024  4296              CMP      r6,r2                 ;437
000026  dd06              BLE      |L9.54|
000028  f8d0c018          LDR      r12,[r0,#0x18]        ;437
00002c  f1bc0f00          CMP      r12,#0                ;437
000030  dd01              BLE      |L9.54|
000032  4601              MOV      r1,r0                 ;437
000034  4632              MOV      r2,r6                 ;437
                  |L9.54|
000036  3020              ADDS     r0,r0,#0x20           ;437
000038  1c5b              ADDS     r3,r3,#1              ;437
                  |L9.58|
00003a  42ab              CMP      r3,r5                 ;437
00003c  dbf1              BLT      |L9.34|
00003e  e008              B        |L9.82|
                  |L9.64|
000040  6986              LDR      r6,[r0,#0x18]         ;437
000042  4296              CMP      r6,r2                 ;437
000044  dd01              BLE      |L9.74|
000046  4601              MOV      r1,r0                 ;437
000048  4632              MOV      r2,r6                 ;437
                  |L9.74|
00004a  3020              ADDS     r0,r0,#0x20           ;437
00004c  1c5b              ADDS     r3,r3,#1              ;437
                  |L9.78|
00004e  42ab              CMP      r3,r5                 ;437
000050  dbf6              BLT      |L9.64|
                  |L9.82|
000052  b3a9              CBZ      r1,|L9.192|
000054  eb041645          ADD      r6,r4,r5,LSL #5       ;444
000058  6848              LDR      r0,[r1,#4]            ;446
00005a  6070              STR      r0,[r6,#4]            ;446
00005c  68c8              LDR      r0,[r1,#0xc]          ;446
00005e  60f0              STR      r0,[r6,#0xc]          ;446
000060  6948              LDR      r0,[r1,#0x14]         ;446
000062  6170              STR      r0,[r6,#0x14]         ;447
000064  6808              LDR      r0,[r1,#0]            ;447
000066  6030              STR      r0,[r6,#0]            ;447
000068  6888              LDR      r0,[r1,#8]            ;447
00006a  60b0              STR      r0,[r6,#8]            ;447
00006c  6908              LDR      r0,[r1,#0x10]         ;447
00006e  6130              STR      r0,[r6,#0x10]         ;452
000070  6848              LDR      r0,[r1,#4]            ;452
000072  680a              LDR      r2,[r1,#0]            ;452
000074  4683              MOV      r11,r0                ;452
000076  4692              MOV      r10,r2                ;452
000078  1a80              SUBS     r0,r0,r2              ;452
00007a  0102              LSLS     r2,r0,#4              ;452
00007c  68c8              LDR      r0,[r1,#0xc]          ;453
00007e  9000              STR      r0,[sp,#0]            ;453
000080  688b              LDR      r3,[r1,#8]            ;453
000082  f8d18010          LDR      r8,[r1,#0x10]         ;454
000086  1ac0              SUBS     r0,r0,r3              ;453
000088  469e              MOV      lr,r3                 ;453
00008a  694b              LDR      r3,[r1,#0x14]         ;454
00008c  eb000040          ADD      r0,r0,r0,LSL #1       ;453
000090  4699              MOV      r9,r3                 ;454
000092  eba30308          SUB      r3,r3,r8              ;454
000096  ea4f0cc3          LSL      r12,r3,#3             ;454
00009a  0080              LSLS     r0,r0,#2              ;453
00009c  2301              MOVS     r3,#1                 ;459
00009e  4282              CMP      r2,r0                 ;460
0000a0  dd01              BLE      |L9.166|
0000a2  4610              MOV      r0,r2                 ;460
0000a4  2300              MOVS     r3,#0                 ;460
                  |L9.166|
0000a6  4584              CMP      r12,r0                ;461
0000a8  dc17              BGT      |L9.218|
0000aa  b16b              CBZ      r3,|L9.200|
0000ac  b14b              CBZ      r3,|L9.194|
0000ae  9800              LDR      r0,[sp,#0]            ;480
0000b0  4470              ADD      r0,r0,lr              ;480
0000b2  eb0070d0          ADD      r0,r0,r0,LSR #31      ;480
0000b6  1040              ASRS     r0,r0,#1              ;480
0000b8  60c8              STR      r0,[r1,#0xc]          ;481
0000ba  1c40              ADDS     r0,r0,#1              ;481
0000bc  60b0              STR      r0,[r6,#8]            ;483
0000be  e014              B        |L9.234|
                  |L9.192|
0000c0  e01d              B        |L9.254|
                  |L9.194|
0000c2  2b02              CMP      r3,#2                 ;473
0000c4  d111              BNE      |L9.234|
0000c6  e008              B        |L9.218|
                  |L9.200|
0000c8  eb0b000a          ADD      r0,r11,r10            ;475
0000cc  eb0070d0          ADD      r0,r0,r0,LSR #31      ;475
0000d0  1040              ASRS     r0,r0,#1              ;475
0000d2  6048              STR      r0,[r1,#4]            ;476
0000d4  1c40              ADDS     r0,r0,#1              ;476
0000d6  6030              STR      r0,[r6,#0]            ;478
0000d8  e007              B        |L9.234|
                  |L9.218|
0000da  eb090008          ADD      r0,r9,r8              ;485
0000de  eb0070d0          ADD      r0,r0,r0,LSR #31      ;485
0000e2  1040              ASRS     r0,r0,#1              ;485
0000e4  6148              STR      r0,[r1,#0x14]         ;486
0000e6  1c40              ADDS     r0,r0,#1              ;486
0000e8  6130              STR      r0,[r6,#0x10]         ;487
                  |L9.234|
0000ea  9801              LDR      r0,[sp,#4]            ;491
0000ec  f7fffffe          BL       update_box
0000f0  4631              MOV      r1,r6                 ;492
0000f2  9801              LDR      r0,[sp,#4]            ;492
0000f4  f7fffffe          BL       update_box
0000f8  1c6d              ADDS     r5,r5,#1              ;492
                  |L9.250|
0000fa  42bd              CMP      r5,r7                 ;433
0000fc  db88              BLT      |L9.16|
                  |L9.254|
;;;494      }
;;;495      return numboxes;
;;;496    }
0000fe  b005              ADD      sp,sp,#0x14
000100  4628              MOV      r0,r5                 ;495
000102  e8bd8ff0          POP      {r4-r11,pc}
;;;497    
                          ENDP


                          AREA ||i.new_color_map_2_quant||, CODE, READONLY, ALIGN=1

                  new_color_map_2_quant PROC
;;;1231   METHODDEF(void)
;;;1232   new_color_map_2_quant (j_decompress_ptr cinfo)
000000  f8d001cc          LDR      r0,[r0,#0x1cc]
;;;1233   {
;;;1234     my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
;;;1235   
;;;1236     /* Reset the inverse color map */
;;;1237     cquantize->needs_zeroed = TRUE;
000004  2101              MOVS     r1,#1
000006  61c1              STR      r1,[r0,#0x1c]
;;;1238   }
000008  4770              BX       lr
;;;1239   
                          ENDP


                          AREA ||i.pass2_fs_dither||, CODE, READONLY, ALIGN=1

                  pass2_fs_dither PROC
;;;949    METHODDEF(void)
;;;950    pass2_fs_dither (j_decompress_ptr cinfo,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;951    		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
;;;952    /* This version performs Floyd-Steinberg dithering */
;;;953    {
000004  b09d              SUB      sp,sp,#0x74
;;;954      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000006  981d              LDR      r0,[sp,#0x74]
000008  f8d001cc          LDR      r0,[r0,#0x1cc]
;;;955      hist3d histogram = cquantize->histogram;
00000c  9018              STR      r0,[sp,#0x60]
00000e  6980              LDR      r0,[r0,#0x18]
;;;956      register LOCFSERROR cur0, cur1, cur2;	/* current error or pixel value */
;;;957      LOCFSERROR belowerr0, belowerr1, belowerr2; /* error for pixel below cur */
;;;958      LOCFSERROR bpreverr0, bpreverr1, bpreverr2; /* error for below/prev col */
;;;959      register FSERRPTR errorptr;	/* => fserrors[] at column before current */
;;;960      JSAMPROW inptr;		/* => current input pixel */
;;;961      JSAMPROW outptr;		/* => current output pixel */
;;;962      histptr cachep;
;;;963      int dir;			/* +1 or -1 depending on direction */
;;;964      int dir3;			/* 3*dir, for advancing inptr & errorptr */
;;;965      int row;
;;;966      JDIMENSION col;
;;;967      JDIMENSION width = cinfo->output_width;
000010  901a              STR      r0,[sp,#0x68]
000012  981d              LDR      r0,[sp,#0x74]
000014  6f00              LDR      r0,[r0,#0x70]
;;;968      JSAMPLE *range_limit = cinfo->sample_range_limit;
000016  900f              STR      r0,[sp,#0x3c]
000018  981d              LDR      r0,[sp,#0x74]
00001a  f8d00144          LDR      r0,[r0,#0x144]
;;;969      int *error_limit = cquantize->error_limiter;
00001e  9005              STR      r0,[sp,#0x14]
000020  9818              LDR      r0,[sp,#0x60]
000022  6a80              LDR      r0,[r0,#0x28]
;;;970      JSAMPROW colormap0 = cinfo->colormap[0];
000024  9004              STR      r0,[sp,#0x10]
000026  981d              LDR      r0,[sp,#0x74]
000028  f8d00088          LDR      r0,[r0,#0x88]
00002c  6801              LDR      r1,[r0,#0]
;;;971      JSAMPROW colormap1 = cinfo->colormap[1];
00002e  9115              STR      r1,[sp,#0x54]
000030  6841              LDR      r1,[r0,#4]
;;;972      JSAMPROW colormap2 = cinfo->colormap[2];
000032  9114              STR      r1,[sp,#0x50]
000034  6880              LDR      r0,[r0,#8]
;;;973      SHIFT_TEMPS
;;;974    
;;;975      for (row = 0; row < num_rows; row++) {
000036  9013              STR      r0,[sp,#0x4c]
000038  2000              MOVS     r0,#0
                  |L11.58|
00003a  4601              MOV      r1,r0
00003c  9019              STR      r0,[sp,#0x64]
00003e  9820              LDR      r0,[sp,#0x80]
000040  4281              CMP      r1,r0
000042  da7c              BGE      |L11.318|
;;;976        inptr = input_buf[row];
000044  981e              LDR      r0,[sp,#0x78]
000046  f8505021          LDR      r5,[r0,r1,LSL #2]
;;;977        outptr = output_buf[row];
00004a  981f              LDR      r0,[sp,#0x7c]
00004c  f8506021          LDR      r6,[r0,r1,LSL #2]
;;;978        if (cquantize->on_odd_row) {
000050  9818              LDR      r0,[sp,#0x60]
000052  6a40              LDR      r0,[r0,#0x24]
000054  b1b0              CBZ      r0,|L11.132|
;;;979          /* work right to left in this row */
;;;980          inptr += (width-1) * 3;	/* so point to rightmost pixel */
;;;981          outptr += width-1;
000056  990f              LDR      r1,[sp,#0x3c]
000058  980f              LDR      r0,[sp,#0x3c]         ;980
00005a  440e              ADD      r6,r6,r1
;;;982          dir = -1;
00005c  f04f31ff          MOV      r1,#0xffffffff
;;;983          dir3 = -3;
;;;984          errorptr = cquantize->fserrors + (width+1)*3; /* => entry after last column */
000060  9111              STR      r1,[sp,#0x44]
000062  9918              LDR      r1,[sp,#0x60]
000064  eb000040          ADD      r0,r0,r0,LSL #1       ;980
000068  4405              ADD      r5,r5,r0              ;980
00006a  6a09              LDR      r1,[r1,#0x20]
00006c  2206              MOVS     r2,#6
00006e  eb020040          ADD      r0,r2,r0,LSL #1
000072  180c              ADDS     r4,r1,r0
;;;985          cquantize->on_odd_row = FALSE; /* flip for next time */
000074  9818              LDR      r0,[sp,#0x60]
000076  2100              MOVS     r1,#0
000078  1eed              SUBS     r5,r5,#3
00007a  f06f0b02          MVN      r11,#2                ;983
00007e  1e76              SUBS     r6,r6,#1
000080  6241              STR      r1,[r0,#0x24]
000082  e007              B        |L11.148|
                  |L11.132|
;;;986        } else {
;;;987          /* work left to right in this row */
;;;988          dir = 1;
000084  2001              MOVS     r0,#1
;;;989          dir3 = 3;
;;;990          errorptr = cquantize->fserrors; /* => entry before first real column */
000086  9011              STR      r0,[sp,#0x44]
000088  9818              LDR      r0,[sp,#0x60]
;;;991          cquantize->on_odd_row = TRUE; /* flip for next time */
00008a  2101              MOVS     r1,#1
00008c  f04f0b03          MOV      r11,#3                ;989
000090  6a04              LDR      r4,[r0,#0x20]
000092  6241              STR      r1,[r0,#0x24]
                  |L11.148|
;;;992        }
;;;993        /* Preset error values: no error propagated to first pixel from left */
;;;994        cur0 = cur1 = cur2 = 0;
000094  2000              MOVS     r0,#0
;;;995        /* and no error propagated to row below yet */
;;;996        belowerr0 = belowerr1 = belowerr2 = 0;
;;;997        bpreverr0 = bpreverr1 = bpreverr2 = 0;
000096  900a              STR      r0,[sp,#0x28]
;;;998    
;;;999        for (col = width; col > 0; col--) {
000098  9f0f              LDR      r7,[sp,#0x3c]
00009a  4601              MOV      r1,r0                 ;994
00009c  900b              STR      r0,[sp,#0x2c]         ;996
00009e  900c              STR      r0,[sp,#0x30]         ;996
0000a0  4688              MOV      r8,r1                 ;994
0000a2  9007              STR      r0,[sp,#0x1c]         ;997
0000a4  9009              STR      r0,[sp,#0x24]         ;997
0000a6  9006              STR      r0,[sp,#0x18]
0000a8  2f00              CMP      r7,#0
0000aa  d07d              BEQ      |L11.424|
                  |L11.172|
;;;1000         /* curN holds the error propagated from the previous pixel on the
;;;1001          * current line.  Add the error propagated from the previous line
;;;1002          * to form the complete error correction term for this pixel, and
;;;1003          * round the error term (which is expressed * 16) to an integer.
;;;1004          * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
;;;1005          * for either sign of the error value.
;;;1006          * Note: errorptr points to *previous* column's array entry.
;;;1007          */
;;;1008         cur0 = RIGHT_SHIFT(cur0 + errorptr[dir3+0] + 8, 4);
0000ac  f934301b          LDRSH    r3,[r4,r11,LSL #1]
0000b0  f1080208          ADD      r2,r8,#8
0000b4  441a              ADD      r2,r2,r3
0000b6  1113              ASRS     r3,r2,#4
;;;1009         cur1 = RIGHT_SHIFT(cur1 + errorptr[dir3+1] + 8, 4);
0000b8  eb04024b          ADD      r2,r4,r11,LSL #1
0000bc  9212              STR      r2,[sp,#0x48]
0000be  f9b2c002          LDRSH    r12,[r2,#2]
0000c2  3108              ADDS     r1,r1,#8
;;;1010         cur2 = RIGHT_SHIFT(cur2 + errorptr[dir3+2] + 8, 4);
0000c4  f9b22004          LDRSH    r2,[r2,#4]
0000c8  3008              ADDS     r0,r0,#8
0000ca  4410              ADD      r0,r0,r2
0000cc  1102              ASRS     r2,r0,#4
;;;1011         /* Limit the error using transfer function set by init_error_limit.
;;;1012          * See comments with init_error_limit for rationale.
;;;1013          */
;;;1014         cur0 = error_limit[cur0];
0000ce  9804              LDR      r0,[sp,#0x10]
0000d0  4461              ADD      r1,r1,r12             ;1009
0000d2  1109              ASRS     r1,r1,#4              ;1009
0000d4  f8500023          LDR      r0,[r0,r3,LSL #2]
;;;1015         cur1 = error_limit[cur1];
0000d8  9b04              LDR      r3,[sp,#0x10]
0000da  f8533021          LDR      r3,[r3,r1,LSL #2]
;;;1016         cur2 = error_limit[cur2];
0000de  9904              LDR      r1,[sp,#0x10]
0000e0  f8512022          LDR      r2,[r1,r2,LSL #2]
;;;1017         /* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
;;;1018          * The maximum error is +- MAXJSAMPLE (or less with error limiting);
;;;1019          * this sets the required size of the range_limit array.
;;;1020          */
;;;1021         cur0 += GETJSAMPLE(inptr[0]);
0000e4  7829              LDRB     r1,[r5,#0]
0000e6  4401              ADD      r1,r1,r0
;;;1022         cur1 += GETJSAMPLE(inptr[1]);
0000e8  7868              LDRB     r0,[r5,#1]
0000ea  4418              ADD      r0,r0,r3
;;;1023         cur2 += GETJSAMPLE(inptr[2]);
0000ec  78ab              LDRB     r3,[r5,#2]
0000ee  441a              ADD      r2,r2,r3
;;;1024         cur0 = GETJSAMPLE(range_limit[cur0]);
0000f0  9b05              LDR      r3,[sp,#0x14]
;;;1025         cur1 = GETJSAMPLE(range_limit[cur1]);
0000f2  f8138000          LDRB     r8,[r3,r0]
0000f6  f8139001          LDRB     r9,[r3,r1]            ;1024
;;;1026         cur2 = GETJSAMPLE(range_limit[cur2]);
0000fa  f813a002          LDRB     r10,[r3,r2]
;;;1027         /* Index into the cache with adjusted pixel value */
;;;1028         cachep = & histogram[cur0>>C0_SHIFT][cur1>>C1_SHIFT][cur2>>C2_SHIFT];
0000fe  ea4f00a8          ASR      r0,r8,#2
000102  0181              LSLS     r1,r0,#6
000104  ea4f00ea          ASR      r0,r10,#3
000108  eb010240          ADD      r2,r1,r0,LSL #1
00010c  981a              LDR      r0,[sp,#0x68]
00010e  ea4f01e9          ASR      r1,r9,#3
000112  f8500021          LDR      r0,[r0,r1,LSL #2]
000116  4410              ADD      r0,r0,r2
;;;1029         /* If we have not seen this color before, find nearest colormap */
;;;1030         /* entry and update the cache */
;;;1031         if (*cachep == 0)
000118  901c              STR      r0,[sp,#0x70]
00011a  8800              LDRH     r0,[r0,#0]
00011c  b940              CBNZ     r0,|L11.304|
;;;1032   	fill_inverse_cmap(cinfo, cur0>>C0_SHIFT,cur1>>C1_SHIFT,cur2>>C2_SHIFT);
00011e  ea4f03ea          ASR      r3,r10,#3
000122  ea4f02a8          ASR      r2,r8,#2
000126  ea4f01e9          ASR      r1,r9,#3
00012a  981d              LDR      r0,[sp,#0x74]
00012c  f7fffffe          BL       fill_inverse_cmap
                  |L11.304|
;;;1033         /* Now emit the colormap index for this cell */
;;;1034         { register int pixcode = *cachep - 1;
000130  981c              LDR      r0,[sp,#0x70]
000132  8800              LDRH     r0,[r0,#0]
000134  1e40              SUBS     r0,r0,#1
;;;1035   	*outptr = (JSAMPLE) pixcode;
000136  7030              STRB     r0,[r6,#0]
;;;1036   	/* Compute representation error for this pixel */
;;;1037   	cur0 -= GETJSAMPLE(colormap0[pixcode]);
000138  9915              LDR      r1,[sp,#0x54]
00013a  5c0a              LDRB     r2,[r1,r0]
00013c  e000              B        |L11.320|
                  |L11.318|
00013e  e047              B        |L11.464|
                  |L11.320|
;;;1038   	cur1 -= GETJSAMPLE(colormap1[pixcode]);
000140  9914              LDR      r1,[sp,#0x50]
000142  eba90202          SUB      r2,r9,r2              ;1037
000146  5c0b              LDRB     r3,[r1,r0]
000148  eba80103          SUB      r1,r8,r3
;;;1039   	cur2 -= GETJSAMPLE(colormap2[pixcode]);
00014c  9b13              LDR      r3,[sp,#0x4c]
;;;1040         }
;;;1041         /* Compute error fractions to be propagated to adjacent pixels.
;;;1042          * Add these into the running sums, and simultaneously shift the
;;;1043          * next-line error sums left by 1 column.
;;;1044          */
;;;1045         { register LOCFSERROR bnexterr, delta;
;;;1046   
;;;1047   	bnexterr = cur0;	/* Process component 0 */
;;;1048   	delta = cur0 * 2;
;;;1049   	cur0 += delta;		/* form error * 3 */
;;;1050   	errorptr[0] = (FSERROR) (bpreverr0 + cur0);
00014e  f8dd8018          LDR      r8,[sp,#0x18]
000152  5c1b              LDRB     r3,[r3,r0]            ;1039
000154  ebaa0003          SUB      r0,r10,r3             ;1039
000158  0053              LSLS     r3,r2,#1              ;1048
00015a  eb020c03          ADD      r12,r2,r3             ;1049
00015e  44e0              ADD      r8,r8,r12
000160  f8a48000          STRH     r8,[r4,#0]
;;;1051   	cur0 += delta;		/* form error * 5 */
;;;1052   	bpreverr0 = belowerr0 + cur0;
000164  f8dd801c          LDR      r8,[sp,#0x1c]
000168  449c              ADD      r12,r12,r3            ;1051
00016a  44e0              ADD      r8,r8,r12
00016c  e9cd8206          STRD     r8,r2,[sp,#0x18]
;;;1053   	belowerr0 = bnexterr;
;;;1054   	cur0 += delta;		/* form error * 7 */
000170  eb0c0803          ADD      r8,r12,r3
;;;1055   	bnexterr = cur1;	/* Process component 1 */
;;;1056   	delta = cur1 * 2;
000174  004a              LSLS     r2,r1,#1
;;;1057   	cur1 += delta;		/* form error * 3 */
;;;1058   	errorptr[1] = (FSERROR) (bpreverr1 + cur1);
000176  f8ddc024          LDR      r12,[sp,#0x24]
00017a  188b              ADDS     r3,r1,r2              ;1057
00017c  449c              ADD      r12,r12,r3
00017e  f8a4c002          STRH     r12,[r4,#2]
;;;1059   	cur1 += delta;		/* form error * 5 */
;;;1060   	bpreverr1 = belowerr1 + cur1;
000182  f8ddc030          LDR      r12,[sp,#0x30]
000186  4413              ADD      r3,r3,r2              ;1059
000188  449c              ADD      r12,r12,r3
;;;1061   	belowerr1 = bnexterr;
;;;1062   	cur1 += delta;		/* form error * 7 */
00018a  910c              STR      r1,[sp,#0x30]
00018c  f8cdc024          STR      r12,[sp,#0x24]
000190  1899              ADDS     r1,r3,r2
;;;1063   	bnexterr = cur2;	/* Process component 2 */
;;;1064   	delta = cur2 * 2;
000192  0042              LSLS     r2,r0,#1
;;;1065   	cur2 += delta;		/* form error * 3 */
;;;1066   	errorptr[2] = (FSERROR) (bpreverr2 + cur2);
000194  f8ddc028          LDR      r12,[sp,#0x28]
000198  1883              ADDS     r3,r0,r2              ;1065
00019a  449c              ADD      r12,r12,r3
00019c  f8a4c004          STRH     r12,[r4,#4]
;;;1067   	cur2 += delta;		/* form error * 5 */
;;;1068   	bpreverr2 = belowerr2 + cur2;
0001a0  9c0b              LDR      r4,[sp,#0x2c]
0001a2  4413              ADD      r3,r3,r2              ;1067
0001a4  441c              ADD      r4,r4,r3
0001a6  e000              B        |L11.426|
                  |L11.424|
0001a8  e009              B        |L11.446|
                  |L11.426|
0001aa  e9cd400a          STRD     r4,r0,[sp,#0x28]
;;;1069   	belowerr2 = bnexterr;
;;;1070   	cur2 += delta;		/* form error * 7 */
0001ae  1898              ADDS     r0,r3,r2
;;;1071         }
;;;1072         /* At this point curN contains the 7/16 error value to be propagated
;;;1073          * to the next pixel on the current line, and all the errors for the
;;;1074          * next line have been shifted over.  We are therefore ready to move on.
;;;1075          */
;;;1076         inptr += dir3;		/* Advance pixel pointers to next column */
;;;1077         outptr += dir;
0001b0  9a11              LDR      r2,[sp,#0x44]
0001b2  9c12              LDR      r4,[sp,#0x48]
0001b4  445d              ADD      r5,r5,r11             ;1076
0001b6  4416              ADD      r6,r6,r2
0001b8  1e7f              SUBS     r7,r7,#1
0001ba  f47faf77          BNE      |L11.172|
                  |L11.446|
;;;1078         errorptr += dir3;		/* advance errorptr to current column */
;;;1079       }
;;;1080       /* Post-loop cleanup: we must unload the final error values into the
;;;1081        * final fserrors[] entry.  Note we need not unload belowerrN because
;;;1082        * it is for the dummy column before or after the actual array.
;;;1083        */
;;;1084       errorptr[0] = (FSERROR) bpreverr0; /* unload prev errs into array */
0001be  9806              LDR      r0,[sp,#0x18]
0001c0  8020              STRH     r0,[r4,#0]
;;;1085       errorptr[1] = (FSERROR) bpreverr1;
0001c2  9809              LDR      r0,[sp,#0x24]
0001c4  8060              STRH     r0,[r4,#2]
;;;1086       errorptr[2] = (FSERROR) bpreverr2;
0001c6  980a              LDR      r0,[sp,#0x28]
0001c8  80a0              STRH     r0,[r4,#4]
0001ca  9819              LDR      r0,[sp,#0x64]         ;975
0001cc  1c40              ADDS     r0,r0,#1              ;975
0001ce  e734              B        |L11.58|
                  |L11.464|
;;;1087     }
;;;1088   }
0001d0  b021              ADD      sp,sp,#0x84
0001d2  e8bd8ff0          POP      {r4-r11,pc}
;;;1089   
                          ENDP


                          AREA ||i.pass2_no_dither||, CODE, READONLY, ALIGN=2

                  pass2_no_dither PROC
;;;915    METHODDEF(void)
;;;916    pass2_no_dither (j_decompress_ptr cinfo,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;917    		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
;;;918    /* This version performs no dithering */
;;;919    {
000004  4683              MOV      r11,r0
;;;920      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000006  f8d001cc          LDR      r0,[r0,#0x1cc]
;;;921      hist3d histogram = cquantize->histogram;
;;;922      register JSAMPROW inptr, outptr;
;;;923      register histptr cachep;
;;;924      register int c0, c1, c2;
;;;925      int row;
;;;926      JDIMENSION col;
;;;927      JDIMENSION width = cinfo->output_width;
;;;928    
;;;929      for (row = 0; row < num_rows; row++) {
00000a  f8dba070          LDR      r10,[r11,#0x70]
00000e  f8d09018          LDR      r9,[r0,#0x18]         ;927
000012  2000              MOVS     r0,#0
                  |L12.20|
000014  9903              LDR      r1,[sp,#0xc]
000016  4680              MOV      r8,r0
000018  4288              CMP      r0,r1
00001a  da26              BGE      |L12.106|
;;;930        inptr = input_buf[row];
00001c  9801              LDR      r0,[sp,#4]
;;;931        outptr = output_buf[row];
;;;932        for (col = width; col > 0; col--) {
00001e  ea5f050a          MOVS     r5,r10
000022  f8504028          LDR      r4,[r0,r8,LSL #2]     ;930
000026  9802              LDR      r0,[sp,#8]            ;931
000028  f8506028          LDR      r6,[r0,r8,LSL #2]     ;931
00002c  d01a              BEQ      |L12.100|
;;;933          /* get pixel value and index into the cache */
;;;934          c0 = GETJSAMPLE(*inptr++) >> C0_SHIFT;
00002e  bf00              NOP      
                  |L12.48|
000030  f8140b01          LDRB     r0,[r4],#1
000034  08c1              LSRS     r1,r0,#3
;;;935          c1 = GETJSAMPLE(*inptr++) >> C1_SHIFT;
000036  f8140b01          LDRB     r0,[r4],#1
00003a  0882              LSRS     r2,r0,#2
;;;936          c2 = GETJSAMPLE(*inptr++) >> C2_SHIFT;
00003c  f8140b01          LDRB     r0,[r4],#1
000040  08c3              LSRS     r3,r0,#3
;;;937          cachep = & histogram[c0][c1][c2];
000042  0190              LSLS     r0,r2,#6
000044  eb000743          ADD      r7,r0,r3,LSL #1
000048  f8590021          LDR      r0,[r9,r1,LSL #2]
00004c  4407              ADD      r7,r7,r0
;;;938          /* If we have not seen this color before, find nearest colormap entry */
;;;939          /* and update the cache */
;;;940          if (*cachep == 0)
00004e  8838              LDRH     r0,[r7,#0]
000050  b910              CBNZ     r0,|L12.88|
;;;941    	fill_inverse_cmap(cinfo, c0,c1,c2);
000052  4658              MOV      r0,r11
000054  f7fffffe          BL       fill_inverse_cmap
                  |L12.88|
;;;942          /* Now emit the colormap index for this cell */
;;;943          *outptr++ = (JSAMPLE) (*cachep - 1);
000058  7838              LDRB     r0,[r7,#0]
00005a  1e40              SUBS     r0,r0,#1
00005c  f8060b01          STRB     r0,[r6],#1
000060  1e6d              SUBS     r5,r5,#1
000062  d1e5              BNE      |L12.48|
                  |L12.100|
000064  f1080001          ADD      r0,r8,#1              ;929
000068  e7d4              B        |L12.20|
                  |L12.106|
;;;944        }
;;;945      }
;;;946    }
00006a  e8bd9fff          POP      {r0-r12,pc}
;;;947    
                          ENDP


                          AREA ||i.prescan_quantize||, CODE, READONLY, ALIGN=1

                  prescan_quantize PROC
;;;223    METHODDEF(void)
;;;224    prescan_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
000000  b5f0              PUSH     {r4-r7,lr}
;;;225    		  JSAMPARRAY output_buf, int num_rows)
;;;226    {
;;;227      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
;;;228      register JSAMPROW ptr;
;;;229      register histptr histp;
;;;230      register hist3d histogram = cquantize->histogram;
000002  f8d021cc          LDR      r2,[r0,#0x1cc]
;;;231      int row;
;;;232      JDIMENSION col;
;;;233      JDIMENSION width = cinfo->output_width;
;;;234    
;;;235      GUI_USE_PARA(output_buf);
;;;236      for (row = 0; row < num_rows; row++) {
000006  2400              MOVS     r4,#0
000008  6f07              LDR      r7,[r0,#0x70]         ;226
00000a  f8d2c018          LDR      r12,[r2,#0x18]        ;233
00000e  e01e              B        |L13.78|
                  |L13.16|
;;;237        ptr = input_buf[row];
000010  f8512024          LDR      r2,[r1,r4,LSL #2]
;;;238        for (col = width; col > 0; col--) {
000014  0038              MOVS     r0,r7
000016  d019              BEQ      |L13.76|
;;;239          /* get pixel value and index into the histogram */
;;;240          histp = & histogram[GETJSAMPLE(ptr[0]) >> C0_SHIFT]
;;;241    			 [GETJSAMPLE(ptr[1]) >> C1_SHIFT]
;;;242    			 [GETJSAMPLE(ptr[2]) >> C2_SHIFT];
;;;243          /* increment, check for overflow and undo increment if so. */
;;;244          if (++(*histp) <= 0)
;;;245    	(*histp)--;
000018  f64f7eff          MOV      lr,#0xffff
                  |L13.28|
00001c  7855              LDRB     r5,[r2,#1]            ;240
00001e  7896              LDRB     r6,[r2,#2]            ;240
000020  08ad              LSRS     r5,r5,#2              ;240
000022  01ad              LSLS     r5,r5,#6              ;240
000024  08f6              LSRS     r6,r6,#3              ;240
000026  eb050546          ADD      r5,r5,r6,LSL #1       ;240
00002a  7816              LDRB     r6,[r2,#0]            ;240
00002c  08f6              LSRS     r6,r6,#3              ;240
00002e  f85c6026          LDR      r6,[r12,r6,LSL #2]    ;240
000032  4435              ADD      r5,r5,r6              ;240
000034  882e              LDRH     r6,[r5,#0]            ;244
000036  1c76              ADDS     r6,r6,#1              ;244
000038  0436              LSLS     r6,r6,#16             ;244
00003a  0c36              LSRS     r6,r6,#16             ;244
00003c  802e              STRH     r6,[r5,#0]            ;244
00003e  d101              BNE      |L13.68|
000040  f8a5e000          STRH     lr,[r5,#0]
                  |L13.68|
000044  1e40              SUBS     r0,r0,#1
000046  f1020203          ADD      r2,r2,#3
00004a  d1e7              BNE      |L13.28|
                  |L13.76|
00004c  1c64              ADDS     r4,r4,#1              ;238
                  |L13.78|
00004e  429c              CMP      r4,r3                 ;236
000050  dbde              BLT      |L13.16|
;;;246          ptr += 3;
;;;247        }
;;;248      }
;;;249    }
000052  bdf0              POP      {r4-r7,pc}
;;;250    
                          ENDP


                          AREA ||i.select_colors||, CODE, READONLY, ALIGN=1

                  select_colors PROC
;;;539    LOCAL(void)
;;;540    select_colors (j_decompress_ptr cinfo, int desired_colors)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;541    /* Master routine for color selection */
;;;542    {
000004  4605              MOV      r5,r0
;;;543      boxptr boxlist;
;;;544      int numboxes;
;;;545      int i;
;;;546    
;;;547      /* Allocate workspace for box list */
;;;548      boxlist = (boxptr) (*cinfo->mem->alloc_small)
000006  6840              LDR      r0,[r0,#4]
000008  460e              MOV      r6,r1                 ;542
00000a  014a              LSLS     r2,r1,#5
00000c  6803              LDR      r3,[r0,#0]
00000e  2101              MOVS     r1,#1
000010  4628              MOV      r0,r5
000012  4798              BLX      r3
000014  4604              MOV      r4,r0
;;;549        ((j_common_ptr) cinfo, JPOOL_IMAGE, desired_colors * SIZEOF(box));
;;;550      /* Initialize one box containing whole space */
;;;551      numboxes = 1;
;;;552      boxlist[0].c0min = 0;
000016  2100              MOVS     r1,#0
;;;553      boxlist[0].c0max = MAXJSAMPLE >> C0_SHIFT;
000018  221f              MOVS     r2,#0x1f
00001a  e9c41200          STRD     r1,r2,[r4,#0]
;;;554      boxlist[0].c1min = 0;
;;;555      boxlist[0].c1max = MAXJSAMPLE >> C1_SHIFT;
00001e  203f              MOVS     r0,#0x3f
000020  e9c41002          STRD     r1,r0,[r4,#8]
000024  e9c41204          STRD     r1,r2,[r4,#0x10]
000028  2701              MOVS     r7,#1                 ;551
;;;556      boxlist[0].c2min = 0;
;;;557      boxlist[0].c2max = MAXJSAMPLE >> C2_SHIFT;
;;;558      /* Shrink it to actually-used volume and set its statistics */
;;;559      update_box(cinfo, & boxlist[0]);
00002a  4621              MOV      r1,r4
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       update_box
;;;560      /* Perform median-cut to produce final box list */
;;;561      numboxes = median_cut(cinfo, boxlist, numboxes, desired_colors);
000032  4633              MOV      r3,r6
000034  463a              MOV      r2,r7
000036  4621              MOV      r1,r4
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       median_cut
00003e  4607              MOV      r7,r0
;;;562      /* Compute the representative color for each box, fill colormap */
;;;563      for (i = 0; i < numboxes; i++)
000040  2600              MOVS     r6,#0
000042  e006              B        |L14.82|
                  |L14.68|
;;;564        compute_color(cinfo, & boxlist[i], i);
000044  eb041146          ADD      r1,r4,r6,LSL #5
000048  4632              MOV      r2,r6
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       compute_color
000050  1c76              ADDS     r6,r6,#1
                  |L14.82|
000052  42be              CMP      r6,r7                 ;563
000054  dbf6              BLT      |L14.68|
;;;565      cinfo->actual_number_of_colors = numboxes;
;;;566      TRACEMS1(cinfo, 1, JTRC_QUANT_SELECTED, numboxes);
000056  f8c57084          STR      r7,[r5,#0x84]
00005a  6829              LDR      r1,[r5,#0]
00005c  2060              MOVS     r0,#0x60
00005e  6148              STR      r0,[r1,#0x14]
000060  6828              LDR      r0,[r5,#0]
000062  2101              MOVS     r1,#1
000064  6187              STR      r7,[r0,#0x18]
000066  6828              LDR      r0,[r5,#0]
000068  6842              LDR      r2,[r0,#4]
00006a  4628              MOV      r0,r5
00006c  e8bd41f0          POP      {r4-r8,lr}
000070  4710              BX       r2
;;;567    }
;;;568    
                          ENDP


                          AREA ||i.start_pass_2_quant||, CODE, READONLY, ALIGN=2

                  start_pass_2_quant PROC
;;;1168   METHODDEF(void)
;;;1169   start_pass_2_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1170   {
;;;1171     my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
;;;1172     hist3d histogram = cquantize->histogram;
000004  f8d041cc          LDR      r4,[r0,#0x1cc]
000008  4605              MOV      r5,r0                 ;1170
;;;1173     int i;
;;;1174   
;;;1175     /* Only F-S dithering or no dithering is supported. */
;;;1176     /* If user asks for ordered dither, give him F-S. */
;;;1177     if (cinfo->dither_mode != JDITHER_NONE)
00000a  f8900058          LDRB     r0,[r0,#0x58]
00000e  69a6              LDR      r6,[r4,#0x18]         ;1170
000010  b110              CBZ      r0,|L15.24|
;;;1178       cinfo->dither_mode = JDITHER_FS;
000012  2002              MOVS     r0,#2
000014  f8850058          STRB     r0,[r5,#0x58]
                  |L15.24|
;;;1179   
;;;1180     if (is_pre_scan) {
;;;1181       /* Set up method pointers */
;;;1182       cquantize->pub.color_quantize = prescan_quantize;
;;;1183       cquantize->pub.finish_pass = finish_pass1;
;;;1184       cquantize->needs_zeroed = TRUE; /* Always zero histogram */
000018  2001              MOVS     r0,#1
00001a  f04f0800          MOV      r8,#0
00001e  b129              CBZ      r1,|L15.44|
000020  492c              LDR      r1,|L15.212|
000022  6061              STR      r1,[r4,#4]            ;1183
000024  492c              LDR      r1,|L15.216|
000026  60a1              STR      r1,[r4,#8]
000028  61e0              STR      r0,[r4,#0x1c]
00002a  e043              B        |L15.180|
                  |L15.44|
;;;1185     } else {
;;;1186       /* Set up method pointers */
;;;1187       if (cinfo->dither_mode == JDITHER_FS)
00002c  f8951058          LDRB     r1,[r5,#0x58]
000030  2902              CMP      r1,#2
000032  d022              BEQ      |L15.122|
;;;1188         cquantize->pub.color_quantize = pass2_fs_dither;
;;;1189       else
;;;1190         cquantize->pub.color_quantize = pass2_no_dither;
000034  4929              LDR      r1,|L15.220|
                  |L15.54|
;;;1191       cquantize->pub.finish_pass = finish_pass2;
000036  6061              STR      r1,[r4,#4]
000038  4929              LDR      r1,|L15.224|
;;;1192   
;;;1193       /* Make sure color count is acceptable */
;;;1194       i = cinfo->actual_number_of_colors;
00003a  60a1              STR      r1,[r4,#8]
;;;1195       if (i < 1)
00003c  f8d57084          LDR      r7,[r5,#0x84]
000040  2f01              CMP      r7,#1
000042  da08              BGE      |L15.86|
;;;1196         ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, 1);
000044  682a              LDR      r2,[r5,#0]
000046  2138              MOVS     r1,#0x38
000048  6151              STR      r1,[r2,#0x14]
00004a  6829              LDR      r1,[r5,#0]
00004c  6188              STR      r0,[r1,#0x18]
00004e  6828              LDR      r0,[r5,#0]
000050  6801              LDR      r1,[r0,#0]
000052  4628              MOV      r0,r5
000054  4788              BLX      r1
                  |L15.86|
;;;1197       if (i > MAXNUMCOLORS)
000056  f44f7080          MOV      r0,#0x100
00005a  4287              CMP      r7,r0
00005c  dd08              BLE      |L15.112|
;;;1198         ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);
00005e  682a              LDR      r2,[r5,#0]
000060  2139              MOVS     r1,#0x39
000062  6151              STR      r1,[r2,#0x14]
000064  6829              LDR      r1,[r5,#0]
000066  6188              STR      r0,[r1,#0x18]
000068  6828              LDR      r0,[r5,#0]
00006a  6801              LDR      r1,[r0,#0]
00006c  4628              MOV      r0,r5
00006e  4788              BLX      r1
                  |L15.112|
;;;1199   
;;;1200       if (cinfo->dither_mode == JDITHER_FS) {
000070  f8950058          LDRB     r0,[r5,#0x58]
000074  2802              CMP      r0,#2
000076  d002              BEQ      |L15.126|
000078  e019              B        |L15.174|
                  |L15.122|
00007a  491a              LDR      r1,|L15.228|
00007c  e7db              B        |L15.54|
                  |L15.126|
;;;1201         size_t arraysize = (size_t) ((cinfo->output_width + 2) *
00007e  6f28              LDR      r0,[r5,#0x70]
000080  1c80              ADDS     r0,r0,#2
000082  eb000040          ADD      r0,r0,r0,LSL #1
000086  0047              LSLS     r7,r0,#1
;;;1202   				   (3 * SIZEOF(FSERROR)));
;;;1203         /* Allocate Floyd-Steinberg workspace if we didn't already. */
;;;1204         if (cquantize->fserrors == NULL)
000088  6a20              LDR      r0,[r4,#0x20]
00008a  b930              CBNZ     r0,|L15.154|
;;;1205   	cquantize->fserrors = (FSERRPTR) (*cinfo->mem->alloc_large)
00008c  6868              LDR      r0,[r5,#4]
00008e  463a              MOV      r2,r7
000090  2101              MOVS     r1,#1
000092  6843              LDR      r3,[r0,#4]
000094  4628              MOV      r0,r5
000096  4798              BLX      r3
000098  6220              STR      r0,[r4,#0x20]
                  |L15.154|
;;;1206   	  ((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);
;;;1207         /* Initialize the propagated errors to zero. */
;;;1208         jzero_far((void FAR *) cquantize->fserrors, arraysize);
00009a  4639              MOV      r1,r7
00009c  f7fffffe          BL       jzero_far
;;;1209         /* Make the error-limit table if we didn't already. */
;;;1210         if (cquantize->error_limiter == NULL)
0000a0  6aa0              LDR      r0,[r4,#0x28]
0000a2  b910              CBNZ     r0,|L15.170|
;;;1211   	init_error_limit(cinfo);
0000a4  4628              MOV      r0,r5
0000a6  f7fffffe          BL       init_error_limit
                  |L15.170|
;;;1212         cquantize->on_odd_row = FALSE;
0000aa  f8c48024          STR      r8,[r4,#0x24]
                  |L15.174|
;;;1213       }
;;;1214   
;;;1215     }
;;;1216     /* Zero the histogram or inverse color map, if necessary */
;;;1217     if (cquantize->needs_zeroed) {
0000ae  69e0              LDR      r0,[r4,#0x1c]
0000b0  2800              CMP      r0,#0
0000b2  d00d              BEQ      |L15.208|
                  |L15.180|
;;;1218       for (i = 0; i < HIST_C0_ELEMS; i++) {
0000b4  2500              MOVS     r5,#0
;;;1219         jzero_far((void FAR *) histogram[i],
0000b6  f44f5780          MOV      r7,#0x1000
0000ba  bf00              NOP      
                  |L15.188|
0000bc  f8560025          LDR      r0,[r6,r5,LSL #2]
0000c0  4639              MOV      r1,r7
0000c2  f7fffffe          BL       jzero_far
0000c6  1c6d              ADDS     r5,r5,#1
0000c8  2d20              CMP      r5,#0x20              ;1218
0000ca  dbf7              BLT      |L15.188|
;;;1220   		HIST_C1_ELEMS*HIST_C2_ELEMS * SIZEOF(histcell));
;;;1221       }
;;;1222       cquantize->needs_zeroed = FALSE;
0000cc  f8c4801c          STR      r8,[r4,#0x1c]
                  |L15.208|
;;;1223     }
;;;1224   }
0000d0  e8bd81f0          POP      {r4-r8,pc}
;;;1225   
                          ENDP

                  |L15.212|
                          DCD      prescan_quantize
                  |L15.216|
                          DCD      finish_pass1
                  |L15.220|
                          DCD      pass2_no_dither
                  |L15.224|
                          DCD      finish_pass2
                  |L15.228|
                          DCD      pass2_fs_dither

                          AREA ||i.update_box||, CODE, READONLY, ALIGN=2

                  update_box PROC
;;;313    LOCAL(void)
;;;314    update_box (j_decompress_ptr cinfo, boxptr boxp)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;315    /* Shrink the min/max bounds of a box to enclose only nonzero elements, */
;;;316    /* and recompute its volume and population */
;;;317    {
;;;318      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000004  f8d001cc          LDR      r0,[r0,#0x1cc]
;;;319      hist3d histogram = cquantize->histogram;
000008  e9d13600          LDRD     r3,r6,[r1,#0]
;;;320      histptr histp;
;;;321      int c0,c1,c2;
;;;322      int c0min,c0max,c1min,c1max,c2min,c2max;
;;;323      INT32 dist0,dist1,dist2;
;;;324      long ccount;
;;;325      
;;;326      c0min = boxp->c0min;  c0max = boxp->c0max;
;;;327      c1min = boxp->c1min;  c1max = boxp->c1max;
;;;328      c2min = boxp->c2min;  c2max = boxp->c2max;
;;;329      
;;;330      if (c0max > c0min)
00000c  6987              LDR      r7,[r0,#0x18]
00000e  e9d10404          LDRD     r0,r4,[r1,#0x10]
000012  e9d12502          LDRD     r2,r5,[r1,#8]
000016  429e              CMP      r6,r3
000018  dd23              BLE      |L16.98|
;;;331        for (c0 = c0min; c0 <= c0max; c0++)
00001a  469b              MOV      r11,r3
00001c  e01f              B        |L16.94|
                  |L16.30|
;;;332          for (c1 = c1min; c1 <= c1max; c1++) {
00001e  4692              MOV      r10,r2
000020  e019              B        |L16.86|
;;;333    	histp = & histogram[c0][c1][c2min];
000022  bf00              NOP      
                  |L16.36|
000024  ea4f1c8a          LSL      r12,r10,#6
000028  eb0c0840          ADD      r8,r12,r0,LSL #1
00002c  f857c02b          LDR      r12,[r7,r11,LSL #2]
;;;334    	for (c2 = c2min; c2 <= c2max; c2++)
000030  4681              MOV      r9,r0
000032  44c4              ADD      r12,r12,r8            ;333
000034  e00b              B        |L16.78|
;;;335    	  if (*histp++ != 0) {
000036  bf00              NOP      
                  |L16.56|
000038  f83c8b02          LDRH     r8,[r12],#2
00003c  f1b80f00          CMP      r8,#0
000040  d003              BEQ      |L16.74|
;;;336    	    boxp->c0min = c0min = c0;
000042  465b              MOV      r3,r11
;;;337    	    goto have_c0min;
000044  f8c1b000          STR      r11,[r1,#0]
000048  e00b              B        |L16.98|
                  |L16.74|
00004a  f1090901          ADD      r9,r9,#1              ;334
                  |L16.78|
00004e  45a1              CMP      r9,r4                 ;334
000050  ddf2              BLE      |L16.56|
000052  f10a0a01          ADD      r10,r10,#1            ;332
                  |L16.86|
000056  45aa              CMP      r10,r5                ;332
000058  dde4              BLE      |L16.36|
00005a  f10b0b01          ADD      r11,r11,#1            ;331
                  |L16.94|
00005e  45b3              CMP      r11,r6                ;331
000060  dddd              BLE      |L16.30|
                  |L16.98|
;;;338    	  }
;;;339          }
;;;340     have_c0min:
;;;341      if (c0max > c0min)
000062  429e              CMP      r6,r3
000064  dd23              BLE      |L16.174|
;;;342        for (c0 = c0max; c0 >= c0min; c0--)
000066  46b3              MOV      r11,r6
000068  e01f              B        |L16.170|
                  |L16.106|
;;;343          for (c1 = c1min; c1 <= c1max; c1++) {
00006a  4692              MOV      r10,r2
00006c  e019              B        |L16.162|
;;;344    	histp = & histogram[c0][c1][c2min];
00006e  bf00              NOP      
                  |L16.112|
000070  ea4f1c8a          LSL      r12,r10,#6
000074  eb0c0840          ADD      r8,r12,r0,LSL #1
000078  f857c02b          LDR      r12,[r7,r11,LSL #2]
;;;345    	for (c2 = c2min; c2 <= c2max; c2++)
00007c  4681              MOV      r9,r0
00007e  44c4              ADD      r12,r12,r8            ;344
000080  e00b              B        |L16.154|
;;;346    	  if (*histp++ != 0) {
000082  bf00              NOP      
                  |L16.132|
000084  f83c8b02          LDRH     r8,[r12],#2
000088  f1b80f00          CMP      r8,#0
00008c  d003              BEQ      |L16.150|
;;;347    	    boxp->c0max = c0max = c0;
00008e  465e              MOV      r6,r11
;;;348    	    goto have_c0max;
000090  f8c1b004          STR      r11,[r1,#4]
000094  e00b              B        |L16.174|
                  |L16.150|
000096  f1090901          ADD      r9,r9,#1              ;345
                  |L16.154|
00009a  45a1              CMP      r9,r4                 ;345
00009c  ddf2              BLE      |L16.132|
00009e  f10a0a01          ADD      r10,r10,#1            ;343
                  |L16.162|
0000a2  45aa              CMP      r10,r5                ;343
0000a4  dde4              BLE      |L16.112|
0000a6  f1ab0b01          SUB      r11,r11,#1            ;342
                  |L16.170|
0000aa  459b              CMP      r11,r3                ;342
0000ac  dadd              BGE      |L16.106|
                  |L16.174|
;;;349    	  }
;;;350          }
;;;351     have_c0max:
;;;352      if (c1max > c1min)
0000ae  4295              CMP      r5,r2
0000b0  dd23              BLE      |L16.250|
;;;353        for (c1 = c1min; c1 <= c1max; c1++)
0000b2  4693              MOV      r11,r2
0000b4  e01f              B        |L16.246|
                  |L16.182|
0000b6  ea4f1c8b          LSL      r12,r11,#6            ;333
;;;354          for (c0 = c0min; c0 <= c0max; c0++) {
0000ba  469a              MOV      r10,r3
0000bc  eb0c0e40          ADD      lr,r12,r0,LSL #1      ;333
0000c0  e015              B        |L16.238|
;;;355    	histp = & histogram[c0][c1][c2min];
0000c2  bf00              NOP      
                  |L16.196|
0000c4  f857802a          LDR      r8,[r7,r10,LSL #2]
;;;356    	for (c2 = c2min; c2 <= c2max; c2++)
0000c8  4681              MOV      r9,r0
0000ca  eb0e0c08          ADD      r12,lr,r8             ;355
0000ce  e00a              B        |L16.230|
                  |L16.208|
;;;357    	  if (*histp++ != 0) {
0000d0  f83c8b02          LDRH     r8,[r12],#2
0000d4  f1b80f00          CMP      r8,#0
0000d8  d003              BEQ      |L16.226|
;;;358    	    boxp->c1min = c1min = c1;
0000da  465a              MOV      r2,r11
;;;359    	    goto have_c1min;
0000dc  f8c1b008          STR      r11,[r1,#8]
0000e0  e00b              B        |L16.250|
                  |L16.226|
0000e2  f1090901          ADD      r9,r9,#1              ;356
                  |L16.230|
0000e6  45a1              CMP      r9,r4                 ;356
0000e8  ddf2              BLE      |L16.208|
0000ea  f10a0a01          ADD      r10,r10,#1            ;354
                  |L16.238|
0000ee  45b2              CMP      r10,r6                ;354
0000f0  dde8              BLE      |L16.196|
0000f2  f10b0b01          ADD      r11,r11,#1            ;353
                  |L16.246|
0000f6  45ab              CMP      r11,r5                ;353
0000f8  dddd              BLE      |L16.182|
                  |L16.250|
;;;360    	  }
;;;361          }
;;;362     have_c1min:
;;;363      if (c1max > c1min)
0000fa  4295              CMP      r5,r2
0000fc  dd23              BLE      |L16.326|
;;;364        for (c1 = c1max; c1 >= c1min; c1--)
0000fe  46ab              MOV      r11,r5
000100  e01f              B        |L16.322|
                  |L16.258|
000102  ea4f1c8b          LSL      r12,r11,#6            ;333
;;;365          for (c0 = c0min; c0 <= c0max; c0++) {
000106  469a              MOV      r10,r3
000108  eb0c0e40          ADD      lr,r12,r0,LSL #1      ;333
00010c  e015              B        |L16.314|
;;;366    	histp = & histogram[c0][c1][c2min];
00010e  bf00              NOP      
                  |L16.272|
000110  f857c02a          LDR      r12,[r7,r10,LSL #2]
;;;367    	for (c2 = c2min; c2 <= c2max; c2++)
000114  4681              MOV      r9,r0
000116  44f4              ADD      r12,r12,lr            ;366
000118  e00b              B        |L16.306|
;;;368    	  if (*histp++ != 0) {
00011a  bf00              NOP      
                  |L16.284|
00011c  f83c8b02          LDRH     r8,[r12],#2
000120  f1b80f00          CMP      r8,#0
000124  d003              BEQ      |L16.302|
;;;369    	    boxp->c1max = c1max = c1;
000126  465d              MOV      r5,r11
;;;370    	    goto have_c1max;
000128  f8c1b00c          STR      r11,[r1,#0xc]
00012c  e00b              B        |L16.326|
                  |L16.302|
00012e  f1090901          ADD      r9,r9,#1              ;367
                  |L16.306|
000132  45a1              CMP      r9,r4                 ;367
000134  ddf2              BLE      |L16.284|
000136  f10a0a01          ADD      r10,r10,#1            ;365
                  |L16.314|
00013a  45b2              CMP      r10,r6                ;365
00013c  dde8              BLE      |L16.272|
00013e  f1ab0b01          SUB      r11,r11,#1            ;364
                  |L16.322|
000142  4593              CMP      r11,r2                ;364
000144  dadd              BGE      |L16.258|
                  |L16.326|
;;;371    	  }
;;;372          }
;;;373     have_c1max:
;;;374      if (c2max > c2min)
000146  4284              CMP      r4,r0
000148  dd29              BLE      |L16.414|
;;;375        for (c2 = c2min; c2 <= c2max; c2++)
;;;376          for (c0 = c0min; c0 <= c0max; c0++) {
;;;377    	histp = & histogram[c0][c1min][c2];
00014a  ea4f1c82          LSL      r12,r2,#6
00014e  4682              MOV      r10,r0                ;375
000150  f8cdc000          STR      r12,[sp,#0]           ;375
000154  e021              B        |L16.410|
                  |L16.342|
000156  f8ddc000          LDR      r12,[sp,#0]
00015a  4699              MOV      r9,r3                 ;376
00015c  eb0c0e4a          ADD      lr,r12,r10,LSL #1
000160  e017              B        |L16.402|
000162  bf00              NOP      
                  |L16.356|
000164  f857c029          LDR      r12,[r7,r9,LSL #2]
000168  eb0e0b0c          ADD      r11,lr,r12
;;;378    	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
00016c  4694              MOV      r12,r2
00016e  e00c              B        |L16.394|
                  |L16.368|
;;;379    	  if (*histp != 0) {
000170  f8bb8000          LDRH     r8,[r11,#0]
000174  f1b80f00          CMP      r8,#0
000178  d003              BEQ      |L16.386|
;;;380    	    boxp->c2min = c2min = c2;
00017a  4650              MOV      r0,r10
;;;381    	    goto have_c2min;
00017c  f8c1a010          STR      r10,[r1,#0x10]
000180  e00d              B        |L16.414|
                  |L16.386|
000182  f10b0b40          ADD      r11,r11,#0x40         ;378
000186  f10c0c01          ADD      r12,r12,#1            ;378
                  |L16.394|
00018a  45ac              CMP      r12,r5                ;378
00018c  ddf0              BLE      |L16.368|
00018e  f1090901          ADD      r9,r9,#1              ;376
                  |L16.402|
000192  45b1              CMP      r9,r6                 ;376
000194  dde6              BLE      |L16.356|
000196  f10a0a01          ADD      r10,r10,#1            ;375
                  |L16.410|
00019a  45a2              CMP      r10,r4                ;375
00019c  dddb              BLE      |L16.342|
                  |L16.414|
;;;382    	  }
;;;383          }
;;;384     have_c2min:
;;;385      if (c2max > c2min)
00019e  4284              CMP      r4,r0
0001a0  dd29              BLE      |L16.502|
0001a2  ea4f1c82          LSL      r12,r2,#6             ;377
;;;386        for (c2 = c2max; c2 >= c2min; c2--)
0001a6  46a2              MOV      r10,r4
0001a8  f8cdc000          STR      r12,[sp,#0]
0001ac  e021              B        |L16.498|
                  |L16.430|
0001ae  f8dd8000          LDR      r8,[sp,#0]            ;377
;;;387          for (c0 = c0min; c0 <= c0max; c0++) {
0001b2  4699              MOV      r9,r3
0001b4  eb080e4a          ADD      lr,r8,r10,LSL #1      ;377
0001b8  e017              B        |L16.490|
;;;388    	histp = & histogram[c0][c1min][c2];
0001ba  bf00              NOP      
                  |L16.444|
0001bc  f8578029          LDR      r8,[r7,r9,LSL #2]
;;;389    	for (c1 = c1min; c1 <= c1max; c1++, histp += HIST_C2_ELEMS)
0001c0  4694              MOV      r12,r2
0001c2  eb0e0b08          ADD      r11,lr,r8             ;388
0001c6  e00c              B        |L16.482|
                  |L16.456|
;;;390    	  if (*histp != 0) {
0001c8  f8bb8000          LDRH     r8,[r11,#0]
0001cc  f1b80f00          CMP      r8,#0
0001d0  d003              BEQ      |L16.474|
;;;391    	    boxp->c2max = c2max = c2;
0001d2  4654              MOV      r4,r10
;;;392    	    goto have_c2max;
0001d4  f8c1a014          STR      r10,[r1,#0x14]
0001d8  e00d              B        |L16.502|
                  |L16.474|
0001da  f10b0b40          ADD      r11,r11,#0x40         ;389
0001de  f10c0c01          ADD      r12,r12,#1            ;389
                  |L16.482|
0001e2  45ac              CMP      r12,r5                ;389
0001e4  ddf0              BLE      |L16.456|
0001e6  f1090901          ADD      r9,r9,#1              ;387
                  |L16.490|
0001ea  45b1              CMP      r9,r6                 ;387
0001ec  dde6              BLE      |L16.444|
0001ee  f1aa0a01          SUB      r10,r10,#1            ;386
                  |L16.498|
0001f2  4582              CMP      r10,r0                ;386
0001f4  dadb              BGE      |L16.430|
                  |L16.502|
;;;393    	  }
;;;394          }
;;;395     have_c2max:
;;;396    
;;;397      /* Update box volume.
;;;398       * We use 2-norm rather than real volume here; this biases the method
;;;399       * against making long narrow boxes, and it has the side benefit that
;;;400       * a box is splittable iff norm > 0.
;;;401       * Since the differences are expressed in histogram-cell units,
;;;402       * we have to shift back to JSAMPLE units to get consistent distances;
;;;403       * after which, we scale according to the selected distance scale factors.
;;;404       */
;;;405      dist0 = ((c0max - c0min) << C0_SHIFT) * C0_SCALE;
0001f6  eba60c03          SUB      r12,r6,r3
0001fa  ea4f1a0c          LSL      r10,r12,#4
;;;406      dist1 = ((c1max - c1min) << C1_SHIFT) * C1_SCALE;
0001fe  eba50c02          SUB      r12,r5,r2
;;;407      dist2 = ((c2max - c2min) << C2_SHIFT) * C2_SCALE;
000202  eba40800          SUB      r8,r4,r0
000206  eb0c0c4c          ADD      r12,r12,r12,LSL #1    ;406
00020a  ea4f09c8          LSL      r9,r8,#3
00020e  ea4f0c8c          LSL      r12,r12,#2            ;406
;;;408      boxp->volume = dist0*dist0 + dist1*dist1 + dist2*dist2;
000212  fb0af80a          MUL      r8,r10,r10
000216  fb0c8c0c          MLA      r12,r12,r12,r8
00021a  fb09cc09          MLA      r12,r9,r9,r12
;;;409      
;;;410      /* Now scan remaining volume of box and compute population */
;;;411      ccount = 0;
00021e  f04f0b00          MOV      r11,#0
;;;412      for (c0 = c0min; c0 <= c0max; c0++)
000222  f8c1c018          STR      r12,[r1,#0x18]
000226  e01d              B        |L16.612|
                  |L16.552|
;;;413        for (c1 = c1min; c1 <= c1max; c1++) {
000228  4691              MOV      r9,r2
00022a  e017              B        |L16.604|
                  |L16.556|
;;;414          histp = & histogram[c0][c1][c2min];
00022c  ea4f1389          LSL      r3,r9,#6
000230  eb030c40          ADD      r12,r3,r0,LSL #1
000234  f857302a          LDR      r3,[r7,r10,LSL #2]
000238  449c              ADD      r12,r12,r3
;;;415          for (c2 = c2min; c2 <= c2max; c2++, histp++)
00023a  4603              MOV      r3,r0
00023c  e00a              B        |L16.596|
;;;416    	if (*histp != 0) {
00023e  bf00              NOP      
                  |L16.576|
000240  f8bc8000          LDRH     r8,[r12,#0]
000244  f1b80f00          CMP      r8,#0
000248  d001              BEQ      |L16.590|
;;;417    	  ccount++;
00024a  f10b0b01          ADD      r11,r11,#1
                  |L16.590|
00024e  1c5b              ADDS     r3,r3,#1
000250  f10c0c02          ADD      r12,r12,#2
                  |L16.596|
000254  42a3              CMP      r3,r4                 ;415
000256  ddf3              BLE      |L16.576|
000258  f1090901          ADD      r9,r9,#1              ;413
                  |L16.604|
00025c  45a9              CMP      r9,r5                 ;413
00025e  dde5              BLE      |L16.556|
000260  f10a0301          ADD      r3,r10,#1             ;412
                  |L16.612|
000264  469a              MOV      r10,r3                ;412
000266  42b3              CMP      r3,r6                 ;412
000268  ddde              BLE      |L16.552|
;;;418    	}
;;;419        }
;;;420      boxp->colorcount = ccount;
00026a  f8c1b01c          STR      r11,[r1,#0x1c]
;;;421    }
00026e  e8bd8ff8          POP      {r3-r11,pc}
;;;422    
                          ENDP

