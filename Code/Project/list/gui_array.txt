; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\gui_array.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\gui_array.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\Widget\GUI_ARRAY.c]
                          THUMB

                          AREA ||i.GUI_ARRAY_AddItem||, CODE, READONLY, ALIGN=1

                  GUI_ARRAY_AddItem PROC
;;;55     */
;;;56     int GUI_ARRAY_AddItem(GUI_ARRAY* pThis, const void *pNew, int Len) {
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;57       WM_HMEM hNewItem = 0;
000004  2700              MOVS     r7,#0
000006  460b              MOV      r3,r1                 ;56
000008  4604              MOV      r4,r0                 ;56
;;;58       WM_HMEM hNewBuffer;
;;;59       WM_HMEM *pNewBuffer;
;;;60       int r = 0;
00000a  463e              MOV      r6,r7
00000c  b12a              CBZ      r2,|L1.26|
;;;61     
;;;62       GUI_ARRAY_CHECK(pThis);    /* Sanity checks at higher debug levels only */
;;;63     
;;;64       WM_LOCK();
;;;65       /* Alloc memory for new item */
;;;66       if (Len) {
;;;67         if ((hNewItem = GUI_ALLOC_AllocInit(pNew, Len)) == 0) {
00000e  b211              SXTH     r1,r2
000010  4618              MOV      r0,r3
000012  f7fffffe          BL       GUI_ALLOC_AllocInit
000016  0007              MOVS     r7,r0
000018  d015              BEQ      |L1.70|
                  |L1.26|
;;;68           GUI_DEBUG_ERROROUT("GUI_ARRAY_AddItem failed to alloc buffer");
;;;69           r = 1;            /* Error */
;;;70         }
;;;71       }
;;;72       /* Put handle of new item into the array */
;;;73       if (r == 0) {
;;;74         int NumItems;
;;;75         NumItems = pThis->NumItems;
00001a  f8b48000          LDRH     r8,[r4,#0]
;;;76         /* Add the handle to new item to the buffer */
;;;77         hNewBuffer = GUI_ALLOC_Realloc(pThis->haHandle, (NumItems + 1) * sizeof(WM_HMEM));
00001e  f9b40002          LDRSH    r0,[r4,#2]
000022  ea4f0148          LSL      r1,r8,#1
000026  1c89              ADDS     r1,r1,#2
000028  f7fffffe          BL       GUI_ALLOC_Realloc
00002c  0005              MOVS     r5,r0
;;;78         if (hNewBuffer == 0) {
00002e  d00c              BEQ      |L1.74|
;;;79           GUI_DEBUG_ERROROUT("GUI_ARRAY_AddItem failed to alloc buffer");
;;;80           GUI_ALLOC_Free(hNewItem);
;;;81           r = 1;            /* Error */
;;;82         } else {
;;;83           pNewBuffer = (WM_HMEM*) GUI_ALLOC_h2p(hNewBuffer);
000030  f7fffffe          BL       GUI_ALLOC_h2p
;;;84           *(pNewBuffer + NumItems) = hNewItem;
000034  f8207018          STRH     r7,[r0,r8,LSL #1]
;;;85           pThis->haHandle = hNewBuffer;
000038  8065              STRH     r5,[r4,#2]
;;;86           pThis->NumItems++;
00003a  8820              LDRH     r0,[r4,#0]
00003c  1c40              ADDS     r0,r0,#1
00003e  8020              STRH     r0,[r4,#0]
                  |L1.64|
;;;87         }
;;;88       }
;;;89       WM_UNLOCK();
;;;90       return r;
000040  4630              MOV      r0,r6
;;;91     }
000042  e8bd81f0          POP      {r4-r8,pc}
                  |L1.70|
000046  2601              MOVS     r6,#1                 ;69
000048  e7fa              B        |L1.64|
                  |L1.74|
00004a  4638              MOV      r0,r7                 ;80
00004c  f7fffffe          BL       GUI_ALLOC_Free
000050  e7f9              B        |L1.70|
;;;92     
                          ENDP


                          AREA ||i.GUI_ARRAY_Delete||, CODE, READONLY, ALIGN=2

                  GUI_ARRAY_Delete PROC
;;;103    */
;;;104    void GUI_ARRAY_Delete(GUI_ARRAY* pThis) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;105      int i;
;;;106      WM_HMEM ha;
;;;107      WM_HMEM* pa;
;;;108    
;;;109      GUI_ARRAY_CHECK(pThis);    /* Sanity checks at higher debug levels only */
;;;110    
;;;111      ha = pThis->haHandle;
000004  f9b00002          LDRSH    r0,[r0,#2]
000008  2800              CMP      r0,#0                 ;104
00000a  d012              BEQ      |L2.50|
;;;112      if (ha) {
;;;113        pa = (WM_HMEM*) GUI_ALLOC_h2p(ha);
00000c  f7fffffe          BL       GUI_ALLOC_h2p
000010  4606              MOV      r6,r0
;;;114        /* Free the attached items, one at a time */
;;;115        for (i = 0; i < pThis->NumItems; i++) {
000012  2400              MOVS     r4,#0
000014  e005              B        |L2.34|
;;;116          GUI_ALLOC_FreePtr(pa+i);
000016  bf00              NOP      
                  |L2.24|
000018  eb060044          ADD      r0,r6,r4,LSL #1
00001c  f7fffffe          BL       GUI_ALLOC_FreePtr
000020  1c64              ADDS     r4,r4,#1
                  |L2.34|
000022  8828              LDRH     r0,[r5,#0]            ;115
000024  42a0              CMP      r0,r4                 ;115
000026  dcf7              BGT      |L2.24|
;;;117        }
;;;118        /* Free the handle buffer */
;;;119        GUI_ALLOC_FreePtr(&pThis->haHandle);
000028  1ca8              ADDS     r0,r5,#2
00002a  f7fffffe          BL       GUI_ALLOC_FreePtr
;;;120        pThis->NumItems = 0;                    /* For safety, in case the array is used after it has been deleted */
00002e  2000              MOVS     r0,#0
000030  8028              STRH     r0,[r5,#0]
                  |L2.50|
;;;121      }
;;;122      #if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
;;;123        pThis->InitState = GUI_ARRAY_STATE_DELETED;
;;;124      #endif
;;;125    }
000032  bd70              POP      {r4-r6,pc}
;;;126    
                          ENDP


                          AREA ||i.GUI_ARRAY_GetNumItems||, CODE, READONLY, ALIGN=1

                  GUI_ARRAY_GetNumItems PROC
;;;34     */
;;;35     unsigned int GUI_ARRAY_GetNumItems(const GUI_ARRAY* pThis) {
000000  8800              LDRH     r0,[r0,#0]
;;;36       GUI_ARRAY_CHECK(pThis);    /* Sanity checks at higher debug levels only */
;;;37     
;;;38       return pThis->NumItems;
;;;39     }
000002  4770              BX       lr
;;;40     
                          ENDP


                          AREA ||i.GUI_ARRAY_GethItem||, CODE, READONLY, ALIGN=1

                  GUI_ARRAY_GethItem PROC
;;;240    */
;;;241    WM_HMEM GUI_ARRAY_GethItem(const GUI_ARRAY* pThis, unsigned int Index) {
000000  b510              PUSH     {r4,lr}
000002  460c              MOV      r4,r1
000004  4601              MOV      r1,r0
;;;242      WM_HMEM h = 0;
000006  2000              MOVS     r0,#0
;;;243    
;;;244      GUI_ARRAY_CHECK(pThis);    /* Sanity checks at higher debug levels only */
;;;245    
;;;246      if (Index < (unsigned)pThis->NumItems) {
000008  880a              LDRH     r2,[r1,#0]
00000a  42a2              CMP      r2,r4
00000c  d908              BLS      |L4.32|
;;;247        WM_HMEM  ha;
;;;248        WM_HMEM* pa;
;;;249        ha = pThis->haHandle;
00000e  f9b11002          LDRSH    r1,[r1,#2]
;;;250        if (ha) {
000012  2900              CMP      r1,#0
000014  d004              BEQ      |L4.32|
;;;251          pa = (WM_HMEM*) GUI_ALLOC_h2p(ha);
000016  4608              MOV      r0,r1
000018  f7fffffe          BL       GUI_ALLOC_h2p
;;;252          h = *(pa + Index);
00001c  f9300014          LDRSH    r0,[r0,r4,LSL #1]
                  |L4.32|
;;;253        }
;;;254      }
;;;255      return h;
;;;256    }
000020  bd10              POP      {r4,pc}
;;;257    
                          ENDP


                          AREA ||i.GUI_ARRAY_GetpItem||, CODE, READONLY, ALIGN=1

                  GUI_ARRAY_GetpItem PROC
;;;272    */
;;;273    void* GUI_ARRAY_GetpItem(const GUI_ARRAY* pThis, unsigned int Index) {
000000  b510              PUSH     {r4,lr}
;;;274      void* p = NULL;
000002  2400              MOVS     r4,#0
;;;275      WM_HMEM h;
;;;276    
;;;277      GUI_ARRAY_CHECK(pThis);    /* Sanity checks at higher debug levels only */
;;;278    
;;;279      h = GUI_ARRAY_GethItem(pThis, Index);
000004  f7fffffe          BL       GUI_ARRAY_GethItem
;;;280      if (h) {
000008  b110              CBZ      r0,|L5.16|
;;;281        p = WM_H2P(h);
00000a  f7fffffe          BL       GUI_ALLOC_h2p
00000e  4604              MOV      r4,r0
                  |L5.16|
;;;282      }
;;;283      return p;
000010  4620              MOV      r0,r4
;;;284    }
000012  bd10              POP      {r4,pc}
;;;285    
                          ENDP


                          AREA ||i.GUI_ARRAY_SetItem||, CODE, READONLY, ALIGN=1

                  GUI_ARRAY_SetItem PROC
;;;184    */
;;;185    WM_HMEM  GUI_ARRAY_SetItem(GUI_ARRAY* pThis, unsigned int Index, const void* pData, int Len) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  460d              MOV      r5,r1
;;;186      WM_HMEM hItem = 0;
;;;187    
;;;188      GUI_ARRAY_CHECK(pThis);    /* Sanity checks at higher debug levels only */
;;;189    
;;;190      if (Index < (unsigned)pThis->NumItems) {
000006  8801              LDRH     r1,[r0,#0]
000008  2400              MOVS     r4,#0                 ;186
00000a  461e              MOV      r6,r3                 ;185
00000c  4617              MOV      r7,r2                 ;185
00000e  42a9              CMP      r1,r5
000010  d920              BLS      |L6.84|
;;;191        WM_HMEM ha;
;;;192        ha = pThis->haHandle;
000012  f9b00002          LDRSH    r0,[r0,#2]
;;;193        if (ha) {
000016  b1e8              CBZ      r0,|L6.84|
;;;194          WM_HMEM* pa;
;;;195          pa = (WM_HMEM*) GUI_ALLOC_h2p(ha);
000018  f7fffffe          BL       GUI_ALLOC_h2p
;;;196          pa += Index;
00001c  eb000545          ADD      r5,r0,r5,LSL #1
;;;197          hItem = *pa;
000020  f9b54000          LDRSH    r4,[r5,#0]
;;;198          /*
;;;199           * If a buffer is already available, a new buffer is only needed when the
;;;200           * new item has a different size.
;;;201           */
;;;202          if (hItem) {
000024  b124              CBZ      r4,|L6.48|
;;;203            if (GUI_ALLOC_GetSize(hItem) != Len) {
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       GUI_ALLOC_GetSize
00002c  42b0              CMP      r0,r6
00002e  d008              BEQ      |L6.66|
                  |L6.48|
;;;204              hItem = 0;
;;;205            }
;;;206          }
;;;207          /*
;;;208           * Allocate a new buffer and free the old one (if needed). 
;;;209           */
;;;210          if (!hItem) {
;;;211            hItem = GUI_ALLOC_AllocZero(Len);
000030  b230              SXTH     r0,r6
000032  f7fffffe          BL       GUI_ALLOC_AllocZero
000036  0004              MOVS     r4,r0
;;;212            if (hItem) {
000038  d003              BEQ      |L6.66|
;;;213              GUI_ALLOC_FreePtr(pa);
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       GUI_ALLOC_FreePtr
;;;214              *pa = hItem;
000040  802c              STRH     r4,[r5,#0]
                  |L6.66|
;;;215            }
;;;216          }
;;;217          /*
;;;218           * Set the item (if needed)
;;;219           */
;;;220          if (pData && hItem) {
000042  b13f              CBZ      r7,|L6.84|
000044  b134              CBZ      r4,|L6.84|
;;;221            char* pItem = (char*) GUI_ALLOC_h2p(hItem);
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       GUI_ALLOC_h2p
;;;222            memcpy(pItem, pData, Len);
00004c  4632              MOV      r2,r6
00004e  4639              MOV      r1,r7
000050  f7fffffe          BL       __aeabi_memcpy
                  |L6.84|
;;;223          }
;;;224        }
;;;225      }
;;;226      return hItem;
000054  4620              MOV      r0,r4
;;;227    }
000056  e8bd81f0          POP      {r4-r8,pc}
;;;228    
                          ENDP


                          AREA ||i.GUI_ARRAY_SethItem||, CODE, READONLY, ALIGN=1

                  GUI_ARRAY_SethItem PROC
;;;145    */
;;;146    int GUI_ARRAY_SethItem(GUI_ARRAY* pThis, unsigned int Index, WM_HMEM hItem) {
000000  b570              PUSH     {r4-r6,lr}
000002  460c              MOV      r4,r1
000004  4601              MOV      r1,r0
000006  4615              MOV      r5,r2
;;;147      WM_HMEM ha;
;;;148      WM_HMEM* pa;
;;;149      int r = 1;
;;;150    
;;;151      GUI_ARRAY_CHECK(pThis);    /* Sanity checks at higher debug levels only */
;;;152    
;;;153      if (Index < (unsigned)pThis->NumItems) {
000008  880a              LDRH     r2,[r1,#0]
00000a  2001              MOVS     r0,#1                 ;149
00000c  42a2              CMP      r2,r4
00000e  d90d              BLS      |L7.44|
;;;154        ha = pThis->haHandle;
000010  f9b11002          LDRSH    r1,[r1,#2]
;;;155        if (ha) {
000014  2900              CMP      r1,#0
000016  d009              BEQ      |L7.44|
;;;156          pa = (WM_HMEM*) GUI_ALLOC_h2p(ha);
000018  4608              MOV      r0,r1
00001a  f7fffffe          BL       GUI_ALLOC_h2p
;;;157          pa += Index;
00001e  eb000444          ADD      r4,r0,r4,LSL #1
;;;158          GUI_ALLOC_FreePtr(pa);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       GUI_ALLOC_FreePtr
;;;159          *pa = hItem;
000028  8025              STRH     r5,[r4,#0]
;;;160          r = 0;
00002a  2000              MOVS     r0,#0
                  |L7.44|
;;;161        }
;;;162      }
;;;163      return r;
;;;164    }
00002c  bd70              POP      {r4-r6,pc}
;;;165    
                          ENDP

