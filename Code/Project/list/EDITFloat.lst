L 1 "..\GUI\Widget\EDITFloat.c"
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : EDITFloat.c
NPurpose     : Edit decimal values
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#include <math.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\math.h" 1
N/*
N * math.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.5
N * Copyright (C) Codemist Ltd., 1988
N * Copyright 1991-1998,2004-2006,2014 ARM Limited. All rights reserved
N */
N
N/*
N * RCS $Revision: 185525 $ Codemist 0.03
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: statham $
N */
N
N/*
N * Parts of this file are based upon fdlibm:
N *
N * ====================================================
N * Copyright (C) 1993 by Sun Microsystems, Inc. All rights reserved.
N *
N * Developed at SunSoft, a Sun Microsystems, Inc. business.
N * Permission to use, copy, modify, and distribute this
N * software is freely granted, provided that this notice
N * is preserved.
N * ====================================================
N */
N
N#ifndef __math_h
N#define __math_h
N#define __ARMCLIB_VERSION 5050041
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N/*
N * Some of these declarations are new in C99.  To access them in C++
N * you can use -D__USE_C99_MATH (or -D__USE_C99_ALL).
N */
N#ifndef __USE_C99_MATH
N  #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X  #if 0L || (1L && 199901L <= 199409L)
S    #define __USE_C99_MATH 1
N  #endif
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#ifdef __TARGET_ARCH_AARCH64
S# define _ARMABI_SOFTFP __declspec(__nothrow)
N#else
N# define _ARMABI_SOFTFP __declspec(__nothrow) __attribute__((__pcs__("aapcs")))
N# define __HAVE_LONGDOUBLE 1
N#endif
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#ifdef __FP_FENV_EXCEPTIONS
S# define _ARMABI_FPEXCEPT _ARMABI
N#else
N# define _ARMABI_FPEXCEPT _ARMABI __attribute__((const))
N#endif
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF inline
S#elif defined __GNUC__ || defined _USE_STATIC_INLINE
X#elif 0L || 0L
S#define _ARMABI_INLINE static __inline
S#define _ARMABI_INLINE_DEF static __inline
S#elif (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif (1L && 199901L <= 199409L)
S#define _ARMABI_INLINE inline
S#define _ARMABI_INLINE_DEF static inline
N#else
N#define _ARMABI_INLINE __inline
N#define _ARMABI_INLINE_DEF __inline
N#endif
N
N#ifdef __TARGET_ARCH_AARCH64
S#  define _SOFTFP
N#else
N#  define _SOFTFP __attribute__((__pcs__("aapcs")))
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain the nans function, as well as the
N    * FP_NANS and FP_NANQ classification macros.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
N/*
N * Macros for our inline functions down below.
N * unsigned& __FLT(float x) - returns the bit pattern of x
N * unsigned& __HI(double x) - returns the bit pattern of the high part of x
N *                            (high part has exponent & sign bit in it)
N * unsigned& __LO(double x) - returns the bit pattern of the low part of x
N *
N * We can assign to __FLT, __HI, and __LO and the appropriate bits get set in
N * the floating point variable used.
N *
N * __HI & __LO are affected by the endianness and the target FPU.
N */
N#define __FLT(x) (*(unsigned *)&(x))
N#if defined(__ARM_BIG_ENDIAN) || defined(__BIG_ENDIAN)
X#if 0L || 0L
S#  define __LO(x) (*(1 + (unsigned *)&(x)))
S#  define __HI(x) (*(unsigned *)&(x))
N#else /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N#  define __HI(x) (*(1 + (unsigned *)&(x)))
N#  define __LO(x) (*(unsigned *)&(x))
N#endif /* !defined(__ARM_BIG_ENDIAN) && !defined(__BIG_ENDIAN) */
N
N#   ifndef __MATH_DECLS
N#   define __MATH_DECLS
N
N
N/*
N * A set of functions that we don't actually want to put in the standard
N * namespace ever.  These are all called by the C99 macros.  As they're
N * not specified by any standard they can't belong in ::std::.  The
N * macro #defines are below amongst the standard function declarations.
N * We only include these if we actually need them later on
N */
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N#   ifdef __cplusplus
S      extern "C" {
N#   endif /* __cplusplus */
N
Nextern _SOFTFP unsigned __ARM_dcmp4(double /*x*/, double /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_dcmp4(double  , double  );
Nextern _SOFTFP unsigned __ARM_fcmp4(float /*x*/, float /*y*/);
Xextern __attribute__((__pcs__("aapcs"))) unsigned __ARM_fcmp4(float  , float  );
N    /*
N     * Compare x and y and return the CPSR in r0.  These means we can test for
N     * result types with bit pattern matching.
N     *
N     * These are a copy of the declarations in rt_fp.h keep in sync.
N     */
N
Nextern _ARMABI_SOFTFP int __ARM_fpclassifyf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassifyf(float  );
Nextern _ARMABI_SOFTFP int __ARM_fpclassify(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_fpclassify(double  );
N    /* Classify x into NaN, infinite, normal, subnormal, zero */
N    /* Used by fpclassify macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinitef(float __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinitef(float __x)
N{
N    return ((__FLT(__x) >> 23) & 0xff) != 0xff;
X    return (((*(unsigned *)&(__x)) >> 23) & 0xff) != 0xff;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isfinite(double __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isfinite(double __x)
N{
N    return ((__HI(__x) >> 20) & 0x7ff) != 0x7ff;
X    return (((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff) != 0x7ff;
N}
N    /* Return 1 if __x is finite, 0 otherwise */
N    /* Used by isfinite macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinff(float __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinff(float __x)
N{
N    return (__FLT(__x) << 1) == 0xff000000;
X    return ((*(unsigned *)&(__x)) << 1) == 0xff000000;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isinf(double __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isinf(double __x)
N{
N    return ((__HI(__x) << 1) == 0xffe00000) && (__LO(__x) == 0);
X    return (((*(1 + (unsigned *)&(__x))) << 1) == 0xffe00000) && ((*(unsigned *)&(__x)) == 0);
N}
N    /* Return 1 if __x is infinite, 0 otherwise */
N    /* Used by isinf macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreaterf(float __x, float __y)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreaterf(float __x, float __y)
N{
N    unsigned __f = __ARM_fcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_islessgreater(double __x, double __y)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_islessgreater(double __x, double __y)
N{
N    unsigned __f = __ARM_dcmp4(__x, __y) >> 28;
N    return (__f == 8) || (__f == 2); /* Just N set or Just Z set */
N}
N    /*
N     * Compare __x and __y and return 1 if __x < __y or __x > __y, 0 otherwise
N     * Used by islessgreater macro
N     */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnanf(float __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnanf(float __x)
N{
N    return (0x7f800000 - (__FLT(__x) & 0x7fffffff)) >> 31;
X    return (0x7f800000 - ((*(unsigned *)&(__x)) & 0x7fffffff)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnan(double __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnan(double __x)
N{
N    unsigned __xf = __HI(__x) | ((__LO(__x) == 0) ? 0 : 1);
X    unsigned __xf = (*(1 + (unsigned *)&(__x))) | (((*(unsigned *)&(__x)) == 0) ? 0 : 1);
N    return (0x7ff00000 - (__xf & 0x7fffffff)) >> 31;
N}
N    /* Return 1 if __x is a NaN, 0 otherwise */
N    /* Used by isnan macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormalf(float __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormalf(float __x)
N{
N    unsigned __xe = (__FLT(__x) >> 23) & 0xff;
X    unsigned __xe = ((*(unsigned *)&(__x)) >> 23) & 0xff;
N    return (__xe != 0xff) && (__xe != 0);
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_isnormal(double __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_isnormal(double __x)
N{
N    unsigned __xe = (__HI(__x) >> 20) & 0x7ff;
X    unsigned __xe = ((*(1 + (unsigned *)&(__x))) >> 20) & 0x7ff;
N    return (__xe != 0x7ff) && (__xe != 0);
N}
N    /* Return 1 if __x is a normalised number, 0 otherwise */
N    /* used by isnormal macro */
N
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbitf(float __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbitf(float __x)
N{
N    return __FLT(__x) >> 31;
X    return (*(unsigned *)&(__x)) >> 31;
N}
N_ARMABI_INLINE_DEF _ARMABI_SOFTFP int __ARM_signbit(double __x)
X__inline __declspec(__nothrow) __attribute__((__pcs__("aapcs"))) int __ARM_signbit(double __x)
N{
N    return __HI(__x) >> 31;
X    return (*(1 + (unsigned *)&(__x))) >> 31;
N}
N    /* Return signbit of __x */
N    /* Used by signbit macro */
N
N#   ifdef __cplusplus
S      } /* extern "C" */
N#   endif /* __cplusplus */
N#endif /* Strict ANSI */
N
N#   undef __CLIBNS
N
N#   ifdef __cplusplus
S      namespace std {
S#       define __CLIBNS ::std::
S        extern "C" {
N#   else
N#       define __CLIBNS
N#   endif  /* __cplusplus */
N
N
N#ifndef __has_builtin
N  #define __has_builtin(x) 0
N#endif
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N  /* C99 additions */
N  typedef float float_t;
N  typedef double double_t;
N#if __has_builtin(__builtin_inf)
X#if 0
S#   define HUGE_VALF __builtin_inff()
S#   define HUGE_VALL __builtin_infl()
S#   define INFINITY __builtin_inff()
S#   define NAN __builtin_nanf("")
N# else
N#   define HUGE_VALF ((float)__INFINITY__)
N#   define HUGE_VALL ((long double)__INFINITY__)
N#   define INFINITY ((float)__INFINITY__)
N#   define NAN (__ESCAPE__(0f_7FC00000))
N#endif
N
N#   define MATH_ERRNO 1
N#   define MATH_ERREXCEPT 2
Nextern const int math_errhandling;
N#endif
N#if __has_builtin(__builtin_inf)
X#if 0
S# define HUGE_VAL __builtin_inf()
N#else
N# define HUGE_VAL ((double)__INFINITY__)
N#endif
N
Nextern _ARMABI double acos(double /*x*/);
Xextern __declspec(__nothrow) double acos(double  );
N   /* computes the principal value of the arc cosine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* Returns: the arc cosine in the range 0 to Pi. */
Nextern _ARMABI double asin(double /*x*/);
Xextern __declspec(__nothrow) double asin(double  );
N   /* computes the principal value of the arc sine of x */
N   /* a domain error occurs for arguments not in the range -1 to 1 */
N   /* and -HUGE_VAL is returned. */
N   /* Returns: the arc sine in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI_PURE double atan(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double atan(double  );
N   /* computes the principal value of the arc tangent of x */
N   /* Returns: the arc tangent in the range -Pi/2 to Pi/2. */
N
Nextern _ARMABI double atan2(double /*y*/, double /*x*/);
Xextern __declspec(__nothrow) double atan2(double  , double  );
N   /* computes the principal value of the arc tangent of y/x, using the */
N   /* signs of both arguments to determine the quadrant of the return value */
N   /* a domain error occurs if both args are zero, and -HUGE_VAL returned. */
N   /* Returns: the arc tangent of y/x, in the range -Pi to Pi. */
N
Nextern _ARMABI double cos(double /*x*/);
Xextern __declspec(__nothrow) double cos(double  );
N   /* computes the cosine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the cosine value. */
Nextern _ARMABI double sin(double /*x*/);
Xextern __declspec(__nothrow) double sin(double  );
N   /* computes the sine of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance. */
N   /* a domain error occurs for infinite input (C 7.12.1 footnote 196). */
N   /* Returns: the sine value. */
N
Nextern void __use_accurate_range_reduction(void);
N   /* reference this to select the larger, slower, but more accurate */
N   /* range reduction in sin, cos and tan */
N
Nextern _ARMABI double tan(double /*x*/);
Xextern __declspec(__nothrow) double tan(double  );
N   /* computes the tangent of x (measured in radians). A large magnitude */
N   /* argument may yield a result with little or no significance */
N   /* Returns: the tangent value. */
N   /*          if range error; returns HUGE_VAL. */
N
Nextern _ARMABI double cosh(double /*x*/);
Xextern __declspec(__nothrow) double cosh(double  );
N   /* computes the hyperbolic cosine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic cosine value. */
N   /*          if range error; returns HUGE_VAL. */
Nextern _ARMABI double sinh(double /*x*/);
Xextern __declspec(__nothrow) double sinh(double  );
N   /* computes the hyperbolic sine of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the hyperbolic sine value. */
N   /*          if range error; returns -HUGE_VAL or HUGE_VAL depending */
N   /*          on the sign of the argument */
N
Nextern _ARMABI_PURE double tanh(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double tanh(double  );
N   /* computes the hyperbolic tangent of x. */
N   /* Returns: the hyperbolic tangent value. */
N
Nextern _ARMABI double exp(double /*x*/);
Xextern __declspec(__nothrow) double exp(double  );
N   /* computes the exponential function of x. A range error occurs if the */
N   /* magnitude of x is too large. */
N   /* Returns: the exponential value. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
N
Nextern _ARMABI double frexp(double /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double frexp(double  , int *  ) __attribute__((__nonnull__(2)));
N   /* breaks a floating-point number into a normalised fraction and an */
N   /* integral power of 2. It stores the integer in the int object pointed */
N   /* to by exp. */
N   /* Returns: the value x, such that x is a double with magnitude in the */
N   /* interval 0.5 to 1.0 or zero, and value equals x times 2 raised to the */
N   /* power *exp. If value is zero, both parts of the result are zero. */
N
Nextern _ARMABI double ldexp(double /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) double ldexp(double  , int  );
N   /* multiplies a floating-point number by an integral power of 2. */
N   /* A range error may occur. */
N   /* Returns: the value of x times 2 raised to the power of exp. */
N   /*          if range error; HUGE_VAL is returned. */
Nextern _ARMABI double log(double /*x*/);
Xextern __declspec(__nothrow) double log(double  );
N   /* computes the natural logarithm of x. A domain error occurs if the */
N   /* argument is negative, and -HUGE_VAL is returned. A range error occurs */
N   /* if the argument is zero. */
N   /* Returns: the natural logarithm. */
N   /*          if range error; -HUGE_VAL is returned. */
Nextern _ARMABI double log10(double /*x*/);
Xextern __declspec(__nothrow) double log10(double  );
N   /* computes the base-ten logarithm of x. A domain error occurs if the */
N   /* argument is negative. A range error occurs if the argument is zero. */
N   /* Returns: the base-ten logarithm. */
Nextern _ARMABI double modf(double /*value*/, double * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) double modf(double  , double *  ) __attribute__((__nonnull__(2)));
N   /* breaks the argument value into integral and fraction parts, each of */
N   /* which has the same sign as the argument. It stores the integral part */
N   /* as a double in the object pointed to by iptr. */
N   /* Returns: the signed fractional part of value. */
N
Nextern _ARMABI double pow(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double pow(double  , double  );
N   /* computes x raised to the power of y. A domain error occurs if x is */
N   /* zero and y is less than or equal to zero, or if x is negative and y */
N   /* is not an integer, and -HUGE_VAL returned. A range error may occur. */
N   /* Returns: the value of x raised to the power of y. */
N   /*          if underflow range error; 0 is returned. */
N   /*          if overflow range error; HUGE_VAL is returned. */
Nextern _ARMABI double sqrt(double /*x*/);
Xextern __declspec(__nothrow) double sqrt(double  );
N   /* computes the non-negative square root of x. A domain error occurs */
N   /* if the argument is negative, and -HUGE_VAL returned. */
N   /* Returns: the value of the square root. */
N
N#if defined(__TARGET_FPU_VFP_DOUBLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE double _sqrt(double __x) { return __sqrt(__x); }
N#else
N    _ARMABI_INLINE double _sqrt(double __x) { return sqrt(__x); }
X    __inline double _sqrt(double __x) { return sqrt(__x); }
N#endif
N#if defined(__TARGET_FPU_VFP_SINGLE) && !defined(__TARGET_FPU_SOFTVFP)
X#if 0L && !1L
S    _ARMABI_INLINE float _sqrtf(float __x) { return __sqrtf(__x); }
N#else
N    _ARMABI_INLINE float _sqrtf(float __x) { return (float)sqrt(__x); }
X    __inline float _sqrtf(float __x) { return (float)sqrt(__x); }
N#endif
N    /* With VFP, _sqrt and _sqrtf should expand inline as the native VFP square root
N     * instructions. They will not behave like the C sqrt() function, because
N     * they will report unusual values as IEEE exceptions (in fpmodes which
N     * support IEEE exceptions) rather than in errno. These function names
N     * are not specified in any standard. */
N
Nextern _ARMABI_PURE double ceil(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double ceil(double  );
N   /* computes the smallest integer not less than x. */
N   /* Returns: the smallest integer not less than x, expressed as a double. */
Nextern _ARMABI_PURE double fabs(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double fabs(double  );
N   /* computes the absolute value of the floating-point number x. */
N   /* Returns: the absolute value of x. */
N
Nextern _ARMABI_PURE double floor(double /*d*/);
Xextern __declspec(__nothrow) __attribute__((const)) double floor(double  );
N   /* computes the largest integer not greater than x. */
N   /* Returns: the largest integer not greater than x, expressed as a double */
N
Nextern _ARMABI double fmod(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double fmod(double  , double  );
N   /* computes the floating-point remainder of x/y. */
N   /* Returns: the value x - i * y, for some integer i such that, if y is */
N   /*          nonzero, the result has the same sign as x and magnitude */
N   /*          less than the magnitude of y. If y is zero, a domain error */
N   /*          occurs and -HUGE_VAL is returned. */
N
N    /* Additional Mathlib functions not defined by the ANSI standard.
N     * Not guaranteed, and not necessarily very well tested.
N     * C99 requires the user to include <math.h> to use these functions
N     * declaring them "by hand" is not sufficient
N     *
N     * The above statement is not completely true now.  Some of the above
N     * C99 functionality has been added as per the Standard, and (where
N     * necessary) old Mathlib functionality withdrawn/changed.  Before
N     * including this header #define __ENABLE_MATHLIB_LEGACY if you want to
N     * re-enable the legacy functionality.
N     */
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
Nextern _ARMABI double acosh(double /*x*/);
Xextern __declspec(__nothrow) double acosh(double  );
N    /*
N     * Inverse cosh. EDOM if argument < 1.0
N     */
Nextern _ARMABI double asinh(double /*x*/);
Xextern __declspec(__nothrow) double asinh(double  );
N    /*
N     * Inverse sinh.
N     */
Nextern _ARMABI double atanh(double /*x*/);
Xextern __declspec(__nothrow) double atanh(double  );
N    /*
N     * Inverse tanh. EDOM if |argument| > 1.0
N     */
Nextern _ARMABI double cbrt(double /*x*/);
Xextern __declspec(__nothrow) double cbrt(double  );
N    /*
N     * Cube root.
N     */
N_ARMABI_INLINE _ARMABI_PURE double copysign(double __x, double __y)
X__inline __declspec(__nothrow) __attribute__((const)) double copysign(double __x, double __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __HI(__x) = (__HI(__x) & 0x7fffffff) | (__HI(__y) & 0x80000000);
X    (*(1 + (unsigned *)&(__x))) = ((*(1 + (unsigned *)&(__x))) & 0x7fffffff) | ((*(1 + (unsigned *)&(__y))) & 0x80000000);
N    return __x;
N}
N_ARMABI_INLINE _ARMABI_PURE float copysignf(float __x, float __y)
X__inline __declspec(__nothrow) __attribute__((const)) float copysignf(float __x, float __y)
N    /*
N     * Returns x with sign bit replaced by sign of y.
N     */
N{
N    __FLT(__x) = (__FLT(__x) & 0x7fffffff) | (__FLT(__y) & 0x80000000);
X    (*(unsigned *)&(__x)) = ((*(unsigned *)&(__x)) & 0x7fffffff) | ((*(unsigned *)&(__y)) & 0x80000000);
N    return __x;
N}
Nextern _ARMABI double erf(double /*x*/);
Xextern __declspec(__nothrow) double erf(double  );
N    /*
N     * Error function. (2/sqrt(pi)) * integral from 0 to x of exp(-t*t) dt.
N     */
Nextern _ARMABI double erfc(double /*x*/);
Xextern __declspec(__nothrow) double erfc(double  );
N    /*
N     * 1-erf(x). (More accurate than just coding 1-erf(x), for large x.)
N     */
Nextern _ARMABI double expm1(double /*x*/);
Xextern __declspec(__nothrow) double expm1(double  );
N    /*
N     * exp(x)-1. (More accurate than just coding exp(x)-1, for small x.)
N     */
N#define fpclassify(x) \
N    ((sizeof(x) == sizeof(float)) ? \
N        __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
X#define fpclassify(x)     ((sizeof(x) == sizeof(float)) ?         __ARM_fpclassifyf(x) : __ARM_fpclassify(x))
N    /*
N     * Classify a floating point number into one of the following values:
N     */
N#define FP_ZERO         (0)
N#define FP_SUBNORMAL    (4)
N#define FP_NORMAL       (5)
N#define FP_INFINITE     (3)
N#define FP_NAN          (7)
N
N#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
X#if 0L && 0L
S/* 
S * Note that we'll never classify a number as FP_NAN, as all NaNs will 
S * be either FP_NANQ or FP_NANS
S */
S#  define FP_NANQ       (8)
S#  define FP_NANS       (9)
N#endif
N
N
Nextern _ARMABI double hypot(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double hypot(double  , double  );
N    /*
N     * sqrt(x*x+y*y), ie the length of the vector (x,y) or the
N     * hypotenuse of a right triangle whose other two sides are x
N     * and y. Won't overflow unless the _answer_ is too big, even
N     * if the intermediate x*x+y*y is too big.
N     */
Nextern _ARMABI int ilogb(double /*x*/);
Xextern __declspec(__nothrow) int ilogb(double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
Nextern _ARMABI int ilogbf(float /*x*/);
Xextern __declspec(__nothrow) int ilogbf(float  );
N    /*
N     * Like ilogb but takes a float
N     */
Nextern _ARMABI int ilogbl(long double /*x*/);
Xextern __declspec(__nothrow) int ilogbl(long double  );
N    /*
N     * Exponent of x (returns 0 for 1.0, 1 for 2.0, -1 for 0.5, etc.)
N     */
N#define FP_ILOGB0   (-0x7fffffff) /* ilogb(0) == -INT_MAX */
N#define FP_ILOGBNAN ( 0x80000000) /* ilogb(NAN) == INT_MIN */
N
N#define isfinite(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isfinitef(x) \
N        : __ARM_isfinite(x))
X#define isfinite(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isfinitef(x)         : __ARM_isfinite(x))
N    /*
N     * Returns true if x is a finite number, size independent.
N     */
N
N#define isgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
X#define isgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x20000000))
N    /*
N     * Returns true if x > y, throws no exceptions except on Signaling NaNs
N     *
N     * We want the C not set but the Z bit clear, V must be clear
N     */
N
N#define isgreaterequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
X#define isgreaterequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x30000000) == 0x20000000)         : ((__ARM_dcmp4((x), (y)) & 0x30000000) == 0x20000000))
N    /*
N     * Returns true if x >= y, throws no exceptions except on Signaling NaNs
N     *
N     * We just need to see if the C bit is set or not and ensure V clear
N     */
N
N#define isinf(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isinff(x) \
N        : __ARM_isinf(x))
X#define isinf(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isinff(x)         : __ARM_isinf(x))
N    /*
N     * Returns true if x is an infinity, size independent.
N     */
N
N#define isless(x, y)  \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
X#define isless(x, y)      (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xf0000000) == 0x80000000)         : ((__ARM_dcmp4((x), (y)) & 0xf0000000) == 0x80000000))
N    /*
N     * Returns true if x < y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than if N is set, V clear
N     */
N
N#define islessequal(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0) \
N        : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
X#define islessequal(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0xc0000000) != 0)         : ((__ARM_dcmp4((x), (y)) & 0xc0000000) != 0))
N    /*
N     * Returns true if x <= y, throws no exceptions except on Signaling NaNs
N     *
N     * We're less than or equal if one of N or Z is set, V clear
N     */
N
N#define islessgreater(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? __ARM_islessgreaterf((x), (y)) \
N        : __ARM_islessgreater((x), (y)))
X#define islessgreater(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? __ARM_islessgreaterf((x), (y))         : __ARM_islessgreater((x), (y)))
N    /*
N     * Returns true if x <> y, throws no exceptions except on Signaling NaNs
N     * Unfortunately this test is too complicated to do in a macro without
N     * evaluating x & y twice.  Shame really...
N     */
N
N#define isnan(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnanf(x) \
N        : __ARM_isnan(x))
X#define isnan(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnanf(x)         : __ARM_isnan(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isnormal(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_isnormalf(x) \
N        : __ARM_isnormal(x))
X#define isnormal(x)     ((sizeof(x) == sizeof(float))         ? __ARM_isnormalf(x)         : __ARM_isnormal(x))
N    /*
N     * Returns TRUE if x is a NaN.
N     */
N
N#define isunordered(x, y) \
N    (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float))) \
N        ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000) \
N        : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
X#define isunordered(x, y)     (((sizeof(x) == sizeof(float)) && (sizeof(y) == sizeof(float)))         ? ((__ARM_fcmp4((x), (y)) & 0x10000000) == 0x10000000)         : ((__ARM_dcmp4((x), (y)) & 0x10000000) == 0x10000000))
N    /*
N     * Returns true if x ? y, throws no exceptions except on Signaling NaNs
N     * Unordered occurs if and only if the V bit is set
N     */
N
Nextern _ARMABI double lgamma (double /*x*/);
Xextern __declspec(__nothrow) double lgamma (double  );
N    /*
N     * The log of the absolute value of the gamma function of x. The sign
N     * of the gamma function of x is returned in the global `signgam'.
N     */
Nextern _ARMABI double log1p(double /*x*/);
Xextern __declspec(__nothrow) double log1p(double  );
N    /*
N     * log(1+x). (More accurate than just coding log(1+x), for small x.)
N     */
Nextern _ARMABI double logb(double /*x*/);
Xextern __declspec(__nothrow) double logb(double  );
N    /*
N     * Like ilogb but returns a double.
N     */
Nextern _ARMABI float logbf(float /*x*/);
Xextern __declspec(__nothrow) float logbf(float  );
N    /*
N     * Like logb but takes and returns float
N     */
Nextern _ARMABI long double logbl(long double /*x*/);
Xextern __declspec(__nothrow) long double logbl(long double  );
N    /*
N     * Like logb but takes and returns long double
N     */
Nextern _ARMABI double nextafter(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double nextafter(double  , double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nextafterf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float nextafterf(float  , float  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nextafterl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nextafterl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double nexttoward(double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) double nexttoward(double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI float nexttowardf(float /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) float nexttowardf(float  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI long double nexttowardl(long double /*x*/, long double /*y*/);
Xextern __declspec(__nothrow) long double nexttowardl(long double  , long double  );
N    /*
N     * Returns the next representable number after x, in the
N     * direction toward y.
N     */
Nextern _ARMABI double remainder(double /*x*/, double /*y*/);
Xextern __declspec(__nothrow) double remainder(double  , double  );
N    /*
N     * Returns the remainder of x by y, in the IEEE 754 sense.
N     */
Nextern _ARMABI_FPEXCEPT double rint(double /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) double rint(double  );
N    /*
N     * Rounds x to an integer, in the IEEE 754 sense.
N     */
Nextern _ARMABI double scalbln(double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) double scalbln(double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalblnf(float /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) float scalblnf(float  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalblnl(long double /*x*/, long int /*n*/);
Xextern __declspec(__nothrow) long double scalblnl(long double  , long int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI double scalbn(double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) double scalbn(double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI float scalbnf(float /*x*/, int /*n*/);
Xextern __declspec(__nothrow) float scalbnf(float  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
Nextern _ARMABI long double scalbnl(long double /*x*/, int /*n*/);
Xextern __declspec(__nothrow) long double scalbnl(long double  , int  );
N    /*
N     * Compute x times 2^n quickly.
N     */
N#define signbit(x) \
N    ((sizeof(x) == sizeof(float)) \
N        ? __ARM_signbitf(x) \
N        : __ARM_signbit(x))
X#define signbit(x)     ((sizeof(x) == sizeof(float))         ? __ARM_signbitf(x)         : __ARM_signbit(x))
N    /*
N     * Returns the signbit of x, size independent macro
N     */
N#endif
N
N/* C99 float versions of functions.  math.h has always reserved these
N   identifiers for this purpose (7.13.4). */
Nextern _ARMABI_PURE float _fabsf(float); /* old ARM name */
Xextern __declspec(__nothrow) __attribute__((const)) float _fabsf(float);  
N_ARMABI_INLINE _ARMABI_PURE float fabsf(float __f) { return _fabsf(__f); }
X__inline __declspec(__nothrow) __attribute__((const)) float fabsf(float __f) { return _fabsf(__f); }
Nextern _ARMABI float sinf(float /*x*/);
Xextern __declspec(__nothrow) float sinf(float  );
Nextern _ARMABI float cosf(float /*x*/);
Xextern __declspec(__nothrow) float cosf(float  );
Nextern _ARMABI float tanf(float /*x*/);
Xextern __declspec(__nothrow) float tanf(float  );
Nextern _ARMABI float acosf(float /*x*/);
Xextern __declspec(__nothrow) float acosf(float  );
Nextern _ARMABI float asinf(float /*x*/);
Xextern __declspec(__nothrow) float asinf(float  );
Nextern _ARMABI float atanf(float /*x*/);
Xextern __declspec(__nothrow) float atanf(float  );
Nextern _ARMABI float atan2f(float /*y*/, float /*x*/);
Xextern __declspec(__nothrow) float atan2f(float  , float  );
Nextern _ARMABI float sinhf(float /*x*/);
Xextern __declspec(__nothrow) float sinhf(float  );
Nextern _ARMABI float coshf(float /*x*/);
Xextern __declspec(__nothrow) float coshf(float  );
Nextern _ARMABI float tanhf(float /*x*/);
Xextern __declspec(__nothrow) float tanhf(float  );
Nextern _ARMABI float expf(float /*x*/);
Xextern __declspec(__nothrow) float expf(float  );
Nextern _ARMABI float logf(float /*x*/);
Xextern __declspec(__nothrow) float logf(float  );
Nextern _ARMABI float log10f(float /*x*/);
Xextern __declspec(__nothrow) float log10f(float  );
Nextern _ARMABI float powf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float powf(float  , float  );
Nextern _ARMABI float sqrtf(float /*x*/);
Xextern __declspec(__nothrow) float sqrtf(float  );
Nextern _ARMABI float ldexpf(float /*x*/, int /*exp*/);
Xextern __declspec(__nothrow) float ldexpf(float  , int  );
Nextern _ARMABI float frexpf(float /*value*/, int * /*exp*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float frexpf(float  , int *  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI_PURE float ceilf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float ceilf(float  );
Nextern _ARMABI_PURE float floorf(float /*x*/);
Xextern __declspec(__nothrow) __attribute__((const)) float floorf(float  );
Nextern _ARMABI float fmodf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float fmodf(float  , float  );
Nextern _ARMABI float modff(float /*value*/, float * /*iptr*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) float modff(float  , float *  ) __attribute__((__nonnull__(2)));
N
N/* C99 long double versions of functions. */
N/* (also need to have 'using' declarations below) */
N#define _ARMDEFLD1(f) \
N    _ARMABI long double f##l(long double /*x*/)
X#define _ARMDEFLD1(f)     _ARMABI long double f##l(long double  )
N
N#define _ARMDEFLD1P(f, T) \
N    _ARMABI long double f##l(long double /*x*/, T /*p*/)
X#define _ARMDEFLD1P(f, T)     _ARMABI long double f##l(long double  , T  )
N
N#define _ARMDEFLD2(f) \
N    _ARMABI long double f##l(long double /*x*/, long double /*y*/)
X#define _ARMDEFLD2(f)     _ARMABI long double f##l(long double  , long double  )
N
N/*
N * Long double versions of C89 functions can be defined
N * unconditionally, because C89 reserved these names in "future
N * library directions".
N */
N_ARMDEFLD1(acos);
X__declspec(__nothrow) long double acosl(long double );
N_ARMDEFLD1(asin);
X__declspec(__nothrow) long double asinl(long double );
N_ARMDEFLD1(atan);
X__declspec(__nothrow) long double atanl(long double );
N_ARMDEFLD2(atan2);
X__declspec(__nothrow) long double atan2l(long double , long double );
N_ARMDEFLD1(ceil);
X__declspec(__nothrow) long double ceill(long double );
N_ARMDEFLD1(cos);
X__declspec(__nothrow) long double cosl(long double );
N_ARMDEFLD1(cosh);
X__declspec(__nothrow) long double coshl(long double );
N_ARMDEFLD1(exp);
X__declspec(__nothrow) long double expl(long double );
N_ARMDEFLD1(fabs);
X__declspec(__nothrow) long double fabsl(long double );
N_ARMDEFLD1(floor);
X__declspec(__nothrow) long double floorl(long double );
N_ARMDEFLD2(fmod);
X__declspec(__nothrow) long double fmodl(long double , long double );
N_ARMDEFLD1P(frexp, int*) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double frexpl(long double , int* ) __attribute__((__nonnull__(2)));
N_ARMDEFLD1P(ldexp, int);
X__declspec(__nothrow) long double ldexpl(long double , int );
N_ARMDEFLD1(log);
X__declspec(__nothrow) long double logl(long double );
N_ARMDEFLD1(log10);
X__declspec(__nothrow) long double log10l(long double );
N_ARMABI long double modfl(long double /*x*/, long double * /*p*/) __attribute__((__nonnull__(2)));
X__declspec(__nothrow) long double modfl(long double  , long double *  ) __attribute__((__nonnull__(2)));
N_ARMDEFLD2(pow);
X__declspec(__nothrow) long double powl(long double , long double );
N_ARMDEFLD1(sin);
X__declspec(__nothrow) long double sinl(long double );
N_ARMDEFLD1(sinh);
X__declspec(__nothrow) long double sinhl(long double );
N_ARMDEFLD1(sqrt);
X__declspec(__nothrow) long double sqrtl(long double );
N_ARMDEFLD1(tan);
X__declspec(__nothrow) long double tanl(long double );
N_ARMDEFLD1(tanh);
X__declspec(__nothrow) long double tanhl(long double );
N
N#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
X#if !0L || 0L
N
N/*
N * C99 float and long double versions of extra-C89 functions.
N */
Nextern _ARMABI float acoshf(float /*x*/);
Xextern __declspec(__nothrow) float acoshf(float  );
N_ARMDEFLD1(acosh);
X__declspec(__nothrow) long double acoshl(long double );
Nextern _ARMABI float asinhf(float /*x*/);
Xextern __declspec(__nothrow) float asinhf(float  );
N_ARMDEFLD1(asinh);
X__declspec(__nothrow) long double asinhl(long double );
Nextern _ARMABI float atanhf(float /*x*/);
Xextern __declspec(__nothrow) float atanhf(float  );
N_ARMDEFLD1(atanh);
X__declspec(__nothrow) long double atanhl(long double );
N_ARMDEFLD2(copysign);
X__declspec(__nothrow) long double copysignl(long double , long double );
Nextern _ARMABI float cbrtf(float /*x*/);
Xextern __declspec(__nothrow) float cbrtf(float  );
N_ARMDEFLD1(cbrt);
X__declspec(__nothrow) long double cbrtl(long double );
Nextern _ARMABI float erff(float /*x*/);
Xextern __declspec(__nothrow) float erff(float  );
N_ARMDEFLD1(erf);
X__declspec(__nothrow) long double erfl(long double );
Nextern _ARMABI float erfcf(float /*x*/);
Xextern __declspec(__nothrow) float erfcf(float  );
N_ARMDEFLD1(erfc);
X__declspec(__nothrow) long double erfcl(long double );
Nextern _ARMABI float expm1f(float /*x*/);
Xextern __declspec(__nothrow) float expm1f(float  );
N_ARMDEFLD1(expm1);
X__declspec(__nothrow) long double expm1l(long double );
Nextern _ARMABI float log1pf(float /*x*/);
Xextern __declspec(__nothrow) float log1pf(float  );
N_ARMDEFLD1(log1p);
X__declspec(__nothrow) long double log1pl(long double );
Nextern _ARMABI float hypotf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float hypotf(float  , float  );
N_ARMDEFLD2(hypot);
X__declspec(__nothrow) long double hypotl(long double , long double );
Nextern _ARMABI float lgammaf(float /*x*/);
Xextern __declspec(__nothrow) float lgammaf(float  );
N_ARMDEFLD1(lgamma);
X__declspec(__nothrow) long double lgammal(long double );
Nextern _ARMABI float remainderf(float /*x*/, float /*y*/);
Xextern __declspec(__nothrow) float remainderf(float  , float  );
N_ARMDEFLD2(remainder);
X__declspec(__nothrow) long double remainderl(long double , long double );
Nextern _ARMABI float rintf(float /*x*/);
Xextern __declspec(__nothrow) float rintf(float  );
N_ARMDEFLD1(rint);
X__declspec(__nothrow) long double rintl(long double );
N
N#endif
N
N#ifdef __USE_C99_MATH
S/*
S * Functions new in C99.
S */
Sextern _ARMABI double exp2(double /*x*/); /* * 2.^x. */
Sextern _ARMABI float exp2f(float /*x*/);
S_ARMDEFLD1(exp2);
Sextern _ARMABI double fdim(double /*x*/, double /*y*/);
Sextern _ARMABI float fdimf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fdim);
S#ifdef __FP_FAST_FMA
S#define FP_FAST_FMA
S#endif
S#ifdef __FP_FAST_FMAF
S#define FP_FAST_FMAF
S#endif
S#ifdef __FP_FAST_FMAL
S#define FP_FAST_FMAL
S#endif
Sextern _ARMABI double fma(double /*x*/, double /*y*/, double /*z*/);
Sextern _ARMABI float fmaf(float /*x*/, float /*y*/, float /*z*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z) \
S    { return (long double)fma((double)__x, (double)__y, (double)__z); }
X_ARMABI_INLINE _ARMABI long double fmal(long double __x, long double __y, long double __z)     { return (long double)fma((double)__x, (double)__y, (double)__z); }
S#endif
Sextern _ARMABI_FPEXCEPT double fmax(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fmaxf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmax);
Sextern _ARMABI_FPEXCEPT double fmin(double /*x*/, double /*y*/);
Sextern _ARMABI_FPEXCEPT float fminf(float /*x*/, float /*y*/);
S_ARMDEFLD2(fmin);
Sextern _ARMABI double log2(double /*x*/); /* * log base 2 of x. */
Sextern _ARMABI float log2f(float /*x*/);
S_ARMDEFLD1(log2);
Sextern _ARMABI long lrint(double /*x*/);
Sextern _ARMABI long lrintf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long lrintl(long double __x) \
S    { return lrint((double)__x); }
X_ARMABI_INLINE _ARMABI long lrintl(long double __x)     { return lrint((double)__x); }
S#endif
Sextern _ARMABI __LONGLONG llrint(double /*x*/);
Sextern _ARMABI __LONGLONG llrintf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x) \
S    { return llrint((double)__x); }
X_ARMABI_INLINE _ARMABI __LONGLONG llrintl(long double __x)     { return llrint((double)__x); }
S#endif
Sextern _ARMABI long lround(double /*x*/);
Sextern _ARMABI long lroundf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI long lroundl(long double __x) \
S    { return lround((double)__x); }
X_ARMABI_INLINE _ARMABI long lroundl(long double __x)     { return lround((double)__x); }
S#endif
Sextern _ARMABI __LONGLONG llround(double /*x*/);
Sextern _ARMABI __LONGLONG llroundf(float /*x*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x) \
S    { return llround((double)__x); }
X_ARMABI_INLINE _ARMABI __LONGLONG llroundl(long double __x)     { return llround((double)__x); }
S#endif
Sextern _ARMABI_PURE double nan(const char */*tagp*/);
Sextern _ARMABI_PURE float nanf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t) \
S    { return (long double)nan(__t); }
X_ARMABI_INLINE _ARMABI_PURE long double nanl(const char *__t)     { return (long double)nan(__t); }
S#endif
S#if defined(_WANT_SNAN) && defined(__SUPPORT_SNAN__)
Sextern _ARMABI_PURE double nans(const char */*tagp*/);
Sextern _ARMABI_PURE float nansf(const char */*tagp*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t) \
S    { return (long double)nans(__t); }
X_ARMABI_INLINE _ARMABI_FPEXCEPT long double nansl(const char *__t)     { return (long double)nans(__t); }
S#endif
S#endif 
Sextern _ARMABI_FPEXCEPT double nearbyint(double /*x*/);
Sextern _ARMABI_FPEXCEPT float nearbyintf(float /*x*/);
S_ARMDEFLD1(nearbyint);
Sextern  double remquo(double /*x*/, double /*y*/, int */*quo*/);
Sextern  float remquof(float /*x*/, float /*y*/, int */*quo*/);
S#ifdef __HAVE_LONGDOUBLE
S_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q) \
S    { return (long double)remquo((double)__x, (double)__y, __q); }
X_ARMABI_INLINE long double remquol(long double __x, long double __y, int *__q)     { return (long double)remquo((double)__x, (double)__y, __q); }
S#endif
Sextern _ARMABI_FPEXCEPT double round(double /*x*/);
Sextern _ARMABI_FPEXCEPT float roundf(float /*x*/);
S_ARMDEFLD1(round);
Sextern _ARMABI double tgamma(double /*x*/); /* * The gamma function of x. */
Sextern _ARMABI float tgammaf(float /*x*/);
S_ARMDEFLD1(tgamma);
Sextern _ARMABI_FPEXCEPT double trunc(double /*x*/);
Sextern _ARMABI_FPEXCEPT float truncf(float /*x*/);
S_ARMDEFLD1(trunc);
N#endif
N
N#undef _ARMDEFLD1
N#undef _ARMDEFLD1P
N#undef _ARMDEFLD2
N
N#ifdef __cplusplus
S  extern "C++" {
S    inline float abs(float __x)   { return fabsf(__x); }
S    inline float acos(float __x)  { return acosf(__x); }
S    inline float asin(float __x)  { return asinf(__x); }
S    inline float atan(float __x)  { return atanf(__x); }
S    inline float atan2(float __y, float __x)    { return atan2f(__y,__x); }
S    inline float ceil(float __x)  { return ceilf(__x); }
S    inline float cos(float __x)   { return cosf(__x); }
S    inline float cosh(float __x)  { return coshf(__x); }
S    inline float exp(float __x)   { return expf(__x); }
S    inline float fabs(float __x)  { return fabsf(__x); }
S    inline float floor(float __x) { return floorf(__x); }
S    inline float fmod(float __x, float __y)     { return fmodf(__x, __y); }
S    float frexp(float __x, int* __exp) __attribute__((__nonnull__(2)));
S    inline float frexp(float __x, int* __exp)   { return frexpf(__x, __exp); }
S    inline float ldexp(float __x, int __exp)    { return ldexpf(__x, __exp);}
S    inline float log(float __x)   { return logf(__x); }
S    inline float log10(float __x) { return log10f(__x); }
S    float modf(float __x, float* __iptr) __attribute__((__nonnull__(2)));
S    inline float modf(float __x, float* __iptr) { return modff(__x, __iptr); }
S    inline float pow(float __x, float __y)      { return powf(__x,__y); }
S    inline float pow(float __x, int __y)     { return powf(__x, (float)__y); }
S    inline float sin(float __x)   { return sinf(__x); }
S    inline float sinh(float __x)  { return sinhf(__x); }
S    inline float sqrt(float __x)  { return sqrtf(__x); }
S    inline float _sqrt(float __x) { return _sqrtf(__x); }
S    inline float tan(float __x)   { return tanf(__x); }
S    inline float tanh(float __x)  { return tanhf(__x); }
S
S    inline double abs(double __x) { return fabs(__x); }
S    inline double pow(double __x, int __y)
S                { return pow(__x, (double) __y); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double abs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double acos(long double __x)
S                { return (long double)acosl(__x); }
S    inline long double asin(long double __x)
S                { return (long double)asinl(__x); }
S    inline long double atan(long double __x)
S                { return (long double)atanl(__x); }
S    inline long double atan2(long double __y, long double __x)
S                { return (long double)atan2l(__y, __x); }
S    inline long double ceil(long double __x)
S                { return (long double)ceill( __x); }
S    inline long double cos(long double __x)
S                { return (long double)cosl(__x); }
S    inline long double cosh(long double __x)
S                { return (long double)coshl(__x); }
S    inline long double exp(long double __x)
S                { return (long double)expl(__x); }
S    inline long double fabs(long double __x)
S                { return (long double)fabsl(__x); }
S    inline long double floor(long double __x)
S                { return (long double)floorl(__x); }
S    inline long double fmod(long double __x, long double __y)
S                { return (long double)fmodl(__x, __y); }
S    long double frexp(long double __x, int* __p) __attribute__((__nonnull__(2)));
S    inline long double frexp(long double __x, int* __p)
S                { return (long double)frexpl(__x, __p); }
S    inline long double ldexp(long double __x, int __exp)
S                { return (long double)ldexpl(__x, __exp); }
S    inline long double log(long double __x)
S                { return (long double)logl(__x); }
S    inline long double log10(long double __x)
S                { return (long double)log10l(__x); }
S    long double modf(long double __x, long double* __p) __attribute__((__nonnull__(2)));
S    inline long double modf(long double __x, long double* __p)
S                { return (long double)modfl(__x, __p); }
S    inline long double pow(long double __x, long double __y)
S                { return (long double)powl(__x, __y); }
S    inline long double pow(long double __x, int __y)
S                { return (long double)powl(__x, __y); }
S    inline long double sin(long double __x)
S                { return (long double)sinl(__x); }
S    inline long double sinh(long double __x)
S                { return (long double)sinhl(__x); }
S    inline long double sqrt(long double __x)
S                { return (long double)sqrtl(__x); }
S    inline long double _sqrt(long double __x)
S                { return (long double)_sqrt((double) __x); }
S    inline long double tan(long double __x)
S                { return (long double)tanl(__x); }
S    inline long double tanh(long double __x)
S                { return (long double)tanhl(__x); }
S#endif
S
S#if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S    inline float acosh(float __x) { return acoshf(__x); }
S    inline float asinh(float __x) { return asinhf(__x); }
S    inline float atanh(float __x) { return atanhf(__x); }
S    inline float cbrt(float __x) { return cbrtf(__x); }
S    inline float erf(float __x) { return erff(__x); }
S    inline float erfc(float __x) { return erfcf(__x); }
S    inline float expm1(float __x) { return expm1f(__x); }
S    inline float log1p(float __x) { return log1pf(__x); }
S    inline float hypot(float __x, float __y) { return hypotf(__x, __y); }
S    inline float lgamma(float __x) { return lgammaf(__x); }
S    inline float remainder(float __x, float __y) { return remainderf(__x, __y); }
S    inline float rint(float __x) { return rintf(__x); }
S#endif
S
S#ifdef __USE_C99_MATH
S    inline float exp2(float __x) { return exp2f(__x); }
S    inline float fdim(float __x, float __y) { return fdimf(__x, __y); }
S    inline float fma(float __x, float __y, float __z) { return fmaf(__x, __y, __z); }
S    inline float fmax(float __x, float __y) { return fmaxf(__x, __y); }
S    inline float fmin(float __x, float __y) { return fminf(__x, __y); }
S    inline float log2(float __x) { return log2f(__x); }
S    inline _ARMABI long lrint(float __x) { return lrintf(__x); }
S    inline _ARMABI __LONGLONG llrint(float __x) { return llrintf(__x); }
S    inline _ARMABI long lround(float __x) { return lroundf(__x); }
S    inline _ARMABI __LONGLONG llround(float __x) { return llroundf(__x); }
S    inline _ARMABI_FPEXCEPT float nearbyint(float __x) { return nearbyintf(__x); }
S    inline float remquo(float __x, float __y, int *__q) { return remquof(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT float round(float __x) { return roundf(__x); }
S    inline float tgamma(float __x) { return tgammaf(__x); }
S    inline _ARMABI_FPEXCEPT float trunc(float __x) { return truncf(__x); }
S
S#ifdef __HAVE_LONGDOUBLE
S    inline long double acosh(long double __x) { return acoshl(__x); }
S    inline long double asinh(long double __x) { return asinhl(__x); }
S    inline long double atanh(long double __x) { return atanhl(__x); }
S    inline long double cbrt(long double __x) { return cbrtl(__x); }
S    inline long double erf(long double __x) { return erfl(__x); }
S    inline long double erfc(long double __x) { return erfcl(__x); }
S    inline long double expm1(long double __x) { return expm1l(__x); }
S    inline long double log1p(long double __x) { return log1pl(__x); }
S    inline long double hypot(long double __x, long double __y) { return hypotl(__x, __y); }
S    inline long double lgamma(long double __x) { return lgammal(__x); }
S    inline long double remainder(long double __x, long double __y) { return remainderl(__x, __y); }
S    inline long double rint(long double __x) { return rintl(__x); }
S    inline long double exp2(long double __x) { return exp2l(__x); }
S    inline long double fdim(long double __x, long double __y) { return fdiml(__x, __y); }
S    inline long double fma(long double __x, long double __y, long double __z) { return fmal(__x, __y, __z); }
S    inline long double fmax(long double __x, long double __y) { return fmaxl(__x, __y); }
S    inline long double fmin(long double __x, long double __y) { return fminl(__x, __y); }
S    inline long double log2(long double __x) { return log2l(__x); }
S    inline _ARMABI long lrint(long double __x) { return lrintl(__x); }
S    inline _ARMABI __LONGLONG llrint(long double __x) { return llrintl(__x); }
S    inline _ARMABI long lround(long double __x) { return lroundl(__x); }
S    inline _ARMABI __LONGLONG llround(long double __x) { return llroundl(__x); }
S    inline _ARMABI_FPEXCEPT long double nearbyint(long double __x) { return nearbyintl(__x); }
S    inline long double remquo(long double __x, long double __y, int *__q) { return remquol(__x, __y, __q); }
S    inline _ARMABI_FPEXCEPT long double round(long double __x) { return roundl(__x); }
S    inline long double tgamma(long double __x) { return tgammal(__x); }
S    inline _ARMABI_FPEXCEPT long double trunc(long double __x) { return truncl(__x); }
S#endif
S#endif
S
S  }
N#endif
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __MATH_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__MATH_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::__use_accurate_range_reduction;
S    using ::std::abs;
S    using ::std::acos;
S    using ::std::asin;
S    using ::std::atan2;
S    using ::std::atan;
S    using ::std::ceil;
S    using ::std::cos;
S    using ::std::cosh;
S    using ::std::exp;
S    using ::std::fabs;
S    using ::std::floor;
S    using ::std::fmod;
S    using ::std::frexp;
S    using ::std::ldexp;
S    using ::std::log10;
S    using ::std::log;
S    using ::std::modf;
S    using ::std::pow;
S    using ::std::sin;
S    using ::std::sinh;
S    using ::std::sqrt;
S    using ::std::_sqrt;
S    using ::std::_sqrtf;
S    using ::std::tan;
S    using ::std::tanh;
S    using ::std::_fabsf;
S    /* C99 float and long double versions in already-C89-reserved namespace */
S    using ::std::acosf;
S    using ::std::acosl;
S    using ::std::asinf;
S    using ::std::asinl;
S    using ::std::atan2f;
S    using ::std::atan2l;
S    using ::std::atanf;
S    using ::std::atanl;
S    using ::std::ceilf;
S    using ::std::ceill;
S    using ::std::cosf;
S    using ::std::coshf;
S    using ::std::coshl;
S    using ::std::cosl;
S    using ::std::expf;
S    using ::std::expl;
S    using ::std::fabsf;
S    using ::std::fabsl;
S    using ::std::floorf;
S    using ::std::floorl;
S    using ::std::fmodf;
S    using ::std::fmodl;
S    using ::std::frexpf;
S    using ::std::frexpl;
S    using ::std::ldexpf;
S    using ::std::ldexpl;
S    using ::std::log10f;
S    using ::std::log10l;
S    using ::std::logf;
S    using ::std::logl;
S    using ::std::modff;
S    using ::std::modfl;
S    using ::std::powf;
S    using ::std::powl;
S    using ::std::sinf;
S    using ::std::sinhf;
S    using ::std::sinhl;
S    using ::std::sinl;
S    using ::std::sqrtf;
S    using ::std::sqrtl;
S    using ::std::tanf;
S    using ::std::tanhf;
S    using ::std::tanhl;
S    using ::std::tanl;
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which for historical reasons appear in non-strict mode */
S      using ::std::acosh;
S      using ::std::asinh;
S      using ::std::atanh;
S      using ::std::cbrt;
S      using ::std::copysign;
S      using ::std::copysignf;
S      using ::std::erf;
S      using ::std::erfc;
S      using ::std::expm1;
S      using ::std::hypot;
S      using ::std::ilogb;
S      using ::std::ilogbf;
S      using ::std::ilogbl;
S      using ::std::lgamma;
S      using ::std::log1p;
S      using ::std::logb;
S      using ::std::logbf;
S      using ::std::logbl;
S      using ::std::nextafter;
S      using ::std::nextafterf;
S      using ::std::nextafterl;
S      using ::std::nexttoward;
S      using ::std::nexttowardf;
S      using ::std::nexttowardl;
S      using ::std::remainder;
S      using ::std::rint;
S      using ::std::scalbln;
S      using ::std::scalblnf;
S      using ::std::scalblnl;
S      using ::std::scalbn;
S      using ::std::scalbnf;
S      using ::std::scalbnl;
S      using ::std::math_errhandling;
S      using ::std::acoshf;
S      using ::std::acoshl;
S      using ::std::asinhf;
S      using ::std::asinhl;
S      using ::std::atanhf;
S      using ::std::atanhl;
S      using ::std::copysignl;
S      using ::std::cbrtf;
S      using ::std::cbrtl;
S      using ::std::erff;
S      using ::std::erfl;
S      using ::std::erfcf;
S      using ::std::erfcl;
S      using ::std::expm1f;
S      using ::std::expm1l;
S      using ::std::log1pf;
S      using ::std::log1pl;
S      using ::std::hypotf;
S      using ::std::hypotl;
S      using ::std::lgammaf;
S      using ::std::lgammal;
S      using ::std::remainderf;
S      using ::std::remainderl;
S      using ::std::rintf;
S      using ::std::rintl;
S    #endif
S    #if !defined(__STRICT_ANSI__) || defined(__USE_C99_MATH)
S      /* C99 additions which appear in C99 or non-strict mode */
S      using ::std::float_t;
S      using ::std::double_t;
S    #endif
S    #ifdef __USE_C99_MATH
S      /* Functions new in C99. */
S      using ::std::exp2;
S      using ::std::exp2f;
S      using ::std::exp2l;
S      using ::std::fdim;
S      using ::std::fdimf;
S      using ::std::fdiml;
S      using ::std::fma;
S      using ::std::fmaf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::fmal;
S#endif
S      using ::std::fmax;
S      using ::std::fmaxf;
S      using ::std::fmaxl;
S      using ::std::fmin;
S      using ::std::fminf;
S      using ::std::fminl;
S      using ::std::log2;
S      using ::std::log2f;
S      using ::std::log2l;
S      using ::std::lrint;
S      using ::std::lrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lrintl;
S#endif
S      using ::std::llrint;
S      using ::std::llrintf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llrintl;
S#endif
S      using ::std::lround;
S      using ::std::lroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::lroundl;
S#endif
S      using ::std::llround;
S      using ::std::llroundf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::llroundl;
S#endif
S      using ::std::nan;
S      using ::std::nanf;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::nanl;
S#endif
S      using ::std::nearbyint;
S      using ::std::nearbyintf;
S      using ::std::nearbyintl;
S      using ::std::remquo;
S      using ::std::remquof;
S#ifdef __HAVE_LONGDOUBLE
S      using ::std::remquol;
S#endif
S      using ::std::round;
S      using ::std::roundf;
S      using ::std::roundl;
S      using ::std::tgamma;
S      using ::std::tgammaf;
S      using ::std::tgammal;
S      using ::std::trunc;
S      using ::std::truncf;
S      using ::std::truncl;
S    #endif
N  #endif
N
N#undef __LONGLONG
N
N#endif /* __math_h */
N
N/* end of math.h */
L 21 "..\GUI\Widget\EDITFloat.c" 2
N
N#include "EDIT_Private.h"
L 1 "..\GUI\Widget\EDIT_Private.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : EDIT_Private.h
NPurpose     : Internal header file
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef EDIT_PRIVATE_H
N#define EDIT_PRIVATE_H
N
N#include "EDIT.h"
L 1 "..\GUI\Widget\EDIT.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : EDIT.h
NPurpose     : EDIT include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef EDIT_H
N#define EDIT_H
N
N#include "WM.h"
L 1 "..\GUI\WM\WM.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : WM.h
NPurpose     : Windows manager include
N----------------------------------------------------------------------
N*/
N
N#ifndef WM_H            /* Make sure we only include it once */
N#define WM_H
N
N
N#include "GUI_ConfDefaults.h"
L 1 "..\GUI\Core\GUI_ConfDefaults.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : GUI_ConfDefaults.h
NPurpose     : Defaults for GUI config switches.
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N#ifndef  GUI_CONFDEFAULTS_H
N#define  GUI_CONFDEFAULTS_H
N
N#include "GUIConf.h"
L 1 "..\Config\GUIConf.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/GUI
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : GUIConf.h
NPurpose     : Configures abilities, fonts etc.
N----------------------------------------------------------------------
N*/
N
N
N#ifndef GUICONF_H
N#define GUICONF_H
N
N#define GUI_OS                    (0)  /* Compile with multitasking support */
N#define GUI_SUPPORT_TOUCH         (1)  /* Support a touch screen (req. win-manager) */
N#define GUI_SUPPORT_UNICODE       (1)  /* Support mixed ASCII/UNICODE strings */
N
N#define GUI_DEFAULT_FONT          &GUI_Font6x8
N#define GUI_ALLOC_SIZE          	(1024*30)  /* Size of dynamic memory ... For WM and memory devices*/
N/*********************************************************************
N*
N*         Configuration of available packages
N*/
N
N#define GUI_WINSUPPORT            1  /* Window manager package available */
N#define GUI_SUPPORT_MEMDEV       1  /* Memory devices available */
N#define GUI_SUPPORT_AA            1  /* Anti aliasing available */
N
N#endif  /* Avoid multiple inclusion */
N
N
N
L 28 "..\GUI\Core\GUI_ConfDefaults.h" 2
N
N/**********************************************************************
N*
N*       Defaults for config switches
N*
N***********************************************************************
N*/
N
N/* Define "universal pointer". Normally, this is not needed (define will expand to nothing)
N   However, on some systems (AVR - IAR compiler) it can be necessary ( -> __generic),
N   since a default pointer can access RAM only, not the built-in Flash
N*/
N#ifndef GUI_UNI_PTR
N  #define GUI_UNI_PTR
N  #define GUI_UNI_PTR_USED 0
N#else
S  #define GUI_UNI_PTR_USED 1
N#endif
N
N/* Define const storage. Normally, this is not needed (define will expand to const)
N   However, on some systems (AVR - IAR compiler) it can be necessary ( -> __flash const),
N   since otherwise constants are copied into RAM
N*/
N#ifndef GUI_USE_MEMDEV_1BPP_FOR_SCREEN
N  #define GUI_USE_MEMDEV_1BPP_FOR_SCREEN 0
N#endif
N
N#ifndef GUI_SUPPORT_UNICODE
S  #define GUI_SUPPORT_UNICODE 1
N#endif
N
N#ifndef GUI_SUPPORT_ARABIC
N  #define GUI_SUPPORT_ARABIC 0
N#endif
N
N#ifndef GUI_ALLOC_SIZE
S  #define GUI_ALLOC_SIZE      1000
N#endif
N
N#ifndef GUI_MAXBLOCKS
N  #define GUI_MAXBLOCKS (2 + GUI_ALLOC_SIZE / 32)
N#endif
N
N#ifndef GUI_CONST_STORAGE
N  #define GUI_CONST_STORAGE const
N#endif
N
N#ifndef GUI_SUPPORT_TOUCH
S  #define GUI_SUPPORT_TOUCH   0
N#endif
N
N#ifndef GUI_SUPPORT_MOUSE
N  #define GUI_SUPPORT_MOUSE   0
N#endif
N
N#ifndef GUI_SUPPORT_MEMDEV
S  #define GUI_SUPPORT_MEMDEV  0
N#endif
N
N#ifndef GUI_SUPPORT_AA
S  #define GUI_SUPPORT_AA      0
N#endif
N
N#ifndef GUI_OS
S  #define GUI_OS              0
N#endif
N
N#ifndef GUI_SUPPORT_LARGE_BITMAPS
N  #if GUI_ALLOC_SIZE > 65535
X  #if (1024*30) > 65535
S    #define GUI_SUPPORT_LARGE_BITMAPS 1
N  #else
N    #define GUI_SUPPORT_LARGE_BITMAPS 0
N  #endif
N#endif
N
N#ifndef GUI_COMPATIBLE_MODE
N  #define GUI_COMPATIBLE_MODE 1
N#endif
N
N#ifndef GUI_NUM_LAYERS
N  #define GUI_NUM_LAYERS      1
N#endif
N
N#ifndef GUI_SUPPORT_CURSOR
N  #define GUI_SUPPORT_CURSOR  (GUI_SUPPORT_MOUSE | GUI_SUPPORT_TOUCH)
N#endif
N
N#ifndef GUI_SUPPORT_DEVICES
N  #ifdef __C51__               /* Keil C51 limitation ... Indirect function calls are limited */
S    #define GUI_SUPPORT_DEVICES 0
N  #else
N    #define GUI_SUPPORT_DEVICES (GUI_SUPPORT_MEMDEV | (GUI_NUM_LAYERS > 1))
N  #endif
N#endif
N
N/* Some compilers for very simple chips can not generate code for function pointers
Nwith parameters. In this case, we do not use function pointers, but limit the functionality slightly */
N#ifndef GUI_COMPILER_SUPPORTS_FP
N  #ifdef __C51__
S    #define GUI_COMPILER_SUPPORTS_FP 0
N  #else
N    #define GUI_COMPILER_SUPPORTS_FP 1
N  #endif
N#endif
N
N#ifndef GUI_SUPPORT_ROTATION
N  #if GUI_COMPILER_SUPPORTS_FP
X  #if 1
N    #define GUI_SUPPORT_ROTATION 1
N  #else
S    #define GUI_SUPPORT_ROTATION 0
N  #endif
N#endif
N
N/* In order to avoid warnings for undefined parameters */
N#ifndef GUI_USE_PARA
N  #if defined (__BORLANDC__) || defined(NC30) || defined(NC308)
X  #if 0L || 0L || 0L
S    #define GUI_USE_PARA(para)
N  #else
N    #define GUI_USE_PARA(para) para=para;
N  #endif
N#endif
N
N/* Default for types */
N#ifndef GUI_TIMER_TIME
N  #define GUI_TIMER_TIME int  /* default is to use 16 bits for 16 bit CPUs,
N	                           32 bits on 32 bit CPUs for timing */
N#endif
N
N/* Types used for memory allocation */
N#if GUI_ALLOC_SIZE <32767
X#if (1024*30) <32767
N  #define GUI_ALLOC_DATATYPE   I16
N  #define GUI_ALLOC_DATATYPE_U U16
N#else
S  #define GUI_ALLOC_DATATYPE   I32
S  #define GUI_ALLOC_DATATYPE_U U32
N#endif
N
N#ifndef   GUI_MEMSET
N  #define GUI_MEMSET GUI__memset
N#endif
N
N
N#endif   /* ifdef GUI_CONFDEFAULTS_H */
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 25 "..\GUI\WM\WM.h" 2
N#include "GUIType.h"      /* Needed because of typedefs only */
L 1 "..\GUI\Core\GUIType.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : GUIType.h
NPurpose     : Include file define the types used for GUI
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N#ifndef  GUITYPE_H_INCLUDED
N#define  GUITYPE_H_INCLUDED
N
N#include "LCD.h"
L 1 "..\GUI\Core\LCD.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : LCD.h
NPurpose     : Declares LCD interface functions
N----------------------------------------------------------------------
N*/
N
N#ifndef LCD_H
N#define LCD_H
N
N#include "GUI_ConfDefaults.h" /* Used for GUI_UNI_PTR */
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*
N  ********************************************************************
N  *                                                                  *
N  *                   Basic type defines                             *
N  *                                                                  *
N  ********************************************************************
N
NThe follwing are defines for types used in the LCD-driver and the
NGUI layers on top of that. Since "C" does not provide data types of
Nfixed length which are identical on all platforms, this is done here.
NFor most 16/32 controllers, the settings will work fine. However, if
Nyou have similar defines in other sections of your program, you might
Nwant to change or relocate these defines, e.g. in a TYPE.h file.
N*/
N 
N#define I8    signed char
N#define U8  unsigned char     /* unsigned 8  bits. */
N#define I16   signed short    /*   signed 16 bits. */
N#define U16 unsigned short    /* unsigned 16 bits. */
N#define I32   signed long   /*   signed 32 bits. */
N#define U32 unsigned long   /* unsigned 32 bits. */
N#define I16P I16              /*   signed 16 bits OR MORE ! */
N#define U16P U16              /* unsigned 16 bits OR MORE ! */
N
N/*
N  ********************************************************************
N  *                                                                  *
N  *               Settings for windows simulation                    *
N  *                                                                  *
N  ********************************************************************
N
NSome settings in the configuration may conflict with the values required
Nin the Simulation. This is why we ignore the target settings for data
Ntypes and use the correct settings for the simulation.
N(U32 could be defined as long, which would yield a 64 bit type on
Nthe PC)
N*/
N
N#ifdef WIN32
S  #pragma warning( disable : 4244 )  // Disable warning messages in simulation
S  #pragma warning( disable : 4761 )  // Disable warning "integral size mismatch in argument; conversion supplied"
N#endif                                      
N
N
N/*      *************************************************************
N        *                                                           *
N        *                Constants                                  *
N        *                                                           *
N        *************************************************************
N*/
N#define LCD_ERR0 (0x10)
N#define LCD_ERR_CONTROLLER_NOT_FOUND (LCD_ERR0+1)
N#define LCD_ERR_MEMORY               (LCD_ERR0+2)
N
N/*
N      *********************************
N      *                               *
N      *      Drawing modes            *
N      *                               *
N      *********************************
N*/
N
N#define LCD_DRAWMODE_NORMAL (0)
N#define LCD_DRAWMODE_XOR    (1<<0)
N#define LCD_DRAWMODE_TRANS  (1<<1)
N#define LCD_DRAWMODE_REV    (1<<2)
N
N
N 
N/*      *************************************************************
N        *                                                           *
N        *                Typedefs                                   *
N        *                                                           *
N        *************************************************************
N*/
N
Ntypedef int LCD_DRAWMODE;
Ntypedef U32 LCD_COLOR;
Xtypedef unsigned long LCD_COLOR;
N
N 
N/********************************************************
N*
N*     Data structures
N*
N*********************************************************
N*/
N
Ntypedef struct { I16P x,y; } GUI_POINT;
Xtypedef struct { signed short x,y; } GUI_POINT;
Ntypedef struct { I16 x0,y0,x1,y1; } LCD_RECT;
Xtypedef struct { signed short x0,y0,x1,y1; } LCD_RECT;
N/*typedef struct { GUI_POINT P0, P1; } LCD_RECT; */
N
Ntypedef struct {
N  int              NumEntries; 
N  char             HasTrans;         
N  const LCD_COLOR GUI_UNI_PTR * pPalEntries; 
X  const LCD_COLOR  * pPalEntries; 
N} LCD_LOGPALETTE; 
N
N/* This is used for the simulation only ! */
Ntypedef struct {
N  int x,y;
N  unsigned char KeyStat;
N} LCD_tMouseState;
N
N/*********************************************************************
N*
N*     Index2Color
N
N  This function needs to be int the public part of the software
N  since it is needed by the simulation. Most other driver
N  functions are hidden in the private header file.
N*/
N
Ntypedef LCD_COLOR      tLCDDEV_Index2Color  (int Index);
Ntypedef unsigned int   tLCDDEV_Color2Index  (LCD_COLOR Color);
Ntypedef unsigned int   tLCDDEV_GetIndexMask (void);
NLCD_COLOR      LCD_L0_Index2Color  (int Index);
NLCD_COLOR      LCD_L0_1_Index2Color(int Index);
NLCD_COLOR      LCD_L0_2_Index2Color(int Index);
NLCD_COLOR      LCD_L0_3_Index2Color(int Index);
NLCD_COLOR      LCD_L0_4_Index2Color(int Index);
Nunsigned int   LCD_L0_Color2Index  (LCD_COLOR Color);
Nunsigned int   LCD_L0_1_Color2Index(LCD_COLOR Color);
Nunsigned int   LCD_L0_2_Color2Index(LCD_COLOR Color);
Nunsigned int   LCD_L0_3_Color2Index(LCD_COLOR Color);
Nunsigned int   LCD_L0_4_Color2Index(LCD_COLOR Color);
Nunsigned int   LCD_L0_GetIndexMask  (void);
Nunsigned int   LCD_L0_1_GetIndexMask(void);
Nunsigned int   LCD_L0_2_GetIndexMask(void);
Nunsigned int   LCD_L0_3_GetIndexMask(void);
Nunsigned int   LCD_L0_4_GetIndexMask(void);
N
N
N/*********************************************************************
N*
N*     Color conversion API tables
N*/
N
Ntypedef struct {
N  tLCDDEV_Color2Index*  pfColor2Index;
N  tLCDDEV_Index2Color*  pfIndex2Color;
N  tLCDDEV_GetIndexMask* pfGetIndexMask;
N} LCD_API_COLOR_CONV;
N
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_2;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_4;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8666;
N
N#define GUI_COLOR_CONV_1    &LCD_API_ColorConv_1
N#define GUI_COLOR_CONV_2    &LCD_API_ColorConv_2
N#define GUI_COLOR_CONV_4    &LCD_API_ColorConv_4
N#define GUI_COLOR_CONV_8666 &LCD_API_ColorConv_8666
N
N/*********************************************************************
N*
N*      LCDDEV function table
N*
N**********************************************************************
N
N  Below the routines which need to in an LCDDEV routine table are
N  defined. All of these routines have to be in the low-level driver
N  (LCD_L0) or in the memory device which can be used to replace the
N  driver.
N  The one exception to this is the SetClipRect routine, which would
N  be identical for all drivers and is therefor contained in the
N  level above (LCD).
N*/
Ntypedef void         tLCDDEV_DrawHLine    (int x0, int y0,  int x1);
Ntypedef void         tLCDDEV_DrawVLine    (int x , int y0,  int y1);
Ntypedef void         tLCDDEV_FillRect     (int x0, int y0, int x1, int y1);
Ntypedef unsigned int tLCDDEV_GetPixelIndex(int x, int y);
Ntypedef void         tLCDDEV_SetPixelIndex(int x, int y, int ColorIndex);
Ntypedef void         tLCDDEV_XorPixel     (int x, int y);
Ntypedef void         tLCDDEV_FillPolygon  (const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Ntypedef void         tLCDDEV_FillPolygonAA(const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Ntypedef void         tLCDDEV_GetRect      (LCD_RECT*pRect);
Ntypedef int          tLCDDEV_Init         (void);
Ntypedef void         tLCDDEV_On           (void);
Ntypedef void         tLCDDEV_Off          (void);
Ntypedef void         tLCDDEV_SetLUTEntry  (U8 Pos, LCD_COLOR color);
Xtypedef void         tLCDDEV_SetLUTEntry  (unsigned char Pos, LCD_COLOR color);
Ntypedef void *       tLCDDEV_GetDevFunc   (int Index);
N
N/*********************************************************************
N*
N*     Memory device API tables
N*/
N#if GUI_COMPILER_SUPPORTS_FP
X#if 1
N  typedef struct tLCDDEV_APIList_struct tLCDDEV_APIList;
N#endif
N
Ntypedef void tLCDDEV_DrawBitmap   (int x0, int y0, int xsize, int ysize,
N                       int BitsPerPixel, int BytesPerLine,
N                       const U8 GUI_UNI_PTR * pData, int Diff,
X                       const unsigned char  * pData, int Diff,
N                       const void* pTrans);   /* Really LCD_PIXELINDEX, but is void to avoid compiler warnings*/
N
Nstruct tLCDDEV_APIList_struct {
N  tLCDDEV_Color2Index*        pfColor2Index;
N  tLCDDEV_Index2Color*        pfIndex2Color;
N  tLCDDEV_GetIndexMask*       pfGetIndexMask;
N  tLCDDEV_DrawBitmap*         pfDrawBitmap;
N  tLCDDEV_DrawHLine*          pfDrawHLine;
N  tLCDDEV_DrawVLine*          pfDrawVLine;
N  tLCDDEV_FillRect*           pfFillRect;
N  tLCDDEV_GetPixelIndex*      pfGetPixelIndex;
N  tLCDDEV_GetRect*            pfGetRect;
N  tLCDDEV_SetPixelIndex*      pfSetPixelIndex;
N  tLCDDEV_XorPixel*           pfXorPixel;
N  tLCDDEV_SetLUTEntry*        pfSetLUTEntry;
N  tLCDDEV_GetDevFunc*         pfGetDevFunc;
N  #if GUI_SUPPORT_MEMDEV
X  #if 1
N    tLCDDEV_FillPolygon*      pfFillPolygon;
N    tLCDDEV_FillPolygonAA*    pfFillPolygonAA;
N    const tLCDDEV_APIList*    pMemDevAPI;
N    unsigned                  BitsPerPixel;
N  #endif
N};
N#if GUI_COMPILER_SUPPORTS_FP
X#if 1
N  extern const struct tLCDDEV_APIList_struct GUI_MEMDEV__APIList1;
N  extern const struct tLCDDEV_APIList_struct GUI_MEMDEV__APIList8;
N  extern const struct tLCDDEV_APIList_struct GUI_MEMDEV__APIList16;
N
N  #define GUI_MEMDEV_APILIST_1  &GUI_MEMDEV__APIList1
N  #define GUI_MEMDEV_APILIST_8  &GUI_MEMDEV__APIList8
N  #define GUI_MEMDEV_APILIST_16 &GUI_MEMDEV__APIList16
N#endif
N
N/*      *************************************************************
N        *                                                           *
N        *                   Defines                                 *
N        *                                                           *
N        *    for device capabilities                                *
N        *                                                           *
N        *************************************************************
N
NThe following is the list of device capabilities which can, but do
Nnot have to be implemented in the driver. This way the driver can be
Nenhanced in the future without affecting the driver interface,
Nkeeping older drivers compatible.
NMore DevCaps can always be added in the future, as older drivers
Nare guaranteed to return 0 for all unimplemented features or queries.
N
NThe values below define the legal parameters to the LCD_GetDeviceCaps
Nand the LCD_GetpCapFunc routines.
N*/
N
N#define LCD_DEVCAP_NUMCOLORS    0x0     /* Quest number of colors
N                                           which LCD can display */
N#define LCD_DEVCAP_XSIZE        0x1     /* Quest horiz. res. of display */
N#define LCD_DEVCAP_YSIZE        0x2     /* Quest vert. res. of display */
N#define LCD_DEVCAP_VXSIZE       0x3     /* Quest vert. res. of virtual disp.*/
N#define LCD_DEVCAP_VYSIZE       0x4     /* Quest vert. res. of virtual disp.*/
N#define LCD_DEVCAP_XORG         0x5     /* X-origin ... usually 0 */
N#define LCD_DEVCAP_YORG         0x6     /* Y-origin ... usually 0 */
N#define LCD_DEVCAP_CONTROLLER   0x7     /* LCD Controller (Numerical) */
N#define LCD_DEVCAP_BITSPERPIXEL 0x8     /* Bits per pixel ... 1/2/4/8 */
N#define LCD_DEVCAP_NUMPAGES     0x10    /* Quest number of pages of display */
N
N#define LCD_DEVCAP_COLOR        0x1000  /* Quest Color[0]
N                                0x1001     Quest Color[1]
N                                0x1002     Quest Color[2]
N                                         ...                    */
N /* The next 4095 entries are reserved so up to 4096 colors
N    can be queried          ...*/
N
Nint LCD_GetXSize(void);
Nint LCD_GetXSize_1(void);
Nint LCD_GetXSizeEx(int Index);
N
Nint LCD_GetYSize(void);
Nint LCD_GetYSize_1(void);
Nint LCD_GetYSizeEx(int Index);
N
Nint LCD_GetVXSize(void);
Nint LCD_GetVXSize_1(void);
Nint LCD_GetVXSizeEx(int Index);
N
Nint LCD_GetVYSize(void);
Nint LCD_GetVYSize_1(void);
Nint LCD_GetVYSizeEx(int Index);
N
NU32 LCD_GetNumColors(void);
Xunsigned long LCD_GetNumColors(void);
NU32 LCD_GetNumColors_1(void);
Xunsigned long LCD_GetNumColors_1(void);
NU32 LCD_GetNumColorsEx(int Index);
Xunsigned long LCD_GetNumColorsEx(int Index);
N
Nint LCD_GetBitsPerPixel(void);
Nint LCD_GetBitsPerPixel_1(void);
Nint LCD_GetBitsPerPixelEx(int Index);
N
Nint LCD_GetFixedPalette(void);
Nint LCD_GetFixedPalette_1(void);
NI32 LCD_GetFixedPaletteEx(int Index);
Xsigned long LCD_GetFixedPaletteEx(int Index);
N
Nint LCD_GetXMag(void);
Nint LCD_GetXMag_1(void);
Nint LCD_GetXMagEx(int Index);
N
Nint LCD_GetYMag(void);
Nint LCD_GetYMag_1(void);
Nint LCD_GetYMagEx(int Index);
N
Nint LCD_GetMirrorXEx(int LayerIndex);
Nint LCD_GetMirrorYEx(int LayerIndex);
Nint LCD_GetSwapXYEx(int LayerIndex);
N
Nint LCD_GetSwapRBEx(int LayerIndex);
Nint LCD_GetDeltaModeEx(int LayerIndex);
Nint LCD_GetBitsPerPixel_L0Ex(int LayerIndex);
N
NtLCDDEV_Index2Color * LCD_GetpfIndex2ColorEx(int LayerIndex);
N
Nint LCD_GetNumLayers(void);
N
N#define LCD_GetNumDisplays() LCD_GetNumLayers()
N
N#define LCD_GET_XSIZE()        LCD_GetXSize()
N#define LCD_GET_YSIZE()        LCD_GetYSize()
N#define LCD_GET_VXSIZE()       LCD_GetVXSize()
N#define LCD_GET_VYSIZE()       LCD_GetVYSize()
N#define LCD_GET_NUMCOLORS()    LCD_GetNumColors()
N#define LCD_GET_BITSPERPIXEL() LCD_GetBitsPerPixel()
N
N#define LCD_DEVFUNC_READRECT  0x1     /* Request of a function pointer for reading a rectangular display area */
N
Nvoid * LCD_L0_GetDevFunc(int Index);
N
N/*********************************************************************
N*
N*      LCD_CLIP function table
N*
N**********************************************************************
N*/
Ntypedef void         tLCD_HL_DrawHLine    (int x0, int y0,  int x1);
Ntypedef void         tLCD_HL_DrawPixel    (int x0, int y0);
N
Ntypedef struct {
N  tLCD_HL_DrawHLine*          pfDrawHLine;
N  tLCD_HL_DrawPixel*          pfDrawPixel;
N} tLCD_HL_APIList;
N
Nvoid LCD_DrawHLine(int x0, int y0,  int x1);
Nvoid LCD_DrawPixel(int x0, int y0);
Nvoid LCD_DrawVLine  (int x, int y0,  int y1);
N
N
N
N/*********************************************************************
N*
N*              Declarations for LCD_
N*
N**********************************************************************
N*/
N
Nvoid LCD_SetClipRectEx(const LCD_RECT* pRect);
Nvoid LCD_SetClipRectMax(void);
N
N/* Get device capabilities (0 if not supported) */
NI32  LCD_GetDevCap(int Index);
Xsigned long  LCD_GetDevCap(int Index);
N
N/* Initialize LCD using config-paramters */
Nint LCD_Init(void);
N
Nvoid LCD_SetBkColor   (LCD_COLOR Color); /* Set background color */
Nvoid LCD_SetColor     (LCD_COLOR Color); /* Set foreground color */
Nvoid LCD_SetPixelIndex(int x, int y, int ColorIndex);
N
N/* Palette routines (Not available on all drivers) */
Nvoid LCD_InitLUT(void);
N
N/* Decompressors */
N//typedef void tfDrawSpecialBitmap(int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR *pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
Nvoid         LCD_DrawBitmap_RLE8(int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR *pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
Xvoid         LCD_DrawBitmap_RLE8(int x0,int y0,int xsize, int ysize, const unsigned char  *pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag);
Nvoid         LCD_DrawBitmap_RLE4(int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR *pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
Xvoid         LCD_DrawBitmap_RLE4(int x0,int y0,int xsize, int ysize, const unsigned char  *pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag);
Nvoid         LCD_DrawBitmap_565 (int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR *pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
Xvoid         LCD_DrawBitmap_565 (int x0,int y0,int xsize, int ysize, const unsigned char  *pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag);
Nvoid         LCD_DrawBitmap_M565(int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR *pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
Xvoid         LCD_DrawBitmap_M565(int x0,int y0,int xsize, int ysize, const unsigned char  *pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag);
N
NLCD_DRAWMODE LCD_SetDrawMode  (LCD_DRAWMODE dm);
Nvoid LCD_SetColorIndex(int Index);
Nvoid LCD_SetBkColorIndex(int Index);
Nvoid LCD_FillRect(int x0, int y0, int x1, int y1);
Ntypedef void tLCD_SetPixelAA(int x, int y, U8 Intens);
Xtypedef void tLCD_SetPixelAA(int x, int y, unsigned char Intens);
N
Nvoid LCD_SetPixelAA(int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA(int x, int y, unsigned char Intens);
Nvoid LCD_SetPixelAA_NoTrans(int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA_NoTrans(int x, int y, unsigned char Intens);
N
NLCD_COLOR    LCD_AA_MixColors(LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
XLCD_COLOR    LCD_AA_MixColors(LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
NLCD_COLOR    LCD_MixColors256(LCD_COLOR Color, LCD_COLOR BkColor, unsigned Intens);
NLCD_COLOR    LCD_GetPixelColor(int x, int y);     /* Get RGB color of pixel */
Nunsigned int LCD_GetPixelIndex(int x, int y);
Nint          LCD_GetBkColorIndex (void);
Nint          LCD_GetColorIndex (void);
N
N/*********************************************************************
N*
N*       Optional support for rotatation
N*
N**********************************************************************
N*/
N
N#if GUI_SUPPORT_ROTATION
X#if 1
N
Ntypedef void tLCD_DrawBitmap(int x0, int y0, int xsize, int ysize,
N                             int xMul, int yMul, int BitsPerPixel, int BytesPerLine,
N                             const U8 GUI_UNI_PTR * pPixel, const void * pTrans);
X                             const unsigned char  * pPixel, const void * pTrans);
Ntypedef void tRect2TextRect (LCD_RECT * pRect);
N
Nstruct tLCD_APIList_struct {
N  tLCD_DrawBitmap   * pfDrawBitmap;
N  tRect2TextRect    * pfRect2TextRect;
N};
N
Ntypedef struct tLCD_APIList_struct tLCD_APIList;
N
Nextern tLCD_APIList LCD_APIListCCW;
Nextern tLCD_APIList LCD_APIListCW;
Nextern tLCD_APIList LCD_APIList180;
N
N#define GUI_ROTATION   tLCD_APIList
N#define GUI_ROTATE_CCW &LCD_APIListCCW
N#define GUI_ROTATE_CW  &LCD_APIListCW
N#define GUI_ROTATE_180 &LCD_APIList180
N#define GUI_ROTATE_0   0
N#endif
N
N
N/*      *************************************************************
N        *                                                           *
N        *      LCD  publics not used by GUI                         *
N        *                                                           *
N        *************************************************************
N  
N
NThe following functions can, but do not have to be defined in the LCD driver
Nas they are not used by the GUI level.
N
N*/
N
N
N
N#define LCD_On          LCD_L0_On
N#define LCD_Off         LCD_L0_Off
N#define LCD_ReInit      LCD_L0_ReInit
N#define LCD_SetLUTEntry LCD_L0_SetLUTEntry
N
N
N#define LCD_CC_UNLOCK (0)    /* Default mode: Cache is transparent */
N#define LCD_CC_LOCK   (1)    /* Cache is locked, no write operations */
N#define LCD_CC_FLUSH  (2)    /* Flush cache, do not change mode */
NU8 LCD_L0_ControlCache(U8 mode);
Xunsigned char LCD_L0_ControlCache(unsigned char mode);
NU8 LCD_L0_1_ControlCache(U8 mode);
Xunsigned char LCD_L0_1_ControlCache(unsigned char mode);
NU8 LCD_L0_2_ControlCache(U8 mode);
Xunsigned char LCD_L0_2_ControlCache(unsigned char mode);
NU8 LCD_L0_3_ControlCache(U8 mode);
Xunsigned char LCD_L0_3_ControlCache(unsigned char mode);
NU8 LCD_L0_4_ControlCache(U8 mode);
Xunsigned char LCD_L0_4_ControlCache(unsigned char mode);
Nvoid LCD_L0_Refresh(void);
Nvoid LCD_L0_1_Refresh(void);
Nvoid LCD_L0_2_Refresh(void);
Nvoid LCD_L0_3_Refresh(void);
Nvoid LCD_L0_4_Refresh(void);
N/* Check if controller is still properly initialized */
Nint  LCD_L0_CheckInit(void);        /* returns if init is still O.K.
N                                      by reading all available registers of
N                                      Display controller.
N                                      0: Init O.K.
N                                    */
N
N#define LCD_ControlCache LCD_L0_ControlCache
N
N/*
N        ******************************************
N        *                                        *
N        *        Support for paging              *
N        *                                        *
N        ******************************************
N*/
N
Nint LCD_SelPage  (int NewPage);    /* returns formerly sel. page */
Nint LCD_ShowPage (int NewPage);    /* sets / returns visible page */
Nint LCD_GetSelPage (void);         /* returns selected page */
Nint LCD_GetVisPage (void);         /* returns visible page */
N
N
N/*      *************************************************************
N        *                                                           *
N        *      LCD  imports                                         *
N        *                  (for routines in LCDColor)               *
N        *                                                           *
N        *************************************************************
N*/
N  
N
Nint              LCD_Color2Index     (LCD_COLOR Color);
NLCD_COLOR        LCD_Index2Color     (int Index);
NLCD_COLOR        LCD_Index2ColorEx   (int i, unsigned int LayerIndex);
N
N/*********************************************************************
N*
N*       LCD_X_...
N*
N**********************************************************************
N*/
N
Nvoid LCD_X_Init(void);
Nvoid LCD_X_On  (void);
Nvoid LCD_X_Off (void);
N
Nchar LCD_X_Read00(void);
Nchar LCD_X_Read01(void);
Nvoid LCD_X_Write00(char c);
Nvoid LCD_X_Write01(char c);
Nvoid LCD_X_WriteM01(char * pData, int NumBytes);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif /* LCD_H */
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 28 "..\GUI\Core\GUIType.h" 2
N#include "GUIConf.h"
N
N/*      *************************************************************
N        *                                                           *
N        *                Simple types                               *
N        *                                                           *
N        *************************************************************
N*/
N
Ntypedef const char *  GUI_ConstString;
N
N
N/*      *************************************************************
N        *                                                           *
N        *                Structures                                 *
N        *                                                           *
N        *************************************************************
N*/
N
Ntypedef LCD_COLOR       GUI_COLOR;
Ntypedef LCD_LOGPALETTE  GUI_LOGPALETTE;
Ntypedef LCD_DRAWMODE    GUI_DRAWMODE;
Ntypedef LCD_RECT        GUI_RECT;
N
Ntypedef struct {
N  void      (* pfDraw)(int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR * pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
X  void      (* pfDraw)(int x0,int y0,int xsize, int ysize, const unsigned char  * pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag);
N  GUI_COLOR (* pfIndex2Color)(int Index);
N} GUI_BITMAP_METHODS;
N
Ntypedef struct {
N  U16P XSize;
X  unsigned short XSize;
N  U16P YSize;
X  unsigned short YSize;
N  U16P BytesPerLine;
X  unsigned short BytesPerLine;
N  U16P BitsPerPixel;
X  unsigned short BitsPerPixel;
N  const U8 GUI_UNI_PTR * pData;
X  const unsigned char  * pData;
N  const GUI_LOGPALETTE GUI_UNI_PTR * pPal;
X  const GUI_LOGPALETTE  * pPal;
N  const GUI_BITMAP_METHODS * pMethods;
N} GUI_BITMAP;
N
N/* This structure may not be changed because the data that it
N   expects is read in binary form (via any kind of interface,
N   at runtime).
N   This structure should therefor not be changed.
N*/
Ntypedef struct {
N  U16 ID;           /* Version 1.00 => 100*/
X  unsigned short ID;            
N  U16 Version;
X  unsigned short Version;
N  U16 XSize;
X  unsigned short XSize;
N  U16 YSize;
X  unsigned short YSize;
N  U16 BytesPerLine;
X  unsigned short BytesPerLine;
N  U16 BitsPerPixel;
X  unsigned short BitsPerPixel;
N  U16 NumColors;
X  unsigned short NumColors;
N  U16 HasTrans;
X  unsigned short HasTrans;
N} GUI_BITMAP_STREAM;
N
Ntypedef struct {
N  int x,y;
N  unsigned char Pressed;
N} GUI_PID_STATE;
N
Ntypedef struct {
N  int xPos;
N  int yPos;
N  int xSize;
N  int ySize;
N  int Delay;
N} GUI_GIF_IMAGE_INFO;
N
Ntypedef struct {
N  int xSize;
N  int ySize;
N  int NumImages;
N} GUI_GIF_INFO;
N
N/*
N      ****************************************
N      *                                      *
N      *      FONT structures (new in V1.10)  *
N      *                                      *
N      ****************************************
N*/
N
N/* Translation list. Translates a character code into up to 2
N   indices of images to display on top of each other;
N   'á' -> index('a'), index('´') */
Ntypedef struct {
N  I16P c0;
X  signed short c0;
N  I16P c1;
X  signed short c1;
N} GUI_FONT_TRANSLIST;
N
Ntypedef struct {
N  U16P FirstChar;
X  unsigned short FirstChar;
N  U16P LastChar;
X  unsigned short LastChar;
N  const GUI_FONT_TRANSLIST GUI_UNI_PTR * pList;
X  const GUI_FONT_TRANSLIST  * pList;
N} GUI_FONT_TRANSINFO;
N
Ntypedef struct {
N  U8 XSize;
X  unsigned char XSize;
N  U8 XDist;
X  unsigned char XDist;
N  U8 BytesPerLine;
X  unsigned char BytesPerLine;
N  const unsigned char GUI_UNI_PTR * pData;
X  const unsigned char  * pData;
N} GUI_CHARINFO;
N
Ntypedef struct GUI_FONT_PROP {
N  U16P First;                                /* first character               */
X  unsigned short First;                                 
N  U16P Last;                                 /* last character                */
X  unsigned short Last;                                  
N  const GUI_CHARINFO GUI_UNI_PTR * paCharInfo;            /* address of first character    */
X  const GUI_CHARINFO  * paCharInfo;             
N  const struct GUI_FONT_PROP GUI_UNI_PTR * pNext;        /* pointer to next */
X  const struct GUI_FONT_PROP  * pNext;         
N} GUI_FONT_PROP;
N
Ntypedef struct {
N  const unsigned char GUI_UNI_PTR * pData;
X  const unsigned char  * pData;
N  const U8 GUI_UNI_PTR * pTransData;
X  const unsigned char  * pTransData;
N  const GUI_FONT_TRANSINFO GUI_UNI_PTR * pTrans;
X  const GUI_FONT_TRANSINFO  * pTrans;
N  U16P FirstChar;
X  unsigned short FirstChar;
N  U16P LastChar;
X  unsigned short LastChar;
N  U8 XSize;
X  unsigned char XSize;
N  U8 XDist;
X  unsigned char XDist;
N  U8 BytesPerLine;
X  unsigned char BytesPerLine;
N} GUI_FONT_MONO;
N
N
Ntypedef struct GUI_FONT_INFO {
N  U16P First;                        /* first character               */
X  unsigned short First;                         
N  U16P Last;                         /* last character                */
X  unsigned short Last;                          
N  const GUI_CHARINFO* paCharInfo;    /* address of first character    */
N  const struct GUI_FONT_INFO* pNext; /* pointer to next */
N} GUI_FONT_INFO;
N
N/*
N      ****************************************
N      *                                      *
N      *      FONT info structure             *
N      *                                      *
N      ****************************************
N
NThis structure is used when retrieving information about a font.
NIt is designed for future expansion without incompatibilities.
N*/
Ntypedef struct {
N  U16 Flags;
X  unsigned short Flags;
N  U8 Baseline;
X  unsigned char Baseline;
N  U8 LHeight;     /* height of a small lower case character (a,x) */
X  unsigned char LHeight;      
N  U8 CHeight;     /* height of a small upper case character (A,X) */
X  unsigned char CHeight;      
N} GUI_FONTINFO;
N
N#define GUI_FONTINFO_FLAG_PROP (1<<0)    /* Is proportional */
N#define GUI_FONTINFO_FLAG_MONO (1<<1)    /* Is monospaced */
N#define GUI_FONTINFO_FLAG_AA   (1<<2)    /* Is an antialiased font */
N#define GUI_FONTINFO_FLAG_AA2  (1<<3)    /* Is an antialiased font, 2bpp */
N#define GUI_FONTINFO_FLAG_AA4  (1<<4)    /* Is an antialiased font, 4bpp */
N
N
N/**********************************************************************
N*
N*         UNICODE Encoding
N*
N***********************************************************************
N*/
Ntypedef U16  tGUI_GetCharCode(const char GUI_UNI_PTR *s);
Xtypedef unsigned short  tGUI_GetCharCode(const char  *s);
Ntypedef int  tGUI_GetCharSize(const char GUI_UNI_PTR *s);
Xtypedef int  tGUI_GetCharSize(const char  *s);
Ntypedef int  tGUI_CalcSizeOfChar(U16 Char);
Xtypedef int  tGUI_CalcSizeOfChar(unsigned short Char);
Ntypedef int  tGUI_Encode(char *s, U16 Char);
Xtypedef int  tGUI_Encode(char *s, unsigned short Char);
N
Ntypedef struct {
N  tGUI_GetCharCode*            pfGetCharCode;
N  tGUI_GetCharSize*            pfGetCharSize;
N  tGUI_CalcSizeOfChar*         pfCalcSizeOfChar;
N  tGUI_Encode*                 pfEncode;
N} GUI_UC_ENC_APILIST;
N
N/**********************************************************************
N*
N*                 FONT Encoding
N*
N***********************************************************************
N*/
N
Ntypedef int  tGUI_GetLineDistX(const char GUI_UNI_PTR *s, int Len);
Xtypedef int  tGUI_GetLineDistX(const char  *s, int Len);
Ntypedef int  tGUI_GetLineLen(const char GUI_UNI_PTR *s, int MaxLen);
Xtypedef int  tGUI_GetLineLen(const char  *s, int MaxLen);
Ntypedef void tGL_DispLine(const char GUI_UNI_PTR *s, int Len);
Xtypedef void tGL_DispLine(const char  *s, int Len);
N
Ntypedef struct {
N  tGUI_GetLineDistX*          pfGetLineDistX;
N  tGUI_GetLineLen*            pfGetLineLen;
N  tGL_DispLine*               pfDispLine;
N} tGUI_ENC_APIList;
N
Nextern const tGUI_ENC_APIList GUI_ENC_APIList_SJIS;
N
N
N/*
N      ****************************************
N      *                                      *
N      *      FONT methods                    *
N      *                                      *
N      ****************************************
N
NThe parameter to the methods called pFont should be of type
NGUI_FONT, but unfortunately a lot of compilers can not handle
Nforward declarations right ...
NSo it ends up to be a void pointer.
N*/
N
Ntypedef struct GUI_FONT GUI_FONT;
N
Ntypedef void GUI_DISPCHAR(U16 c);
Xtypedef void GUI_DISPCHAR(unsigned short c);
Ntypedef int  GUI_GETCHARDISTX(U16P c);
Xtypedef int  GUI_GETCHARDISTX(unsigned short c);
Ntypedef void GUI_GETFONTINFO(const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO * pfi);
Xtypedef void GUI_GETFONTINFO(const GUI_FONT  * pFont, GUI_FONTINFO * pfi);
Ntypedef char GUI_ISINFONT   (const GUI_FONT GUI_UNI_PTR * pFont, U16 c);
Xtypedef char GUI_ISINFONT   (const GUI_FONT  * pFont, unsigned short c);
N
N#define DECLARE_FONT(Type)                                     \
Nvoid GUI##Type##_DispChar    (U16P c);                         \
Nint  GUI##Type##_GetCharDistX(U16P c);                         \
Nvoid GUI##Type##_GetFontInfo (const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO * pfi); \
Nchar GUI##Type##_IsInFont    (const GUI_FONT GUI_UNI_PTR * pFont, U16 c)
X#define DECLARE_FONT(Type)                                     void GUI##Type##_DispChar    (U16P c);                         int  GUI##Type##_GetCharDistX(U16P c);                         void GUI##Type##_GetFontInfo (const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO * pfi); char GUI##Type##_IsInFont    (const GUI_FONT GUI_UNI_PTR * pFont, U16 c)
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/* MONO: Monospaced fonts */
NDECLARE_FONT(MONO);
Xvoid GUIMONO_DispChar (unsigned short c); int GUIMONO_GetCharDistX(unsigned short c); void GUIMONO_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIMONO_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_MONO       \
N  GUIMONO_DispChar,             \
N	GUIMONO_GetCharDistX,         \
N	GUIMONO_GetFontInfo,          \
N	GUIMONO_IsInFont,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_MONO         GUIMONO_DispChar,             	GUIMONO_GetCharDistX,         	GUIMONO_GetFontInfo,          	GUIMONO_IsInFont,               (tGUI_ENC_APIList*)0
N
N/* PROP: Proportional fonts */
NDECLARE_FONT(PROP);
Xvoid GUIPROP_DispChar (unsigned short c); int GUIPROP_GetCharDistX(unsigned short c); void GUIPROP_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_PROP       \
N  GUIPROP_DispChar,             \
N	GUIPROP_GetCharDistX,         \
N	GUIPROP_GetFontInfo,          \
N	GUIPROP_IsInFont,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP         GUIPROP_DispChar,             	GUIPROP_GetCharDistX,         	GUIPROP_GetFontInfo,          	GUIPROP_IsInFont,               (tGUI_ENC_APIList*)0
N
N/* PROP: Proportional fonts SJIS */
NDECLARE_FONT(PROP);
Xvoid GUIPROP_DispChar (unsigned short c); int GUIPROP_GetCharDistX(unsigned short c); void GUIPROP_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_PROP_SJIS  \
N  GUIPROP_DispChar,             \
N	GUIPROP_GetCharDistX,         \
N	GUIPROP_GetFontInfo,          \
N	GUIPROP_IsInFont,             \
N  &GUI_ENC_APIList_SJIS
X#define GUI_FONTTYPE_PROP_SJIS    GUIPROP_DispChar,             	GUIPROP_GetCharDistX,         	GUIPROP_GetFontInfo,          	GUIPROP_IsInFont,               &GUI_ENC_APIList_SJIS
N
N/* PROPAA: Proportional, antialiased fonts */
NDECLARE_FONT(PROPAA);
Xvoid GUIPROPAA_DispChar (unsigned short c); int GUIPROPAA_GetCharDistX(unsigned short c); void GUIPROPAA_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROPAA_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_PROPAA       \
N  GUIPROPAA_DispChar,             \
N	GUIPROPAA_GetCharDistX,         \
N	GUIPROPAA_GetFontInfo,          \
N	GUIPROPAA_IsInFont,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROPAA         GUIPROPAA_DispChar,             	GUIPROPAA_GetCharDistX,         	GUIPROPAA_GetFontInfo,          	GUIPROPAA_IsInFont,               (tGUI_ENC_APIList*)0
N
N/* PROPAA: Proportional, antialiased fonts, 2bpp */
NDECLARE_FONT(PROP_AA2);
Xvoid GUIPROP_AA2_DispChar (unsigned short c); int GUIPROP_AA2_GetCharDistX(unsigned short c); void GUIPROP_AA2_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA2_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_PROP_AA2       \
N  GUIPROP_AA2_DispChar,             \
N	GUIPROP_AA2_GetCharDistX,         \
N	GUIPROP_AA2_GetFontInfo,          \
N	GUIPROP_AA2_IsInFont,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_AA2         GUIPROP_AA2_DispChar,             	GUIPROP_AA2_GetCharDistX,         	GUIPROP_AA2_GetFontInfo,          	GUIPROP_AA2_IsInFont,               (tGUI_ENC_APIList*)0
N
N/* PROPAA: Proportional, antialiased fonts, 2bpp, SJIS encoding */
NDECLARE_FONT(PROP_AA2);
Xvoid GUIPROP_AA2_DispChar (unsigned short c); int GUIPROP_AA2_GetCharDistX(unsigned short c); void GUIPROP_AA2_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA2_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_PROP_AA2_SJIS  \
N  GUIPROP_AA2_DispChar,             \
N	GUIPROP_AA2_GetCharDistX,         \
N	GUIPROP_AA2_GetFontInfo,          \
N	GUIPROP_AA2_IsInFont,             \
N  GUI_ENCODE_SJIS
X#define GUI_FONTTYPE_PROP_AA2_SJIS    GUIPROP_AA2_DispChar,             	GUIPROP_AA2_GetCharDistX,         	GUIPROP_AA2_GetFontInfo,          	GUIPROP_AA2_IsInFont,               GUI_ENCODE_SJIS
N
N/* PROPAA: Proportional, antialiased fonts, 4bpp */
NDECLARE_FONT(PROP_AA4);
Xvoid GUIPROP_AA4_DispChar (unsigned short c); int GUIPROP_AA4_GetCharDistX(unsigned short c); void GUIPROP_AA4_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA4_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_PROP_AA4       \
N  GUIPROP_AA4_DispChar,             \
N	GUIPROP_AA4_GetCharDistX,         \
N	GUIPROP_AA4_GetFontInfo,          \
N	GUIPROP_AA4_IsInFont,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_AA4         GUIPROP_AA4_DispChar,             	GUIPROP_AA4_GetCharDistX,         	GUIPROP_AA4_GetFontInfo,          	GUIPROP_AA4_IsInFont,               (tGUI_ENC_APIList*)0
N
N/* PROPAA: Proportional, antialiased fonts, 4bpp, SJIS encoding */
NDECLARE_FONT(PROP_AA4);
Xvoid GUIPROP_AA4_DispChar (unsigned short c); int GUIPROP_AA4_GetCharDistX(unsigned short c); void GUIPROP_AA4_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA4_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_PROP_AA4_SJIS  \
N  GUIPROP_AA4_DispChar,             \
N	GUIPROP_AA4_GetCharDistX,         \
N	GUIPROP_AA4_GetFontInfo,          \
N	GUIPROP_AA4_IsInFont,             \
N  GUI_ENCODE_SJIS
X#define GUI_FONTTYPE_PROP_AA4_SJIS    GUIPROP_AA4_DispChar,             	GUIPROP_AA4_GetCharDistX,         	GUIPROP_AA4_GetFontInfo,          	GUIPROP_AA4_IsInFont,               GUI_ENCODE_SJIS
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
Nstruct GUI_FONT {
N  GUI_DISPCHAR*     pfDispChar; 
N  GUI_GETCHARDISTX* pfGetCharDistX; 
N  GUI_GETFONTINFO*  pfGetFontInfo; 
N  GUI_ISINFONT*     pfIsInFont;
N  const tGUI_ENC_APIList* pafEncode;
N  U8 YSize;
X  unsigned char YSize;
N  U8 YDist;
X  unsigned char YDist;
N  U8 XMag;
X  unsigned char XMag;
N  U8 YMag;
X  unsigned char YMag;
N  union {
N    const void          GUI_UNI_PTR * pFontData;
X    const void           * pFontData;
N    const GUI_FONT_MONO GUI_UNI_PTR * pMono;
X    const GUI_FONT_MONO  * pMono;
N    const GUI_FONT_PROP GUI_UNI_PTR * pProp;
X    const GUI_FONT_PROP  * pProp;
N  } p;
N  U8 Baseline;
X  unsigned char Baseline;
N  U8 LHeight;     /* height of a small lower case character (a,x) */
X  unsigned char LHeight;      
N  U8 CHeight;     /* height of a small upper case character (A,X) */
X  unsigned char CHeight;      
N};
N
N/*********************************************************************
N*
N*       Position independent font structures
N*/
Ntypedef struct {
N  U32 ID;           /* Font file ID */
X  unsigned long ID;            
N  U16 YSize;        /* Height of font */
X  unsigned short YSize;         
N  U16 YDist;        /* Space of font Y */
X  unsigned short YDist;         
N  U16 Baseline;     /* Index of baseline */
X  unsigned short Baseline;      
N  U16 LHeight;      /* Height of a small lower case character (a) */
X  unsigned short LHeight;       
N  U16 CHeight;      /* Height of a upper case character (A) */
X  unsigned short CHeight;       
N  U16 NumAreas;     /* Number of character areas */
X  unsigned short NumAreas;      
N} GUI_SI_FONT;
N
Ntypedef struct {
N  U16 First;        /* Index of first character */
X  unsigned short First;         
N  U16 Last;         /* Index of last character */
X  unsigned short Last;          
N} GUI_SIF_CHAR_AREA;
N
Ntypedef struct {
N  U16 XSize;        /* Size of bitmap data in X */
X  unsigned short XSize;         
N  U16 XDist;        /* Number of pixels for increment cursor in X */
X  unsigned short XDist;         
N  U16 BytesPerLine; /* Number of bytes per line */
X  unsigned short BytesPerLine;  
N  U16 Dummy;
X  unsigned short Dummy;
N  U32 OffData;      /* Offset of pixel data */
X  unsigned long OffData;       
N} GUI_SIF_CHARINFO;
N
Ntypedef struct tGUI_SIF_APIList_struct {
N  GUI_DISPCHAR     * pDispChar;
N  GUI_GETCHARDISTX * pGetCharDistX;
N  GUI_GETFONTINFO  * pGetFontInfo;
N  GUI_ISINFONT     * pIsInFont;
N} tGUI_SIF_APIList;
N
N#define GUI_SIF_TYPE          tGUI_SIF_APIList
N#define GUI_SIF_TYPE_PROP     &GUI_SIF_APIList_Prop
N#define GUI_SIF_TYPE_PROP_AA2 &GUI_SIF_APIList_Prop_AA2
N#define GUI_SIF_TYPE_PROP_AA4 &GUI_SIF_APIList_Prop_AA4
N
N/*
N      *********************************
N      *                               *
N      *      Typedefs                 *
N      *                               *
N      *********************************
N*/
N
N#ifndef     GUI_HMEM
N  #if GUI_MAXBLOCKS < 32768
X  #if (2 + (1024*30) / 32) < 32768
N    #define     GUI_HMEM        I16P
N  #else
S    #define     GUI_HMEM        I32
N  #endif
N#endif
N#define     GUI_HMEM_NULL     (0)
Ntypedef     GUI_HMEM      GUI_HWIN;
Xtypedef     signed short      GUI_HWIN;
N#endif  /* GUITYPE_H_INCLUDED */
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 26 "..\GUI\WM\WM.h" 2
N#include "WM_GUI.h"       /* Some functions needed by GUI routines */
L 1 "..\GUI\WM\WM_GUI.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : WM_GUI.h
NPurpose     : Windows manager include for low level GUI routines
N----------------------------------------------------------------------
N*/
N
N#ifndef WM_GUI_H            /* Make sure we only include it once */
N#define WM_GUI_H
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
Nint       WM__InitIVRSearch(const GUI_RECT* pMaxRect);
Nint       WM__GetNextIVR   (void);
Nint       WM__GetOrgX_AA(void);
Nint       WM__GetOrgY_AA(void);
N
N#define WM_ITERATE_START(pRect)                   \
N  {                                               \
N    if (WM__InitIVRSearch(pRect))                 \
N      do {
X#define WM_ITERATE_START(pRect)                     {                                                   if (WM__InitIVRSearch(pRect))                       do {
N
N#define WM_ITERATE_END()                          \
N    } while (WM__GetNextIVR());                   \
N  }
X#define WM_ITERATE_END()                              } while (WM__GetNextIVR());                     }
N
N#define WM_ADDORGX(x)    x += GUI_Context.xOff
N#define WM_ADDORGY(y)    y += GUI_Context.yOff
N#define WM_ADDORG(x0,y0) WM_ADDORGX(x0); WM_ADDORGY(y0)
N#define WM_ADDORGX_AA(x)    x += WM__GetOrgX_AA()
N#define WM_ADDORGY_AA(y)    y += WM__GetOrgY_AA()
N#define WM_ADDORG_AA(x0,y0) WM_ADDORGX_AA(x0); WM_ADDORGY_AA(y0)
N#define WM_SUBORGX(x)    x -= GUI_Context.xOff
N#define WM_SUBORGY(y)    y -= GUI_Context.yOff
N#define WM_SUBORG(x0,y0) WM_SUBORGX(x0); WM_SUBORGY(y0)
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N
N#endif   /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 27 "..\GUI\WM\WM.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/* Support for transparency. Switching it off makes Wm smaller and faster */
N#ifndef WM_SUPPORT_TRANSPARENCY
N  #define WM_SUPPORT_TRANSPARENCY 1 /* Should be defined outside of GUI_WINSUPPORT because of "#if GUI_WINSUPPORT && WM_SUPPORT_TRANSPARENCY" in some files */
N#endif
N
N/* This is for tests only. It will fill the invalid area of a window.
N   Can be used for debugging. */
N#ifndef WM_SUPPORT_DIAG
N  #ifdef WIN32   /* In simulation */
S    #define WM_SUPPORT_DIAG GUI_WINSUPPORT
N  #else
N    #define WM_SUPPORT_DIAG 0
N  #endif
N#endif
N
N/* Make sure we actually have configured windows. If we have not,
N  there is no point for a windows manager and it will therefor not
N  generate any code !
N*/
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*              Config defaults
N*
N**********************************************************************
N*/
N
N#ifndef WM_ASSERT
N  #define WM_ASSERT(expr) GUI_DEBUG_ASSERT(expr)
N#endif
N
N#ifndef WM_SUPPORT_TOUCH
N  #define WM_SUPPORT_TOUCH        GUI_SUPPORT_TOUCH
N#endif
N
N#ifndef WM_SUPPORT_OBSTRUCT
N  #define WM_SUPPORT_OBSTRUCT 1
N#endif
N
N/* Allow older API calls */
N#ifndef WM_COMPATIBLE_MODE
N  #define WM_COMPATIBLE_MODE 1
N#endif
N
N/* Send a message if visibility of a window has changed */
N#ifndef WM_SUPPORT_NOTIFY_VIS_CHANGED
N  #define WM_SUPPORT_NOTIFY_VIS_CHANGED 0
N#endif
N
N
N/*
N      *************************************************************
N      *                                                           *
N      *               Configuration check                         *
N      *                                                           *
N      *************************************************************
N*/
N
N/*
N      *************************************************************
N      *                                                           *
N      *               Locking macros                              *
N      *                                                           *
N      *************************************************************
N  For performance reasons, the windows manager uses the same locking mechanisms
N  as the GUI layer. The advantage is that wiht a single call to GUI_LOCK both
N  the graphic level and the WM level are covered.
N*/
N
N#define WM_LOCK()   GUI_LOCK()
N#define WM_UNLOCK() GUI_UNLOCK()
N
N/************************************************************
N*
N*          Data types
N*
N*************************************************************
N*/
N
Ntypedef struct {
N  int Key, PressedCnt;
N} WM_KEY_INFO;
N
Ntypedef struct {
N  int NumItems, v, PageSize;
N} WM_SCROLL_STATE;
N
Ntypedef struct {
N  int Done;
N  int ReturnValue;
N} WM_DIALOG_STATUS;
N
Ntypedef struct {
N  int x,y;
N  U8  State;
X  unsigned char  State;
N  U8  StatePrev;
X  unsigned char  StatePrev;
N} WM_PID_STATE_CHANGED_INFO;
N
N
N
N/*********************************************************************
N*
N*               Messages Ids
N
NThe following is the list of windows messages.
N*/
N
N
N#define WM_CREATE                   0x0001  /* The first message received, right after client has actually been created */
N#define WM_MOVE                     0x0003  /* window has been moved (Same as WIN32) */
N
N#define WM_SIZE                     0x0005  /* Is sent to a window after its size has changed (Same as WIN32, do not change !) */
N
N#define WM_DELETE                   11      /* Delete (Destroy) command: This tells the client to free its data strutures since the window
N                                               it is associates with no longer exists.*/
N#define WM_TOUCH                    12      /* Touch screen message */
N#define WM_TOUCH_CHILD              13      /* Touch screen message to ancestors */
N#define WM_KEY                      14      /* Key has been pressed */
N
N#define WM_PAINT                    0x000F  /* Repaint window (because content is (partially) invalid */
N
N#if GUI_SUPPORT_MOUSE
X#if 0
S#define WM_MOUSEOVER                16      /* Mouse has moved, no key pressed */
S#define WM_MOUSEOVER_END            18      /* Mouse has moved, no key pressed */
N#endif
N
N#define WM_PID_STATE_CHANGED        17      /* Pointer input device state has changed */
N
N#define WM_GET_INSIDE_RECT          20      /* get inside rectangle: client rectangle minus pixels lost to effect */
N#define WM_GET_ID                   21      /* Get id of widget */
N#define WM_SET_ID                   22      /* Set id of widget */
N#define WM_GET_CLIENT_WINDOW        23      /* Get window handle of client window. Default is the same as window */
N#define WM_CAPTURE_RELEASED         24      /* Let window know that mouse capture is over */
N
N#define WM_INIT_DIALOG              29      /* Inform dialog that it is ready for init */
N
N#define WM_SET_FOCUS                30      /* Inform window that it has gotten or lost the focus */
N#define WM_GET_ACCEPT_FOCUS         31      /* Find out if window can accept the focus */
N#define WM_NOTIFY_CHILD_HAS_FOCUS   32      /* Sent to parent when child receives / loses focus */
N
N#define WM_NOTIFY_OWNER_KEY         33      /* Some widgets (e.g. listbox) notify owner when receiving key messages */
N
N#define WM_GET_BKCOLOR              34      /* Return back ground color (only frame window and similar) */
N#define WM_GET_SCROLL_STATE         35      /* Query state of scroll bar */
N
N#define WM_SET_SCROLL_STATE         36      /* Set scroll info ... only effective for scrollbars */
N
N#define WM_NOTIFY_CLIENTCHANGE      37      /* Client area may have changed */
N#define WM_NOTIFY_PARENT            38      /* Notify parent. Information is detailed as notification code */
N#define WM_NOTIFY_PARENT_REFLECTION 39      /* Notify parent reflection. 
N                                               Sometimes send back as a result of the WM_NOTIFY_PARENT message
N                                               to let child react on behalf of its parent.
N                                               Information is detailed as notification code */
N#define WM_NOTIFY_ENABLE            40      /* Enable or disable widget */
N#define WM_NOTIFY_VIS_CHANGED       41      /* Visibility of a window has or may have changed */
N
N#define WM_HANDLE_DIALOG_STATUS     42      /* Set or get dialog status */
N#define WM_GET_RADIOGROUP           43      /* Send to all siblings and children of a radio control when
N                                               selection changed */
N#define WM_MENU                     44      /* Send to owner window of menu widget */
N#define WM_SCREENSIZE_CHANGED       45      /* Send to all windows when size of screen has changed */
N
N#define WM_TIMER                    0x0113  /* Timer has expired              (Keep the same as WIN32) */
N#define WM_WIDGET                   0x0300  /* 256 messages reserved for Widget messages */
N#define WM_USER                     0x0400  /* Reserved for user messages ... (Keep the same as WIN32) */
N
N
N/*********************************************************************
N*
N*               Notification codes
N*
N* The following is the list of notification codes send
N* with the WM_NOTIFY_PARENT message
N*/
N#define WM_NOTIFICATION_CLICKED             1
N#define WM_NOTIFICATION_RELEASED            2
N#define WM_NOTIFICATION_MOVED_OUT           3
N#define WM_NOTIFICATION_SEL_CHANGED         4
N#define WM_NOTIFICATION_VALUE_CHANGED       5
N#define WM_NOTIFICATION_SCROLLBAR_ADDED     6      /* Scroller added */
N#define WM_NOTIFICATION_CHILD_DELETED       7      /* Inform window that child is about to be deleted */
N#define WM_NOTIFICATION_GOT_FOCUS           8
N#define WM_NOTIFICATION_LOST_FOCUS          9
N#define WM_NOTIFICATION_SCROLL_CHANGED     10
N
N#define WM_NOTIFICATION_WIDGET             11      /* Space for widget defined notifications */
N#define WM_NOTIFICATION_USER               16      /* Space for  application (user) defined notifications */
N/*********************************************************************
N*
N*       Memory management
N*/
N
N#define WM_HWIN        GUI_HWIN
N#define WM_HWIN_NULL   GUI_HMEM_NULL
N#define WM_HMEM        GUI_HMEM
N#define WM_HMEM_NULL   GUI_HMEM_NULL
N
N/*********************************************************************
N*
N*       Window defines
N*/
N#define WM_HBKWIN      WM_GetDesktopWindow()                /* Handle of background window */
N#define WM_UNATTACHED  ((WM_HMEM)-1)                        /* Do not attach to a window */
N
N
N/*********************************************************************
N*
N*           Window create flags.
N* These flags can be passed to the create window
N* function as flag-parameter. The flags are combinable using the
N* binary or operator.
N*/
N
N#define WM_CF_HASTRANS         (1<<0)  /* Has transparency. Needs to be defined for windows which do not fill the entire
N                                          section of their (client) rectangle. */
N#define WM_CF_HIDE             (0<<1)  /* Hide window after creation (default !) */
N#define WM_CF_SHOW             (1<<1)  /* Show window after creation */
N#define WM_CF_MEMDEV           (1<<2)  /* Use memory device for redraws */
N#define WM_CF_STAYONTOP        (1<<3)  /* Stay on top */
N#define WM_CF_DISABLED         (1<<4)  /* Disabled: Does not receive PID (mouse & touch) input */
N/* Create only flags ... Not available as status flags */
N#define WM_CF_ACTIVATE         (1<<5)  /* If automatic activation upon creation of window is desired */
N#define WM_CF_FGND             (0<<6)  /* Put window in foreground after creation (default !) */
N#define WM_CF_BGND             (1<<6)  /* Put window in background after creation */
N
N/* Anchor flags */
N#define WM_CF_ANCHOR_RIGHT     (1<<7)  /* Right anchor ... If parent is resized, distance to right will remain const (left is default) */
N#define WM_CF_ANCHOR_BOTTOM    (1<<8)  /* Bottom anchor ... If parent is resized, distance to bottom will remain const (top is default) */
N#define WM_CF_ANCHOR_LEFT      (1<<9)  /* Left anchor ... If parent is resized, distance to left will remain const (left is default) */
N#define WM_CF_ANCHOR_TOP       (1<<10) /* Top anchor ... If parent is resized, distance to top will remain const (top is default) */
N
N#define WM_CF_CONST_OUTLINE    (1<<11) /* Constant outline. This is relevant for transparent windows only. If a window is transparent
N                                       and does not have a constant outline, its background is invalided instead of the window itself.
N                                       This causes add. computation time when redrawing. */
N#define WM_CF_LATE_CLIP        (1<<12)
N#define WM_CF_MEMDEV_ON_REDRAW (1<<13)
N#define WM_CF_RESERVED3        (1<<14)
N#define WM_CF_RESERVED4        (1<<15)
N
N/*********************************************************************
N*
N*           Window manager types
N*/
N
Ntypedef struct WM_Obj     WM_Obj;
Ntypedef struct WM_OBJ_X   WM_OBJ_X;
Ntypedef struct WM_MESSAGE WM_MESSAGE;
N
Ntypedef void WM_CALLBACK( WM_MESSAGE* pMsg);
N
Nstruct WM_MESSAGE {
N  int MsgId;            /* type of message */
N  WM_HWIN hWin;         /* Destination window */
X  GUI_HWIN hWin;          
N  WM_HWIN hWinSrc;      /* Source window  */
X  GUI_HWIN hWinSrc;       
N  union {
N    const void* p;            /* Some messages need more info ... Pointer is declared "const" because some systems (M16C) have 4 byte const, byte 2 byte default ptrs */
N    int v;
N    GUI_COLOR Color;
N  } Data;
N};
N
Nstruct WM_Obj {
N  GUI_RECT Rect;        /* Outer dimensions of window */
N  GUI_RECT InvalidRect; /* Invalid rectangle */
N  WM_CALLBACK* cb;      /* Ptr to notification callback */
N  WM_HWIN hNextLin;     /* Next window in linear list */
X  GUI_HWIN hNextLin;      
N  WM_HWIN hParent;
X  GUI_HWIN hParent;
N  WM_HWIN hFirstChild;
X  GUI_HWIN hFirstChild;
N  WM_HWIN hNext;
X  GUI_HWIN hNext;
N  U16 Status;	          /* Some status flags */
X  unsigned short Status;	           
N};
N
Nstruct WM_OBJ_X {       /* For debugging only if a pointer-based memory management is used */
N  int    Dummy;
N  struct WM_Obj Win;
N};
N
Ntypedef void WM_tfPollPID(void);
Ntypedef void WM_tfForEach(WM_HWIN hWin, void * pData);
Xtypedef void WM_tfForEach(GUI_HWIN hWin, void * pData);
N
N/*
N**********************************************************************
N*
N*              General control routines
N*
N**********************************************************************
N*/
N
N
Nvoid WM_Activate  (void);
Nvoid WM_Deactivate(void);
Nvoid WM_Init      (void);
Nint  WM_Exec      (void);    /* Execute all jobs ... Return 0 if nothing was done. */
Nint  WM_Exec1     (void);    /* Execute one job  ... Return 0 if nothing was done. */
NU16  WM_SetCreateFlags(U16 Flags);
Xunsigned short  WM_SetCreateFlags(unsigned short Flags);
NWM_tfPollPID* WM_SetpfPollPID(WM_tfPollPID* pf);
Nvoid WM_SetCapture(WM_HWIN hObj, int AutoRelease);
Xvoid WM_SetCapture(GUI_HWIN hObj, int AutoRelease);
Nvoid WM_SetCaptureMove(WM_HWIN hWin, const GUI_PID_STATE* pState, int MinVisibility, int LimitTop); /* Not yet documented */
Xvoid WM_SetCaptureMove(GUI_HWIN hWin, const GUI_PID_STATE* pState, int MinVisibility, int LimitTop);  
Nvoid WM_ReleaseCapture(void);
N
N/*********************************************************************
N*
N*           Window manager interface
N*
N**********************************************************************
N*/
N
Nvoid    WM_AttachWindow              (WM_HWIN hWin, WM_HWIN hParent);
Xvoid    WM_AttachWindow              (GUI_HWIN hWin, GUI_HWIN hParent);
Nvoid    WM_AttachWindowAt            (WM_HWIN hWin, WM_HWIN hParent, int x, int y);
Xvoid    WM_AttachWindowAt            (GUI_HWIN hWin, GUI_HWIN hParent, int x, int y);
Nint     WM_CheckScrollPos            (WM_SCROLL_STATE* pScrollState, int Pos, int LowerDist, int UpperDist); /* not to be documented (may change in future version) */
Nvoid    WM_ClrHasTrans               (WM_HWIN hWin);
Xvoid    WM_ClrHasTrans               (GUI_HWIN hWin);
NWM_HWIN WM_CreateWindow              (int x0, int y0, int xSize, int ySize, U16 Style, WM_CALLBACK* cb, int NumExtraBytes);
XGUI_HWIN WM_CreateWindow              (int x0, int y0, int xSize, int ySize, unsigned short Style, WM_CALLBACK* cb, int NumExtraBytes);
NWM_HWIN WM_CreateWindowAsChild       (int x0, int y0, int xSize, int ySize, WM_HWIN hWinParent, U16 Style, WM_CALLBACK* cb, int NumExtraBytes);
XGUI_HWIN WM_CreateWindowAsChild       (int x0, int y0, int xSize, int ySize, GUI_HWIN hWinParent, unsigned short Style, WM_CALLBACK* cb, int NumExtraBytes);
Nvoid    WM_DeleteWindow              (WM_HWIN hWin);
Xvoid    WM_DeleteWindow              (GUI_HWIN hWin);
Nvoid    WM_DetachWindow              (WM_HWIN hWin);
Xvoid    WM_DetachWindow              (GUI_HWIN hWin);
Nint     WM_GetHasTrans               (WM_HWIN hWin);
Xint     WM_GetHasTrans               (GUI_HWIN hWin);
NWM_HWIN WM_GetFocussedWindow         (void);
XGUI_HWIN WM_GetFocussedWindow         (void);
Nvoid    WM_HideWindow                (WM_HWIN hWin);
Xvoid    WM_HideWindow                (GUI_HWIN hWin);
Nvoid    WM_InvalidateArea            (const GUI_RECT* pRect);
Nvoid    WM_InvalidateRect            (WM_HWIN hWin, const GUI_RECT*pRect);
Xvoid    WM_InvalidateRect            (GUI_HWIN hWin, const GUI_RECT*pRect);
Nvoid    WM_InvalidateWindow          (WM_HWIN hWin);
Xvoid    WM_InvalidateWindow          (GUI_HWIN hWin);
Nvoid    WM_InvalidateWindowAndDescsEx(WM_HWIN hWin, const GUI_RECT * pInvalidRect);
Xvoid    WM_InvalidateWindowAndDescsEx(GUI_HWIN hWin, const GUI_RECT * pInvalidRect);
Nvoid    WM_InvalidateWindowAndDescs  (WM_HWIN hWin);    /* not to be documented (may change in future version) */
Xvoid    WM_InvalidateWindowAndDescs  (GUI_HWIN hWin);     
Nint     WM_IsEnabled                 (WM_HWIN hObj);
Xint     WM_IsEnabled                 (GUI_HWIN hObj);
Nint     WM_IsFocussable              (WM_HWIN hWin);
Xint     WM_IsFocussable              (GUI_HWIN hWin);
Nint     WM_IsVisible                 (WM_HWIN hWin);
Xint     WM_IsVisible                 (GUI_HWIN hWin);
Nint     WM_IsWindow                  (WM_HWIN hWin);    /* Check validity */
Xint     WM_IsWindow                  (GUI_HWIN hWin);     
Nchar    WM_IsCompletelyVisible       (WM_HWIN hWin);    /* Is the window completely visible ? */
Xchar    WM_IsCompletelyVisible       (GUI_HWIN hWin);     
Nvoid    WM_SetHasTrans               (WM_HWIN hWin);
Xvoid    WM_SetHasTrans               (GUI_HWIN hWin);
Nvoid    WM_SetId                     (WM_HWIN hObj, int Id);
Xvoid    WM_SetId                     (GUI_HWIN hObj, int Id);
Nvoid    WM_SetTransState             (WM_HWIN hWin, unsigned State);
Xvoid    WM_SetTransState             (GUI_HWIN hWin, unsigned State);
Nvoid    WM_ShowWindow                (WM_HWIN hWin);
Xvoid    WM_ShowWindow                (GUI_HWIN hWin);
Nvoid    WM_ValidateRect              (WM_HWIN hWin, const GUI_RECT*pRect);
Xvoid    WM_ValidateRect              (GUI_HWIN hWin, const GUI_RECT*pRect);
Nvoid    WM_ValidateWindow            (WM_HWIN hWin);
Xvoid    WM_ValidateWindow            (GUI_HWIN hWin);
Nint     WM_GetInvalidRect            (WM_HWIN hWin, GUI_RECT * pRect);
Xint     WM_GetInvalidRect            (GUI_HWIN hWin, GUI_RECT * pRect);
Nvoid    WM_SetStayOnTop              (WM_HWIN hWin, int OnOff);
Xvoid    WM_SetStayOnTop              (GUI_HWIN hWin, int OnOff);
Nint     WM_GetStayOnTop              (WM_HWIN hWin);
Xint     WM_GetStayOnTop              (GUI_HWIN hWin);
Nvoid    WM_SetAnchor                 (WM_HWIN hWin, U16 AnchorFlags);
Xvoid    WM_SetAnchor                 (GUI_HWIN hWin, unsigned short AnchorFlags);
N
N/* Move/resize windows */
Nvoid WM_MoveWindow                (WM_HWIN hWin, int dx, int dy);
Xvoid WM_MoveWindow                (GUI_HWIN hWin, int dx, int dy);
Nvoid WM_ResizeWindow              (WM_HWIN hWin, int dx, int dy);
Xvoid WM_ResizeWindow              (GUI_HWIN hWin, int dx, int dy);
Nvoid WM_MoveTo                    (WM_HWIN hWin, int x, int y);
Xvoid WM_MoveTo                    (GUI_HWIN hWin, int x, int y);
Nvoid WM_MoveChildTo               (WM_HWIN hWin, int x, int y);
Xvoid WM_MoveChildTo               (GUI_HWIN hWin, int x, int y);
Nvoid WM_SetSize                   (WM_HWIN hWin, int XSize, int YSize);
Xvoid WM_SetSize                   (GUI_HWIN hWin, int XSize, int YSize);
Nvoid WM_SetWindowPos              (WM_HWIN hWin, int xPos, int yPos, int xSize, int ySize);
Xvoid WM_SetWindowPos              (GUI_HWIN hWin, int xPos, int yPos, int xSize, int ySize);
Nint  WM_SetXSize                  (WM_HWIN hWin, int xSize);
Xint  WM_SetXSize                  (GUI_HWIN hWin, int xSize);
Nint  WM_SetYSize                  (WM_HWIN hWin, int ySize);
Xint  WM_SetYSize                  (GUI_HWIN hWin, int ySize);
Nint  WM_CreateTimer               (WM_HWIN hWin, int UserID, int Period, int Mode); /* not to be documented (may change in future version) */
Xint  WM_CreateTimer               (GUI_HWIN hWin, int UserID, int Period, int Mode);  
Nvoid WM_DeleteTimer               (WM_HWIN hWin, int UserId); /* not to be documented (may change in future version) */
Xvoid WM_DeleteTimer               (GUI_HWIN hWin, int UserId);  
Nint  WM_SetScrollbarH             (WM_HWIN hWin, int OnOff); /* not to be documented (may change in future version) */
Xint  WM_SetScrollbarH             (GUI_HWIN hWin, int OnOff);  
Nint  WM_SetScrollbarV             (WM_HWIN hWin, int OnOff); /* not to be documented (may change in future version) */
Xint  WM_SetScrollbarV             (GUI_HWIN hWin, int OnOff);  
N
N
N/* Diagnostics */
Nint WM_GetNumWindows(void);
Nint WM_GetNumInvalidWindows(void);
N
N/* Scroll state related functions */
Nvoid WM_CheckScrollBounds(WM_SCROLL_STATE* pScrollState); /* not to be documented (may change in future version) */
Nint  WM_GetScrollPosH    (WM_HWIN hWin);
Xint  WM_GetScrollPosH    (GUI_HWIN hWin);
Nint  WM_GetScrollPosV    (WM_HWIN hWin);
Xint  WM_GetScrollPosV    (GUI_HWIN hWin);
Nvoid WM_SetScrollPosH    (WM_HWIN hWin, unsigned ScrollPos);
Xvoid WM_SetScrollPosH    (GUI_HWIN hWin, unsigned ScrollPos);
Nvoid WM_SetScrollPosV    (WM_HWIN hWin, unsigned ScrollPos);
Xvoid WM_SetScrollPosV    (GUI_HWIN hWin, unsigned ScrollPos);
Nint  WM_SetScrollValue   (WM_SCROLL_STATE* pScrollState, int v); /* not to be documented (may change in future version) */
N
N
N/* Get / Set (new) callback function */
NWM_CALLBACK * WM_SetCallback(WM_HWIN hWin, WM_CALLBACK * cb);
XWM_CALLBACK * WM_SetCallback(GUI_HWIN hWin, WM_CALLBACK * cb);
NWM_CALLBACK * WM_GetCallback(WM_HWIN hWin);
XWM_CALLBACK * WM_GetCallback(GUI_HWIN hWin);
N
N/* Get size/origin of a window */
Nvoid WM_GetClientRect             (GUI_RECT* pRect);
Nvoid WM_GetClientRectEx           (WM_HWIN hWin, GUI_RECT* pRect);
Xvoid WM_GetClientRectEx           (GUI_HWIN hWin, GUI_RECT* pRect);
Nvoid WM_GetInsideRect             (GUI_RECT* pRect);
Nvoid WM_GetInsideRectEx           (WM_HWIN hWin, GUI_RECT* pRect);
Xvoid WM_GetInsideRectEx           (GUI_HWIN hWin, GUI_RECT* pRect);
Nvoid WM_GetInsideRectExScrollbar  (WM_HWIN hWin, GUI_RECT* pRect); /* not to be documented (may change in future version) */
Xvoid WM_GetInsideRectExScrollbar  (GUI_HWIN hWin, GUI_RECT* pRect);  
Nvoid WM_GetWindowRect             (GUI_RECT* pRect);
Nvoid WM_GetWindowRectEx           (WM_HWIN hWin, GUI_RECT* pRect);
Xvoid WM_GetWindowRectEx           (GUI_HWIN hWin, GUI_RECT* pRect);
Nint  WM_GetOrgX                   (void);
Nint  WM_GetOrgY                   (void);
Nint  WM_GetWindowOrgX             (WM_HWIN hWin);
Xint  WM_GetWindowOrgX             (GUI_HWIN hWin);
Nint  WM_GetWindowOrgY             (WM_HWIN hWin);
Xint  WM_GetWindowOrgY             (GUI_HWIN hWin);
Nint  WM_GetWindowSizeX            (WM_HWIN hWin);
Xint  WM_GetWindowSizeX            (GUI_HWIN hWin);
Nint  WM_GetWindowSizeY            (WM_HWIN hWin);
Xint  WM_GetWindowSizeY            (GUI_HWIN hWin);
NWM_HWIN WM_GetFirstChild          (WM_HWIN hWin);
XGUI_HWIN WM_GetFirstChild          (GUI_HWIN hWin);
NWM_HWIN WM_GetNextSibling         (WM_HWIN hWin);
XGUI_HWIN WM_GetNextSibling         (GUI_HWIN hWin);
NWM_HWIN WM_GetParent              (WM_HWIN hWin);
XGUI_HWIN WM_GetParent              (GUI_HWIN hWin);
NWM_HWIN WM_GetPrevSibling         (WM_HWIN hWin);
XGUI_HWIN WM_GetPrevSibling         (GUI_HWIN hWin);
Nint     WM_GetId                  (WM_HWIN hWin);
Xint     WM_GetId                  (GUI_HWIN hWin);
NWM_HWIN WM_GetScrollbarV          (WM_HWIN hWin);
XGUI_HWIN WM_GetScrollbarV          (GUI_HWIN hWin);
NWM_HWIN WM_GetScrollbarH          (WM_HWIN hWin);
XGUI_HWIN WM_GetScrollbarH          (GUI_HWIN hWin);
NWM_HWIN WM_GetScrollPartner       (WM_HWIN hWin);
XGUI_HWIN WM_GetScrollPartner       (GUI_HWIN hWin);
NWM_HWIN WM_GetClientWindow        (WM_HWIN hObj);
XGUI_HWIN WM_GetClientWindow        (GUI_HWIN hObj);
NGUI_COLOR WM_GetBkColor           (WM_HWIN hObj);
XGUI_COLOR WM_GetBkColor           (GUI_HWIN hObj);
N
N/* Change Z-Order of windows */
Nvoid WM_BringToBottom(WM_HWIN hWin);
Xvoid WM_BringToBottom(GUI_HWIN hWin);
Nvoid WM_BringToTop(WM_HWIN hWin);
Xvoid WM_BringToTop(GUI_HWIN hWin);
N
NGUI_COLOR WM_SetDesktopColor(GUI_COLOR Color);
NGUI_COLOR WM_SetDesktopColorEx(GUI_COLOR Color, unsigned int LayerIndex);
Nvoid WM_SetDesktopColors(GUI_COLOR Color);
N
N/* Select window used for drawing operations */
NWM_HWIN WM_SelectWindow           (WM_HWIN  hWin);
XGUI_HWIN WM_SelectWindow           (GUI_HWIN  hWin);
NWM_HWIN WM_GetActiveWindow        (void);
XGUI_HWIN WM_GetActiveWindow        (void);
Nvoid    WM_Paint                  (WM_HWIN hObj);
Xvoid    WM_Paint                  (GUI_HWIN hObj);
Nvoid    WM_Update                 (WM_HWIN hWin);
Xvoid    WM_Update                 (GUI_HWIN hWin);
Nvoid    WM_PaintWindowAndDescs    (WM_HWIN hWin);
Xvoid    WM_PaintWindowAndDescs    (GUI_HWIN hWin);
Nvoid    WM_UpdateWindowAndDescs   (WM_HWIN hWin);
Xvoid    WM_UpdateWindowAndDescs   (GUI_HWIN hWin);
N
N/* Get foreground/background windows */
NWM_HWIN WM_GetDesktopWindow    (void);
XGUI_HWIN WM_GetDesktopWindow    (void);
NWM_HWIN WM_GetDesktopWindowEx  (unsigned int LayerIndex);
XGUI_HWIN WM_GetDesktopWindowEx  (unsigned int LayerIndex);
N
N/* Reduce clipping area of a window */
Nconst GUI_RECT* WM_SetUserClipRect(const GUI_RECT* pRect);
Nvoid            WM_SetDefault     (void);
N
N/* Use of memory devices */
Nvoid WM_EnableMemdev              (WM_HWIN hWin);
Xvoid WM_EnableMemdev              (GUI_HWIN hWin);
Nvoid WM_DisableMemdev             (WM_HWIN hWin);
Xvoid WM_DisableMemdev             (GUI_HWIN hWin);
N
Nint WM_OnKey(int Key, int Pressed);
Nvoid WM_MakeModal(WM_HWIN hWin);
Xvoid WM_MakeModal(GUI_HWIN hWin);
N
N
N/******************************************************************
N*
N*           Message related funcions
N*
N*******************************************************************
N  Please note that some of these functions do not yet show up in the
N  documentation, as they should not be required by application program.
N*/
N
Nvoid      WM_NotifyParent         (WM_HWIN hWin, int Notification);
Xvoid      WM_NotifyParent         (GUI_HWIN hWin, int Notification);
Nvoid      WM_SendMessage          (WM_HWIN hWin, WM_MESSAGE* p);
Xvoid      WM_SendMessage          (GUI_HWIN hWin, WM_MESSAGE* p);
Nvoid      WM_SendMessageNoPara    (WM_HWIN hWin, int MsgId);             /* not to be documented (may change in future versionumented */
Xvoid      WM_SendMessageNoPara    (GUI_HWIN hWin, int MsgId);              
Nvoid      WM_DefaultProc          (WM_MESSAGE* pMsg);
Nint       WM_BroadcastMessage     (WM_MESSAGE* pMsg);
Nvoid      WM_SetScrollState       (WM_HWIN hWin, const WM_SCROLL_STATE* pState);
Xvoid      WM_SetScrollState       (GUI_HWIN hWin, const WM_SCROLL_STATE* pState);
Nvoid      WM_SetEnableState       (WM_HWIN hItem, int State);
Xvoid      WM_SetEnableState       (GUI_HWIN hItem, int State);
Nvoid      WM_SendToParent         (WM_HWIN hWin, WM_MESSAGE* pMsg);
Xvoid      WM_SendToParent         (GUI_HWIN hWin, WM_MESSAGE* pMsg);
Nint       WM_HasCaptured          (WM_HWIN hWin);
Xint       WM_HasCaptured          (GUI_HWIN hWin);
Nint       WM_HasFocus             (WM_HWIN hWin);
Xint       WM_HasFocus             (GUI_HWIN hWin);
Nint       WM_SetFocus             (WM_HWIN hWin);
Xint       WM_SetFocus             (GUI_HWIN hWin);
NWM_HWIN   WM_SetFocusOnNextChild  (WM_HWIN hParent);     /* Set the focus to the next child */
XGUI_HWIN   WM_SetFocusOnNextChild  (GUI_HWIN hParent);      
NWM_HWIN   WM_SetFocusOnPrevChild  (WM_HWIN hParent);     /* Set the focus to the previous child */
XGUI_HWIN   WM_SetFocusOnPrevChild  (GUI_HWIN hParent);      
NWM_HWIN   WM_GetDialogItem        (WM_HWIN hWin, int Id);
XGUI_HWIN   WM_GetDialogItem        (GUI_HWIN hWin, int Id);
Nvoid      WM_EnableWindow         (WM_HWIN hWin);
Xvoid      WM_EnableWindow         (GUI_HWIN hWin);
Nvoid      WM_DisableWindow        (WM_HWIN hWin);
Xvoid      WM_DisableWindow        (GUI_HWIN hWin);
Nvoid      WM_GetScrollState       (WM_HWIN hObj, WM_SCROLL_STATE* pScrollState);
Xvoid      WM_GetScrollState       (GUI_HWIN hObj, WM_SCROLL_STATE* pScrollState);
Nint       WM_GetUserData          (WM_HWIN hWin,       void* pDest, int SizeOfBuffer);
Xint       WM_GetUserData          (GUI_HWIN hWin,       void* pDest, int SizeOfBuffer);
Nint       WM_SetUserData          (WM_HWIN hWin, const void* pSrc,  int SizeOfBuffer);
Xint       WM_SetUserData          (GUI_HWIN hWin, const void* pSrc,  int SizeOfBuffer);
N
N
N/*********************************************************************
N*
N*           Misc routines
N*/
N
Nint       WM_HandlePID      (void);
NWM_HWIN   WM_Screen2hWin    (int x, int y);
XGUI_HWIN   WM_Screen2hWin    (int x, int y);
NWM_HWIN   WM_Screen2hWinEx  (WM_HWIN hStop, int x, int y);
XGUI_HWIN   WM_Screen2hWinEx  (GUI_HWIN hStop, int x, int y);
Nvoid      WM_ForEachDesc    (WM_HWIN hWin, WM_tfForEach * pcb, void * pData);
Xvoid      WM_ForEachDesc    (GUI_HWIN hWin, WM_tfForEach * pcb, void * pData);
Nvoid      WM_SetScreenSize  (int xSize, int ySize);
Nint       WM_PollSimMsg     (void);
N
N/*********************************************************************
N*
N*           Diagnostics routines
N*/
N#if (WM_SUPPORT_DIAG)
X#if (0)
Svoid WM_DIAG_EnableInvalidationColoring(int OnOff);
N#endif
N
N/*
N      *************************************************
N      *                                               *
N      *  Macros for compatibility with older versions *
N      *                                               *
N      *************************************************
N*/
N
N#if WM_COMPATIBLE_MODE
X#if 1
N  #define HBWIN             WM_HWIN
N  #define HBWIN_NULL        WM_HWIN_NULL
N
N  #define WM_HideWin        WM_HideWindow
N  #define WM_ShowWin        WM_ShowWindow
N  #define WM_GetKey         GUI_GetKey
N  #define WM_WaitKey        GUI_WaitKey
N
N  #define WM_ExecIdle       WM_Exec
N  #define WM_ExecIdle1      WM_Exec1
N
N  #define WM_Invalidate     WM_InvalidateWindow
N  #define WM_GetWinRect     WM_GetWindowRect
N  #define WM_GetWinOrgX     WM_GetWindowOrgX
N  #define WM_GetWinOrgY     WM_GetWindowOrgY
N  #define WM_GetWinSizeX    WM_GetWindowSizeX
N  #define WM_GetWinSizeY    WM_GetWindowSizeY
N  #define WM_GetXSize       WM_GetWindowSizeX
N  #define WM_GetYSize       WM_GetWindowSizeY
N  #define WM_SelWin         WM_SelectWindow
N  #define WM_GetBackgroundWindow  WM_GetDesktopWindow
N  #define WM_GetForegroundWindow    0
N  #define WM_SetForegroundWindow    WM_BringToTop
N  #define WM_SetUserClipArea WM_SetUserClipRect
N
N
N  #define WM_Start()
N  #define WM_Stop()
N  #define WM_SetBkWindowColor(Color)  WM_SetDesktopColor(Color)
N
N#endif
N
N
N#endif   /* GUI_WINSUPPORT */
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif 
N
N#endif   /* WM_H */
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 24 "..\GUI\Widget\EDIT.h" 2
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
L 1 "..\GUI\Widget\DIALOG_Intern.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : Dialog.h
NPurpose     : Dialog box include
N----------------------------------------------------------------------
NOpen items:
NNone
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef DIALOG_INTERN_H
N#define DIALOG_INTERN_H
N
N#include "WM.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*           typedefs
N*
N**********************************************************************
N*/
N
Ntypedef struct  GUI_WIDGET_CREATE_INFO_struct GUI_WIDGET_CREATE_INFO;
Ntypedef WM_HWIN GUI_WIDGET_CREATE_FUNC       (const GUI_WIDGET_CREATE_INFO* pCreate, WM_HWIN hWin, int x0, int y0, WM_CALLBACK* cb);
Xtypedef GUI_HWIN GUI_WIDGET_CREATE_FUNC       (const GUI_WIDGET_CREATE_INFO* pCreate, GUI_HWIN hWin, int x0, int y0, WM_CALLBACK* cb);
N
N/*********************************************************************
N*
N*           structures
N*
N**********************************************************************
N*/
Nstruct GUI_WIDGET_CREATE_INFO_struct {
N  GUI_WIDGET_CREATE_FUNC* pfCreateIndirect;
N  const char* pName;                     /* Text ... Not used on all widgets */
N  I16 Id;                                /* ID ... should be unique in a dialog */
X  signed short Id;                                 
N  I16 x0, y0, xSize, ySize;              /* Define position and size */
X  signed short x0, y0, xSize, ySize;               
N  U16 Flags;                             /* Widget specific create flags (opt.) */
X  unsigned short Flags;                              
N  I32 Para;                              /* Widget specific parameter (opt.) */ 
X  signed long Para;                                
N};
N
N/*********************************************************************
N*
N*           Create functions for well known widgets
N*
N**********************************************************************
N*/
N
NWM_HWIN BUTTON_CreateIndirect   (const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
XGUI_HWIN BUTTON_CreateIndirect   (const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
NWM_HWIN CHECKBOX_CreateIndirect (const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
XGUI_HWIN CHECKBOX_CreateIndirect (const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
NWM_HWIN EDIT_CreateIndirect     (const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
XGUI_HWIN EDIT_CreateIndirect     (const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
NWM_HWIN FRAMEWIN_CreateIndirect (const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
XGUI_HWIN FRAMEWIN_CreateIndirect (const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
NWM_HWIN RADIO_CreateIndirect    (const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
XGUI_HWIN RADIO_CreateIndirect    (const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
NWM_HWIN SLIDER_CreateIndirect   (const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
XGUI_HWIN SLIDER_CreateIndirect   (const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
NWM_HWIN SCROLLBAR_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
XGUI_HWIN SCROLLBAR_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
NWM_HWIN TEXT_CreateIndirect     (const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
XGUI_HWIN TEXT_CreateIndirect     (const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
N
N/*********************************************************************
N*
N*           Public API functions
N*
N**********************************************************************
N*/
Nint     GUI_ExecDialogBox     (const GUI_WIDGET_CREATE_INFO* paWidget, int NumWidgets, WM_CALLBACK* cb, WM_HWIN hParent, int x0, int y0);
Xint     GUI_ExecDialogBox     (const GUI_WIDGET_CREATE_INFO* paWidget, int NumWidgets, WM_CALLBACK* cb, GUI_HWIN hParent, int x0, int y0);
Nint     GUI_ExecCreatedDialog (WM_HWIN hDialog);
Xint     GUI_ExecCreatedDialog (GUI_HWIN hDialog);
NWM_HWIN GUI_CreateDialogBox   (const GUI_WIDGET_CREATE_INFO* paWidget, int NumWidgets, WM_CALLBACK* cb, WM_HWIN hParent, int x0, int y0);
XGUI_HWIN GUI_CreateDialogBox   (const GUI_WIDGET_CREATE_INFO* paWidget, int NumWidgets, WM_CALLBACK* cb, GUI_HWIN hParent, int x0, int y0);
Nvoid    GUI_SetDialogStatusPtr(WM_HWIN hDialog, WM_DIALOG_STATUS* pDialogStatus); /* not to documented */
Xvoid    GUI_SetDialogStatusPtr(GUI_HWIN hDialog, WM_DIALOG_STATUS* pDialogStatus);  
NWM_DIALOG_STATUS*  GUI_GetDialogStatusPtr(WM_HWIN hDialog);                       /* not to documented */
XWM_DIALOG_STATUS*  GUI_GetDialogStatusPtr(GUI_HWIN hDialog);                        
Nvoid    GUI_EndDialog(WM_HWIN hWin, int r);
Xvoid    GUI_EndDialog(GUI_HWIN hWin, int r);
NLCD_COLOR DIALOG_GetBkColor(void);                                                /* obsolete */
NLCD_COLOR DIALOG_SetBkColor(LCD_COLOR BkColor);                                   /* obsolete */
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N
N#endif   /* GUI_WINSUPPORT */
N#endif
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 25 "..\GUI\Widget\EDIT.h" 2
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defaults for configuration switches
N*
N**********************************************************************
N
NThe following are defaults for config switches which affect the
Ninterface specified in this module
N*/
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N
N/************************************************************
N*
N*       Create / Status flags
N*/
N#define EDIT_CF_LEFT    GUI_TA_LEFT
N#define EDIT_CF_RIGHT   GUI_TA_RIGHT
N#define EDIT_CF_HCENTER GUI_TA_HCENTER
N
N#define EDIT_CF_VCENTER GUI_TA_VCENTER
N#define EDIT_CF_TOP     GUI_TA_TOP
N#define EDIT_CF_BOTTOM  GUI_TA_BOTTOM
N
N/*********************************************************************
N*
N*       Color indices
N*/
N#define EDIT_CI_DISABLED 0
N#define EDIT_CI_ENABLED  1
N
N/************************************************************
N*
N*       States
N*/
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM EDIT_Handle;
Xtypedef signed short EDIT_Handle;
Ntypedef void tEDIT_AddKeyEx    (EDIT_Handle hObj, int Key);
Ntypedef void tEDIT_UpdateBuffer(EDIT_Handle hObj);
N
N
N/*
N      *************************************************************
N      *                                                           *
N      *                 Create function(s)                        *
N      *                                                           *
N      *                   (Constructors)                          *
N      *                                                           *
N      *************************************************************
N
N*/
N/* Note: the parameters to a create function may vary.
N         Some widgets may have multiple create functions */
N
N
NEDIT_Handle EDIT_Create        (int x0, int y0, int xsize, int ysize, int Id, int MaxLen, int Flags);
NEDIT_Handle EDIT_CreateAsChild (int x0, int y0, int xsize, int ysize, WM_HWIN hParent, int Id, int Flags, int MaxLen);
XEDIT_Handle EDIT_CreateAsChild (int x0, int y0, int xsize, int ysize, GUI_HWIN hParent, int Id, int Flags, int MaxLen);
NEDIT_Handle EDIT_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
XEDIT_Handle EDIT_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
NEDIT_Handle EDIT_CreateEx      (int x0, int y0, int xsize, int ysize, WM_HWIN hParent,
XEDIT_Handle EDIT_CreateEx      (int x0, int y0, int xsize, int ysize, GUI_HWIN hParent,
N                                int WinFlags, int ExFlags, int Id, int MaxLen);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid EDIT_Callback(WM_MESSAGE * pMsg);
N
N/*
N      *************************************************************
N      *                                                           *
N      *                 Standard member functions                 *
N      *                                                           *
N      *************************************************************
N*/
N
N#define EDIT_EnableMemdev(hObj)  WM_EnableMemdev(hObj)
N#define EDIT_DisableMemdev(hObj) WM_DisableMemdev(hObj)
N#define EDIT_Delete(hObj)        WM_DeleteWindow(hObj)
N#define EDIT_Paint(hObj)         WM_Paint(hObj)
N#define EDIT_Invalidate(hObj)    WM_InvalidateWindow(hObj)
N
N/*
N      *************************************************************
N      *                                                           *
N      *           Individual member functions                     *
N      *                                                           *
N      *************************************************************
N
N*/
N
N/* Methods changing preferences */
Nvoid EDIT_SetDefaultBkColor(unsigned int Index, GUI_COLOR Color);
Nvoid EDIT_SetDefaultFont(const GUI_FONT* pFont);
Nvoid EDIT_SetDefaultTextAlign(int Align);
Nvoid EDIT_SetDefaultTextColor(unsigned int Index, GUI_COLOR Color);
N
N/* Query preferences */
NGUI_COLOR                    EDIT_GetDefaultBkColor(unsigned int Index);
Nconst GUI_FONT GUI_UNI_PTR * EDIT_GetDefaultFont(void);
Xconst GUI_FONT  * EDIT_GetDefaultFont(void);
Nint                          EDIT_GetDefaultTextAlign(void);
NGUI_COLOR                    EDIT_GetDefaultTextColor(unsigned int Index);
N
N/* Methods changing properties */
Nvoid EDIT_AddKey           (EDIT_Handle hObj, int Key);
Nvoid EDIT_ClearCursor      (EDIT_Handle hObj);
Nvoid EDIT_SetBkColor       (EDIT_Handle hObj, unsigned int Index, GUI_COLOR color);
Nvoid EDIT_SetCursorAtChar  (EDIT_Handle hObj, int Pos);
Nvoid EDIT_SetCursorAtPixel (EDIT_Handle hObj, int xPos);
Nvoid EDIT_SetFocussable    (EDIT_Handle hObj, int State);
Nvoid EDIT_SetFont          (EDIT_Handle hObj, const GUI_FONT GUI_UNI_PTR * pfont);
Xvoid EDIT_SetFont          (EDIT_Handle hObj, const GUI_FONT  * pfont);
Nint  EDIT_SetInsertMode    (EDIT_Handle hObj, int OnOff);
Nvoid EDIT_SetMaxLen        (EDIT_Handle hObj, int MaxLen);
Nvoid EDIT_SetpfAddKeyEx    (EDIT_Handle hObj, tEDIT_AddKeyEx * pfAddKeyEx);
Nvoid EDIT_SetpfUpdateBuffer(EDIT_Handle hObj, tEDIT_UpdateBuffer * pfUpdateBuffer);
Nvoid EDIT_SetText          (EDIT_Handle hObj, const char* s);
Nvoid EDIT_SetTextAlign     (EDIT_Handle hObj, int Align);
Nvoid EDIT_SetTextColor     (EDIT_Handle hObj, unsigned int Index, GUI_COLOR color);
Nvoid EDIT_SetSel           (EDIT_Handle hObj, int FirstChar, int LastChar);
N
N/* Get/Set user input */
Nint   EDIT_GetCursorCharPos (EDIT_Handle hObj);
Nvoid  EDIT_GetCursorPixelPos(EDIT_Handle hObj, int * pxPos, int * pyPos);
Nfloat EDIT_GetFloatValue    (EDIT_Handle hObj);
Nint   EDIT_GetNumChars      (EDIT_Handle hObj);
Nvoid  EDIT_GetText          (EDIT_Handle hObj, char* sDest, int MaxLen);
NI32   EDIT_GetValue         (EDIT_Handle hObj);
Xsigned long   EDIT_GetValue         (EDIT_Handle hObj);
Nvoid  EDIT_SetFloatValue    (EDIT_Handle hObj, float Value);
Nvoid  EDIT_SetValue         (EDIT_Handle hObj, I32 Value);
Xvoid  EDIT_SetValue         (EDIT_Handle hObj, signed long Value);
N
N/*********************************************************************
N*
N*             Routines for editing values
N*
N**********************************************************************
N*/
N
Nvoid  EDIT_SetHexMode(EDIT_Handle hEdit, U32 Value, U32 Min, U32 Max);
Xvoid  EDIT_SetHexMode(EDIT_Handle hEdit, unsigned long Value, unsigned long Min, unsigned long Max);
Nvoid  EDIT_SetBinMode(EDIT_Handle hEdit, U32 Value, U32 Min, U32 Max);
Xvoid  EDIT_SetBinMode(EDIT_Handle hEdit, unsigned long Value, unsigned long Min, unsigned long Max);
Nvoid  EDIT_SetDecMode(EDIT_Handle hEdit, I32 Value, I32 Min, I32 Max, int Shift, U8 Flags);
Xvoid  EDIT_SetDecMode(EDIT_Handle hEdit, signed long Value, signed long Min, signed long Max, int Shift, unsigned char Flags);
Nvoid  EDIT_SetFloatMode(EDIT_Handle hEdit, float Value, float Min, float Max, int Shift, U8 Flags);
Xvoid  EDIT_SetFloatMode(EDIT_Handle hEdit, float Value, float Min, float Max, int Shift, unsigned char Flags);
Nvoid  EDIT_SetTextMode(EDIT_Handle hEdit);
Nvoid  EDIT_SetUlongMode(EDIT_Handle hEdit, U32 Value, U32 Min, U32 Max);
Xvoid  EDIT_SetUlongMode(EDIT_Handle hEdit, unsigned long Value, unsigned long Min, unsigned long Max);
N
NU32   GUI_EditHex(U32 Value, U32 Min, U32 Max, int Len, int xsize);
Xunsigned long   GUI_EditHex(unsigned long Value, unsigned long Min, unsigned long Max, int Len, int xsize);
NU32   GUI_EditBin(U32 Value, U32 Min, U32 Max, int Len, int xsize);
Xunsigned long   GUI_EditBin(unsigned long Value, unsigned long Min, unsigned long Max, int Len, int xsize);
NI32   GUI_EditDec(I32 Value, I32 Min, I32 Max, int Len, int xsize, int Shift, U8 Flags);
Xsigned long   GUI_EditDec(signed long Value, signed long Min, signed long Max, int Len, int xsize, int Shift, unsigned char Flags);
Nfloat GUI_EditFloat(float Value, float Min, float Max, int Len, int xsize, int Shift, U8 Flags);
Xfloat GUI_EditFloat(float Value, float Min, float Max, int Len, int xsize, int Shift, unsigned char Flags);
Nvoid  GUI_EditString(char * pString, int Len, int xsize);
N
N/*********************************************************************
N*
N*             Flags
N*
N**********************************************************************
N*/
N
N/* Signed or normal mode */
N#define GUI_EDIT_NORMAL 0
N#define GUI_EDIT_SIGNED 1
N
N/* Edit modes */
N#define GUI_EDIT_MODE_INSERT    0
N#define GUI_EDIT_MODE_OVERWRITE 1
N
N/* Compatibility macros */
N#define EDIT_CI_DISABELD EDIT_CI_DISABLED
N#define EDIT_CI_ENABELD  EDIT_CI_ENABLED
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif   /* GUI_WINSUPPORT */
N#endif   /* EDIT_H */
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 24 "..\GUI\Widget\EDIT_Private.h" 2
N
N#if GUI_WINSUPPORT
X#if 1
N
N#include "WIDGET.h"
L 1 "..\GUI\Widget\WIDGET.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : WIDGET.h
NPurpose     : Widget interface
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef WIDGET_H        /* Avoid multiple inclusion  */
N#define WIDGET_H
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#include "WM_Intern.h"  /* Window manager, including some internals, which speed things up */
L 1 "..\GUI\WM\WM_Intern.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : WM_Intern.h
NPurpose     : Windows manager internal include
N----------------------------------------------------------------------
N*/
N
N#ifndef WM_INTERN_H            /* Make sure we only include it once */
N#define WM_INTERN_H            /* Make sure we only include it once */
N
N#include "WM.h"
N#include "GUI_Protected.h"       /* For GUI_Context */
L 1 "..\GUI\Core\GUI_Protected.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : GUI_Protected.h
NPurpose     : GUI internal declarations
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef  GUI_PROTECTED_H
N#define  GUI_PROTECTED_H
N
N#include "GUI.h"
L 1 "..\GUI\Core\GUI.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : GUI.h
NPurpose     : GUI API include file
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N
N#ifndef  GUI_H
N#define  GUI_H
N#define __EMWIN_GSC__   /* Allow "C" to find out that emWin GSC is used */
N
N
N#include "GUI_ConfDefaults.h"
N#include "GUIType.h"
N#include "GUIVersion.h"
L 1 "..\GUI\Core\GUIVersion.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : GUIVersion.h
NPurpose     : Include file defining current GUI version
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef  GUI_VERSION_H
N#define  GUI_VERSION_H
N
N#define GUI_VERSION 39800
N
N#endif   /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 33 "..\GUI\Core\GUI.h" 2
N
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*        Limitations for certain C51 Keil  (__C51__)
N*
N**********************************************************************
N*/
N#if defined (__C51__) && GUI_SUPPORT_MEMDEV
X#if 0L && 1
S  #error __C51__ (Keil) can not support function pointers sufficiently !  -> Disable memory devices  -> GUI_SUPPORT_MEMDEV 0
N#endif
N
N/*********************************************************************
N*
N*        macros, function replacement
N*
N**********************************************************************
N*/
N#define GUI_COUNTOF(a) (sizeof(a) / sizeof(a[0]))
N
N/************************************************************
N*
N*                    GUI_KEY_...
N*
N*************************************************************
NThese ID values are basically meant to be used with widgets
NNote that we have chosen the values to be close to existing
N"standards", so do not change them unless forced to.
N
N*/
N
N#define GUI_KEY_BACKSPACE         8         /* ASCII: BACKSPACE Crtl-H */
N#define GUI_KEY_TAB               9         /* ASCII: TAB       Crtl-I */
N#define GUI_KEY_BACKTAB           10
N#define GUI_KEY_ENTER             13        /* ASCII: ENTER     Crtl-M */
N#define GUI_KEY_LEFT              16
N#define GUI_KEY_UP                17
N#define GUI_KEY_RIGHT             18
N#define GUI_KEY_DOWN              19
N#define GUI_KEY_HOME              23
N#define GUI_KEY_END               24
N#define GUI_KEY_SHIFT             25
N#define GUI_KEY_CONTROL           26
N#define GUI_KEY_ESCAPE            27        /* ASCII: ESCAPE    0x1b   */
N#define GUI_KEY_INSERT            29
N#define GUI_KEY_DELETE            30
N#define GUI_KEY_SPACE             32
N#define GUI_KEY_PGUP              33
N#define GUI_KEY_PGDOWN            34
N
N#define GUI_KEY_F1                40
N#define GUI_KEY_F2                41
N
N#define GUI_KEY_NUM0		48
N#define GUI_KEY_NUM1		49
N#define GUI_KEY_NUM2		50
N#define GUI_KEY_NUM3		51
N#define GUI_KEY_NUM4		52
N#define GUI_KEY_NUM5		53
N#define GUI_KEY_NUM6		54
N#define GUI_KEY_NUM7		55
N#define GUI_KEY_NUM8		56
N#define GUI_KEY_NUM9		57
N
N#define GUI_KEY_STAR			42
N#define GUI_KEY_NUMBER_KEY	35
N
N#define GUI_KEY_LEFT_FUN		5
N#define GUI_KEY_RIGHT_FUN		6
N#define GUI_KEY_MIDDLE_FUN		GUI_KEY_ENTER
N
N
N/*********************************************************************
N*
N*       Dialog item IDs
N*
N*  The IDs below are arbitrary values. They just have to be unique
N*  within the dialog.
N*
N*  If you use your own Ids, we recommend to use values above GUI_ID_USER.
N*/
N
N#define GUI_ID_OK                1
N#define GUI_ID_CANCEL            2
N#define GUI_ID_YES               3
N#define GUI_ID_NO                4
N#define GUI_ID_CLOSE             5
N#define GUI_ID_HELP              6
N#define GUI_ID_MAXIMIZE          7
N#define GUI_ID_MINIMIZE          8
N
N#define GUI_ID_VSCROLL  0xFE
N#define GUI_ID_HSCROLL  0xFF
N
N#define GUI_ID_EDIT0    0x100
N#define GUI_ID_EDIT1    0x101
N#define GUI_ID_EDIT2    0x102
N#define GUI_ID_EDIT3    0x103
N#define GUI_ID_EDIT4    0x104
N#define GUI_ID_EDIT5    0x105
N#define GUI_ID_EDIT6    0x106
N#define GUI_ID_EDIT7    0x107
N#define GUI_ID_EDIT8    0x108
N#define GUI_ID_EDIT9    0x109
N
N#define GUI_ID_LISTBOX0 0x110
N#define GUI_ID_LISTBOX1 0x111
N#define GUI_ID_LISTBOX2 0x112
N#define GUI_ID_LISTBOX3 0x113
N#define GUI_ID_LISTBOX4 0x114
N#define GUI_ID_LISTBOX5 0x115
N#define GUI_ID_LISTBOX6 0x116
N#define GUI_ID_LISTBOX7 0x117
N#define GUI_ID_LISTBOX8 0x118
N#define GUI_ID_LISTBOX9 0x119
N
N#define GUI_ID_CHECK0   0x120
N#define GUI_ID_CHECK1   0x121
N#define GUI_ID_CHECK2   0x122
N#define GUI_ID_CHECK3   0x123
N#define GUI_ID_CHECK4   0x124
N#define GUI_ID_CHECK5   0x125
N#define GUI_ID_CHECK6   0x126
N#define GUI_ID_CHECK7   0x127
N#define GUI_ID_CHECK8   0x128
N#define GUI_ID_CHECK9   0x129
N
N#define GUI_ID_SLIDER0  0x130
N#define GUI_ID_SLIDER1  0x131
N#define GUI_ID_SLIDER2  0x132
N#define GUI_ID_SLIDER3  0x133
N#define GUI_ID_SLIDER4  0x134
N#define GUI_ID_SLIDER5  0x135
N#define GUI_ID_SLIDER6  0x136
N#define GUI_ID_SLIDER7  0x137
N#define GUI_ID_SLIDER8  0x138
N#define GUI_ID_SLIDER9  0x139
N
N#define GUI_ID_SCROLLBAR0 0x140
N#define GUI_ID_SCROLLBAR1 0x141
N#define GUI_ID_SCROLLBAR2 0x142
N#define GUI_ID_SCROLLBAR3 0x142
N
N#define GUI_ID_RADIO0 0x150
N#define GUI_ID_RADIO1 0x151
N#define GUI_ID_RADIO2 0x152
N#define GUI_ID_RADIO3 0x153
N#define GUI_ID_RADIO4 0x154
N#define GUI_ID_RADIO5 0x155
N#define GUI_ID_RADIO6 0x156
N#define GUI_ID_RADIO7 0x157
N
N#define GUI_ID_TEXT0  0x160
N#define GUI_ID_TEXT1  0x161
N#define GUI_ID_TEXT2  0x162
N#define GUI_ID_TEXT3  0x163
N#define GUI_ID_TEXT4  0x164
N#define GUI_ID_TEXT5  0x165
N#define GUI_ID_TEXT6  0x166
N#define GUI_ID_TEXT7  0x167
N#define GUI_ID_TEXT8  0x168
N#define GUI_ID_TEXT9  0x169
N
N#define GUI_ID_BUTTON0 0x170
N#define GUI_ID_BUTTON1 0x171
N#define GUI_ID_BUTTON2 0x172
N#define GUI_ID_BUTTON3 0x173
N#define GUI_ID_BUTTON4 0x174
N#define GUI_ID_BUTTON5 0x175
N#define GUI_ID_BUTTON6 0x176
N#define GUI_ID_BUTTON7 0x177
N#define GUI_ID_BUTTON8 0x178
N#define GUI_ID_BUTTON9 0x179
N
N#define GUI_ID_DROPDOWN0  0x180
N#define GUI_ID_DROPDOWN1  0x181
N#define GUI_ID_DROPDOWN2  0x182
N#define GUI_ID_DROPDOWN3  0x183
N
N#define GUI_ID_MULTIEDIT0 0x190
N#define GUI_ID_MULTIEDIT1 0x191
N#define GUI_ID_MULTIEDIT2 0x192
N#define GUI_ID_MULTIEDIT3 0x193
N
N#define GUI_ID_LISTVIEW0  0x200
N#define GUI_ID_LISTVIEW1  0x201
N#define GUI_ID_LISTVIEW2  0x202
N#define GUI_ID_LISTVIEW3  0x203
N
N#define GUI_ID_PROGBAR0   0x210
N#define GUI_ID_PROGBAR1   0x211
N#define GUI_ID_PROGBAR2   0x212
N#define GUI_ID_PROGBAR3   0x213
N
N#define GUI_ID_GRAPH0 0x220
N#define GUI_ID_GRAPH1 0x221
N#define GUI_ID_GRAPH2 0x222
N#define GUI_ID_GRAPH3 0x223
N
N#define GUI_ID_MULTIPAGE0 0x230
N#define GUI_ID_MULTIPAGE1 0x231
N#define GUI_ID_MULTIPAGE2 0x232
N#define GUI_ID_MULTIPAGE3 0x233
N
N#define GUI_ID_USER     0x800
N
N/*********************************************************************
N*
N*       Mouse buttons
N*/
N#define GUI_LBUTTON (1 << 0) /* Left button */
N#define GUI_RBUTTON (1 << 1) /* Right button */
N#define GUI_MBUTTON (1 << 2) /* Middle button */
N#define GUI_DBUTTON (1 << 7) /* Double-click button */
N
N/*********************************************************************
N*
N*       Wrap modes
N*/
Ntypedef enum { GUI_WRAPMODE_NONE, GUI_WRAPMODE_WORD, GUI_WRAPMODE_CHAR } GUI_WRAPMODE;
N
N/*********************************************************************
N*
N*               Constants  needed for GL
N*
N**********************************************************************
N*/
N
N/**********************************
N*
N*      Text styles
N*
N***********************************
N*/
N
N#define GUI_TS_NORMAL           (0)
N#define GUI_TS_UNDERLINE        (1 << 0)
N#define GUI_TS_STRIKETHRU       (1 << 1)
N#define GUI_TS_OVERLINE         (1 << 2)
N
N/**********************************
N*
N*      Line styles
N*
N***********************************
N*/
N
N#define GUI_LS_SOLID        (0)
N#define GUI_LS_DASH         (1)
N#define GUI_LS_DOT          (2)
N#define GUI_LS_DASHDOT      (3)
N#define GUI_LS_DASHDOTDOT   (4)
N
N
N/**********************************
N*
N*      Pen shapes
N*
N***********************************
N*/
N
N#define GUI_PS_ROUND        (0)
N#define GUI_PS_FLAT         (1)
N#define GUI_PS_SQUARE       (2)
N
N
N
N/*      *********************************
N        *
N        *      Standard colors
N        *
N        *********************************
N*/
N
N#define GUI_BLUE          0xFF0000
N#define GUI_GREEN         0x00FF00
N#define GUI_RED           0x0000FF
N#define GUI_CYAN          0xFFFF00
N#define GUI_MAGENTA       0xFF00FF
N#define GUI_YELLOW        0x00FFFF
N#define GUI_LIGHTBLUE     0xFF8080
N#define GUI_LIGHTGREEN    0x80FF80
N#define GUI_LIGHTRED      0x8080FF
N#define GUI_LIGHTCYAN     0xFFFF80
N#define GUI_LIGHTMAGENTA  0xFF80FF
N#define GUI_LIGHTYELLOW   0x80FFFF
N#define GUI_DARKBLUE      0x800000
N#define GUI_DARKGREEN     0x008000
N#define GUI_DARKRED       0x000080
N#define GUI_DARKCYAN      0x808000
N#define GUI_DARKMAGENTA   0x800080
N#define GUI_DARKYELLOW    0x008080
N#define GUI_WHITE         0xFFFFFF
N#define GUI_LIGHTGRAY     0xD3D3D3
N#define GUI_GRAY          0x808080
N#define GUI_DARKGRAY      0x404040
N#define GUI_BLACK         0x000000
N
N#define GUI_BROWN         0x2A2AA5
N
N#define GUI_INVALID_COLOR 0xFFFFFFF      /* Invalid color - more than 24 bits */
N
N/*      *********************************
N        *
N        *      Coordinates
N        *
N        *********************************
N*/
N#define GUI_COORD_X 0
N#define GUI_COORD_Y 1
N
N/*********************************************************************
N*
N*            Standard Fonts
N*
N**********************************************************************
N
NNote: The external declarations for the fonts are now also included in
N      this file.
N*/
N
N
N/* Proportional fonts */
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8_ASCII,        GUI_Font8_1;
Xextern const GUI_FONT GUI_Font8_ASCII,        GUI_Font8_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font10S_ASCII,      GUI_Font10S_1;
Xextern const GUI_FONT GUI_Font10S_ASCII,      GUI_Font10S_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font10_ASCII,       GUI_Font10_1;
Xextern const GUI_FONT GUI_Font10_ASCII,       GUI_Font10_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13_ASCII,       GUI_Font13_1;
Xextern const GUI_FONT GUI_Font13_ASCII,       GUI_Font13_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13B_ASCII,      GUI_Font13B_1;
Xextern const GUI_FONT GUI_Font13B_ASCII,      GUI_Font13B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13H_ASCII,      GUI_Font13H_1;
Xextern const GUI_FONT GUI_Font13H_ASCII,      GUI_Font13H_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13HB_ASCII,     GUI_Font13HB_1;
Xextern const GUI_FONT GUI_Font13HB_ASCII,     GUI_Font13HB_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font16_ASCII,       GUI_Font16_1,       GUI_Font16_HK,    GUI_Font16_1HK;
Xextern const GUI_FONT GUI_Font16_ASCII,       GUI_Font16_1,       GUI_Font16_HK,    GUI_Font16_1HK;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font16B_ASCII,      GUI_Font16B_1;
Xextern const GUI_FONT GUI_Font16B_ASCII,      GUI_Font16B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font24_ASCII,       GUI_Font24_1;
Xextern const GUI_FONT GUI_Font24_ASCII,       GUI_Font24_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font24B_ASCII,      GUI_Font24B_1;
Xextern const GUI_FONT GUI_Font24B_ASCII,      GUI_Font24B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font32_ASCII,       GUI_Font32_1;
Xextern const GUI_FONT GUI_Font32_ASCII,       GUI_Font32_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font32B_ASCII,      GUI_Font32B_1;
Xextern const GUI_FONT GUI_Font32B_ASCII,      GUI_Font32B_1;
N
N/* Monospaced */
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font4x6;
Xextern const GUI_FONT GUI_Font4x6;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font6x8,            GUI_Font6x9;
Xextern const GUI_FONT GUI_Font6x8,            GUI_Font6x9;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x8,            GUI_Font8x9;
Xextern const GUI_FONT GUI_Font8x8,            GUI_Font8x9;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x10_ASCII;
Xextern const GUI_FONT GUI_Font8x10_ASCII;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x12_ASCII;
Xextern const GUI_FONT GUI_Font8x12_ASCII;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x13_ASCII,     GUI_Font8x13_1;
Xextern const GUI_FONT GUI_Font8x13_ASCII,     GUI_Font8x13_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x15B_ASCII,    GUI_Font8x15B_1;
Xextern const GUI_FONT GUI_Font8x15B_ASCII,    GUI_Font8x15B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x16,           GUI_Font8x17,       GUI_Font8x18;
Xextern const GUI_FONT GUI_Font8x16,           GUI_Font8x17,       GUI_Font8x18;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x16x1x2,       GUI_Font8x16x2x2,   GUI_Font8x16x3x3;
Xextern const GUI_FONT GUI_Font8x16x1x2,       GUI_Font8x16x2x2,   GUI_Font8x16x3x3;
N
N/* Digits */
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD24x32;
Xextern const GUI_FONT GUI_FontD24x32;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD32;
Xextern const GUI_FONT GUI_FontD32;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD36x48;
Xextern const GUI_FONT GUI_FontD36x48;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD48;
Xextern const GUI_FONT GUI_FontD48;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD48x64;
Xextern const GUI_FONT GUI_FontD48x64;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD64;
Xextern const GUI_FONT GUI_FontD64;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD60x80;
Xextern const GUI_FONT GUI_FontD60x80;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD80;
Xextern const GUI_FONT GUI_FontD80;
N
N/* Comic fonts */
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontComic18B_ASCII, GUI_FontComic18B_1;
Xextern const GUI_FONT GUI_FontComic18B_ASCII, GUI_FontComic18B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontComic24B_ASCII, GUI_FontComic24B_1;
Xextern const GUI_FONT GUI_FontComic24B_ASCII, GUI_FontComic24B_1;
N
N
N/*
N      *********************************
N      *                               *
N      * Text and drawing mode defines *
N      *                               *
N      *********************************
N
NThese defines come in two flavors: the long version (.._DRAWMODE_..)
Nand the short ones (.._DM_..). They are identical, feel free to use
Nwhich ever one you like best.
N
N*/
N
N#define GUI_DRAWMODE_NORMAL  LCD_DRAWMODE_NORMAL
N#define GUI_DRAWMODE_XOR     LCD_DRAWMODE_XOR
N#define GUI_DRAWMODE_TRANS   LCD_DRAWMODE_TRANS
N#define GUI_DRAWMODE_REV     LCD_DRAWMODE_REV
N#define GUI_DM_NORMAL        LCD_DRAWMODE_NORMAL
N#define GUI_DM_XOR           LCD_DRAWMODE_XOR
N#define GUI_DM_TRANS         LCD_DRAWMODE_TRANS
N#define GUI_DM_REV           LCD_DRAWMODE_REV
N
N#define GUI_TEXTMODE_NORMAL  LCD_DRAWMODE_NORMAL
N#define GUI_TEXTMODE_XOR     LCD_DRAWMODE_XOR
N#define GUI_TEXTMODE_TRANS   LCD_DRAWMODE_TRANS
N#define GUI_TEXTMODE_REV     LCD_DRAWMODE_REV
N#define GUI_TM_NORMAL        LCD_DRAWMODE_NORMAL
N#define GUI_TM_XOR           LCD_DRAWMODE_XOR
N#define GUI_TM_TRANS         LCD_DRAWMODE_TRANS
N#define GUI_TM_REV           LCD_DRAWMODE_REV
N
N/* Text alignment flags, horizontal */
N#define GUI_TA_HORIZONTAL  (3<<0)
N#define GUI_TA_LEFT        (0<<0)
N#define GUI_TA_RIGHT	     (1<<0)
N#define GUI_TA_CENTER	     (2<<0)
N#define GUI_TA_HCENTER	   GUI_TA_CENTER  /* easier to remember :-)  */
N
N/* Text alignment flags, vertical */
N#define GUI_TA_VERTICAL   (3<<2)
N#define GUI_TA_TOP	      (0<<2)
N#define GUI_TA_BOTTOM	    (1<<2)
N#define GUI_TA_BASELINE   (2<<2)
N#define GUI_TA_VCENTER    (3<<2)
N
N/*    *********************************
N      *
N      *     Min/Max coordinates
N      *
N      *********************************
N*/
N/* Define minimum and maximum coordinates in x and y */
N#define GUI_XMIN -4095
N#define GUI_XMAX  4095
N#define GUI_YMIN -4095
N#define GUI_YMAX  4095
N
N/*********************************************************************
N*
N*       Support for multitasking systems (locking)
N*
N**********************************************************************
N*/
N
Ntypedef struct GUI_CONTEXT GUI_CONTEXT;
N
N#if !GUI_OS
X#if !(0)
N  #define GUI_LOCK()
N  #define GUI_UNLOCK()
N  #define GUITASK_INIT()
N  #define GUITASK_COPY_CONTEXT()
N#else
S  void GUI_Lock(void);
S  void GUI_Unlock(void);
S  void GUITASK_Init(void);
S  void GUITASK_CopyContext(void);
S  GUI_CONTEXT * GUITASK_GetpContext(int Index);
S  #define GUI_LOCK()             GUI_Lock()
S  #define GUI_UNLOCK()           GUI_Unlock()
S  #define GUITASK_INIT()         GUITASK_Init()
S  #define GUITASK_COPY_CONTEXT() GUITASK_CopyContext()
N#endif
N
N/*********************************************************************
N*
N*             GUI_CONTEXT
N*
N**********************************************************************
N
N  This structure is public for one reason only:
N  To allow the application to save and restore the context.
N*/
N
Ntypedef union {
N  U8  aColorIndex8[2];
X  unsigned char  aColorIndex8[2];
N  U16 aColorIndex16[2];
X  unsigned short aColorIndex16[2];
N  U32 aColorIndex32[2];
X  unsigned long aColorIndex32[2];
N} LCD_COLORINDEX_UNION;
N
Nstruct GUI_CONTEXT {
N/* Variables in LCD module */
N  LCD_COLORINDEX_UNION LCD;
N  LCD_RECT       ClipRect;
N  U8             DrawMode;
X  unsigned char             DrawMode;
N  U8             SelLayer;
X  unsigned char             SelLayer;
N  U8             TextStyle;
X  unsigned char             TextStyle;
N/* Variables in GL module */
N  GUI_RECT* pClipRect_HL;                /* High level clip rectangle ... Speed optimization so drawing routines can optimize */
N  U8        PenSize;
X  unsigned char        PenSize;
N  U8        PenShape;
X  unsigned char        PenShape;
N  U8        LineStyle;
X  unsigned char        LineStyle;
N  U8        FillStyle;
X  unsigned char        FillStyle;
N/* Variables in GUICHAR module */
N  const GUI_FONT           GUI_UNI_PTR * pAFont;
X  const GUI_FONT            * pAFont;
N  #if GUI_SUPPORT_UNICODE
X  #if (1)
N    const GUI_UC_ENC_APILIST * pUC_API;    /* Unicode encoding API */
N  #endif
N  I16P LBorder;
X  signed short LBorder;
N  I16P DispPosX, DispPosY;
X  signed short DispPosX, DispPosY;
N  I16P DrawPosX, DrawPosY;
X  signed short DrawPosX, DrawPosY;
N  I16P TextMode, TextAlign;
X  signed short TextMode, TextAlign;
N  GUI_COLOR Color, BkColor;           /* Required only when changing devices and for speed opt (caching) */
N/* Variables in WM module */
N  #if GUI_WINSUPPORT
X  #if 1
N    const GUI_RECT* WM__pUserClipRect;
N    GUI_HWIN hAWin;
N    int xOff, yOff;
N  #endif
N/* Variables in MEMDEV module (with memory devices only) */
N  #if GUI_SUPPORT_DEVICES
X  #if (1 | (1 > 1))
N    const tLCDDEV_APIList* pDeviceAPI;  /* function pointers only */
N    GUI_HMEM    hDevData;
X    signed short    hDevData;
N    GUI_RECT    ClipRectPrev;
N  #endif
N/* Variables in Anitaliasing module */
N  #if GUI_SUPPORT_AA
X  #if 1
N    const tLCD_HL_APIList* pLCD_HL;     /* Required to reroute drawing (HLine & Pixel) to the AA module */
N    U8 AA_Factor;
X    unsigned char AA_Factor;
N    U8 AA_HiResEnable;
X    unsigned char AA_HiResEnable;
N  #endif
N};
N
N/* Rename GUI_SaveContext in order to avoid crashes if wrong GUIConf is used */
N#if   ( GUI_WINSUPPORT &&  GUI_SUPPORT_DEVICES)
X#if   ( 1 &&  (1 | (1 > 1)))
N  #define GUI_SaveContext GUI_SaveContext_W_M
N#elif (!GUI_WINSUPPORT &&  GUI_SUPPORT_DEVICES)
S  #define GUI_SaveContext GUI_SaveContext_M
S#elif ( GUI_WINSUPPORT && !GUI_SUPPORT_DEVICES)
S  #define GUI_SaveContext GUI_SaveContext_W
S#else
S  #define GUI_SaveContext GUI_SaveContext_
N#endif
N
N/*********************************************************************
N*
N*             General routines
N*
N**********************************************************************
N*/
Nint          GUI_Init             (void);
Nvoid         GUI_SetDefault       (void);
NGUI_DRAWMODE GUI_SetDrawMode      (GUI_DRAWMODE dm);
Nconst char * GUI_GetVersionString (void);
Nvoid         GUI_SaveContext      (      GUI_CONTEXT* pContext);
Xvoid         GUI_SaveContext_W_M      (      GUI_CONTEXT* pContext);
Nvoid         GUI_RestoreContext   (const GUI_CONTEXT* pContext);
Nvoid         GUI_SetScreenSizeX   (int xSize);
Nvoid         GUI_SetScreenSizeY   (int ySize);
Nint          GUI_GetScreenSizeX   (void);
Nint          GUI_GetScreenSizeY   (void);
Nconst GUI_RECT * GUI_SetClipRect  (const GUI_RECT * pRect);
N
N/*********************************************************************
N*
N*           Rectangle helper functions
N*
N**********************************************************************
N*/
N
Nint  GUI_RectsIntersect(const GUI_RECT* pr0, const GUI_RECT* pr1);
Nvoid GUI_MoveRect       (GUI_RECT *pRect, int x, int y);
Nvoid GUI_MergeRect      (GUI_RECT* pDest, const GUI_RECT* pr0, const GUI_RECT* pr1);
Nint  GUI__IntersectRects(GUI_RECT* pDest, const GUI_RECT* pr0, const GUI_RECT* pr1);
Nvoid GUI__IntersectRect (GUI_RECT* pDest, const GUI_RECT* pr0);
Nvoid GUI__ReduceRect    (GUI_RECT* pDest, const GUI_RECT *pRect, int Dist);
N
N/*********************************************************************
N*
N*       Misc helper functions
N*
N**********************************************************************
N*/
N
Nint  GUI__DivideRound     (int a, int b);
NI32  GUI__DivideRound32   (I32 a, I32 b);
Xsigned long  GUI__DivideRound32   (signed long a, signed long b);
Nint  GUI__SetText(GUI_HMEM* phText, const char* s);
Xint  GUI__SetText(signed short* phText, const char* s);
N
N
N
N/*********************************************************************
N*
N*      Get / Set Attributes
N*
N**********************************************************************
N*/
N 
NGUI_COLOR GUI_GetBkColor     (void);
NGUI_COLOR GUI_GetColor       (void);
Nint       GUI_GetBkColorIndex(void);
Nint       GUI_GetColorIndex  (void);
NU8        GUI_GetPenSize     (void);
Xunsigned char        GUI_GetPenSize     (void);
NU8        GUI_GetPenShape    (void);
Xunsigned char        GUI_GetPenShape    (void);
NU8        GUI_GetLineStyle   (void);
Xunsigned char        GUI_GetLineStyle   (void);
NU8        GUI_GetFillStyle   (void);
Xunsigned char        GUI_GetFillStyle   (void);
N
Nvoid      GUI_SetBkColor   (GUI_COLOR);
Nvoid      GUI_SetColor     (GUI_COLOR);
Nvoid      GUI_SetBkColorIndex(int Index);
Nvoid      GUI_SetColorIndex(int Index);
N
NU8        GUI_SetPenSize   (U8 Size);
Xunsigned char        GUI_SetPenSize   (unsigned char Size);
NU8        GUI_SetPenShape  (U8 Shape);
Xunsigned char        GUI_SetPenShape  (unsigned char Shape);
NU8        GUI_SetLineStyle (U8 Style);
Xunsigned char        GUI_SetLineStyle (unsigned char Style);
NU8        GUI_SetFillStyle (U8 Style);
Xunsigned char        GUI_SetFillStyle (unsigned char Style);
N
N/* Get/Set Character used as decimal point (usually '.' or ',') */
Nchar      GUI_GetDecChar(void);
Nchar      GUI_SetDecChar(char c);
N
N
N/*********************************************************************
N*
N*       Color / Index related functions
N*
N**********************************************************************
N*/
N
Nint       GUI_Color2Index(GUI_COLOR color);
NGUI_COLOR GUI_Color2VisColor(GUI_COLOR color);
Nchar      GUI_ColorIsAvailable(GUI_COLOR color);
NGUI_COLOR GUI_Index2Color(int Index);
Nvoid      GUI_InitLUT(void);
Nvoid      GUI_SetLUTEntry (U8 Pos, GUI_COLOR Color);
Xvoid      GUI_SetLUTEntry (unsigned char Pos, GUI_COLOR Color);
Nvoid      GUI_SetLUTColor (U8 Pos, GUI_COLOR Color);
Xvoid      GUI_SetLUTColor (unsigned char Pos, GUI_COLOR Color);
Nvoid      GUI_SetLUTColorEx(U8 Pos, LCD_COLOR Color, unsigned int LayerIndex);
Xvoid      GUI_SetLUTColorEx(unsigned char Pos, LCD_COLOR Color, unsigned int LayerIndex);
NU32       GUI_CalcColorDist (GUI_COLOR Color0, GUI_COLOR  Color1);
Xunsigned long       GUI_CalcColorDist (GUI_COLOR Color0, GUI_COLOR  Color1);
NU32       GUI_CalcVisColorError(GUI_COLOR color);
Xunsigned long       GUI_CalcVisColorError(GUI_COLOR color);
N
N/*********************************************************************
N*
N*       Logging (for debugging primarily)
N*
N**********************************************************************
N*/
Nvoid GUI_Log      (const char *s);
Nvoid GUI_Log1     (const char *s, int p0);
Nvoid GUI_Log2     (const char *s, int p0, int p1);
Nvoid GUI_Log3     (const char *s, int p0, int p1, int p2);
Nvoid GUI_Log4     (const char *s, int p0, int p1, int p2,int p3);
Nvoid GUI_Warn     (const char *s);
Nvoid GUI_Warn1    (const char *s, int p0);
Nvoid GUI_Warn2    (const char *s, int p0, int p1);
Nvoid GUI_Warn3    (const char *s, int p0, int p1, int p2);
Nvoid GUI_Warn4    (const char *s, int p0, int p1, int p2, int p3);
Nvoid GUI_ErrorOut (const char *s);
Nvoid GUI_ErrorOut1(const char *s, int p0);
Nvoid GUI_ErrorOut2(const char *s, int p0, int p1);
Nvoid GUI_ErrorOut3(const char *s, int p0, int p1, int p2);
Nvoid GUI_ErrorOut4(const char *s, int p0, int p1, int p2, int p3);
N
N/*********************************************************************
N*
N*             2d - GL
N*
N**********************************************************************
N*/
N
Nint  GUI_BMP_Draw         (const void * pFileData, int x0, int y0);
Nint  GUI_BMP_GetXSize     (const void * pFileData);
Nint  GUI_BMP_GetYSize     (const void * pFileData);
Nvoid GUI_Clear            (void);
Nvoid GUI_ClearRect        (int x0, int y0, int x1, int y1);
Nvoid GUI_ClearRectEx      (const GUI_RECT* pRect);
Nvoid GUI_DrawArc          (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GUI_DrawBitmap       (const GUI_BITMAP GUI_UNI_PTR * pBM, int x0, int y0);
Xvoid GUI_DrawBitmap       (const GUI_BITMAP  * pBM, int x0, int y0);
Nvoid GUI_DrawBitmapMag    (const GUI_BITMAP GUI_UNI_PTR * pBM, int x0, int y0, int XMul, int YMul);
Xvoid GUI_DrawBitmapMag    (const GUI_BITMAP  * pBM, int x0, int y0, int XMul, int YMul);
Nvoid GUI_DrawBitmapEx     (const GUI_BITMAP GUI_UNI_PTR * pBitmap, int x0, int y0, int xCenter, int yCenter, int xMag, int yMag);
Xvoid GUI_DrawBitmapEx     (const GUI_BITMAP  * pBitmap, int x0, int y0, int xCenter, int yCenter, int xMag, int yMag);
Nvoid GUI_DrawBitmapExp    (int x0, int y0, int XSize, int YSize, int XMul,  int YMul, int BitsPerPixel, int BytesPerLine, const U8 GUI_UNI_PTR * pData, const GUI_LOGPALETTE GUI_UNI_PTR * pPal);
Xvoid GUI_DrawBitmapExp    (int x0, int y0, int XSize, int YSize, int XMul,  int YMul, int BitsPerPixel, int BytesPerLine, const unsigned char  * pData, const GUI_LOGPALETTE  * pPal);
Nvoid GUI_DrawCircle       (int x0, int y0, int r);
Nvoid GUI_DrawEllipse      (int x0, int y0, int rx, int ry);
Nvoid GUI_DrawGraph        (I16 *pay, int NumPoints, int x0, int y0);
Xvoid GUI_DrawGraph        (signed short *pay, int NumPoints, int x0, int y0);
Nvoid GUI_DrawGraphEx      (I16 *pay, int NumPoints, int x0, int y0, int Numerator, int Denominator);
Xvoid GUI_DrawGraphEx      (signed short *pay, int NumPoints, int x0, int y0, int Numerator, int Denominator);
Nvoid GUI_DrawHLine        (int y0, int x0, int x1);
Nvoid GUI_DrawLine         (int x0, int y0, int x1, int y1);
Nvoid GUI_DrawLineRel      (int dx, int dy);
Nvoid GUI_DrawLineTo       (int x, int y);
Nvoid GUI_DrawPie          (int x0, int y0, int r, int a0, int a1, int Type);
Nvoid GUI_DrawPixel        (int x, int y);
Nvoid GUI_DrawPoint        (int x, int y);
Nvoid GUI_DrawPolygon      (const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_DrawPolyLine     (const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_DrawFocusRect    (const GUI_RECT *pRect, int Dist);
Nvoid GUI_DrawRect         (int x0, int y0, int x1, int y1);
Nvoid GUI_DrawRectEx       (const GUI_RECT *pRect);
Nvoid GUI_DrawVLine        (int x0, int y0, int y1);
Nvoid GUI_FillCircle       (int x0, int y0, int r);
Nvoid GUI_FillEllipse      (int x0, int y0, int rx, int ry);
Nvoid GUI_FillPolygon      (const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_FillRect         (int x0, int y0, int x1, int y1);
Nvoid GUI_FillRectEx       (const GUI_RECT* pRect);
Nvoid GUI_GetClientRect    (GUI_RECT* pRect);
Nint  GUI_GIF_Draw         (const void * pGIF, U32 NumBytes, int x0, int y0);
Xint  GUI_GIF_Draw         (const void * pGIF, unsigned long NumBytes, int x0, int y0);
Nint  GUI_GIF_DrawEx       (const void * pGIF, U32 NumBytes, int x0, int y0, int Index);
Xint  GUI_GIF_DrawEx       (const void * pGIF, unsigned long NumBytes, int x0, int y0, int Index);
Nint  GUI_GIF_GetComment   (const void * pGIF, U32 NumBytes, U8 * pBuffer, int MaxSize, int Index);
Xint  GUI_GIF_GetComment   (const void * pGIF, unsigned long NumBytes, unsigned char * pBuffer, int MaxSize, int Index);
Nint  GUI_GIF_GetXSize     (const void * pGIF);
Nint  GUI_GIF_GetYSize     (const void * pGIF);
Nint  GUI_GIF_GetImageInfo (const void * pGIF, U32 NumBytes, GUI_GIF_IMAGE_INFO * pInfo, int Index);
Xint  GUI_GIF_GetImageInfo (const void * pGIF, unsigned long NumBytes, GUI_GIF_IMAGE_INFO * pInfo, int Index);
Nint  GUI_GIF_GetInfo      (const void * pGIF, U32 NumBytes, GUI_GIF_INFO * pInfo);
Xint  GUI_GIF_GetInfo      (const void * pGIF, unsigned long NumBytes, GUI_GIF_INFO * pInfo);
Nvoid GUI_InvertRect       (int x0, int y0, int x1, int y1);
Nvoid GUI_MoveRel          (int dx, int dy);
Nvoid GUI_MoveTo           (int x, int y);
N
N/*********************************************************************
N*
N*       JPEG support
N*
N**********************************************************************
N*/
Ntypedef struct {
N  int XSize;
N  int YSize;
N} GUI_JPEG_INFO;
N
Ntypedef int GUI_JPEG_GET_DATA_FUNC(void * p, int MaxNumBytes, const U8 ** ppData, unsigned StartOfFile);
Xtypedef int GUI_JPEG_GET_DATA_FUNC(void * p, int MaxNumBytes, const unsigned char ** ppData, unsigned StartOfFile);
N
Nint  GUI_JPEG_Draw        (const void * pFileData, int DataSize, int x0, int y0);
Nint  GUI_JPEG_DrawEx      (GUI_JPEG_GET_DATA_FUNC * fpGetData, void * p, int x0, int y0);
Nint  GUI_JPEG_DrawScaled  (const void * pFileData, int DataSize, int x0, int y0, int Num, int Denom);
Nint  GUI_JPEG_DrawScaledEx(GUI_JPEG_GET_DATA_FUNC * fpGetData, void * p, int x0, int y0, int Num, int Denom);
Nint  GUI_JPEG_GetInfo     (const void * pFileData, int DataSize, GUI_JPEG_INFO* pInfo);
Nint  GUI_JPEG_GetInfoEx   (GUI_JPEG_GET_DATA_FUNC * fpGetData, void * p, GUI_JPEG_INFO * pInfo);
N
N/*********************************************************************
N*
N*              Cursor routines
N*
N**********************************************************************
N*/
N
Ntypedef struct {
N  const GUI_UNI_PTR GUI_BITMAP * pBitmap;
X  const  GUI_BITMAP * pBitmap;
N  int xHot, yHot;
N} GUI_CURSOR;
N
N#if GUI_SUPPORT_CURSOR
X#if (0 | (1))
N  void               GUI_CURSOR_Activate   (void);
N  void               GUI_CURSOR_Deactivate (void);
N  int                GUI_CURSOR_GetState   (void);
N  void               GUI_CURSOR_Hide       (void);
N  void               GUI_CURSOR_SetXor     (const GUI_BITMAP * pBM, int x, int y);
N  void               GUI_CURSOR_SetPosition(int x, int y);
N  const GUI_CURSOR GUI_UNI_PTR * GUI_CURSOR_Select     (const GUI_CURSOR GUI_UNI_PTR * pCursor);
X  const GUI_CURSOR  * GUI_CURSOR_Select     (const GUI_CURSOR  * pCursor);
N  void               GUI_CURSOR_Show       (void);
N#else
S  #define GUI_CURSOR_Show()
S  #define GUI_CURSOR_Clear();
N#endif
N
N/*********************************************************************
N*
N*       Cursors and their bitmaps
N*
N**********************************************************************
N*/
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowS,  GUI_CursorArrowSI;
Xextern const GUI_CURSOR GUI_CursorArrowS,  GUI_CursorArrowSI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowM,  GUI_CursorArrowMI;
Xextern const GUI_CURSOR GUI_CursorArrowM,  GUI_CursorArrowMI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowL,  GUI_CursorArrowLI;
Xextern const GUI_CURSOR GUI_CursorArrowL,  GUI_CursorArrowLI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossS,  GUI_CursorCrossSI;
Xextern const GUI_CURSOR GUI_CursorCrossS,  GUI_CursorCrossSI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossM,  GUI_CursorCrossMI;
Xextern const GUI_CURSOR GUI_CursorCrossM,  GUI_CursorCrossMI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossL,  GUI_CursorCrossLI;
Xextern const GUI_CURSOR GUI_CursorCrossL,  GUI_CursorCrossLI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorHeaderM, GUI_CursorHeaderMI;
Xextern const GUI_CURSOR GUI_CursorHeaderM, GUI_CursorHeaderMI;
N
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapArrowS, GUI_BitmapArrowSI;
Xextern const GUI_BITMAP GUI_BitmapArrowS, GUI_BitmapArrowSI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapArrowM, GUI_BitmapArrowMI;
Xextern const GUI_BITMAP GUI_BitmapArrowM, GUI_BitmapArrowMI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapArrowL, GUI_BitmapArrowLI;
Xextern const GUI_BITMAP GUI_BitmapArrowL, GUI_BitmapArrowLI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapCrossS, GUI_BitmapCrossSI;
Xextern const GUI_BITMAP GUI_BitmapCrossS, GUI_BitmapCrossSI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapCrossM, GUI_BitmapCrossMI;
Xextern const GUI_BITMAP GUI_BitmapCrossM, GUI_BitmapCrossMI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapCrossL, GUI_BitmapCrossLI;
Xextern const GUI_BITMAP GUI_BitmapCrossL, GUI_BitmapCrossLI;
N
N/*********************************************************************
N*
N*              Text related routines
N*
N**********************************************************************
N*/
N
Nvoid  GUI_DispCEOL (void);
Nvoid  GUI_DispChar  (U16 c);
Xvoid  GUI_DispChar  (unsigned short c);
Nvoid  GUI_DispChars (U16 c, int Cnt);
Xvoid  GUI_DispChars (unsigned short c, int Cnt);
Nvoid  GUI_DispCharAt(U16 c, I16P x, I16P y);
Xvoid  GUI_DispCharAt(unsigned short c, signed short x, signed short y);
Nvoid  GUI_DispString         (const char GUI_UNI_PTR *s);
Xvoid  GUI_DispString         (const char  *s);
Nvoid  GUI_DispStringAt       (const char GUI_UNI_PTR *s, int x, int y);
Xvoid  GUI_DispStringAt       (const char  *s, int x, int y);
Nvoid  GUI_DispStringAtCEOL   (const char GUI_UNI_PTR *s, int x, int y);
Xvoid  GUI_DispStringAtCEOL   (const char  *s, int x, int y);
Nvoid  GUI_DispStringHCenterAt(const char GUI_UNI_PTR *s, int x, int y);
Xvoid  GUI_DispStringHCenterAt(const char  *s, int x, int y);
Nvoid  GUI__DispStringInRect  (const char GUI_UNI_PTR *s, GUI_RECT* pRect, int TextAlign, int MaxNumChars);
Xvoid  GUI__DispStringInRect  (const char  *s, GUI_RECT* pRect, int TextAlign, int MaxNumChars);
Nvoid  GUI_DispStringInRect   (const char GUI_UNI_PTR *s, GUI_RECT* pRect, int Flags);
Xvoid  GUI_DispStringInRect   (const char  *s, GUI_RECT* pRect, int Flags);
N#if GUI_SUPPORT_ROTATION
X#if 1
N  void  GUI_DispStringInRectEx (const char GUI_UNI_PTR *s, GUI_RECT* pRect, int TextAlign, int MaxLen, const GUI_ROTATION * pLCD_Api);
X  void  GUI_DispStringInRectEx (const char  *s, GUI_RECT* pRect, int TextAlign, int MaxLen, const tLCD_APIList * pLCD_Api);
N#endif
Nvoid  GUI_DispStringInRectMax(const char GUI_UNI_PTR *s, GUI_RECT* pRect, int TextAlign, int MaxLen); /* Not to be doc. */
Xvoid  GUI_DispStringInRectMax(const char  *s, GUI_RECT* pRect, int TextAlign, int MaxLen);  
Nvoid  GUI_DispStringInRectWrap(const char GUI_UNI_PTR *s, GUI_RECT* pRect, int TextAlign, GUI_WRAPMODE WrapMode); /* Not to be doc. */
Xvoid  GUI_DispStringInRectWrap(const char  *s, GUI_RECT* pRect, int TextAlign, GUI_WRAPMODE WrapMode);  
Nvoid  GUI_DispStringLen      (const char GUI_UNI_PTR *s, int Len);
Xvoid  GUI_DispStringLen      (const char  *s, int Len);
Nvoid  GUI_GetTextExtend(GUI_RECT* pRect, const char GUI_UNI_PTR * s, int Len);
Xvoid  GUI_GetTextExtend(GUI_RECT* pRect, const char  * s, int Len);
Nint   GUI_GetYAdjust(void);
Nint   GUI_GetDispPosX(void);
Nint   GUI_GetDispPosY(void);
Nconst GUI_FONT GUI_UNI_PTR * GUI_GetFont(void);
Xconst GUI_FONT  * GUI_GetFont(void);
Nint   GUI_GetCharDistX(U16 c);
Xint   GUI_GetCharDistX(unsigned short c);
Nint   GUI_GetStringDistX(const char GUI_UNI_PTR *s);
Xint   GUI_GetStringDistX(const char  *s);
NGUI_DRAWMODE GUI_GetDrawMode(void);
Nint   GUI_GetFontDistY(void);
Nint   GUI_GetFontSizeY(void);
Nvoid  GUI_GetFontInfo   (const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO* pfi);
Xvoid  GUI_GetFontInfo   (const GUI_FONT  * pFont, GUI_FONTINFO* pfi);
Nvoid  GUI_GetOrg(int * px, int * py);
Nint   GUI_GetYSizeOfFont(const GUI_FONT GUI_UNI_PTR * pFont);
Xint   GUI_GetYSizeOfFont(const GUI_FONT  * pFont);
Nint   GUI_GetYDistOfFont(const GUI_FONT GUI_UNI_PTR * pFont);
Xint   GUI_GetYDistOfFont(const GUI_FONT  * pFont);
Nint   GUI_GetTextAlign(void);
Nint   GUI_GetTextMode(void);
Nchar  GUI_IsInFont(const GUI_FONT GUI_UNI_PTR * pFont, U16 c);
Xchar  GUI_IsInFont(const GUI_FONT  * pFont, unsigned short c);
Nint   GUI_SetTextAlign(int Align);
Nint   GUI_SetTextMode(int Mode);
Nchar  GUI_SetTextStyle(char Style);
Nint   GUI_SetLBorder(int x);
Nvoid  GUI_SetOrg(int x, int y);
Nconst GUI_FONT GUI_UNI_PTR * GUI_SetFont(const GUI_FONT GUI_UNI_PTR * pNewFont);
Xconst GUI_FONT  * GUI_SetFont(const GUI_FONT  * pNewFont);
Nchar  GUI_GotoXY(int x, int y);
Nchar  GUI_GotoX(int x);
Nchar  GUI_GotoY(int y);
Nvoid  GUI_DispNextLine(void);
N
N/*********************************************************************
N*
N*       Position independent fonts
N*
N**********************************************************************
N*/
Nvoid GUI_SIF_CreateFont(void * pFontData, GUI_FONT * pFont, const GUI_SIF_TYPE * pFontType);
Xvoid GUI_SIF_CreateFont(void * pFontData, GUI_FONT * pFont, const tGUI_SIF_APIList * pFontType);
Nvoid GUI_SIF_DeleteFont(GUI_FONT * pFont);
N
N/*********************************************************************
N*
N*         Unicode support
N*
N**********************************************************************
N*/
N
Nint   GUI_UC_ConvertUC2UTF8   (const U16 GUI_UNI_PTR * s, int Len, char * pBuffer, int BufferSize);
Xint   GUI_UC_ConvertUC2UTF8   (const unsigned short  * s, int Len, char * pBuffer, int BufferSize);
Nint   GUI_UC_ConvertUTF82UC   (const char GUI_UNI_PTR * s, int Len, U16 * pBuffer, int BufferSize);
Xint   GUI_UC_ConvertUTF82UC   (const char  * s, int Len, unsigned short * pBuffer, int BufferSize);
Nint   GUI_UC_Encode           (char* s, U16 Char);
Xint   GUI_UC_Encode           (char* s, unsigned short Char);
Nint   GUI_UC_GetCharSize      (const char GUI_UNI_PTR * s);
Xint   GUI_UC_GetCharSize      (const char  * s);
NU16   GUI_UC_GetCharCode      (const char GUI_UNI_PTR * s);
Xunsigned short   GUI_UC_GetCharCode      (const char  * s);
Nvoid  GUI_UC_SetEncodeNone    (void);
Nvoid  GUI_UC_SetEncodeUTF8    (void);
N
Nvoid GUI_UC_DispString(const U16 GUI_UNI_PTR *s);
Xvoid GUI_UC_DispString(const unsigned short  *s);
Nvoid GUI_UC2DB (U16 Code, U8* pOut);
Xvoid GUI_UC2DB (unsigned short Code, unsigned char* pOut);
NU16  GUI_DB2UC (U8 Byte0, U8 Byte1);
Xunsigned short  GUI_DB2UC (unsigned char Byte0, unsigned char Byte1);
N
N/*    *********************************
N      *                               *
N      *         GUIVAL.C              *
N      *                               *
N      *********************************
N*/
N
Nvoid GUI_DispBin  (U32  v, U8 Len);
Xvoid GUI_DispBin  (unsigned long  v, unsigned char Len);
Nvoid GUI_DispBinAt(U32  v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispBinAt(unsigned long  v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispDec  (I32 v, U8 Len);
Xvoid GUI_DispDec  (signed long v, unsigned char Len);
Nvoid GUI_DispDecAt (I32 v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispDecAt (signed long v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispDecMin(I32 v);
Xvoid GUI_DispDecMin(signed long v);
Nvoid GUI_DispDecShift(I32 v, U8 Len, U8 Shift);
Xvoid GUI_DispDecShift(signed long v, unsigned char Len, unsigned char Shift);
Nvoid GUI_DispDecSpace(I32 v, U8 MaxDigits);
Xvoid GUI_DispDecSpace(signed long v, unsigned char MaxDigits);
Nvoid GUI_DispHex  (U32 v, U8 Len);
Xvoid GUI_DispHex  (unsigned long v, unsigned char Len);
Nvoid GUI_DispHexAt(U32 v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispHexAt(unsigned long v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispSDec(I32 v, U8 Len);
Xvoid GUI_DispSDec(signed long v, unsigned char Len);
Nvoid GUI_DispSDecShift(I32 v, U8 Len, U8 Shift);
Xvoid GUI_DispSDecShift(signed long v, unsigned char Len, unsigned char Shift);
N
N/*    *********************************
N      *                               *
N      *         GUIVALF.C             *
N      *                               *
N      *********************************
N
NRoutines to display floating point values. These routines use the routines
Ndefined in the module GUIVAL.C as base routines.
N
N*/
N
Nvoid GUI_DispFloat    (float v, char Len);
Nvoid GUI_DispFloatFix (float v, char Len, char Fract);
Nvoid GUI_DispFloatMin (float v, char Fract);
Nvoid GUI_DispSFloatFix(float v, char Len, char Fract);
Nvoid GUI_DispSFloatMin(float v, char Fract);
N
N
N/*********************************************************************
N*
N*         Dynamic memory management
N*
N**********************************************************************
N*/
N
N#if !defined(GUI_ALLOC_ALLOC)
X#if !0L
N  /* diagnostics */
N  GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBytes (void);
X  signed short GUI_ALLOC_GetNumFreeBytes (void);
N  GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBlocks(void);
X  signed short GUI_ALLOC_GetNumFreeBlocks(void);
N  GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBytes (void);
X  signed short GUI_ALLOC_GetNumUsedBytes (void);
N  GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBlocks(void);
X  signed short GUI_ALLOC_GetNumUsedBlocks(void);
N#else
S  #define GUI_ALLOC_GetNumFreeBytes()  0
S  #define GUI_ALLOC_GetNumFreeBlocks() 0
S  #define GUI_ALLOC_GetNumUsedBytes()  0
S  #define GUI_ALLOC_GetNumUsedBlocks() 0
N#endif
N
NGUI_HMEM           GUI_ALLOC_AllocInit  (const void *pInitData, GUI_ALLOC_DATATYPE Size);
Xsigned short           GUI_ALLOC_AllocInit  (const void *pInitData, signed short Size);
NGUI_HMEM           GUI_ALLOC_AllocNoInit(GUI_ALLOC_DATATYPE size);
Xsigned short           GUI_ALLOC_AllocNoInit(signed short size);
NGUI_HMEM           GUI_ALLOC_AllocZero  (GUI_ALLOC_DATATYPE size);
Xsigned short           GUI_ALLOC_AllocZero  (signed short size);
Nvoid               GUI_ALLOC_Free       (GUI_HMEM  hMem);
Xvoid               GUI_ALLOC_Free       (signed short  hMem);
Nvoid               GUI_ALLOC_FreePtrArray(GUI_HMEM * pArray, int NumElems);
Xvoid               GUI_ALLOC_FreePtrArray(signed short * pArray, int NumElems);
Nvoid               GUI_ALLOC_FreePtr    (GUI_HMEM *phMem);
Xvoid               GUI_ALLOC_FreePtr    (signed short *phMem);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetSize    (GUI_HMEM  hMem);
Xsigned short GUI_ALLOC_GetSize    (signed short  hMem);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxSize (void);
Xsigned short GUI_ALLOC_GetMaxSize (void);
Nvoid*              GUI_ALLOC_h2p        (GUI_HMEM  hMem);
Xvoid*              GUI_ALLOC_h2p        (signed short  hMem);
Nvoid               GUI_ALLOC_Init       (void);
NGUI_HMEM           GUI_ALLOC_Realloc    (GUI_HMEM hOld, int NewSize);
Xsigned short           GUI_ALLOC_Realloc    (signed short hOld, int NewSize);
Nvoid               GUI_ALLOC_Lock       (void);
Nvoid               GUI_ALLOC_Unlock     (void);
N
N
N/*********************************************************************
N*
N*      Memory device: GUI_MEMDEV
N*
N**********************************************************************
N*/
N
N#define GUI_MEMDEV_HASTRANS       0
N#define GUI_MEMDEV_NOTRANS    (1<<0)
N
N#if GUI_SUPPORT_DEVICES
X#if (1 | (1 > 1))
N  typedef GUI_HMEM GUI_MEMDEV_Handle;
X  typedef signed short GUI_MEMDEV_Handle;
N  typedef void GUI_CALLBACK_VOID_P(void* p);
N
N  typedef struct {
N    GUI_RECT rView, rPrev;
N    char FirstCall;
N  } GUI_AUTODEV;
N
N  typedef struct {
N    char DrawFixed;
N    char IsMeasurement;
N  } GUI_AUTODEV_INFO;
N
N  int  GUI_MEMDEV_CreateAuto(GUI_AUTODEV * pAutoDev);
N  void GUI_MEMDEV_DeleteAuto(GUI_AUTODEV * pAutoDev);
N  int  GUI_MEMDEV_DrawAuto  (GUI_AUTODEV * pAutoDev, GUI_AUTODEV_INFO * pAutoDevInfo, GUI_CALLBACK_VOID_P * pfDraw, void * pData);
N
N  /* Create a memory device which is compatible to the selected LCD */
N  GUI_MEMDEV_Handle GUI_MEMDEV_Create     (int x0, int y0, int XSize, int YSize);
N  GUI_MEMDEV_Handle GUI_MEMDEV_CreateEx   (int x0, int y0, int XSize, int YSize, int Flags);
N  GUI_MEMDEV_Handle GUI_MEMDEV_CreateFixed(int x0, int y0, int xsize, int ysize, int Flags,
N                                           const tLCDDEV_APIList * pMemDevAPI,
N                                           const LCD_API_COLOR_CONV * pColorConvAPI);
N  void GUI_MEMDEV_Clear         (GUI_MEMDEV_Handle hMem);
N  void GUI_MEMDEV_CopyFromLCD   (GUI_MEMDEV_Handle hMem);
N  void GUI_MEMDEV_CopyFromLCDAA (GUI_MEMDEV_Handle hMem);
N  void GUI_MEMDEV_CopyToLCD     (GUI_MEMDEV_Handle hMem);
N  void GUI_MEMDEV_CopyToLCDAA   (GUI_MEMDEV_Handle hMem);
N  void GUI_MEMDEV_CopyToLCDAt   (GUI_MEMDEV_Handle hMem, int x, int y);
N  int  GUI_MEMDEV_CompareWithLCD(GUI_MEMDEV_Handle hMem, int*px, int*py, int *pExp, int*pAct);
N  void GUI_MEMDEV_Delete        (GUI_MEMDEV_Handle MemDev);
N  int  GUI_MEMDEV_GetXSize      (GUI_MEMDEV_Handle hMem);
N  int  GUI_MEMDEV_GetYSize      (GUI_MEMDEV_Handle hMem);
N  void GUI_MEMDEV_MarkDirty     (GUI_MEMDEV_Handle hMem, int x0, int y0, int x1, int y1);
N  void GUI_MEMDEV_ReduceYSize   (GUI_MEMDEV_Handle hMem, int YSize);
N  GUI_MEMDEV_Handle GUI_MEMDEV_Select (GUI_MEMDEV_Handle hMem);  /* Select (activate) a particular memory device. */
N  void  GUI_MEMDEV_SetOrg        (GUI_MEMDEV_Handle hMem, int x0, int y0);
N  void  GUI_MEMDEV_WriteAt       (GUI_MEMDEV_Handle hMem, int x, int y);
N  void  GUI_MEMDEV_Write         (GUI_MEMDEV_Handle hMem);
N  void  GUI_MEMDEV_WriteAlphaAt  (GUI_MEMDEV_Handle hMem, int Alpha, int x, int y);
N  void  GUI_MEMDEV_WriteAlpha    (GUI_MEMDEV_Handle hMem, int Alpha);
N  void  GUI_MEMDEV_WriteExAt     (GUI_MEMDEV_Handle hMem, int x, int y, int xMag, int yMag, int Alpha);
N  void  GUI_MEMDEV_WriteEx       (GUI_MEMDEV_Handle hMem, int xMag, int yMag, int Alpha);
N  int   GUI_MEMDEV_Draw          (GUI_RECT* pRect, GUI_CALLBACK_VOID_P* pfDraw, void* pData, int MemSize, int Flags);
N  void* GUI_MEMDEV_GetDataPtr    (GUI_MEMDEV_Handle hMem);
N  void  GUI_MEMDEV_SetColorConv  (GUI_MEMDEV_Handle hMem, const LCD_API_COLOR_CONV * pColorConvAPI);
N#endif
N
Nvoid GUI_SelectLCD(void);
Nunsigned int GUI_SelectLayer(unsigned int Index);
N
N/**************************************************************
N*
N*      Measure device: GUI_MEASDEV
N*
N***************************************************************
N*/
N
Ntypedef GUI_HMEM GUI_MEASDEV_Handle;
Xtypedef signed short GUI_MEASDEV_Handle;
N
NGUI_MEASDEV_Handle GUI_MEASDEV_Create (void);
Nvoid               GUI_MEASDEV_Delete (GUI_MEASDEV_Handle hMemDev);
Nvoid               GUI_MEASDEV_Select (GUI_MEASDEV_Handle hMem);
Nvoid               GUI_MEASDEV_GetRect(GUI_MEASDEV_Handle hMem, GUI_RECT *pRect);
Nvoid               GUI_MEASDEV_ClearRect(GUI_MEASDEV_Handle hMem);
N
N/************************************************************
N*
N*                 Polygon helpers
N*
N*************************************************************
N*/
Nvoid GUI_RotatePolygon(GUI_POINT* pDest, const GUI_POINT* pSrc, int NumPoints, float Angle);
Nvoid GUI_MagnifyPolygon(GUI_POINT* pDest, const GUI_POINT* pSrc, int NumPoints, int Mag);
Nvoid GUI_EnlargePolygon(GUI_POINT* pDest, const GUI_POINT* pSrc, int NumPoints, int Len);
N
N/************************************************************
N*
N*                 Streamed bitmap
N*
N*************************************************************
N*/
Nvoid GUI_DrawStreamedBitmap(const GUI_BITMAP_STREAM *pBitmapStream, int x, int y);
N
N/************************************************************
N*
N*                 BMP-export
N*
N*************************************************************
N*/
Ntypedef void GUI_CALLBACK_VOID_U8_P(U8 Data, void * p);
Xtypedef void GUI_CALLBACK_VOID_U8_P(unsigned char Data, void * p);
N
Nvoid GUI_BMP_SerializeEx(GUI_CALLBACK_VOID_U8_P * pfSerialize, int x0, int y0, int xSize, int ySize, void * p);
Nvoid GUI_BMP_Serialize  (GUI_CALLBACK_VOID_U8_P * pfSerialize, void * p);
N
N/*********************************************************************
N*
N*      Time / execution related routines
N*
N**********************************************************************
N*/
Nvoid GUI_Delay  (int Period);
Nint  GUI_GetTime(void);
Nint  GUI_Exec(void);         /* Execute all jobs ... Return 0 if nothing was done. */
Nint  GUI_Exec1(void);        /* Execute one job  ... Return 0 if nothing was done. */
N
N/*********************************************************************
N*
N*                 MessageBox
N*
N**********************************************************************
N
N  Note: These should be moved into a separate file.
N*/
Nint     GUI_MessageBox   (const char * sMessage, const char * sCaption, int Flags);
N#define GUI_MESSAGEBOX_CF_MOVEABLE (1 << 0)
N#define GUI_MESSAGEBOX_CF_MODAL    (1 << 1)
N
N#define GUI_MB_OK                20
N#define GUI_MB_WARNING           21
N
N/*********************************************************************
N*
N*                 GUI_TIMER module
N*
N**********************************************************************
N*/
N
Ntypedef struct {
N  GUI_TIMER_TIME Time;
X  int Time;
N  U32            Context;
X  unsigned long            Context;
N  GUI_HMEM hTimer;
X  signed short hTimer;
N} GUI_TIMER_MESSAGE;
N
Ntypedef GUI_HMEM GUI_TIMER_HANDLE;
Xtypedef signed short GUI_TIMER_HANDLE;
Ntypedef void GUI_TIMER_CALLBACK(/*const*/ GUI_TIMER_MESSAGE* pTM);
N
NGUI_TIMER_HANDLE GUI_TIMER_Create   (GUI_TIMER_CALLBACK* cb, int Time,  U32 Context, int Flags);
XGUI_TIMER_HANDLE GUI_TIMER_Create   (GUI_TIMER_CALLBACK* cb, int Time,  unsigned long Context, int Flags);
Nvoid             GUI_TIMER_Delete   (GUI_TIMER_HANDLE hObj);
N
N/* Methods changing properties */
Nvoid GUI_TIMER_SetPeriod (GUI_TIMER_HANDLE hObj, GUI_TIMER_TIME Period);
Xvoid GUI_TIMER_SetPeriod (GUI_TIMER_HANDLE hObj, int Period);
Nvoid GUI_TIMER_SetTime   (GUI_TIMER_HANDLE hObj, GUI_TIMER_TIME Period);
Xvoid GUI_TIMER_SetTime   (GUI_TIMER_HANDLE hObj, int Period);
Nvoid GUI_TIMER_SetDelay  (GUI_TIMER_HANDLE hObj, GUI_TIMER_TIME Delay);
Xvoid GUI_TIMER_SetDelay  (GUI_TIMER_HANDLE hObj, int Delay);
Nvoid GUI_TIMER_Restart   (GUI_TIMER_HANDLE hObj);
Nint  GUI_TIMER_Exec(void);
N
N
N/******************************************************************
N*
N*                 Anti Aliasing
N*
N*******************************************************************
N*/
N
Nvoid GUI_AA_DisableHiRes     (void);
Nvoid GUI_AA_EnableHiRes      (void);
Nint  GUI_AA_GetFactor        (void);
Nvoid GUI_AA_SetFactor        (int Factor);
Nvoid GUI_AA_DrawArc          (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GUI_AA_DrawLine         (int x0, int y0, int x1, int y1);
Nvoid GUI_AA_DrawPolyOutline  (const GUI_POINT * pSrc, int NumPoints, int Thickness, int x, int y);
Nvoid GUI_AA_DrawPolyOutlineEx(const GUI_POINT * pSrc, int NumPoints, int Thickness, int x, int y, GUI_POINT * pBuffer);
Nvoid GUI_AA_FillCircle       (int x0, int y0, int r);
Nvoid GUI_AA_FillPolygon      (GUI_POINT* pPoints, int NumPoints, int x0, int y0);
N
N/******************************************************************
N*
N*                 Keyboard
N*
N*******************************************************************
N*/
N
N/* Message layer */
Nvoid GUI_StoreKeyMsg(int Key, int Pressed);
Nvoid GUI_SendKeyMsg (int Key, int Pressed);
Nint  GUI_PollKeyMsg(void);
N
N/* Message hook */
Ntypedef int GUI_KEY_MSG_HOOK(int Key, int Pressed);
Nextern  GUI_KEY_MSG_HOOK* GUI_pfKeyMsgHook;
NGUI_KEY_MSG_HOOK* GUI_SetKeyMsgHook(GUI_KEY_MSG_HOOK* pHook);
N
N/* Application layer */
Nint  GUI_GetKey(void);
Nint  GUI_WaitKey(void);
Nvoid GUI_StoreKey(int c);
Nvoid GUI_ClearKeyBuffer(void);
N
N/*********************************************************************
N*
N*       Task syncronisation (depends on configuration)
N*/
Nvoid GUI_WaitEvent(void);
N
N/*********************************************************************
N*
N*          PID  (Pointer input device ... mouse/touch) 
N*/
N
Nvoid GUI_PID_StoreState(const GUI_PID_STATE *pState);
Nint  GUI_PID_GetState  (      GUI_PID_STATE *pState);
N
N/*********************************************************************
N*
N*        Mouse, generic
N*/
Nint  GUI_MOUSE_GetState  (      GUI_PID_STATE *pState);
Nvoid GUI_MOUSE_StoreState(const GUI_PID_STATE *pState);
N
N/*********************************************************************
N*
N*          TOUCH screen, generic
N*/
N
Nint  GUI_TOUCH_GetState     (GUI_PID_STATE *pState);
Nvoid GUI_TOUCH_GetUnstable  (int* px, int* py);  /* for diagnostics only */
Nvoid GUI_TOUCH_StoreState   (int x, int y);
Nvoid GUI_TOUCH_StoreStateEx (const GUI_PID_STATE *pState);
Nvoid GUI_TOUCH_StoreUnstable(int x, int y);
N
N
N/*********************************************************************
N*
N*        Mouse, PS2 driver
N*/
Nvoid GUI_MOUSE_DRIVER_PS2_Init(void);               /* optional */
Nvoid GUI_MOUSE_DRIVER_PS2_OnRx(unsigned char Data);
N
N
N/*********************************************************************
N*
N*          TOUCH screen, analog driver
N*/
Nvoid GUI_TOUCH_Exec(void);
Nint  GUI_TOUCH_Calibrate(int Coord, int Log0, int Log1, int Phys0, int Phys1);
Nvoid GUI_TOUCH_SetDefaultCalibration(void);
Nint  GUI_TOUCH_GetxPhys(void);    /* for diagnostics only */
Nint  GUI_TOUCH_GetyPhys(void);    /* for diagnostics only */
Nvoid GUI_TOUCH_GetCalData(int Coord, int* pMin,int* pMax);
Nvoid GUI_TOUCH_SetCalData(int Coord, int* pMin,int* pMax);
N
N
N/*********************************************************************
N*
N*          TOUCH
N*
N*          imports
N*
N**********************************************************************
N
NPlease note: The following functions are required by the module.
NThey need to be part of your application software (or rather, part
Nof the hardware-layer of your software).
N*/
N
Nvoid GUI_TOUCH_X_ActivateX(void);
Nvoid GUI_TOUCH_X_ActivateY(void);
Nvoid GUI_TOUCH_X_Disable(void);
Nint  GUI_TOUCH_X_MeasureX(void);
Nint  GUI_TOUCH_X_MeasureY(void);
N
N/**************************************************************
N*
N*   Constants for fonts and bitmaps
N*
N***************************************************************
N*/
N
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE4;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE8;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLEM16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods555;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM555;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods888;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM888;
N
N#define GUI_COMPRESS_RLE4 0
N#define GUI_COMPRESS_RLE8 0
N
N#define GUI_DRAW_RLE4    &GUI_BitmapMethodsRLE4   /* Method table ! */
N#define GUI_DRAW_RLE8    &GUI_BitmapMethodsRLE8   /* Method table ! */
N#define GUI_DRAW_RLE16   &GUI_BitmapMethodsRLE16  /* Method table ! */
N#define GUI_DRAW_RLEM16  &GUI_BitmapMethodsRLEM16 /* Method table ! */
N#define GUI_DRAW_BMP555  &GUI_BitmapMethods555    /* Method table ! */
N#define GUI_DRAW_BMPM555 &GUI_BitmapMethodsM555   /* Method table ! */
N#define GUI_DRAW_BMP565  &GUI_BitmapMethods565    /* Method table ! */
N#define GUI_DRAW_BMPM565 &GUI_BitmapMethodsM565   /* Method table ! */
N#define GUI_DRAW_BMP888  &GUI_BitmapMethods888    /* Method table ! */
N#define GUI_DRAW_BMPM888 &GUI_BitmapMethodsM888   /* Method table ! */
N
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA2;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA4;
N
N/**************************************************************
N*
N*      Defines for constants
N*
N***************************************************************
N*/
N
N#define	________	0x0
N#define	_______X	0x1
N#define	______X_	0x2
N#define	______XX	0x3
N#define	_____X__	0x4
N#define	_____X_X	0x5
N#define	_____XX_	0x6
N#define	_____XXX	0x7
N#define	____X___	0x8
N#define	____X__X	0x9
N#define	____X_X_	0xa
N#define	____X_XX	0xb
N#define	____XX__	0xc
N#define	____XX_X	0xd
N#define	____XXX_	0xe
N#define	____XXXX	0xf
N#define	___X____	0x10
N#define	___X___X	0x11
N#define	___X__X_	0x12
N#define	___X__XX	0x13
N#define	___X_X__	0x14
N#define	___X_X_X	0x15
N#define	___X_XX_	0x16
N#define	___X_XXX	0x17
N#define	___XX___	0x18
N#define	___XX__X	0x19
N#define	___XX_X_	0x1a
N#define	___XX_XX	0x1b
N#define	___XXX__	0x1c
N#define	___XXX_X	0x1d
N#define	___XXXX_	0x1e
N#define	___XXXXX	0x1f
N#define	__X_____	0x20
N#define	__X____X	0x21
N#define	__X___X_	0x22
N#define	__X___XX	0x23
N#define	__X__X__	0x24
N#define	__X__X_X	0x25
N#define	__X__XX_	0x26
N#define	__X__XXX	0x27
N#define	__X_X___	0x28
N#define	__X_X__X	0x29
N#define	__X_X_X_	0x2a
N#define	__X_X_XX	0x2b
N#define	__X_XX__	0x2c
N#define	__X_XX_X	0x2d
N#define	__X_XXX_	0x2e
N#define	__X_XXXX	0x2f
N#define	__XX____	0x30
N#define	__XX___X	0x31
N#define	__XX__X_	0x32
N#define	__XX__XX	0x33
N#define	__XX_X__	0x34
N#define	__XX_X_X	0x35
N#define	__XX_XX_	0x36
N#define	__XX_XXX	0x37
N#define	__XXX___	0x38
N#define	__XXX__X	0x39
N#define	__XXX_X_	0x3a
N#define	__XXX_XX	0x3b
N#define	__XXXX__	0x3c
N#define	__XXXX_X	0x3d
N#define	__XXXXX_	0x3e
N#define	__XXXXXX	0x3f
N#define	_X______	0x40
N#define	_X_____X	0x41
N#define	_X____X_	0x42
N#define	_X____XX	0x43
N#define	_X___X__	0x44
N#define	_X___X_X	0x45
N#define	_X___XX_	0x46
N#define	_X___XXX	0x47
N#define	_X__X___	0x48
N#define	_X__X__X	0x49
N#define	_X__X_X_	0x4a
N#define	_X__X_XX	0x4b
N#define	_X__XX__	0x4c
N#define	_X__XX_X	0x4d
N#define	_X__XXX_	0x4e
N#define	_X__XXXX	0x4f
N#define	_X_X____	0x50
N#define	_X_X___X	0x51
N#define	_X_X__X_	0x52
N#define	_X_X__XX	0x53
N#define	_X_X_X__	0x54
N#define	_X_X_X_X	0x55
N#define	_X_X_XX_	0x56
N#define	_X_X_XXX	0x57
N#define	_X_XX___	0x58
N#define	_X_XX__X	0x59
N#define	_X_XX_X_	0x5a
N#define	_X_XX_XX	0x5b
N#define	_X_XXX__	0x5c
N#define	_X_XXX_X	0x5d
N#define	_X_XXXX_	0x5e
N#define	_X_XXXXX	0x5f
N#define	_XX_____	0x60
N#define	_XX____X	0x61
N#define	_XX___X_	0x62
N#define	_XX___XX	0x63
N#define	_XX__X__	0x64
N#define	_XX__X_X	0x65
N#define	_XX__XX_	0x66
N#define	_XX__XXX	0x67
N#define	_XX_X___	0x68
N#define	_XX_X__X	0x69
N#define	_XX_X_X_	0x6a
N#define	_XX_X_XX	0x6b
N#define	_XX_XX__	0x6c
N#define	_XX_XX_X	0x6d
N#define	_XX_XXX_	0x6e
N#define	_XX_XXXX	0x6f
N#define	_XXX____	0x70
N#define	_XXX___X	0x71
N#define	_XXX__X_	0x72
N#define	_XXX__XX	0x73
N#define	_XXX_X__	0x74
N#define	_XXX_X_X	0x75
N#define	_XXX_XX_	0x76
N#define	_XXX_XXX	0x77
N#define	_XXXX___	0x78
N#define	_XXXX__X	0x79
N#define	_XXXX_X_	0x7a
N#define	_XXXX_XX	0x7b
N#define	_XXXXX__	0x7c
N#define	_XXXXX_X	0x7d
N#define	_XXXXXX_	0x7e
N#define	_XXXXXXX	0x7f
N#define	X_______	0x80
N#define	X______X	0x81
N#define	X_____X_	0x82
N#define	X_____XX	0x83
N#define	X____X__	0x84
N#define	X____X_X	0x85
N#define	X____XX_	0x86
N#define	X____XXX	0x87
N#define	X___X___	0x88
N#define	X___X__X	0x89
N#define	X___X_X_	0x8a
N#define	X___X_XX	0x8b
N#define	X___XX__	0x8c
N#define	X___XX_X	0x8d
N#define	X___XXX_	0x8e
N#define	X___XXXX	0x8f
N#define	X__X____	0x90
N#define	X__X___X	0x91
N#define	X__X__X_	0x92
N#define	X__X__XX	0x93
N#define	X__X_X__	0x94
N#define	X__X_X_X	0x95
N#define	X__X_XX_	0x96
N#define	X__X_XXX	0x97
N#define	X__XX___	0x98
N#define	X__XX__X	0x99
N#define	X__XX_X_	0x9a
N#define X__XX_XX	0x9b
N#define X__XXX__	0x9c
N#define X__XXX_X	0x9d
N#define	X__XXXX_	0x9e
N#define	X__XXXXX	0x9f
N#define	X_X_____	0xa0
N#define	X_X____X	0xa1
N#define	X_X___X_	0xa2
N#define	X_X___XX	0xa3
N#define	X_X__X__	0xa4
N#define	X_X__X_X	0xa5
N#define	X_X__XX_	0xa6
N#define	X_X__XXX	0xa7
N#define	X_X_X___	0xa8
N#define	X_X_X__X	0xa9
N#define	X_X_X_X_	0xaa
N#define	X_X_X_XX	0xab
N#define	X_X_XX__	0xac
N#define	X_X_XX_X	0xad
N#define	X_X_XXX_	0xae
N#define	X_X_XXXX	0xaf
N#define	X_XX____	0xb0
N#define X_XX___X	0xb1
N#define	X_XX__X_	0xb2
N#define	X_XX__XX	0xb3
N#define	X_XX_X__	0xb4
N#define	X_XX_X_X	0xb5
N#define	X_XX_XX_	0xb6
N#define	X_XX_XXX	0xb7
N#define	X_XXX___	0xb8
N#define	X_XXX__X	0xb9
N#define	X_XXX_X_	0xba
N#define	X_XXX_XX	0xbb
N#define	X_XXXX__	0xbc
N#define	X_XXXX_X	0xbd
N#define	X_XXXXX_	0xbe
N#define	X_XXXXXX	0xbf
N#define	XX______	0xc0
N#define	XX_____X	0xc1
N#define	XX____X_	0xc2
N#define	XX____XX	0xc3
N#define	XX___X__	0xc4
N#define	XX___X_X	0xc5
N#define	XX___XX_	0xc6
N#define	XX___XXX	0xc7
N#define	XX__X___	0xc8
N#define	XX__X__X	0xc9
N#define	XX__X_X_	0xca
N#define	XX__X_XX	0xcb
N#define	XX__XX__	0xcc
N#define	XX__XX_X	0xcd
N#define	XX__XXX_	0xce
N#define XX__XXXX	0xcf
N#define	XX_X____	0xd0
N#define	XX_X___X	0xd1
N#define	XX_X__X_	0xd2
N#define	XX_X__XX	0xd3
N#define	XX_X_X__	0xd4
N#define	XX_X_X_X	0xd5
N#define	XX_X_XX_	0xd6
N#define	XX_X_XXX	0xd7
N#define	XX_XX___	0xd8
N#define	XX_XX__X	0xd9
N#define	XX_XX_X_	0xda
N#define	XX_XX_XX	0xdb
N#define	XX_XXX__	0xdc
N#define	XX_XXX_X	0xdd
N#define	XX_XXXX_	0xde
N#define	XX_XXXXX	0xdf
N#define	XXX_____	0xe0
N#define	XXX____X	0xe1
N#define	XXX___X_	0xe2
N#define	XXX___XX	0xe3
N#define	XXX__X__	0xe4
N#define	XXX__X_X	0xe5
N#define	XXX__XX_	0xe6
N#define	XXX__XXX	0xe7
N#define	XXX_X___	0xe8
N#define	XXX_X__X	0xe9
N#define	XXX_X_X_	0xea
N#define	XXX_X_XX	0xeb
N#define	XXX_XX__	0xec
N#define	XXX_XX_X	0xed
N#define	XXX_XXX_	0xee
N#define	XXX_XXXX	0xef
N#define	XXXX____	0xf0
N#define	XXXX___X	0xf1
N#define	XXXX__X_	0xf2
N#define	XXXX__XX	0xf3
N#define	XXXX_X__	0xf4
N#define	XXXX_X_X	0xf5
N#define	XXXX_XX_	0xf6
N#define	XXXX_XXX	0xf7
N#define	XXXXX___	0xf8
N#define	XXXXX__X	0xf9
N#define	XXXXX_X_	0xfa
N#define	XXXXX_XX	0xfb
N#define	XXXXXX__	0xfc
N#define	XXXXXX_X	0xfd
N#define	XXXXXXX_	0xfe
N#define	XXXXXXXX	0xff
N
N/**************************************************************
N*
N*      Compatibility with older versions
N*
N***************************************************************
N*/
N
N#define GUI_DispString_UC  GUI_UC_DispString
N#define TOUCH_X_ActivateX  GUI_TOUCH_X_ActivateX
N#define TOUCH_X_ActivateY  GUI_TOUCH_X_ActivateY
N#define TOUCH_X_Disable    GUI_TOUCH_X_Disable
N#define TOUCH_X_MeasureX   GUI_TOUCH_X_MeasureX
N#define TOUCH_X_MeasureY   GUI_TOUCH_X_MeasureY
N#define GUI_SelLayer       GUI_SelectLayer
N#if defined(__cplusplus)
X#if 0L
S}
N#endif 
N
N#endif   /* ifdef GUI_H */
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 24 "..\GUI\Core\GUI_Protected.h" 2
N#include "LCD_Protected.h"
L 1 "..\GUI\Core\LCD_Protected.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : LCD_Protected.h
NPurpose     : Internals of the LCD level
N----------------------------------------------------------------------
N*/
N
N#ifndef LCD_INTERN_H
N#define LCD_INTERN_H
N
N#include "LCD.h"
N
N/*********************************************************************
N*
N*      Data types
N*
N**********************************************************************
N*/
N
Ntypedef struct {
N  int              NumEntries; 
N  const LCD_COLOR* pPalEntries; 
N} LCD_PHYSPALETTE; 
N
N/*********************************************************************
N*
N*      Data
N*
N**********************************************************************
N*/
Nextern GUI_CONST_STORAGE U8 LCD_aMirror[256];
Xextern const unsigned char LCD_aMirror[256];
N
N
N/********************************************************
N*
N*     Color conversion routines (used internally only !
N*
N*********************************************************
N*/
Nunsigned LCD_Color2Index_User    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_0       (LCD_COLOR Color, const LCD_PHYSPALETTE* pPhysPal);
Nunsigned LCD_Color2Index_1       (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M1      (LCD_COLOR Color);
Nunsigned LCD_Color2Index_2       (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M2      (LCD_COLOR Color);
Nunsigned LCD_Color2Index_4       (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M4      (LCD_COLOR Color);
Nunsigned LCD_Color2Index_111     (LCD_COLOR Color);
Nunsigned LCD_Color2Index_222     (LCD_COLOR Color);
Nunsigned LCD_Color2Index_233     (LCD_COLOR Color);
Nunsigned LCD_Color2Index_323     (LCD_COLOR Color);
Nunsigned LCD_Color2Index_332     (LCD_COLOR Color);
Nunsigned LCD_Color2Index_444_12  (LCD_COLOR Color);
Nunsigned LCD_Color2Index_444_12_1(LCD_COLOR Color);
Nunsigned LCD_Color2Index_444_16  (LCD_COLOR Color);
Nunsigned LCD_Color2Index_555     (LCD_COLOR Color);
Nunsigned LCD_Color2Index_565     (LCD_COLOR Color);
Nunsigned LCD_Color2Index_556     (LCD_COLOR Color);
Nunsigned LCD_Color2Index_655     (LCD_COLOR Color);
Nunsigned LCD_Color2Index_666     (LCD_COLOR Color);
Nunsigned LCD_Color2Index_8666    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_8666_1  (LCD_COLOR Color);
Nunsigned LCD_Color2Index_888     (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M888    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M111    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M222    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M233    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M323    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M332    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M444_12 (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M444_16 (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M555    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M565    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M556    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M655    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M666    (LCD_COLOR Color);
N
NLCD_COLOR LCD_Index2Color_User    (int Index);
NLCD_COLOR LCD_Index2Color_0       (int Index, const LCD_PHYSPALETTE* pPhysPal);
NLCD_COLOR LCD_Index2Color_1       (int Index);
NLCD_COLOR LCD_Index2Color_2       (int Index);
NLCD_COLOR LCD_Index2Color_4       (int Index);
NLCD_COLOR LCD_Index2Color_111     (int Index);
NLCD_COLOR LCD_Index2Color_222     (int Index);
NLCD_COLOR LCD_Index2Color_233     (int Index);
NLCD_COLOR LCD_Index2Color_323     (int Index);
NLCD_COLOR LCD_Index2Color_332     (int Index);
NLCD_COLOR LCD_Index2Color_444_12  (int Index);
NLCD_COLOR LCD_Index2Color_444_12_1(int Index);
NLCD_COLOR LCD_Index2Color_444_16  (int Index);
NLCD_COLOR LCD_Index2Color_555     (int Index);
NLCD_COLOR LCD_Index2Color_565     (int Index);
NLCD_COLOR LCD_Index2Color_556     (int Index);
NLCD_COLOR LCD_Index2Color_655     (int Index);
NLCD_COLOR LCD_Index2Color_666     (int Index);
NLCD_COLOR LCD_Index2Color_8666    (int Index);
NLCD_COLOR LCD_Index2Color_8666_1  (int Index);
NLCD_COLOR LCD_Index2Color_888     (int Index);
NLCD_COLOR LCD_Index2Color_M888    (int Index);
NLCD_COLOR LCD_Index2Color_M111    (int Index);
NLCD_COLOR LCD_Index2Color_M222    (int Index);
NLCD_COLOR LCD_Index2Color_M233    (int Index);
NLCD_COLOR LCD_Index2Color_M323    (int Index);
NLCD_COLOR LCD_Index2Color_M332    (int Index);
NLCD_COLOR LCD_Index2Color_M444_12 (int Index);
NLCD_COLOR LCD_Index2Color_M444_16 (int Index);
NLCD_COLOR LCD_Index2Color_M555    (int Index);
NLCD_COLOR LCD_Index2Color_M565    (int Index);
NLCD_COLOR LCD_Index2Color_M556    (int Index);
NLCD_COLOR LCD_Index2Color_M655    (int Index);
NLCD_COLOR LCD_Index2Color_M666    (int Index);
N
Nunsigned LCD_GetIndexMask_User    (void);
Nunsigned LCD_GetIndexMask_0       (void);
Nunsigned LCD_GetIndexMask_1       (void);
Nunsigned LCD_GetIndexMask_M1      (void);
Nunsigned LCD_GetIndexMask_2       (void);
Nunsigned LCD_GetIndexMask_M2      (void);
Nunsigned LCD_GetIndexMask_4       (void);
Nunsigned LCD_GetIndexMask_M4      (void);
Nunsigned LCD_GetIndexMask_111     (void);
Nunsigned LCD_GetIndexMask_222     (void);
Nunsigned LCD_GetIndexMask_233     (void);
Nunsigned LCD_GetIndexMask_323     (void);
Nunsigned LCD_GetIndexMask_332     (void);
Nunsigned LCD_GetIndexMask_444_12  (void);
Nunsigned LCD_GetIndexMask_444_12_1(void);
Nunsigned LCD_GetIndexMask_444_16  (void);
Nunsigned LCD_GetIndexMask_555     (void);
Nunsigned LCD_GetIndexMask_565     (void);
Nunsigned LCD_GetIndexMask_556     (void);
Nunsigned LCD_GetIndexMask_655     (void);
Nunsigned LCD_GetIndexMask_666     (void);
Nunsigned LCD_GetIndexMask_8666    (void);
Nunsigned LCD_GetIndexMask_8666_1  (void);
Nunsigned LCD_GetIndexMask_888     (void);
Nunsigned LCD_GetIndexMask_M888    (void);
Nunsigned LCD_GetIndexMask_M111    (void);
Nunsigned LCD_GetIndexMask_M222    (void);
Nunsigned LCD_GetIndexMask_M233    (void);
Nunsigned LCD_GetIndexMask_M323    (void);
Nunsigned LCD_GetIndexMask_M332    (void);
Nunsigned LCD_GetIndexMask_M444_12 (void);
Nunsigned LCD_GetIndexMask_M444_16 (void);
Nunsigned LCD_GetIndexMask_M555    (void);
Nunsigned LCD_GetIndexMask_M565    (void);
Nunsigned LCD_GetIndexMask_M556    (void);
Nunsigned LCD_GetIndexMask_M655    (void);
Nunsigned LCD_GetIndexMask_M666    (void);
N
Nvoid LCD_SelectLCD(void);
N
N/*********************************************************************
N*
N*              Declarations for LCD_L0_
N*
N**********************************************************************
N
N  Prefixes are as follows:
N  LCD_L0_xxx       ... Driver for first  LCD
N  LCD_L0_1_xxx     ... Driver for second LCD/layer
N  LCD_L0_2_xxx     ... Driver for third  LCD/layer
N  LCD_L0_MAG_xxx   ... Driver for first  LCD, magnification level (calling LCD_L0_xxx after magnification)
N  LCD_L0_DELTA_xxx ... Driver for first  LCD, delta mode
N
N*/
N
Nunsigned int LCD_L0_Color2Index       (LCD_COLOR Color);
Nunsigned int LCD_L0_1_Color2Index     (LCD_COLOR Color);
Nunsigned int LCD_L0_2_Color2Index     (LCD_COLOR Color);
Nunsigned int LCD_L0_3_Color2Index     (LCD_COLOR Color);
Nunsigned int LCD_L0_4_Color2Index     (LCD_COLOR Color);
Nvoid         LCD_L0_DrawHLine         (int x0, int y0,  int x1);
Nvoid         LCD_L0_1_DrawHLine       (int x0, int y0,  int x1);
Nvoid         LCD_L0_2_DrawHLine       (int x0, int y0,  int x1);
Nvoid         LCD_L0_3_DrawHLine       (int x0, int y0,  int x1);
Nvoid         LCD_L0_4_DrawHLine       (int x0, int y0,  int x1);
Nvoid         LCD_L0_MAG_DrawHLine     (int x0, int y0,  int x1);
Nvoid         LCD_L0_DELTA_DrawHLine     (int x0, int y0,  int x1);
Nvoid         LCD_L0_DrawVLine         (int x,  int y0,  int y1);
Nvoid         LCD_L0_1_DrawVLine       (int x,  int y0,  int y1);
Nvoid         LCD_L0_2_DrawVLine       (int x,  int y0,  int y1);
Nvoid         LCD_L0_3_DrawVLine       (int x,  int y0,  int y1);
Nvoid         LCD_L0_4_DrawVLine       (int x,  int y0,  int y1);
Nvoid         LCD_L0_MAG_DrawVLine     (int x,  int y0,  int y1);
Nvoid         LCD_L0_DELTA_DrawVLine     (int x,  int y0,  int y1);
Nvoid         LCD_L0_FillRect          (int x0, int y0, int x1, int y1);
Nvoid         LCD_L0_1_FillRect        (int x0, int y0, int x1, int y1);
Nvoid         LCD_L0_2_FillRect        (int x0, int y0, int x1, int y1);
Nvoid         LCD_L0_3_FillRect        (int x0, int y0, int x1, int y1);
Nvoid         LCD_L0_4_FillRect        (int x0, int y0, int x1, int y1);
Nvoid         LCD_L0_MAG_FillRect      (int x0, int y0, int x1, int y1);
Nvoid         LCD_L0_DELTA_FillRect      (int x0, int y0, int x1, int y1);
Nunsigned int LCD_L0_GetPixelIndex     (int x,  int y);
Nunsigned int LCD_L0_1_GetPixelIndex   (int x,  int y);
Nunsigned int LCD_L0_2_GetPixelIndex   (int x,  int y);
Nunsigned int LCD_L0_3_GetPixelIndex   (int x,  int y);
Nunsigned int LCD_L0_4_GetPixelIndex   (int x,  int y);
Nunsigned int LCD_L0_MAG_GetPixelIndex (int x,  int y);
Nunsigned int LCD_L0_DELTA_GetPixelIndex (int x,  int y);
Nvoid         LCD_L0_GetRect           (LCD_RECT * pRect);
Nvoid         LCD_L0_1_GetRect         (LCD_RECT * pRect);
Nvoid         LCD_L0_2_GetRect         (LCD_RECT * pRect);
Nvoid         LCD_L0_3_GetRect         (LCD_RECT * pRect);
Nvoid         LCD_L0_4_GetRect         (LCD_RECT * pRect);
Nvoid         LCD_L0_SetPixelIndex     (int x,  int y, int ColorIndex);
Nvoid         LCD_L0_1_SetPixelIndex   (int x,  int y, int ColorIndex);
Nvoid         LCD_L0_2_SetPixelIndex   (int x,  int y, int ColorIndex);
Nvoid         LCD_L0_3_SetPixelIndex   (int x,  int y, int ColorIndex);
Nvoid         LCD_L0_4_SetPixelIndex   (int x,  int y, int ColorIndex);
Nvoid         LCD_L0_MAG_SetPixelIndex (int x,  int y, int ColorIndex);
Nvoid         LCD_L0_DELTA_SetPixelIndex (int x,  int y, int ColorIndex);
Nvoid         LCD_L0_XorPixel          (int x,  int y);
Nvoid         LCD_L0_1_XorPixel        (int x,  int y);
Nvoid         LCD_L0_2_XorPixel        (int x,  int y);
Nvoid         LCD_L0_3_XorPixel        (int x,  int y);
Nvoid         LCD_L0_4_XorPixel        (int x,  int y);
Nvoid         LCD_L0_MAG_XorPixel      (int x,  int y);
Nvoid         LCD_L0_DELTA_XorPixel      (int x,  int y);
Nint          LCD_L0_Init              (void);
Nint          LCD_L0_1_Init            (void);
Nint          LCD_L0_2_Init            (void);
Nint          LCD_L0_3_Init            (void);
Nint          LCD_L0_4_Init            (void);
Nint          LCD_L0_MAG_Init          (void);
Nint          LCD_L0_DELTA_Init          (void);
Nvoid         LCD_L0_On                (void);
Nvoid         LCD_L0_1_On              (void);
Nvoid         LCD_L0_2_On              (void);
Nvoid         LCD_L0_3_On              (void);
Nvoid         LCD_L0_4_On              (void);
Nvoid         LCD_L0_Off               (void);
Nvoid         LCD_L0_1_Off             (void);
Nvoid         LCD_L0_2_Off             (void);
Nvoid         LCD_L0_3_Off             (void);
Nvoid         LCD_L0_4_Off             (void);
Nvoid         LCD_L0_SetLUTEntry       (U8 Pos, LCD_COLOR color);
Xvoid         LCD_L0_SetLUTEntry       (unsigned char Pos, LCD_COLOR color);
Nvoid         LCD_L0_1_SetLUTEntry     (U8 Pos, LCD_COLOR color);
Xvoid         LCD_L0_1_SetLUTEntry     (unsigned char Pos, LCD_COLOR color);
Nvoid         LCD_L0_2_SetLUTEntry     (U8 Pos, LCD_COLOR color);
Xvoid         LCD_L0_2_SetLUTEntry     (unsigned char Pos, LCD_COLOR color);
Nvoid         LCD_L0_3_SetLUTEntry     (U8 Pos, LCD_COLOR color);
Xvoid         LCD_L0_3_SetLUTEntry     (unsigned char Pos, LCD_COLOR color);
Nvoid         LCD_L0_4_SetLUTEntry     (U8 Pos, LCD_COLOR color);
Xvoid         LCD_L0_4_SetLUTEntry     (unsigned char Pos, LCD_COLOR color);
Nvoid *       LCD_L0_GetDevFunc        (int Index);
Nvoid *       LCD_L0_1_GetDevFunc      (int Index);
Nvoid *       LCD_L0_2_GetDevFunc      (int Index);
Nvoid *       LCD_L0_3_GetDevFunc      (int Index);
Nvoid *       LCD_L0_4_GetDevFunc      (int Index);
NtLCDDEV_Index2Color * LCD_L0_GetpfIndex2Color(void);
NtLCDDEV_Index2Color * LCD_L0_1_GetpfIndex2Color(void);
NtLCDDEV_Index2Color * LCD_L0_2_GetpfIndex2Color(void);
NtLCDDEV_Index2Color * LCD_L0_3_GetpfIndex2Color(void);
NtLCDDEV_Index2Color * LCD_L0_4_GetpfIndex2Color(void);
N
Nvoid LCD_L0_ReInit       (void); /* Reinitialize LCD using config-paramters */
Nvoid LCD_L0_1_ReInit     (void);
Nvoid LCD_L0_2_ReInit     (void);
Nvoid LCD_L0_3_ReInit     (void);
Nvoid LCD_L0_4_ReInit     (void);
Nvoid LCD_L0_Refresh      (void); /* Refresh entire LCD */
N                                 /* Refresh LCD partially. Could be one line, depends on what
N                                    the LCD controller can handle efficiently */
Nvoid LCD_L0_1_Refresh    (void);
Nvoid LCD_L0_2_Refresh    (void);
Nvoid LCD_L0_3_Refresh    (void);
Nvoid LCD_L0_4_Refresh    (void);
Nvoid LCD_L0_SetOrg       (int x, int y);
Nvoid LCD_L0_1_SetOrg     (int x, int y);
Nvoid LCD_L0_2_SetOrg     (int x, int y);
Nvoid LCD_L0_3_SetOrg     (int x, int y);
Nvoid LCD_L0_4_SetOrg     (int x, int y);
N
N
N#endif /* LCD_INTERN_H */
N
N
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 25 "..\GUI\Core\GUI_Protected.h" 2
N#include "GUIDebug.h"
L 1 "..\GUI\Core\GUIDebug.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : GUIDebug.h
NPurpose     : Debug macros
N----------------------------------------------------------------------
N   Debug macros for logging
N
N In the GUI Simulation, all output is transferred into the log window.
N*/
N
N#ifndef GUI_DEBUG_H
N#define GUI_DEBUG_H
N
N#include "GUI.h"
N#include "GUI_X.h"
L 1 "..\GUI\Core\GUI_X.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : GUI_X.h
NPurpose     : Declarations for GUI_X module
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N#ifndef  GUI_X_H
N#define  GUI_X_H
N
N#include "GUI.h"
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/************************************************************
N*
N*                    GUI_X_
N*
N*         externals, to be defined by application
N*
N*************************************************************
N
NThe externals defined below should be defined by the
Napplication. They are per default contained in the module
NGUI_X.c.
NNote that a lot if not all of these are not required in most target
Nsystems.
NFor this module, samples are available for configurations
Nwith or without operating system.
N*/
N
N/**** Init ****/
Nvoid GUI_X_Init(void);
N
N/**** ExecIdle - called if nothing else is left to do ****/
Nvoid GUI_X_ExecIdle(void);
N
N/**** Timing routines - required for blinking ****/
Nint  GUI_X_GetTime(void);
Nvoid GUI_X_Delay(int Period);
N
N/**** Multitask routines - required only if multitasking is used (#define GUI_OS 1) ****/
Nvoid GUI_X_Unlock(void);
Nvoid GUI_X_Lock(void);
NU32  GUI_X_GetTaskId(void);
Xunsigned long  GUI_X_GetTaskId(void);
Nvoid GUI_X_InitOS(void);
N
N/****      Event driving (optional with multitasking)  ****/
Nvoid GUI_X_WaitEvent(void);
Nvoid GUI_X_SignalEvent(void);
N/**** Recording (logs/warnings and errors) - required only for higher levels ****/
Nvoid GUI_X_Log(const char *s);
Nvoid GUI_X_Warn(const char *s);
Nvoid GUI_X_ErrorOut(const char *s); 
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N#endif   /* ifdef GUI_X_H */
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 28 "..\GUI\Core\GUIDebug.h" 2
N
N#define GUI_DEBUG_LEVEL_NOCHECK       0  /* No run time checks are performed */
N#define GUI_DEBUG_LEVEL_CHECK_PARA    1  /* Parameter checks are performed to avoid crashes */
N#define GUI_DEBUG_LEVEL_CHECK_ALL     2  /* Parameter checks and consistency checks are performed */
N#define GUI_DEBUG_LEVEL_LOG_ERRORS    3  /* Errors are recorded */
N#define GUI_DEBUG_LEVEL_LOG_WARNINGS  4  /* Errors & Warnings are recorded */
N#define GUI_DEBUG_LEVEL_LOG_ALL       5  /* Errors, Warnings and Messages are recorded. */
N
N#ifndef GUI_DEBUG_LEVEL
N  #ifdef WIN32
S    #define GUI_DEBUG_LEVEL GUI_DEBUG_LEVEL_LOG_WARNINGS  /* Simulation should log all warnings */
N  #else
N    #define GUI_DEBUG_LEVEL GUI_DEBUG_LEVEL_CHECK_PARA  /* For most targets, min. size is important */
N  #endif
N#endif
N
N/*******************************************************************
N*
N*               Commandline
N*
N********************************************************************
N*/
N
N#ifdef WIN32
S  #define GUI_DEBUG_GETCMDLINE() SIM_GetCmdLine()
N#else
N  #define GUI_DEBUG_GETCMDLINE() 0
N#endif
N
N/*******************************************************************
N*
N*               Error macros
N*
N********************************************************************
N*/
N
N/* Make sure the macros are actually defined */
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_ERRORS
X#if 1 >= 3
S  #define GUI_DEBUG_ERROROUT(s)              GUI_ErrorOut(s)
S  #define GUI_DEBUG_ERROROUT1(s,p0)          GUI_ErrorOut1(s,p0)
S  #define GUI_DEBUG_ERROROUT2(s,p0,p1)       GUI_ErrorOut2(s,p0,p1)
S  #define GUI_DEBUG_ERROROUT3(s,p0,p1,p2)    GUI_ErrorOut3(s,p0,p1,p2)
S  #define GUI_DEBUG_ERROROUT4(s,p0,p1,p2,p3) GUI_ErrorOut4(s,p0,p1,p2,p3)
S  #define GUI_DEBUG_ERROROUT_IF(exp,s)              { if (exp) GUI_DEBUG_ERROROUT(s); }
S  #define GUI_DEBUG_ERROROUT1_IF(exp,s,p0)          { if (exp) GUI_DEBUG_ERROROUT1(s,p0); }
S  #define GUI_DEBUG_ERROROUT2_IF(exp,s,p0,p1)       { if (exp) GUI_DEBUG_ERROROUT2(s,p0,p1); }
S  #define GUI_DEBUG_ERROROUT3_IF(exp,s,p0,p1,p2)    { if (exp) GUI_DEBUG_ERROROUT3(s,p0,p1,p2); }
S  #define GUI_DEBUG_ERROROUT4_IF(exp,s,p0,p1,p2,p3) { if (exp) GUI_DEBUG_ERROROUT4(s,p0,p1,p2,p3); }
N#else
N  #define GUI_DEBUG_ERROROUT(s)
N  #define GUI_DEBUG_ERROROUT1(s,p0)
N  #define GUI_DEBUG_ERROROUT2(s,p0,p1)
N  #define GUI_DEBUG_ERROROUT3(s,p0,p1,p2)
N  #define GUI_DEBUG_ERROROUT4(s,p0,p1,p2,p3)
N  #define GUI_DEBUG_ERROROUT_IF(exp,s)
N  #define GUI_DEBUG_ERROROUT1_IF(exp,s,p0)
N  #define GUI_DEBUG_ERROROUT2_IF(exp,s,p0,p1)
N  #define GUI_DEBUG_ERROROUT3_IF(exp,s,p0,p1,p2)
N  #define GUI_DEBUG_ERROROUT4_IF(exp,s,p0,p1,p2,p3)
N#endif
N
N/*******************************************************************
N*
N*               Warning macros
N*
N********************************************************************
N*/
N
N/* Make sure the macros are actually defined */
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_WARNINGS
X#if 1 >= 4
S  #define GUI_DEBUG_WARN(s)              GUI_Warn(s)
S  #define GUI_DEBUG_WARN1(s,p0)          GUI_Warn1(s,p0)
S  #define GUI_DEBUG_WARN2(s,p0,p1)       GUI_Warn2(s,p0,p1)
S  #define GUI_DEBUG_WARN3(s,p0,p1,p2)    GUI_Warn3(s,p0,p1,p2)
S  #define GUI_DEBUG_WARN4(s,p0,p1,p2,p3) GUI_Warn4(s,p0,p1,p2,p3)
S  #define GUI_DEBUG_WARN_IF(exp,s)                  { if (exp) GUI_DEBUG_WARN(s); }
S  #define GUI_DEBUG_WARN1_IF(exp,s,p0)              { if (exp) GUI_DEBUG_WARN1(s,p0); }
S  #define GUI_DEBUG_WARN2_IF(exp,s,p0,p1)           { if (exp) GUI_DEBUG_WARN2(s,p0,p1); }
S  #define GUI_DEBUG_WARN3_IF(exp,s,p0,p1,p2)        { if (exp) GUI_DEBUG_WARN3(s,p0,p1,p2); }
S  #define GUI_DEBUG_WARN4_IF(exp,s,p0,p1,p2,p3)     { if (exp) GUI_DEBUG_WARN4(s,p0,p1,p2,p3); }
N#else
N  #define GUI_DEBUG_WARN(s)
N  #define GUI_DEBUG_WARN1(s,p0)
N  #define GUI_DEBUG_WARN2(s,p0,p1)
N  #define GUI_DEBUG_WARN3(s,p0,p1,p2)
N  #define GUI_DEBUG_WARN4(s,p0,p1,p2,p3)
N  #define GUI_DEBUG_WARN_IF(exp,s)
N  #define GUI_DEBUG_WARN1_IF(exp,s,p0)
N  #define GUI_DEBUG_WARN2_IF(exp,s,p0,p1)
N  #define GUI_DEBUG_WARN3_IF(exp,s,p0,p1,p2)
N  #define GUI_DEBUG_WARN4_IF(exp,s,p0,p1,p2,p3)
N#endif
N
N/*******************************************************************
N*
N*               Logging macros
N*
N********************************************************************
N*/
N/* Make sure the macros are actually defined */
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_ALL
X#if 1 >= 5
S  #define GUI_DEBUG_LOG(s)              GUI_Log(s)
S  #define GUI_DEBUG_LOG1(s,p0)          GUI_Warn1(s,p0)
S  #define GUI_DEBUG_LOG2(s,p0,p1)       GUI_Warn2(s,p0,p1)
S  #define GUI_DEBUG_LOG3(s,p0,p1,p2)    GUI_Warn3(s,p0,p1,p2)
S  #define GUI_DEBUG_LOG4(s,p0,p1,p2,p3) GUI_Warn4(s,p0,p1,p2,p3)
S  #define GUI_DEBUG_LOG_IF(exp,s)                   { if (exp) GUI_DEBUG_LOG(s); }
S  #define GUI_DEBUG_LOG1_IF(exp,s,p0)               { if (exp) GUI_DEBUG_LOG1(s,p0); }
S  #define GUI_DEBUG_LOG2_IF(exp,s,p0,p1)            { if (exp) GUI_DEBUG_LOG2(s,p0,p1); }
S  #define GUI_DEBUG_LOG3_IF(exp,s,p0,p1,p2)         { if (exp) GUI_DEBUG_LOG3(s,p0,p1,p2); }
S  #define GUI_DEBUG_LOG4_IF(exp,s,p0,p1,p2,p3)      { if (exp) GUI_DEBUG_LOG4(s,p0,p1,p2,p3); }
N#else
N  #define GUI_DEBUG_LOG(s)
N  #define GUI_DEBUG_LOG1(s,p0)
N  #define GUI_DEBUG_LOG2(s,p0,p1)
N  #define GUI_DEBUG_LOG3(s,p0,p1,p2)
N  #define GUI_DEBUG_LOG4(s,p0,p1,p2,p3)
N  #define GUI_DEBUG_LOG_IF(exp,s)
N  #define GUI_DEBUG_LOG1_IF(exp,s,p0)
N  #define GUI_DEBUG_LOG2_IF(exp,s,p0,p1)
N  #define GUI_DEBUG_LOG3_IF(exp,s,p0,p1,p2)
N  #define GUI_DEBUG_LOG4_IF(exp,s,p0,p1,p2,p3)
N#endif
N
N/*******************************************************************
N*
N*               Asserts
N*
N********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_ERRORS
X#if 1 >= 3
S  #define GUI_DEBUG_ASSERT(exp)                     { if (!exp) GUI_DEBUG_ERROROUT(#exp); }
N#else
N  #define GUI_DEBUG_ASSERT(exp)
N#endif
N
N#endif /* LCD_H */
N
N
N
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 26 "..\GUI\Core\GUI_Protected.h" 2
N#if GUI_WINSUPPORT
X#if 1
N  #include "WM_GUI.h"
N#endif
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/**********************************************************************
N*
N*                        Defaults for config switches
N*
N***********************************************************************
N
N  The config switches below do not affect the interface in GUI.h and
N  are therefor not required to be in GUI.h.
N*/
N
N/* Short address area.
N   For  most compilers, this is "near" or "__near"
N   We do not use this except for some CPUs which we know to always have some
N   near memory, because the GUI_Context ans some other data will be declared
N   to be in this short address (near) memory area as it has a major effect
N   on performance.
N   Please define in GUIConf.h (if you want to use it)
N*/
N#ifndef GUI_SADDR
N  #define GUI_SADDR
N#endif
N
N#ifndef GUI_DEFAULT_FONT
S  #define GUI_DEFAULT_FONT    &GUI_Font6x8
N#endif
N
N#ifndef GUI_DEFAULT_CURSOR
N  #define GUI_DEFAULT_CURSOR  &GUI_CursorArrowM
N#endif
N
N#ifndef GUI_DEFAULT_BKCOLOR
N  #define GUI_DEFAULT_BKCOLOR GUI_BLACK
N#endif
N
N#ifndef GUI_DEFAULT_COLOR
N  #define GUI_DEFAULT_COLOR   GUI_WHITE
N#endif
N
N#ifndef GUI_X_SIGNAL_EVENT
N  #define GUI_X_SIGNAL_EVENT()
N#endif
N
N#ifndef GUI_X_WAIT_EVENT
N  #define GUI_X_WAIT_EVENT() GUI_X_ExecIdle()
N#endif
N
N
N/*      *********************************
N        *                               *
N        *      Angles                   *
N        *                               *
N        *********************************
N*/
N
N#define GUI_45DEG  512
N#define GUI_90DEG  (2*GUI_45DEG)
N#define GUI_180DEG (4*GUI_45DEG)
N#define GUI_360DEG (8*GUI_45DEG)
N
N
N
N
N
N/*****************************************************
N*
N*        Locking checks
N*
N******************************************************
N*/
N
N#if defined (WIN32) && defined (_DEBUG) && GUI_OS
X#if 0L && 0L && (0)
S  #define GUI_ASSERT_LOCK()   GUITASK_AssertLock()
S  #define GUI_ASSERT_NO_LOCK() GUITASK_AssertNoLock()
S  void GUITASK_AssertLock(void);
S  void GUITASK_AssertNoLock(void);
N#else
N  #define GUI_ASSERT_LOCK()
N  #define GUI_ASSERT_NO_LOCK()
N#endif
N
N/*****************************************************
N*
N*        Usage internals
N*
N******************************************************
N*/
N
Ntypedef GUI_HMEM GUI_USAGE_Handle;
Xtypedef signed short GUI_USAGE_Handle;
Ntypedef struct tsUSAGE_APIList tUSAGE_APIList;
Ntypedef struct GUI_Usage GUI_USAGE;
N#define GUI_USAGE_h GUI_USAGE_Handle
N
N
N
Ntypedef GUI_USAGE_h tUSAGE_CreateCompatible(GUI_USAGE* p);
Xtypedef GUI_USAGE_Handle tUSAGE_CreateCompatible(GUI_USAGE* p);
Ntypedef void        tUSAGE_AddPixel        (GUI_USAGE* p, int x, int y);
Ntypedef void        tUSAGE_AddHLine        (GUI_USAGE* p, int x0, int y0, int len);
Ntypedef void        tUSAGE_Clear           (GUI_USAGE* p);
Ntypedef void        tUSAGE_Delete          (GUI_USAGE_h h);
Xtypedef void        tUSAGE_Delete          (GUI_USAGE_Handle h);
Ntypedef int         tUSAGE_GetNextDirty    (GUI_USAGE* p, int *pxOff, int yOff);
N#define GUI_USAGE_H2P(h) ((GUI_USAGE*)GUI_ALLOC_h2p(h))
N
N
Nvoid GUI_USAGE_DecUseCnt(GUI_USAGE_Handle  hUsage);
N
NGUI_USAGE_Handle GUI_USAGE_BM_Create(int x0, int y0, int xsize, int ysize, int Flags);
Nvoid    GUI_USAGE_Select(GUI_USAGE_Handle hUsage);
Nvoid    GUI_USAGE_AddRect(GUI_USAGE*  pUsage, int x0, int y0, int xSize, int ySize);
N#define GUI_USAGE_AddPixel(p, x,y)            p->pAPI->pfAddPixel(p,x,y)
N#define GUI_USAGE_AddHLine(p,x,y,len)         p->pAPI->pfAddHLine(p,x,y,len)
N#define GUI_USAGE_Clear(p)                    p->pAPI->pfClear(p)
N#define GUI_USAGE_Delete(p)                   p->pAPI->pfDelete(p)
N#define GUI_USAGE_GetNextDirty(p,pxOff, yOff) p->pAPI->pfGetNextDirty(p,pxOff, yOff)
N
Nstruct tsUSAGE_APIList {
N  tUSAGE_AddPixel*                pfAddPixel;
N  tUSAGE_AddHLine*                pfAddHLine;
N  tUSAGE_Clear*                   pfClear;
N  tUSAGE_CreateCompatible*        pfCreateCompatible;
N  tUSAGE_Delete*                  pfDelete;
N  tUSAGE_GetNextDirty*            pfGetNextDirty;
N} ;
N
Nstruct GUI_Usage {
N  I16P x0, y0, XSize, YSize;
X  signed short x0, y0, XSize, YSize;
N  const tUSAGE_APIList *pAPI;
N  I16 UseCnt;
X  signed short UseCnt;
N};
N
N/*****************************************************
N*
N*        GUI_MEMDEV
N*
N******************************************************
N*/
N
N#if GUI_SUPPORT_MEMDEV
X#if 1
N  typedef struct {
N    I16P                   x0, y0, XSize, YSize;
X    signed short                   x0, y0, XSize, YSize;
N    int                    NumColors;
N    unsigned               BytesPerLine;
N    unsigned               BitsPerPixel;
N    unsigned               LayerIndex;
N    GUI_HMEM               hUsage;
X    signed short               hUsage;
N    tLCDDEV_Color2Index*   pfColor2Index;
N    tLCDDEV_Index2Color*   pfIndex2Color;
N    tLCDDEV_GetIndexMask*  pfGetIndexMask;
N    const tLCDDEV_APIList* pAPIList;
N  } GUI_MEMDEV;
N
N  #define      GUI_MEMDEV_H2P(h) ((GUI_MEMDEV*)GUI_ALLOC_h2p(h))
N
N  void         GUI_MEMDEV__CopyFromLCD (GUI_MEMDEV_Handle hMem);
N  void         GUI_MEMDEV__GetRect     (GUI_RECT* pRect);
N  unsigned     GUI_MEMDEV__Color2Index (LCD_COLOR Color);
N  LCD_COLOR    GUI_MEMDEV__Index2Color (int Index);
N  unsigned int GUI_MEMDEV__GetIndexMask(void);
N
N  GUI_MEMDEV_Handle GUI_MEMDEV__CreateFixed(int x0, int y0, int xsize, int ysize, int Flags
N                                          ,const tLCDDEV_APIList * pMemDevAPI
N                                          ,tLCDDEV_Color2Index*        pfColor2Index
N                                          ,tLCDDEV_Index2Color*        pfIndex2Color
N                                          ,tLCDDEV_GetIndexMask*       pfGetIndexMask);
N
N#endif
N
N/*******************************************************************
N*
N*                   LCD_HL_ level defines
N*
N********************************************************************
N*/
N
N#if GUI_SUPPORT_AA
X#if 1
N  #define LCD_HL_DrawHLine             GUI_Context.pLCD_HL->pfDrawHLine
N  #define LCD_HL_DrawPixel             GUI_Context.pLCD_HL->pfDrawPixel
N#else
S  #define LCD_HL_DrawHLine             LCD_DrawHLine
S  #define LCD_HL_DrawPixel             LCD_DrawPixel
N#endif
N
N
N/*********************************************************************
N*
N*                     Helper functions
N*
N***********************************************************************
N*/
N
N#define GUI_ZEROINIT(Obj) GUI_MEMSET(Obj, 0, sizeof(Obj))
Nint  GUI_cos(int angle);
Nint  GUI_sin(int angle);
Nextern const U32 GUI_Pow10[10];
Xextern const unsigned long GUI_Pow10[10];
N
N/* GUIAALib.c --- direct anti-aliased drawing */
Nint  GUI_AA_Init(int x0, int x1);
Nint  GUI_AA_Init_HiRes(int x0, int x1);
Nvoid GUI_AA_Exit(void);
NI16 GUI_AA_HiRes2Pixel(int HiRes);
Xsigned short GUI_AA_HiRes2Pixel(int HiRes);
N
Nvoid GL_FillCircleAA_HiRes(int x0, int y0, int r);
N
Nvoid GUI_AA__DrawCharAA2NoTrans(int x0, int y0, int XSize, int YSize, int BytesPerLine, const U8*pData);
Xvoid GUI_AA__DrawCharAA2NoTrans(int x0, int y0, int XSize, int YSize, int BytesPerLine, const unsigned char*pData);
Nvoid GUI_AA__DrawCharAA2Trans  (int x0, int y0, int XSize, int YSize, int BytesPerLine, const U8*pData);
Xvoid GUI_AA__DrawCharAA2Trans  (int x0, int y0, int XSize, int YSize, int BytesPerLine, const unsigned char*pData);
Nvoid GUI_AA__DrawCharAA4       (int x0, int y0, int XSize, int YSize, int BytesPerLine, const U8*pData);
Xvoid GUI_AA__DrawCharAA4       (int x0, int y0, int XSize, int YSize, int BytesPerLine, const unsigned char*pData);
N
N/* System independent font routines */
Nint        GUI_SIF__GetCharDistX(U16P c);
Xint        GUI_SIF__GetCharDistX(unsigned short c);
Nvoid       GUI_SIF__GetFontInfo (const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO * pfi);
Xvoid       GUI_SIF__GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi);
Nchar       GUI_SIF__IsInFont    (const GUI_FONT GUI_UNI_PTR * pFont, U16 c);
Xchar       GUI_SIF__IsInFont    (const GUI_FONT  * pFont, unsigned short c);
Nconst U8 * GUI_SIF__GetpCharInfo(const GUI_FONT GUI_UNI_PTR * pFont, U16P c);
Xconst unsigned char * GUI_SIF__GetpCharInfo(const GUI_FONT  * pFont, unsigned short c);
N
N/* Conversion routines */
Nvoid GUI_AddHex     (U32 v, U8 Len, char**ps);
Xvoid GUI_AddHex     (unsigned long v, unsigned char Len, char**ps);
Nvoid GUI_AddBin     (U32 v, U8 Len, char**ps);
Xvoid GUI_AddBin     (unsigned long v, unsigned char Len, char**ps);
Nvoid GUI_AddDecMin  (I32 v, char**ps);
Xvoid GUI_AddDecMin  (signed long v, char**ps);
Nvoid GUI_AddDec     (I32 v, U8 Len, char**ps);
Xvoid GUI_AddDec     (signed long v, unsigned char Len, char**ps);
Nvoid GUI_AddDecShift(I32 v, U8 Len, U8 Shift, char**ps);
Xvoid GUI_AddDecShift(signed long v, unsigned char Len, unsigned char Shift, char**ps);
Nlong GUI_AddSign    (long v, char**ps);
Nint  GUI_Long2Len   (I32 v);
Xint  GUI_Long2Len   (signed long v);
N
N#if GUI_SUPPORT_UNICODE
X#if (1)
N  #define GUI_UC__GetCharSize(sText)  GUI_Context.pUC_API->pfGetCharSize(sText)
N  #define GUI_UC__GetCharCode(sText)  GUI_Context.pUC_API->pfGetCharCode(sText)
N#else
S  #define GUI_UC__GetCharSize(sText)  GUI_UC_GetCharSize(sText)
S  #define GUI_UC__GetCharCode(sText)  GUI_UC_GetCharCode(sText)
N#endif
N
Nint   GUI_UC__CalcSizeOfChar   (U16 Char);
Xint   GUI_UC__CalcSizeOfChar   (unsigned short Char);
NU16   GUI_UC__GetCharCodeInc   (const char GUI_UNI_PTR ** ps);
Xunsigned short   GUI_UC__GetCharCodeInc   (const char  ** ps);
Nint   GUI_UC__NumChars2NumBytes(const char GUI_UNI_PTR * s, int NumChars);
Xint   GUI_UC__NumChars2NumBytes(const char  * s, int NumChars);
Nint   GUI_UC__NumBytes2NumChars(const char GUI_UNI_PTR * s, int NumBytes);
Xint   GUI_UC__NumBytes2NumChars(const char  * s, int NumBytes);
N
Nint  GUI__GetLineNumChars  (const char GUI_UNI_PTR *s, int MaxNumChars);
Xint  GUI__GetLineNumChars  (const char  *s, int MaxNumChars);
Nint  GUI__GetNumChars      (const char GUI_UNI_PTR *s);
Xint  GUI__GetNumChars      (const char  *s);
Nint  GUI__GetLineDistX     (const char GUI_UNI_PTR *s, int Len);
Xint  GUI__GetLineDistX     (const char  *s, int Len);
Nint  GUI__GetFontSizeY     (void);
Nint  GUI__HandleEOLine     (const char GUI_UNI_PTR **ps);
Xint  GUI__HandleEOLine     (const char  **ps);
Nvoid GUI__DispLine         (const char GUI_UNI_PTR *s, int Len, const GUI_RECT* pr);
Xvoid GUI__DispLine         (const char  *s, int Len, const GUI_RECT* pr);
Nvoid GUI__AddSpaceHex      (U32 v, U8 Len, char**ps);
Xvoid GUI__AddSpaceHex      (unsigned long v, unsigned char Len, char**ps);
Nvoid GUI__CalcTextRect     (const char GUI_UNI_PTR* pText, const GUI_RECT* pTextRectIn, GUI_RECT* pTextRectOut, int TextAlign);
Xvoid GUI__CalcTextRect     (const char * pText, const GUI_RECT* pTextRectIn, GUI_RECT* pTextRectOut, int TextAlign);
N
Nint  GUI__WrapGetNumCharsDisp       (const char GUI_UNI_PTR * pText, int xSize, GUI_WRAPMODE WrapMode);
Xint  GUI__WrapGetNumCharsDisp       (const char  * pText, int xSize, GUI_WRAPMODE WrapMode);
Nint  GUI__WrapGetNumCharsToNextLine (const char GUI_UNI_PTR * pText, int xSize, GUI_WRAPMODE WrapMode);
Xint  GUI__WrapGetNumCharsToNextLine (const char  * pText, int xSize, GUI_WRAPMODE WrapMode);
Nint  GUI__WrapGetNumBytesToNextLine (const char GUI_UNI_PTR * pText, int xSize, GUI_WRAPMODE WrapMode);
Xint  GUI__WrapGetNumBytesToNextLine (const char  * pText, int xSize, GUI_WRAPMODE WrapMode);
Nvoid GUI__memset    (U8 * p, U8 Fill, int NumBytes);
Xvoid GUI__memset    (unsigned char * p, unsigned char Fill, int NumBytes);
Nvoid GUI__memset16  (U16* p, U16 Fill, int NumWords);
Xvoid GUI__memset16  (unsigned short* p, unsigned short Fill, int NumWords);
Nint  GUI__strlen    (const char GUI_UNI_PTR * s);
Xint  GUI__strlen    (const char  * s);
Nint  GUI__strcmp    (const char GUI_UNI_PTR * s0, const char GUI_UNI_PTR * s1);
Xint  GUI__strcmp    (const char  * s0, const char  * s1);
Nint  GUI__strcmp_hp (GUI_HMEM hs0, const char GUI_UNI_PTR * s1);
Xint  GUI__strcmp_hp (signed short hs0, const char  * s1);
N
N/* Get cursor position */
Nint  GUI__GetCursorPosX     (const char GUI_UNI_PTR * s, int Index, int MaxNumChars);
Xint  GUI__GetCursorPosX     (const char  * s, int Index, int MaxNumChars);
Nint  GUI__GetCursorPosChar  (const char GUI_UNI_PTR * s, int x, int NumCharsToNextLine);
Xint  GUI__GetCursorPosChar  (const char  * s, int x, int NumCharsToNextLine);
NU16  GUI__GetCursorCharacter(const char GUI_UNI_PTR * s, int Index, int MaxNumChars, int * pIsRTL);
Xunsigned short  GUI__GetCursorCharacter(const char  * s, int Index, int MaxNumChars, int * pIsRTL);
N
N/* Arabic support */
NU16  GUI__GetPresentationForm     (U16 Char, U16 Next, U16 Prev, int * pIgnoreNext);
Xunsigned short  GUI__GetPresentationForm     (unsigned short Char, unsigned short Next, unsigned short Prev, int * pIgnoreNext);
Nvoid GUI__DispLineArabic          (const char GUI_UNI_PTR * s, int MaxNumChars, const GUI_RECT * pRect);
Xvoid GUI__DispLineArabic          (const char  * s, int MaxNumChars, const GUI_RECT * pRect);
Nint  GUI__GetLineDistXArabic      (const char GUI_UNI_PTR * s, int MaxNumChars);
Xint  GUI__GetLineDistXArabic      (const char  * s, int MaxNumChars);
Nint  GUI__IsArabicCharacter       (U16 c);
Xint  GUI__IsArabicCharacter       (unsigned short c);
Nint  GUI__GetCursorPosXArabic     (const char GUI_UNI_PTR * s, int Index, int MaxNumChars);
Xint  GUI__GetCursorPosXArabic     (const char  * s, int Index, int MaxNumChars);
Nint  GUI__GetCursorPosCharArabic  (const char GUI_UNI_PTR * s, int x, int MaxNumChars);
Xint  GUI__GetCursorPosCharArabic  (const char  * s, int x, int MaxNumChars);
NU16  GUI__GetCursorCharacterArabic(const char GUI_UNI_PTR * s, int Index, int MaxNumChars, int * pIsRTL);
Xunsigned short  GUI__GetCursorCharacterArabic(const char  * s, int Index, int MaxNumChars, int * pIsRTL);
N
N/* Reading data routines */
NU16 GUI__Read16(const U8 ** ppData);
Xunsigned short GUI__Read16(const unsigned char ** ppData);
NU32 GUI__Read32(const U8 ** ppData);
Xunsigned long GUI__Read32(const unsigned char ** ppData);
N
N/* Virtual screen support */
Nvoid GUI__GetOrg(int * px, int * py);
N
N/*********************************************************************
N*
N*             2d - GL
N*
N**********************************************************************
N*/
N
Nvoid GL_DispChar         (U16 c);
Xvoid GL_DispChar         (unsigned short c);
Nvoid GL_DrawArc          (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GL_DrawBitmap       (const GUI_BITMAP GUI_UNI_PTR * pBM, int x0, int y0);
Xvoid GL_DrawBitmap       (const GUI_BITMAP  * pBM, int x0, int y0);
Nvoid GL_DrawCircle       (int x0, int y0, int r);
Nvoid GL_DrawEllipse      (int x0, int y0, int rx, int ry);
Nvoid GL_DrawHLine        (int y0, int x0, int x1);
Nvoid GL_DrawPolygon      (const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Nvoid GL_DrawPoint        (int x, int y);
Nvoid GL_DrawLine1        (int x0, int y0, int x1, int y1);
Nvoid GL_DrawLine1Ex      (int x0, int y0, int x1, int y1, unsigned * pPixelCnt);
Nvoid GL_DrawLineRel      (int dx, int dy);
Nvoid GL_DrawLineTo       (int x, int y);
Nvoid GL_DrawLineToEx     (int x, int y, unsigned * pPixelCnt);
Nvoid GL_DrawLine         (int x0, int y0, int x1, int y1);
Nvoid GL_DrawLineEx       (int x0, int y0, int x1, int y1, unsigned * pPixelCnt);
Nvoid GL_MoveTo           (int x, int y);
Nvoid GL_FillCircle       (int x0, int y0, int r);
Nvoid GL_FillCircleAA     (int x0, int y0, int r);
Nvoid GL_FillEllipse      (int x0, int y0, int rx, int ry);
Nvoid GL_FillPolygon      (const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Nvoid GL_SetDefault       (void);
N
N/************************************************************
N*
N*                 Callback pointers for dynamic linkage
N*
N*************************************************************
NDynamic linkage pointers reduces configuration hassles.
N*/
Ntypedef int  GUI_tfTimer(void);
Ntypedef char GUI_CURSOR_tfTempHide  (const GUI_RECT* pRect);
Ntypedef void GUI_CURSOR_tfTempUnhide(void);
Ntypedef int  WM_tfHandlePID(void);
N
N
N/************************************************************
N*
N*        Cursors 
N*
N*************************************************************
N*/
N
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_ArrowS[45];
Xextern const unsigned char  GUI_Pixels_ArrowS[45];
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_ArrowM[60];
Xextern const unsigned char  GUI_Pixels_ArrowM[60];
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_ArrowL[150];
Xextern const unsigned char  GUI_Pixels_ArrowL[150];
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_CrossS[33];
Xextern const unsigned char  GUI_Pixels_CrossS[33];
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_CrossM[126];
Xextern const unsigned char  GUI_Pixels_CrossM[126];
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_CrossL[248];
Xextern const unsigned char  GUI_Pixels_CrossL[248];
Nextern GUI_CONST_STORAGE unsigned char  GUI_PixelsHeaderM[5 * 17];
Xextern const unsigned char  GUI_PixelsHeaderM[5 * 17];
N
N
Nextern GUI_CONST_STORAGE GUI_LOGPALETTE GUI_CursorPal;
Xextern const GUI_LOGPALETTE GUI_CursorPal;
Nextern GUI_CONST_STORAGE GUI_LOGPALETTE GUI_CursorPalI;
Xextern const GUI_LOGPALETTE GUI_CursorPalI;
N
N/************************************************************
N*
N*        Text rotation
N*
N*************************************************************
N*/
N
Nextern GUI_RECT  GUI_RectDispString; /* Used by LCD_Rotate...() and GUI_DispStringInRect() */
N
N/*********************************************************************
N*
N*       Multitasking support
N*
N**********************************************************************
N*/
Nextern int GUITASK__EntranceCnt;
N
N/*********************************************************************
N*
N*             Bitmap related functions
N*
N**********************************************************************
N*/
N
Nint       GUI_GetBitmapPixelIndex(const GUI_BITMAP GUI_UNI_PTR * pBMP, unsigned x, unsigned y);
Xint       GUI_GetBitmapPixelIndex(const GUI_BITMAP  * pBMP, unsigned x, unsigned y);
NGUI_COLOR GUI_GetBitmapPixelColor(const GUI_BITMAP GUI_UNI_PTR * pBMP, unsigned x, unsigned y);
XGUI_COLOR GUI_GetBitmapPixelColor(const GUI_BITMAP  * pBMP, unsigned x, unsigned y);
N
Nvoid      GUI__DrawBitmap16bpp(int x0, int y0, int xsize, int ysize, const U8 GUI_UNI_PTR * pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag, tLCDDEV_Index2Color * pfIndex2Color);
Xvoid      GUI__DrawBitmap16bpp(int x0, int y0, int xsize, int ysize, const unsigned char  * pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag, tLCDDEV_Index2Color * pfIndex2Color);
N
Nextern const GUI_UC_ENC_APILIST GUI_UC_None;
N
N/************************************************************
N*
N*         EXTERNs for GL_CORE
N*
N*************************************************************
N*/
N
N#ifdef  GL_CORE_C
S  #define GUI_EXTERN
N#else
N  #define GUI_EXTERN extern
N#endif
N
NGUI_EXTERN GUI_SADDR GUI_CONTEXT        GUI_Context;        /* Thread wide globals */
Xextern  GUI_CONTEXT        GUI_Context;         
NGUI_EXTERN GUI_SADDR char               GUI_DecChar;
Xextern  char               GUI_DecChar;
NGUI_EXTERN           GUI_tfTimer*       GUI_pfTimerExec;
Xextern           GUI_tfTimer*       GUI_pfTimerExec;
NGUI_EXTERN           WM_tfHandlePID*    WM_pfHandlePID;
Xextern           WM_tfHandlePID*    WM_pfHandlePID;
NGUI_EXTERN      void (*GUI_pfDispCharStyle)(U16 Char);
Xextern      void (*GUI_pfDispCharStyle)(unsigned short Char);
N
N#if GUI_COMPILER_SUPPORTS_FP && GUI_SUPPORT_ROTATION
X#if 1 && 1
N  GUI_EXTERN const     tLCD_APIList *     GUI_pLCD_APIList;   /* Used for rotating text */
X  extern const     tLCD_APIList *     GUI_pLCD_APIList;    
N#endif
N
N#if GUI_SUPPORT_CURSOR
X#if (0 | (1))
N  GUI_EXTERN GUI_CURSOR_tfTempHide*   GUI_CURSOR_pfTempHide;
X  extern GUI_CURSOR_tfTempHide*   GUI_CURSOR_pfTempHide;
N  GUI_EXTERN GUI_CURSOR_tfTempUnhide* GUI_CURSOR_pfTempUnhide;
X  extern GUI_CURSOR_tfTempUnhide* GUI_CURSOR_pfTempUnhide;
N#endif
N
NGUI_EXTERN I16 GUI_OrgX, GUI_OrgY;
Xextern signed short GUI_OrgX, GUI_OrgY;
NGUI_EXTERN U8  GUI_MoveRTL;
Xextern unsigned char  GUI_MoveRTL;
N
N#undef GUI_EXTERN
N
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif 
N
N#endif   /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 25 "..\GUI\WM\WM_Intern.h" 2
N
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*       defines
N*
N**********************************************************************
N
N  The following could be placed in a file of its own as it is not
N  used outside of the window manager
N
N*/
N/* Basic Windows status flags.
N   For module-internally use only !
N*/
N#define WM_SF_HASTRANS          WM_CF_HASTRANS
N#define WM_SF_MEMDEV            WM_CF_MEMDEV
N#define WM_SF_MEMDEV_ON_REDRAW  WM_CF_MEMDEV_ON_REDRAW
N#define WM_SF_DISABLED          WM_CF_DISABLED  /* Disabled: Does not receive PID (mouse & touch) input */
N#define WM_SF_ISVIS             WM_CF_SHOW      /* Is visible flag */
N
N#define WM_SF_STAYONTOP         WM_CF_STAYONTOP
N#define WM_SF_LATE_CLIP         WM_CF_LATE_CLIP
N#define WM_SF_ANCHOR_RIGHT      WM_CF_ANCHOR_RIGHT
N#define WM_SF_ANCHOR_BOTTOM     WM_CF_ANCHOR_BOTTOM
N#define WM_SF_ANCHOR_LEFT       WM_CF_ANCHOR_LEFT
N#define WM_SF_ANCHOR_TOP        WM_CF_ANCHOR_TOP
N
N#define WM_SF_INVALID           WM_CF_ACTIVATE  /* We reuse this flag, as it is create only and Invalid is status only */
N
N#define WM_SF_CONST_OUTLINE     WM_CF_CONST_OUTLINE       /* Constant outline.*/
N
N#define WM_HANDLE2PTR(hWin) ((WM_Obj*)GUI_ALLOC_h2p(hWin))    /* older form ... to be eliminated */
N#define WM_H2P(hWin)        ((WM_Obj*)GUI_ALLOC_h2p(hWin))
N
N
N#if GUI_DEBUG_LEVEL  >= GUI_DEBUG_LEVEL_LOG_WARNINGS
X#if 1  >= 4
S  #define WM_ASSERT_NOT_IN_PAINT() { if (WM__PaintCallbackCnt) \
S                                       GUI_DEBUG_ERROROUT("Function may not be called from within a paint event"); \
S                                   }
X  #define WM_ASSERT_NOT_IN_PAINT() { if (WM__PaintCallbackCnt)                                        GUI_DEBUG_ERROROUT("Function may not be called from within a paint event");                                    }
N#else
N  #define WM_ASSERT_NOT_IN_PAINT()
N#endif
N
N/*********************************************************************
N*
N*       Data types & structures
N*
N**********************************************************************
N*/
Ntypedef struct {
N  WM_HWIN hWin;
X  GUI_HWIN hWin;
N  WM_Obj* pWin;
N} WM_PAINTINFO;
N
Ntypedef struct {
N  WM_HWIN hOld;
X  GUI_HWIN hOld;
N  WM_HWIN hNew;
X  GUI_HWIN hNew;
N} WM_NOTIFY_CHILD_HAS_FOCUS_INFO;
N
Ntypedef struct WM_CRITICAL_HANDLE {
N  struct  WM_CRITICAL_HANDLE * pNext;
N  volatile WM_HWIN hWin;
X  volatile GUI_HWIN hWin;
N} WM_CRITICAL_HANDLE;
N
N/*********************************************************************
N*
N*       Data (extern)
N*
N**********************************************************************
N*/
Nextern U16                    WM__CreateFlags;
Xextern unsigned short                    WM__CreateFlags;
Nextern WM_HWIN                WM__hCapture;
Xextern GUI_HWIN                WM__hCapture;
Nextern WM_HWIN                WM__hWinFocus;
Xextern GUI_HWIN                WM__hWinFocus;
Nextern char                   WM__CaptureReleaseAuto;
Nextern WM_tfPollPID*          WM_pfPollPID;
Nextern U8                     WM__PaintCallbackCnt;      /* Public for assertions only */
Xextern unsigned char                     WM__PaintCallbackCnt;       
Nextern GUI_PID_STATE          WM_PID__StateLast;
Nextern U8                     WM_IsActive;
Xextern unsigned char                     WM_IsActive;
N
N#if WM_SUPPORT_TRANSPARENCY
X#if 1
N  extern int     WM__TransWindowCnt;
N  extern WM_HWIN WM__hATransWindow;
X  extern GUI_HWIN WM__hATransWindow;
N#endif
N
N#if WM_SUPPORT_DIAG
X#if 0
S  extern void (*WM__pfShowInvalid)(WM_HWIN hWin);
N#endif
N
Nextern WM_CRITICAL_HANDLE     WM__CHWinModal;
Nextern WM_CRITICAL_HANDLE     WM__CHWinLast;
N
N#if GUI_SUPPORT_MOUSE
X#if 0
S  extern WM_CRITICAL_HANDLE   WM__CHWinMouseOver;
N#endif
N
N#ifdef WM_C
S  #define GUI_EXTERN
N#else
N  #define GUI_EXTERN extern
N#endif
N
NGUI_EXTERN U16     WM__NumWindows;
Xextern unsigned short     WM__NumWindows;
NGUI_EXTERN U16     WM__NumInvalidWindows;
Xextern unsigned short     WM__NumInvalidWindows;
NGUI_EXTERN WM_HWIN WM__FirstWin;
Xextern GUI_HWIN WM__FirstWin;
NGUI_EXTERN WM_CRITICAL_HANDLE*  WM__pFirstCriticalHandle;
Xextern WM_CRITICAL_HANDLE*  WM__pFirstCriticalHandle;
N#undef GUI_EXTERN
N
N/*********************************************************************
N*
N*       Prototypes
N*
N**********************************************************************
N*/
N
Nvoid    WM__ActivateClipRect        (void);
Nint     WM__ClipAtParentBorders     (GUI_RECT* pRect, WM_HWIN hWin);
Xint     WM__ClipAtParentBorders     (GUI_RECT* pRect, GUI_HWIN hWin);
Nvoid    WM__Client2Screen           (const WM_Obj* pWin, GUI_RECT *pRect);
Nvoid    WM__DetachWindow            (WM_HWIN hChild);
Xvoid    WM__DetachWindow            (GUI_HWIN hChild);
Nvoid    WM__ForEachDesc(WM_HWIN hWin, WM_tfForEach * pcb, void * pData);
Xvoid    WM__ForEachDesc(GUI_HWIN hWin, WM_tfForEach * pcb, void * pData);
Nvoid    WM__GetClientRectWin        (const WM_Obj* pWin, GUI_RECT* pRect);
NWM_HWIN WM__GetFirstSibling         (WM_HWIN hWin);
XGUI_HWIN WM__GetFirstSibling         (GUI_HWIN hWin);
NWM_HWIN WM__GetFocussedChild        (WM_HWIN hWin);
XGUI_HWIN WM__GetFocussedChild        (GUI_HWIN hWin);
Nint     WM__GetHasFocus             (WM_HWIN hWin);
Xint     WM__GetHasFocus             (GUI_HWIN hWin);
NWM_HWIN WM__GetLastSibling          (WM_HWIN hWin);
XGUI_HWIN WM__GetLastSibling          (GUI_HWIN hWin);
NWM_HWIN WM__GetPrevSibling          (WM_HWIN hWin);
XGUI_HWIN WM__GetPrevSibling          (GUI_HWIN hWin);
Nint     WM__GetWindowSizeX          (const WM_Obj* pWin);
Nint     WM__GetWindowSizeY          (const WM_Obj* pWin);
Nvoid    WM__InsertWindowIntoList    (WM_HWIN hWin, WM_HWIN hParent);
Xvoid    WM__InsertWindowIntoList    (GUI_HWIN hWin, GUI_HWIN hParent);
Nvoid    WM__Invalidate1Abs          (WM_HWIN hWin, const GUI_RECT * pRect);
Xvoid    WM__Invalidate1Abs          (GUI_HWIN hWin, const GUI_RECT * pRect);
Nvoid    WM__InvalidateAreaBelow     (const GUI_RECT* pRect, WM_HWIN StopWin);
Xvoid    WM__InvalidateAreaBelow     (const GUI_RECT* pRect, GUI_HWIN StopWin);
Nvoid    WM__InvalidateRectEx        (const GUI_RECT* pInvalidRect, WM_HWIN hParent, WM_HWIN hStop);
Xvoid    WM__InvalidateRectEx        (const GUI_RECT* pInvalidRect, GUI_HWIN hParent, GUI_HWIN hStop);
Nvoid    WM__InvalidateTransAreaAbove(const GUI_RECT* pRect, WM_HWIN StopWin);
Xvoid    WM__InvalidateTransAreaAbove(const GUI_RECT* pRect, GUI_HWIN StopWin);
Nint     WM__IntersectRect           (GUI_RECT* pDest, const GUI_RECT* pr0, const GUI_RECT* pr1);
Nint     WM__IsAncestor              (WM_HWIN hChild, WM_HWIN hParent);
Xint     WM__IsAncestor              (GUI_HWIN hChild, GUI_HWIN hParent);
Nint     WM__IsAncestorOrSelf        (WM_HWIN hChild, WM_HWIN hParent);
Xint     WM__IsAncestorOrSelf        (GUI_HWIN hChild, GUI_HWIN hParent);
Nint     WM__IsChild                 (WM_HWIN hWin, WM_HWIN hParent);
Xint     WM__IsChild                 (GUI_HWIN hWin, GUI_HWIN hParent);
Nint     WM__IsEnabled               (WM_HWIN hWin);
Xint     WM__IsEnabled               (GUI_HWIN hWin);
Nint     WM__IsInModalArea           (WM_HWIN hWin);
Xint     WM__IsInModalArea           (GUI_HWIN hWin);
Nint     WM__IsInWindow              (WM_Obj * pWin, int x, int y);
Nint     WM__IsWindow                (WM_HWIN hWin);
Xint     WM__IsWindow                (GUI_HWIN hWin);
Nvoid    WM__LeaveIVRSearch          (void);
Nvoid    WM__MoveTo                  (WM_HWIN hWin, int x, int y);
Xvoid    WM__MoveTo                  (GUI_HWIN hWin, int x, int y);
Nvoid    WM__MoveWindow              (WM_HWIN hWin, int dx, int dy);
Xvoid    WM__MoveWindow              (GUI_HWIN hWin, int dx, int dy);
Nvoid    WM__NotifyVisChanged        (WM_HWIN hWin, GUI_RECT * pRect);
Xvoid    WM__NotifyVisChanged        (GUI_HWIN hWin, GUI_RECT * pRect);
Nint     WM__RectIsNZ                (const GUI_RECT* pr);
Nvoid    WM__RemoveWindowFromList    (WM_HWIN hWin);
Xvoid    WM__RemoveWindowFromList    (GUI_HWIN hWin);
Nvoid    WM__RemoveFromLinList       (WM_HWIN hWin);
Xvoid    WM__RemoveFromLinList       (GUI_HWIN hWin);
Nvoid    WM__Screen2Client           (const WM_Obj* pWin, GUI_RECT *pRect);
Nvoid    WM__SendMsgNoData           (WM_HWIN hWin, U8 MsgId);
Xvoid    WM__SendMsgNoData           (GUI_HWIN hWin, unsigned char MsgId);
Nvoid    WM__SendMessage             (WM_HWIN hWin, WM_MESSAGE* pm);
Xvoid    WM__SendMessage             (GUI_HWIN hWin, WM_MESSAGE* pm);
Nvoid    WM__SendMessageIfEnabled    (WM_HWIN hWin, WM_MESSAGE* pm);
Xvoid    WM__SendMessageIfEnabled    (GUI_HWIN hWin, WM_MESSAGE* pm);
Nvoid    WM__SendMessageNoPara       (WM_HWIN hWin, int MsgId);
Xvoid    WM__SendMessageNoPara       (GUI_HWIN hWin, int MsgId);
Nvoid    WM__SendPIDMessage          (WM_HWIN hWin, WM_MESSAGE* pMsg);
Xvoid    WM__SendPIDMessage          (GUI_HWIN hWin, WM_MESSAGE* pMsg);
Nint     WM__SetScrollbarH           (WM_HWIN hWin, int OnOff);
Xint     WM__SetScrollbarH           (GUI_HWIN hWin, int OnOff);
Nint     WM__SetScrollbarV           (WM_HWIN hWin, int OnOff);
Xint     WM__SetScrollbarV           (GUI_HWIN hWin, int OnOff);
Nvoid    WM__UpdateChildPositions    (WM_Obj* pObj, int dx0, int dy0, int dx1, int dy1);
Nvoid    WM_PID__GetPrevState        (GUI_PID_STATE* pPrevState);
Nvoid    WM_PID__SetPrevState        (GUI_PID_STATE* pPrevState);
Nvoid    WM__SendTouchMessage        (WM_HWIN hWin, WM_MESSAGE* pMsg);
Xvoid    WM__SendTouchMessage        (GUI_HWIN hWin, WM_MESSAGE* pMsg);
N
NU16     WM_GetFlags(WM_HWIN hWin);
Xunsigned short     WM_GetFlags(GUI_HWIN hWin);
Nvoid    WM__PaintWinAndOverlays     (WM_PAINTINFO* pInfo);
Nint     WM__Paint                   (WM_HWIN hWin, WM_Obj* pWin);
Xint     WM__Paint                   (GUI_HWIN hWin, WM_Obj* pWin);
Nvoid    WM__AddCriticalHandle       (WM_CRITICAL_HANDLE* pCH);
Nvoid    WM__RemoveCriticalHandle    (WM_CRITICAL_HANDLE* pCH);
N
N#endif   /* GUI_WINSUPPORT */
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif   /* WM_INTERN_H */
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 28 "..\GUI\Widget\WIDGET.h" 2
N
N#if GUI_WINSUPPORT
X#if 1
N
N#include "SCROLLBAR.h"
L 1 "..\GUI\Widget\SCROLLBAR.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : SCROLLBAR.h
NPurpose     : SCROLLBAR include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef SCROLLBAR_H
N#define SCROLLBAR_H
N
N#include "WM.h"
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
N#include "WIDGET.h"
L 1 "..\GUI\Widget\WIDGET.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : WIDGET.h
NPurpose     : Widget interface
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef WIDGET_H        /* Avoid multiple inclusion  */
S#define WIDGET_H
S
S#if defined(__cplusplus)
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
S#endif
S
S#include "WM_Intern.h"  /* Window manager, including some internals, which speed things up */
S
S#if GUI_WINSUPPORT
S
S#include "SCROLLBAR.h"
S
S
S/*********************************************************************
S*
S*       Defines
S*
S**********************************************************************
S*/
S/*********************************************************************
S*
S*       Unique widget id's
S*/
S#define BUTTON_ID    0x42555454 /* BUTT */
S#define CHECKBOX_ID  0x43484543 /* CHEC */
S#define DROPDOWN_ID  0x44524f50 /* DROP */
S#define EDIT_ID      0x45444954 /* EDIT */
S#define FRAMEWIN_ID  0x4652414d /* FRAM */
S#define GRAPH_ID     0x47524150 /* GRAP */
S#define HEADER_ID    0x48454144 /* HEAD */
S#define LISTBOX_ID   0x4C495342 /* LISB */
S#define LISTVIEW_ID  0x4C495356 /* LISV */
S#define MENU_ID      0x4d454e55 /* MENU */
S#define MULTIEDIT_ID 0x4d554c45 /* MULE */
S#define MULTIPAGE_ID 0x4d554c50 /* MULP */
S#define PROGBAR_ID   0x50524f47 /* PROG */
S#define RADIO_ID     0x52414449 /* RADI */
S#define SCROLLBAR_ID 0x5343524f /* SCRO */
S#define SLIDER_ID    0x534c4944 /* SLID */
S#define TEXT_ID      0x54455854 /* TEXT */
S
S#define WIDGET_H2P(hWin)        ((WIDGET*)GUI_ALLOC_h2p(hWin))
S
S/*********************************************************************
S*
S*       Config switches
S*/
S
S#ifndef   WIDGET_USE_PARENT_EFFECT
S  #define WIDGET_USE_PARENT_EFFECT 0
S#endif
S#if !defined(WIDGET_USE_SCHEME_SMALL) && !defined(WIDGET_USE_SCHEME_MEDIUM) && !defined(WIDGET_USE_SCHEME_LARGE)
S  #define WIDGET_USE_SCHEME_SMALL  1
S  #define WIDGET_USE_SCHEME_MEDIUM 0
S  #define WIDGET_USE_SCHEME_LARGE  0
S#endif
S#ifndef   WIDGET_USE_SCHEME_SMALL
S  #define WIDGET_USE_SCHEME_SMALL  0
S#endif
S#ifndef   WIDGET_USE_SCHEME_MEDIUM
S  #define WIDGET_USE_SCHEME_MEDIUM 0
S#endif
S#ifndef   WIDGET_USE_SCHEME_LARGE
S  #define WIDGET_USE_SCHEME_LARGE  0
S#endif
S#if (WIDGET_USE_SCHEME_SMALL + WIDGET_USE_SCHEME_MEDIUM + WIDGET_USE_SCHEME_LARGE) > 1
S  #error Only one scheme can be selected!
S#endif
S
S/*********************************************************************
S*
S*       States
S*/
S
S#define WIDGET_STATE_FOCUS              (1<<0)
S#define WIDGET_STATE_VERTICAL           (1<<3)
S#define WIDGET_STATE_FOCUSSABLE         (1<<4)
S
S#define WIDGET_STATE_USER0              (1<<8)    /* Freely available for derived widget */
S#define WIDGET_STATE_USER1              (1<<9)    /* Freely available for derived widget */
S#define WIDGET_STATE_USER2              (1<<10)   /* Freely available for derived widget */
S
S#define WIDGET_ITEM_DRAW                0
S#define WIDGET_ITEM_GET_XSIZE           1
S#define WIDGET_ITEM_GET_YSIZE           2
S
S/*********************************************************************
S*
S*       Messages
S*/
S
S#define WM_WIDGET_SET_EFFECT    WM_WIDGET + 0
S
S/*********************************************************************
S*
S*       Create flags
S*/
S
S#define WIDGET_CF_VERTICAL      WIDGET_STATE_VERTICAL
S
S/*********************************************************************
S*
S*         typedefs
S*
S**********************************************************************
S*/
S
Stypedef struct {
S  WM_HWIN hWin;
S  int     Cmd;         /* WIDGET_ITEM_GET_XSIZE, WIDGET_ITEM_GET_YSIZE, WIDGET_ITEM_DRAW, */
S  int     ItemIndex;
S  int     x0, y0;
S} WIDGET_ITEM_DRAW_INFO;
S
Stypedef int WIDGET_DRAW_ITEM_FUNC(const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
S
S
S/*********************************************************************
S*
S*         Widget object
S*
S* The widget object is the base class for most widgets
S*/
Stypedef struct {
S  void  (*pfDrawUp)(void);
S  void  (*pfDrawDown)(void);
S  void  (*pfDrawUpRect)  (const GUI_RECT *pRect);
S  void  (*pfDrawDownRect)(const GUI_RECT *pRect);
S  void  (*pfGetRect)(GUI_RECT *pRect);
S  int EffectSize;
S} WIDGET_EFFECT;
S
Stypedef struct {
S  WM_Obj      Win;
S  const WIDGET_EFFECT* pEffect;
S  I16 Id;
S  U16 State;
S} WIDGET;
S
S
S/*********************************************************************
S*
S*         GUI_DRAW
S*
S* The GUI_DRAW object is used as base class for selfdrawing,
S* non-windows objects. They are used as content of different widgets,
S* such as the bitmap or header widgets.
S*/
S/* Declare Object struct */
Stypedef struct GUI_DRAW GUI_DRAW;
Stypedef void   GUI_DRAW_SELF_CB (void);
S/* Declare Object constants (member functions etc)  */
Stypedef struct {
S  void (* pfDraw)    (const GUI_DRAW * pObj, int x, int y);
S  int  (* pfGetXSize)(const GUI_DRAW * pObj);
S  int  (* pfGetYSize)(const GUI_DRAW * pObj);
S} GUI_DRAW_CONSTS;
S
S/* Declare Object */
Sstruct GUI_DRAW {
S  const GUI_DRAW_CONSTS* pConsts;
S  union {
S    const void * pData;
S    GUI_DRAW_SELF_CB* pfDraw;
S  } Data;
S  I16 xOff, yOff;
S};
S
Stypedef WM_HMEM GUI_DRAW_HANDLE;
S
S/* GUI_DRAW_ API */
Svoid GUI_DRAW__Draw    (GUI_DRAW_HANDLE hDrawObj, int x, int y);
Sint  GUI_DRAW__GetXSize(GUI_DRAW_HANDLE hDrawObj);
Sint  GUI_DRAW__GetYSize(GUI_DRAW_HANDLE hDrawObj);
S
S/* GUI_DRAW_ Constructurs for different objects */
SWM_HMEM GUI_DRAW_BITMAP_Create  (const GUI_BITMAP* pBitmap, int x, int y);
SWM_HMEM GUI_DRAW_BMP_Create     (const void* pBMP, int x, int y);
SWM_HMEM GUI_DRAW_STREAMED_Create(const GUI_BITMAP_STREAM * pBitmap, int x, int y);
SWM_HMEM GUI_DRAW_SELF_Create(GUI_DRAW_SELF_CB* pfDraw, int x, int y);
S
S/*********************************************************************
S*
S*           Global data
S*
S**********************************************************************
S*/
S
Sextern const WIDGET_EFFECT WIDGET_Effect_3D;
Sextern const WIDGET_EFFECT WIDGET_Effect_3D1L;
Sextern const WIDGET_EFFECT WIDGET_Effect_3D2L;
Sextern const WIDGET_EFFECT WIDGET_Effect_None;
Sextern const WIDGET_EFFECT WIDGET_Effect_Simple;
S
S/*********************************************************************
S*
S*           Internal API routines
S*
S**********************************************************************
S*/
S
Svoid      WIDGET__DrawFocusRect(WIDGET* pWidget, const GUI_RECT* pRect, int Dist);
Svoid      WIDGET__DrawVLine(WIDGET* pWidget, int x, int y0, int y1);
Svoid      WIDGET__EFFECT_DrawDownRect(WIDGET* pWidget, GUI_RECT* pRect);
Svoid      WIDGET__EFFECT_DrawDown(WIDGET* pWidget);
Svoid      WIDGET__EFFECT_DrawUpRect(WIDGET* pWidget, GUI_RECT* pRect);
Svoid      WIDGET__FillRectEx(WIDGET* pWidget, const GUI_RECT* pRect);
Sint       WIDGET__GetWindowSizeX(WM_HWIN hWin);
SGUI_COLOR WIDGET__GetBkColor(WM_HWIN hObj);
Sint       WIDGET__GetXSize(const WIDGET* pWidget);
Sint       WIDGET__GetYSize(const WIDGET* pWidget);
Svoid      WIDGET__GetClientRect(WIDGET* pWidget, GUI_RECT* pRect);
Svoid      WIDGET__GetInsideRect(WIDGET* pWidget, GUI_RECT* pRect);
Svoid      WIDGET__Init(WIDGET* pWidget, int Id, U16 State);
Svoid      WIDGET__RotateRect90(WIDGET* pWidget, GUI_RECT* pDest, const GUI_RECT* pRect);
Svoid      WIDGET__SetScrollState(WM_HWIN hWin, const WM_SCROLL_STATE* pVState, const WM_SCROLL_STATE* pState);
Svoid      WIDGET__FillStringInRect(const char GUI_UNI_PTR * pText, const GUI_RECT * pFillRect, const GUI_RECT * pTextRectMax, const GUI_RECT * pTextRectAct);
S
S/*********************************************************************
S*
S*           API routines
S*
S**********************************************************************
S*/
Svoid  WIDGET_SetState     (WM_HWIN hObj, int State);
Svoid  WIDGET_AndState     (WM_HWIN hObj, int State);
Svoid  WIDGET_OrState      (WM_HWIN hObj, int State);
Sint   WIDGET_HandleActive (WM_HWIN hObj, WM_MESSAGE* pMsg);
Sint   WIDGET_GetState     (WM_HWIN hObj);
Sint   WIDGET_SetWidth     (WM_HWIN hObj, int Width);
S
Svoid  WIDGET_EFFECT_3D_DrawUp(void);
S
Svoid  WIDGET_SetDefaultEffect_3D    (void);
Svoid  WIDGET_SetDefaultEffect_3D1L  (void);
Svoid  WIDGET_SetDefaultEffect_3D2L  (void);
Svoid  WIDGET_SetDefaultEffect_None  (void);
Svoid  WIDGET_SetDefaultEffect_Simple(void);
S
Sconst WIDGET_EFFECT* WIDGET_SetDefaultEffect(const WIDGET_EFFECT* pEffect);
S
Svoid  WIDGET_SetEffect              (WM_HWIN hObj, const WIDGET_EFFECT* pEffect);
S
Sconst WIDGET_EFFECT* WIDGET_GetDefaultEffect(void);
Sint   WIDGET_SetWidth(WM_HWIN hObj, int Width);
S
S
S#endif /* GUI_WINSUPPORT */
S
S#if defined(__cplusplus)
S  }
S#endif
S
N#endif   /* SLIDER_H */
N
N
N
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 26 "..\GUI\Widget\SCROLLBAR.h" 2
N
N#if GUI_WINSUPPORT
X#if 1
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N#define SCROLLBAR_CI_THUMB 0
N#define SCROLLBAR_CI_SHAFT 1
N#define SCROLLBAR_CI_ARROW 2
N
N/*********************************************************************
N*
N*       States
N*/
N#define SCROLLBAR_STATE_PRESSED   WIDGET_STATE_USER0
N
N/*********************************************************************
N*
N*       Create / Status flags
N*/
N#define SCROLLBAR_CF_VERTICAL     WIDGET_CF_VERTICAL
N#define SCROLLBAR_CF_FOCUSSABLE   WIDGET_STATE_FOCUSSABLE
N
N/*********************************************************************
N*
N*       Public Types
N*
N**********************************************************************
N*/
Ntypedef WM_HMEM SCROLLBAR_Handle;
Xtypedef signed short SCROLLBAR_Handle;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NSCROLLBAR_Handle SCROLLBAR_Create        (int x0, int y0, int xsize, int ysize, WM_HWIN hParent, int Id, int WinFlags, int SpecialFlags);
XSCROLLBAR_Handle SCROLLBAR_Create        (int x0, int y0, int xsize, int ysize, GUI_HWIN hParent, int Id, int WinFlags, int SpecialFlags);
NSCROLLBAR_Handle SCROLLBAR_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
XSCROLLBAR_Handle SCROLLBAR_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
NSCROLLBAR_Handle SCROLLBAR_CreateAttached(WM_HWIN hParent, int SpecialFlags);
XSCROLLBAR_Handle SCROLLBAR_CreateAttached(GUI_HWIN hParent, int SpecialFlags);
NSCROLLBAR_Handle SCROLLBAR_CreateEx      (int x0, int y0, int xsize, int ysize, WM_HWIN hParent,
XSCROLLBAR_Handle SCROLLBAR_CreateEx      (int x0, int y0, int xsize, int ysize, GUI_HWIN hParent,
N                                          int WinFlags, int ExFlags, int Id);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid SCROLLBAR_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Member functions
N*
N**********************************************************************
N*/
N
N/* Methods changing properties */
N
Nvoid      SCROLLBAR_AddValue   (SCROLLBAR_Handle hObj, int Add);
Nvoid      SCROLLBAR_Dec        (SCROLLBAR_Handle hObj);
Nvoid      SCROLLBAR_Inc        (SCROLLBAR_Handle hObj);
NGUI_COLOR SCROLLBAR_SetColor   (SCROLLBAR_Handle hObj, int Index, GUI_COLOR Color);
Nvoid      SCROLLBAR_SetNumItems(SCROLLBAR_Handle hObj, int NumItems);
Nvoid      SCROLLBAR_SetPageSize(SCROLLBAR_Handle hObj, int PageSize);
Nvoid      SCROLLBAR_SetValue   (SCROLLBAR_Handle hObj, int v);
Nint       SCROLLBAR_SetWidth   (SCROLLBAR_Handle hObj, int Width);
Nvoid      SCROLLBAR_SetState   (SCROLLBAR_Handle hObj, const WM_SCROLL_STATE* pState);
N
N/*********************************************************************
N*
N*       Global functions
N*
N**********************************************************************
N*/
Nint       SCROLLBAR_GetDefaultWidth  (void);
NGUI_COLOR SCROLLBAR_SetDefaultColor  (GUI_COLOR Color, unsigned int Index); /* Not yet documented */
Nint       SCROLLBAR_SetDefaultWidth  (int DefaultWidth);
N
N/*********************************************************************
N*
N*       Query state
N*
N**********************************************************************
N*/
Nint SCROLLBAR_GetValue(SCROLLBAR_Handle hObj);
N
N/*********************************************************************
N*
N*       Macros for compatibility
N*
N**********************************************************************
N*/
N#define SCROLLBAR_BKCOLOR0_DEFAULT SCROLLBAR_COLOR_ARROW_DEFAULT
N#define SCROLLBAR_BKCOLOR1_DEFAULT SCROLLBAR_COLOR_SHAFT_DEFAULT
N#define SCROLLBAR_COLOR0_DEFAULT   SCROLLBAR_COLOR_THUMB_DEFAULT
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif   /* if GUI_WINSUPPORT */
N#endif   /* SCROLLBAR_H */
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 32 "..\GUI\Widget\WIDGET.h" 2
N
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       Unique widget id's
N*/
N#define BUTTON_ID    0x42555454 /* BUTT */
N#define CHECKBOX_ID  0x43484543 /* CHEC */
N#define DROPDOWN_ID  0x44524f50 /* DROP */
N#define EDIT_ID      0x45444954 /* EDIT */
N#define FRAMEWIN_ID  0x4652414d /* FRAM */
N#define GRAPH_ID     0x47524150 /* GRAP */
N#define HEADER_ID    0x48454144 /* HEAD */
N#define LISTBOX_ID   0x4C495342 /* LISB */
N#define LISTVIEW_ID  0x4C495356 /* LISV */
N#define MENU_ID      0x4d454e55 /* MENU */
N#define MULTIEDIT_ID 0x4d554c45 /* MULE */
N#define MULTIPAGE_ID 0x4d554c50 /* MULP */
N#define PROGBAR_ID   0x50524f47 /* PROG */
N#define RADIO_ID     0x52414449 /* RADI */
N#define SCROLLBAR_ID 0x5343524f /* SCRO */
N#define SLIDER_ID    0x534c4944 /* SLID */
N#define TEXT_ID      0x54455854 /* TEXT */
N
N#define WIDGET_H2P(hWin)        ((WIDGET*)GUI_ALLOC_h2p(hWin))
N
N/*********************************************************************
N*
N*       Config switches
N*/
N
N#ifndef   WIDGET_USE_PARENT_EFFECT
N  #define WIDGET_USE_PARENT_EFFECT 0
N#endif
N#if !defined(WIDGET_USE_SCHEME_SMALL) && !defined(WIDGET_USE_SCHEME_MEDIUM) && !defined(WIDGET_USE_SCHEME_LARGE)
X#if !0L && !0L && !0L
N  #define WIDGET_USE_SCHEME_SMALL  1
N  #define WIDGET_USE_SCHEME_MEDIUM 0
N  #define WIDGET_USE_SCHEME_LARGE  0
N#endif
N#ifndef   WIDGET_USE_SCHEME_SMALL
S  #define WIDGET_USE_SCHEME_SMALL  0
N#endif
N#ifndef   WIDGET_USE_SCHEME_MEDIUM
S  #define WIDGET_USE_SCHEME_MEDIUM 0
N#endif
N#ifndef   WIDGET_USE_SCHEME_LARGE
S  #define WIDGET_USE_SCHEME_LARGE  0
N#endif
N#if (WIDGET_USE_SCHEME_SMALL + WIDGET_USE_SCHEME_MEDIUM + WIDGET_USE_SCHEME_LARGE) > 1
X#if (1 + 0 + 0) > 1
S  #error Only one scheme can be selected!
N#endif
N
N/*********************************************************************
N*
N*       States
N*/
N
N#define WIDGET_STATE_FOCUS              (1<<0)
N#define WIDGET_STATE_VERTICAL           (1<<3)
N#define WIDGET_STATE_FOCUSSABLE         (1<<4)
N
N#define WIDGET_STATE_USER0              (1<<8)    /* Freely available for derived widget */
N#define WIDGET_STATE_USER1              (1<<9)    /* Freely available for derived widget */
N#define WIDGET_STATE_USER2              (1<<10)   /* Freely available for derived widget */
N
N#define WIDGET_ITEM_DRAW                0
N#define WIDGET_ITEM_GET_XSIZE           1
N#define WIDGET_ITEM_GET_YSIZE           2
N
N/*********************************************************************
N*
N*       Messages
N*/
N
N#define WM_WIDGET_SET_EFFECT    WM_WIDGET + 0
N
N/*********************************************************************
N*
N*       Create flags
N*/
N
N#define WIDGET_CF_VERTICAL      WIDGET_STATE_VERTICAL
N
N/*********************************************************************
N*
N*         typedefs
N*
N**********************************************************************
N*/
N
Ntypedef struct {
N  WM_HWIN hWin;
X  GUI_HWIN hWin;
N  int     Cmd;         /* WIDGET_ITEM_GET_XSIZE, WIDGET_ITEM_GET_YSIZE, WIDGET_ITEM_DRAW, */
N  int     ItemIndex;
N  int     x0, y0;
N} WIDGET_ITEM_DRAW_INFO;
N
Ntypedef int WIDGET_DRAW_ITEM_FUNC(const WIDGET_ITEM_DRAW_INFO * pDrawItemInfo);
N
N
N/*********************************************************************
N*
N*         Widget object
N*
N* The widget object is the base class for most widgets
N*/
Ntypedef struct {
N  void  (*pfDrawUp)(void);
N  void  (*pfDrawDown)(void);
N  void  (*pfDrawUpRect)  (const GUI_RECT *pRect);
N  void  (*pfDrawDownRect)(const GUI_RECT *pRect);
N  void  (*pfGetRect)(GUI_RECT *pRect);
N  int EffectSize;
N} WIDGET_EFFECT;
N
Ntypedef struct {
N  WM_Obj      Win;
N  const WIDGET_EFFECT* pEffect;
N  I16 Id;
X  signed short Id;
N  U16 State;
X  unsigned short State;
N} WIDGET;
N
N
N/*********************************************************************
N*
N*         GUI_DRAW
N*
N* The GUI_DRAW object is used as base class for selfdrawing,
N* non-windows objects. They are used as content of different widgets,
N* such as the bitmap or header widgets.
N*/
N/* Declare Object struct */
Ntypedef struct GUI_DRAW GUI_DRAW;
Ntypedef void   GUI_DRAW_SELF_CB (void);
N/* Declare Object constants (member functions etc)  */
Ntypedef struct {
N  void (* pfDraw)    (const GUI_DRAW * pObj, int x, int y);
N  int  (* pfGetXSize)(const GUI_DRAW * pObj);
N  int  (* pfGetYSize)(const GUI_DRAW * pObj);
N} GUI_DRAW_CONSTS;
N
N/* Declare Object */
Nstruct GUI_DRAW {
N  const GUI_DRAW_CONSTS* pConsts;
N  union {
N    const void * pData;
N    GUI_DRAW_SELF_CB* pfDraw;
N  } Data;
N  I16 xOff, yOff;
X  signed short xOff, yOff;
N};
N
Ntypedef WM_HMEM GUI_DRAW_HANDLE;
Xtypedef signed short GUI_DRAW_HANDLE;
N
N/* GUI_DRAW_ API */
Nvoid GUI_DRAW__Draw    (GUI_DRAW_HANDLE hDrawObj, int x, int y);
Nint  GUI_DRAW__GetXSize(GUI_DRAW_HANDLE hDrawObj);
Nint  GUI_DRAW__GetYSize(GUI_DRAW_HANDLE hDrawObj);
N
N/* GUI_DRAW_ Constructurs for different objects */
NWM_HMEM GUI_DRAW_BITMAP_Create  (const GUI_BITMAP* pBitmap, int x, int y);
Xsigned short GUI_DRAW_BITMAP_Create  (const GUI_BITMAP* pBitmap, int x, int y);
NWM_HMEM GUI_DRAW_BMP_Create     (const void* pBMP, int x, int y);
Xsigned short GUI_DRAW_BMP_Create     (const void* pBMP, int x, int y);
NWM_HMEM GUI_DRAW_STREAMED_Create(const GUI_BITMAP_STREAM * pBitmap, int x, int y);
Xsigned short GUI_DRAW_STREAMED_Create(const GUI_BITMAP_STREAM * pBitmap, int x, int y);
NWM_HMEM GUI_DRAW_SELF_Create(GUI_DRAW_SELF_CB* pfDraw, int x, int y);
Xsigned short GUI_DRAW_SELF_Create(GUI_DRAW_SELF_CB* pfDraw, int x, int y);
N
N/*********************************************************************
N*
N*           Global data
N*
N**********************************************************************
N*/
N
Nextern const WIDGET_EFFECT WIDGET_Effect_3D;
Nextern const WIDGET_EFFECT WIDGET_Effect_3D1L;
Nextern const WIDGET_EFFECT WIDGET_Effect_3D2L;
Nextern const WIDGET_EFFECT WIDGET_Effect_None;
Nextern const WIDGET_EFFECT WIDGET_Effect_Simple;
N
N/*********************************************************************
N*
N*           Internal API routines
N*
N**********************************************************************
N*/
N
Nvoid      WIDGET__DrawFocusRect(WIDGET* pWidget, const GUI_RECT* pRect, int Dist);
Nvoid      WIDGET__DrawVLine(WIDGET* pWidget, int x, int y0, int y1);
Nvoid      WIDGET__EFFECT_DrawDownRect(WIDGET* pWidget, GUI_RECT* pRect);
Nvoid      WIDGET__EFFECT_DrawDown(WIDGET* pWidget);
Nvoid      WIDGET__EFFECT_DrawUpRect(WIDGET* pWidget, GUI_RECT* pRect);
Nvoid      WIDGET__FillRectEx(WIDGET* pWidget, const GUI_RECT* pRect);
Nint       WIDGET__GetWindowSizeX(WM_HWIN hWin);
Xint       WIDGET__GetWindowSizeX(GUI_HWIN hWin);
NGUI_COLOR WIDGET__GetBkColor(WM_HWIN hObj);
XGUI_COLOR WIDGET__GetBkColor(GUI_HWIN hObj);
Nint       WIDGET__GetXSize(const WIDGET* pWidget);
Nint       WIDGET__GetYSize(const WIDGET* pWidget);
Nvoid      WIDGET__GetClientRect(WIDGET* pWidget, GUI_RECT* pRect);
Nvoid      WIDGET__GetInsideRect(WIDGET* pWidget, GUI_RECT* pRect);
Nvoid      WIDGET__Init(WIDGET* pWidget, int Id, U16 State);
Xvoid      WIDGET__Init(WIDGET* pWidget, int Id, unsigned short State);
Nvoid      WIDGET__RotateRect90(WIDGET* pWidget, GUI_RECT* pDest, const GUI_RECT* pRect);
Nvoid      WIDGET__SetScrollState(WM_HWIN hWin, const WM_SCROLL_STATE* pVState, const WM_SCROLL_STATE* pState);
Xvoid      WIDGET__SetScrollState(GUI_HWIN hWin, const WM_SCROLL_STATE* pVState, const WM_SCROLL_STATE* pState);
Nvoid      WIDGET__FillStringInRect(const char GUI_UNI_PTR * pText, const GUI_RECT * pFillRect, const GUI_RECT * pTextRectMax, const GUI_RECT * pTextRectAct);
Xvoid      WIDGET__FillStringInRect(const char  * pText, const GUI_RECT * pFillRect, const GUI_RECT * pTextRectMax, const GUI_RECT * pTextRectAct);
N
N/*********************************************************************
N*
N*           API routines
N*
N**********************************************************************
N*/
Nvoid  WIDGET_SetState     (WM_HWIN hObj, int State);
Xvoid  WIDGET_SetState     (GUI_HWIN hObj, int State);
Nvoid  WIDGET_AndState     (WM_HWIN hObj, int State);
Xvoid  WIDGET_AndState     (GUI_HWIN hObj, int State);
Nvoid  WIDGET_OrState      (WM_HWIN hObj, int State);
Xvoid  WIDGET_OrState      (GUI_HWIN hObj, int State);
Nint   WIDGET_HandleActive (WM_HWIN hObj, WM_MESSAGE* pMsg);
Xint   WIDGET_HandleActive (GUI_HWIN hObj, WM_MESSAGE* pMsg);
Nint   WIDGET_GetState     (WM_HWIN hObj);
Xint   WIDGET_GetState     (GUI_HWIN hObj);
Nint   WIDGET_SetWidth     (WM_HWIN hObj, int Width);
Xint   WIDGET_SetWidth     (GUI_HWIN hObj, int Width);
N
Nvoid  WIDGET_EFFECT_3D_DrawUp(void);
N
Nvoid  WIDGET_SetDefaultEffect_3D    (void);
Nvoid  WIDGET_SetDefaultEffect_3D1L  (void);
Nvoid  WIDGET_SetDefaultEffect_3D2L  (void);
Nvoid  WIDGET_SetDefaultEffect_None  (void);
Nvoid  WIDGET_SetDefaultEffect_Simple(void);
N
Nconst WIDGET_EFFECT* WIDGET_SetDefaultEffect(const WIDGET_EFFECT* pEffect);
N
Nvoid  WIDGET_SetEffect              (WM_HWIN hObj, const WIDGET_EFFECT* pEffect);
Xvoid  WIDGET_SetEffect              (GUI_HWIN hObj, const WIDGET_EFFECT* pEffect);
N
Nconst WIDGET_EFFECT* WIDGET_GetDefaultEffect(void);
Nint   WIDGET_SetWidth(WM_HWIN hObj, int Width);
Xint   WIDGET_SetWidth(GUI_HWIN hObj, int Width);
N
N
N#endif /* GUI_WINSUPPORT */
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif   /* SLIDER_H */
N
N
N
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 28 "..\GUI\Widget\EDIT_Private.h" 2
N
N/*********************************************************************
N*
N*       Defines
N*
N**********************************************************************
N*/
N
N#define EDIT_REALLOC_SIZE  16
N
N#ifndef EDIT_XOFF
N  #define EDIT_XOFF 1
N#endif
N
N/*********************************************************************
N*
N*       Types
N*
N**********************************************************************
N*/
N
Ntypedef struct EDIT_Obj_struct EDIT_Obj;
N
Ntypedef struct {
N  int                          Align;
N  int                          Border;
N  const GUI_FONT GUI_UNI_PTR * pFont;
X  const GUI_FONT  * pFont;
N  GUI_COLOR                    aTextColor[2];
N  GUI_COLOR                    aBkColor[2];
N} EDIT_PROPS;
N
Nstruct EDIT_Obj_struct {
N  WIDGET Widget;
N  WM_HMEM hpText;
X  signed short hpText;
N  I16 MaxLen;
X  signed short MaxLen;
N  U16 BufferSize;
X  unsigned short BufferSize;
N  I32 Min, Max;            /* Min max values as normalized floats (integers) */
X  signed long Min, Max;             
N  U8 NumDecs;              /* Number of decimals */
X  unsigned char NumDecs;               
N  U32 CurrentValue;        /* Current value */
X  unsigned long CurrentValue;         
N  int CursorPos;           /* Cursor position. 0 means left most */
N  unsigned SelSize;        /* Number of selected characters */
N  U8 EditMode;             /* Insert or overwrite mode */
X  unsigned char EditMode;              
N  U8 XSizeCursor;          /* Size of cursor when working in insert mode */
X  unsigned char XSizeCursor;           
N  U8 Flags;
X  unsigned char Flags;
N  tEDIT_AddKeyEx     * pfAddKeyEx;     /* Handle key input */
N  tEDIT_UpdateBuffer * pfUpdateBuffer;  /* Update textbuffer */
N  EDIT_PROPS Props;
N  #if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X  #if 1 >= 2
S    int DebugId;
N  #endif  
N};
N
N/*********************************************************************
N*
N*       Macros for internal use
N*
N**********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
X#if 1 >= 2
S  EDIT_Obj * EDIT_h2p(EDIT_Handle h);
S  #define EDIT_H2P(h) EDIT_h2p(h)
S  #define EDIT_INIT_ID(p) p->DebugId = EDIT_ID
N#else
N  #define EDIT_H2P(h) (EDIT_Obj *)GUI_ALLOC_h2p(h)
N  #define EDIT_INIT_ID(p)
N#endif
N
N/*********************************************************************
N*
N*       Public data (internal defaults)
N*
N**********************************************************************
N*/
N
Nextern EDIT_PROPS EDIT__DefaultProps;
N
N/*********************************************************************
N*
N*       Public functions (internal)
N*
N**********************************************************************
N*/
N
Nvoid EDIT__SetCursorPos   (EDIT_Obj* pObj, int CursorPos);
NU16  EDIT__GetCurrentChar (EDIT_Obj* pObj);
Xunsigned short  EDIT__GetCurrentChar (EDIT_Obj* pObj);
Nvoid EDIT__SetValueUnsigned(EDIT_Handle hObj, I32 Value);
Xvoid EDIT__SetValueUnsigned(EDIT_Handle hObj, signed long Value);
N
N#endif /* GUI_WINSUPPORT */
N
N#endif /* EDIT_PRIVATE_H */
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 23 "..\GUI\Widget\EDITFloat.c" 2
N#include "GUIDebug.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*             Exported routines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       EDIT_SetFloatMode
N*/
Nvoid EDIT_SetFloatMode(EDIT_Handle hEdit, float Value, float Min, float Max, int Shift, U8 Flags) {
Xvoid EDIT_SetFloatMode(EDIT_Handle hEdit, float Value, float Min, float Max, int Shift, unsigned char Flags) {
N  I32 _Value, _Min, _Max;
X  signed long _Value, _Min, _Max;
N  float Scale;
N  if (hEdit) {
N    WM_LOCK();
X    ;
N    Scale  =(float)GUI_Pow10[Shift];
N    _Value = floor(Scale * Value + 0.5);
N    _Min   = floor(Scale * Min + 0.5);
N    _Max   = floor(Scale * Max + 0.5);
N    EDIT_SetDecMode(hEdit, _Value, _Min, _Max, Shift, Flags);
N    WM_UNLOCK();
X    ;
N  }
N}
N
N/*********************************************************************
N*
N*       EDIT_GetFloatValue
N*/
Nfloat EDIT_GetFloatValue(EDIT_Handle hObj) {
N  float Value = 0;
N  if (hObj) {
N    float Scale;
N    EDIT_Obj * pObj;
N    WM_LOCK();
X    ;
N    pObj  = EDIT_H2P(hObj);
X    pObj  = (EDIT_Obj *)GUI_ALLOC_h2p(hObj);
N    Scale = (float)GUI_Pow10[pObj->NumDecs];
N    Value = (float)(I32)pObj->CurrentValue / Scale;
X    Value = (float)(signed long)pObj->CurrentValue / Scale;
N    WM_UNLOCK();
X    ;
N  }
N  return Value;
N}
N
N/*********************************************************************
N*
N*       EDIT_SetFloatValue
N*/
Nvoid EDIT_SetFloatValue(EDIT_Handle hObj, float Value) {
N  if (hObj) {
N    float Scale;
N    EDIT_Obj * pObj;
N    WM_LOCK();
X    ;
N    pObj  = EDIT_H2P(hObj);
X    pObj  = (EDIT_Obj *)GUI_ALLOC_h2p(hObj);
N    Scale = (float)GUI_Pow10[pObj->NumDecs];
N    Value *= Scale;
N    EDIT_SetValue(hObj, (I32)(Value + (Value >= 0 ? 0.5 : -0.5)));
X    EDIT_SetValue(hObj, (signed long)(Value + (Value >= 0 ? 0.5 : -0.5)));
N    WM_UNLOCK();
X    ;
N  }
N}
N
N#else  /* avoid empty object files */
S
Svoid EditFloat_C(void);
Svoid EditFloat_C(void){}
S
N#endif /* GUI_WINSUPPORT */
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
