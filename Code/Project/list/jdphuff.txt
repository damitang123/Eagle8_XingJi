; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\jdphuff.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jdphuff.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\JPEG\jdphuff.c]
                          THUMB

                          AREA ||i.decode_mcu_AC_first||, CODE, READONLY, ALIGN=2

                  decode_mcu_AC_first PROC
;;;356    METHODDEF(boolean)
;;;357    decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;358    {   
000004  b089              SUB      sp,sp,#0x24
000006  4606              MOV      r6,r0
;;;359      phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
;;;360      int Se = cinfo->Se;
;;;361      int Al = cinfo->Al;
000008  f8d09194          LDR      r9,[r0,#0x194]
00000c  f8d051bc          LDR      r5,[r0,#0x1bc]
000010  f8d0019c          LDR      r0,[r0,#0x19c]
;;;362      register int s, k, r;
;;;363      unsigned int EOBRUN;
;;;364      JBLOCKROW block;
;;;365      BITREAD_STATE_VARS;
;;;366      d_derived_tbl * tbl;
;;;367    
;;;368      /* Process restart marker if needed; may have to suspend */
;;;369      if (cinfo->restart_interval) {
000014  9006              STR      r0,[sp,#0x18]
000016  f8d60114          LDR      r0,[r6,#0x114]        ;358
00001a  460f              MOV      r7,r1                 ;358
00001c  b130              CBZ      r0,|L1.44|
;;;370        if (entropy->restarts_to_go == 0)
00001e  6aa8              LDR      r0,[r5,#0x28]
000020  b920              CBNZ     r0,|L1.44|
;;;371          if (! process_restart(cinfo))
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       process_restart
000028  2800              CMP      r0,#0
00002a  d03b              BEQ      |L1.164|
                  |L1.44|
;;;372    	return FALSE;
;;;373      }
;;;374    
;;;375      /* If we've run out of data, just leave the MCU set to zeroes.
;;;376       * This way, we return uniform gray for the remainder of the segment.
;;;377       */
;;;378      if (! entropy->pub.insufficient_data) {
00002c  68a8              LDR      r0,[r5,#8]
00002e  2800              CMP      r0,#0
000030  d17d              BNE      |L1.302|
;;;379    
;;;380        /* Load up working state.
;;;381         * We can avoid loading/saving bitread state if in an EOB run.
;;;382         */
;;;383        EOBRUN = entropy->saved.EOBRUN;	/* only part of saved state we need */
;;;384    
;;;385        /* There is always only one block per MCU */
;;;386    
;;;387        if (EOBRUN > 0)		/* if it's a band of zeroes... */
000032  696c              LDR      r4,[r5,#0x14]
000034  b10c              CBZ      r4,|L1.58|
000036  1e64              SUBS     r4,r4,#1
;;;388          EOBRUN--;			/* ...process it now (we do nothing) */
000038  e08f              B        |L1.346|
                  |L1.58|
;;;389        else {
;;;390          BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
00003a  9605              STR      r6,[sp,#0x14]
00003c  69b0              LDR      r0,[r6,#0x18]
00003e  6801              LDR      r1,[r0,#0]
000040  9101              STR      r1,[sp,#4]
000042  6840              LDR      r0,[r0,#4]
000044  9002              STR      r0,[sp,#8]
000046  e9d51203          LDRD     r1,r2,[r5,#0xc]
;;;391          block = MCU_data[0];
00004a  6838              LDR      r0,[r7,#0]
;;;392          tbl = entropy->ac_derived_tbl;
00004c  9007              STR      r0,[sp,#0x1c]
;;;393    
;;;394          for (k = cinfo->Ss; k <= Se; k++) {
00004e  f8d5b03c          LDR      r11,[r5,#0x3c]
000052  f8d68190          LDR      r8,[r6,#0x190]
000056  e076              B        |L1.326|
                  |L1.88|
;;;395    	HUFF_DECODE(s, br_state, tbl, return FALSE, label2);
000058  2a08              CMP      r2,#8
00005a  da0b              BGE      |L1.116|
00005c  2300              MOVS     r3,#0
00005e  a801              ADD      r0,sp,#4
000060  f7fffffe          BL       jpeg_fill_bit_buffer
000064  2800              CMP      r0,#0
000066  d01d              BEQ      |L1.164|
000068  e9dd1203          LDRD     r1,r2,[sp,#0xc]
00006c  2a08              CMP      r2,#8
00006e  da01              BGE      |L1.116|
000070  2001              MOVS     r0,#1
000072  e00f              B        |L1.148|
                  |L1.116|
000074  f1a20008          SUB      r0,r2,#8
000078  fa41f000          ASR      r0,r1,r0
00007c  b2c0              UXTB     r0,r0
00007e  eb0b0380          ADD      r3,r11,r0,LSL #2
000082  f8d33090          LDR      r3,[r3,#0x90]
000086  b123              CBZ      r3,|L1.146|
000088  4458              ADD      r0,r0,r11
00008a  1ad2              SUBS     r2,r2,r3
00008c  f8900490          LDRB     r0,[r0,#0x490]
000090  e00d              B        |L1.174|
                  |L1.146|
000092  2009              MOVS     r0,#9
                  |L1.148|
000094  9000              STR      r0,[sp,#0]
000096  465b              MOV      r3,r11
000098  a801              ADD      r0,sp,#4
00009a  f7fffffe          BL       jpeg_huff_decode
00009e  2800              CMP      r0,#0
0000a0  da03              BGE      |L1.170|
0000a2  2000              MOVS     r0,#0
                  |L1.164|
;;;396    	r = s >> 4;
;;;397    	s &= 15;
;;;398    	if (s) {
;;;399    	  k += r;
;;;400    	  CHECK_BIT_BUFFER(br_state, s, return FALSE);
;;;401    	  r = GET_BITS(s);
;;;402    	  s = HUFF_EXTEND(r, s);
;;;403    	  /* Scale and output coefficient in natural (dezigzagged) order */
;;;404    	  (*block)[jpeg_natural_order[k]] = (JCOEF) (s << Al);
;;;405    	} else {
;;;406    	  if (r == 15) {	/* ZRL */
;;;407    	    k += 15;		/* skip 15 zeroes in band */
;;;408    	  } else {		/* EOBr, run length is 2^r + appended bits */
;;;409    	    EOBRUN = 1 << r;
;;;410    	    if (r) {		/* EOBr, r > 0 */
;;;411    	      CHECK_BIT_BUFFER(br_state, r, return FALSE);
;;;412    	      r = GET_BITS(r);
;;;413    	      EOBRUN += r;
;;;414    	    }
;;;415    	    EOBRUN--;		/* this band is processed at this moment */
;;;416    	    break;		/* force end-of-band */
;;;417    	  }
;;;418    	}
;;;419          }
;;;420    
;;;421          BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
;;;422        }
;;;423    
;;;424        /* Completed MCU, so update state */
;;;425        entropy->saved.EOBRUN = EOBRUN;	/* only part of saved state we need */
;;;426      }
;;;427    
;;;428      /* Account for restart interval (no-op if not using restarts) */
;;;429      entropy->restarts_to_go--;
;;;430    
;;;431      return TRUE;
;;;432    }
0000a4  b009              ADD      sp,sp,#0x24
0000a6  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.170|
0000aa  e9dd1203          LDRD     r1,r2,[sp,#0xc]
                  |L1.174|
0000ae  1107              ASRS     r7,r0,#4              ;396
0000b0  f000000f          AND      r0,r0,#0xf            ;397
0000b4  ea5f0a00          MOVS     r10,r0                ;397
0000b8  d028              BEQ      |L1.268|
0000ba  4447              ADD      r7,r7,r8              ;399
0000bc  4650              MOV      r0,r10                ;400
0000be  4552              CMP      r2,r10                ;400
0000c0  da07              BGE      |L1.210|
0000c2  4603              MOV      r3,r0                 ;400
0000c4  a801              ADD      r0,sp,#4              ;400
0000c6  f7fffffe          BL       jpeg_fill_bit_buffer
0000ca  2800              CMP      r0,#0                 ;400
0000cc  d0ea              BEQ      |L1.164|
0000ce  e9dd1203          LDRD     r1,r2,[sp,#0xc]       ;400
                  |L1.210|
0000d2  eba2020a          SUB      r2,r2,r10             ;401
0000d6  2301              MOVS     r3,#1                 ;401
0000d8  fa41f002          ASR      r0,r1,r2              ;401
0000dc  fa03f30a          LSL      r3,r3,r10             ;401
0000e0  f8dfc084          LDR      r12,|L1.360|
0000e4  1e5b              SUBS     r3,r3,#1              ;401
0000e6  4018              ANDS     r0,r0,r3              ;401
0000e8  f85c302a          LDR      r3,[r12,r10,LSL #2]   ;402
0000ec  4283              CMP      r3,r0                 ;402
0000ee  dd04              BLE      |L1.250|
0000f0  f10c0c40          ADD      r12,r12,#0x40         ;402
0000f4  f85c302a          LDR      r3,[r12,r10,LSL #2]   ;402
0000f8  4418              ADD      r0,r0,r3              ;402
                  |L1.250|
0000fa  9b06              LDR      r3,[sp,#0x18]         ;404
0000fc  4098              LSLS     r0,r0,r3              ;404
0000fe  4b1b              LDR      r3,|L1.364|
000100  f853c027          LDR      r12,[r3,r7,LSL #2]    ;404
000104  9b07              LDR      r3,[sp,#0x1c]         ;404
000106  f823001c          STRH     r0,[r3,r12,LSL #1]    ;404
00010a  e01a              B        |L1.322|
                  |L1.268|
00010c  2f0f              CMP      r7,#0xf               ;406
00010e  d016              BEQ      |L1.318|
000110  2401              MOVS     r4,#1                 ;409
000112  40bc              LSLS     r4,r4,r7              ;409
000114  b18f              CBZ      r7,|L1.314|
000116  42ba              CMP      r2,r7                 ;411
000118  da07              BGE      |L1.298|
00011a  463b              MOV      r3,r7                 ;411
00011c  a801              ADD      r0,sp,#4              ;411
00011e  f7fffffe          BL       jpeg_fill_bit_buffer
000122  2800              CMP      r0,#0                 ;411
000124  d0be              BEQ      |L1.164|
000126  e9dd1203          LDRD     r1,r2,[sp,#0xc]       ;411
                  |L1.298|
00012a  1bd2              SUBS     r2,r2,r7              ;412
00012c  e000              B        |L1.304|
                  |L1.302|
00012e  e015              B        |L1.348|
                  |L1.304|
000130  fa41f002          ASR      r0,r1,r2              ;412
000134  1e63              SUBS     r3,r4,#1              ;412
000136  4018              ANDS     r0,r0,r3              ;412
000138  4404              ADD      r4,r4,r0              ;413
                  |L1.314|
00013a  1e64              SUBS     r4,r4,#1              ;413
00013c  e005              B        |L1.330|
                  |L1.318|
00013e  f108070f          ADD      r7,r8,#0xf            ;407
                  |L1.322|
000142  f1070801          ADD      r8,r7,#1              ;407
                  |L1.326|
000146  45c8              CMP      r8,r9                 ;394
000148  dd86              BLE      |L1.88|
                  |L1.330|
00014a  69b3              LDR      r3,[r6,#0x18]         ;421
00014c  9801              LDR      r0,[sp,#4]            ;421
00014e  6018              STR      r0,[r3,#0]            ;421
000150  69b0              LDR      r0,[r6,#0x18]         ;421
000152  9b02              LDR      r3,[sp,#8]            ;421
000154  6043              STR      r3,[r0,#4]            ;421
000156  e9c51203          STRD     r1,r2,[r5,#0xc]       ;421
                  |L1.346|
00015a  616c              STR      r4,[r5,#0x14]         ;425
                  |L1.348|
00015c  6aa8              LDR      r0,[r5,#0x28]         ;429
00015e  1e40              SUBS     r0,r0,#1              ;429
000160  62a8              STR      r0,[r5,#0x28]         ;431
000162  2001              MOVS     r0,#1                 ;431
000164  e79e              B        |L1.164|
;;;433    
                          ENDP

000166  0000              DCW      0x0000
                  |L1.360|
                          DCD      ||.constdata||
                  |L1.364|
                          DCD      jpeg_natural_order

                          AREA ||i.decode_mcu_AC_refine||, CODE, READONLY, ALIGN=2

                  decode_mcu_AC_refine PROC
;;;490    METHODDEF(boolean)
;;;491    decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;492    {   
000004  b0cd              SUB      sp,sp,#0x134
000006  4607              MOV      r7,r0
;;;493      phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
;;;494      int Se = cinfo->Se;
000008  f8d061bc          LDR      r6,[r0,#0x1bc]
00000c  f8d00194          LDR      r0,[r0,#0x194]
000010  460d              MOV      r5,r1                 ;492
;;;495      int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
000012  9049              STR      r0,[sp,#0x124]
000014  f897119c          LDRB     r1,[r7,#0x19c]
000018  2001              MOVS     r0,#1
00001a  4088              LSLS     r0,r0,r1
;;;496      int m1 = (-1) << cinfo->Al;	/* -1 in the bit position being coded */
00001c  9047              STR      r0,[sp,#0x11c]
00001e  f04f30ff          MOV      r0,#0xffffffff
000022  4088              LSLS     r0,r0,r1
;;;497      register int s, k, r;
;;;498      unsigned int EOBRUN;
;;;499      JBLOCKROW block;
;;;500      JCOEFPTR thiscoef;
;;;501      BITREAD_STATE_VARS;
;;;502      d_derived_tbl * tbl;
;;;503      int num_newnz;
;;;504      int newnz_pos[DCTSIZE2];
;;;505    
;;;506      /* Process restart marker if needed; may have to suspend */
;;;507      if (cinfo->restart_interval) {
000024  9048              STR      r0,[sp,#0x120]
000026  f8d70114          LDR      r0,[r7,#0x114]        ;492
00002a  b130              CBZ      r0,|L2.58|
;;;508        if (entropy->restarts_to_go == 0)
00002c  6ab0              LDR      r0,[r6,#0x28]
00002e  b920              CBNZ     r0,|L2.58|
;;;509          if (! process_restart(cinfo))
000030  4638              MOV      r0,r7
000032  f7fffffe          BL       process_restart
000036  2800              CMP      r0,#0
000038  d070              BEQ      |L2.284|
                  |L2.58|
;;;510    	return FALSE;
;;;511      }
;;;512    
;;;513      /* If we've run out of data, don't modify the MCU.
;;;514       */
;;;515      if (! entropy->pub.insufficient_data) {
00003a  68b0              LDR      r0,[r6,#8]
00003c  2800              CMP      r0,#0
00003e  d16e              BNE      |L2.286|
;;;516    
;;;517        /* Load up working state */
;;;518        BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
000040  9746              STR      r7,[sp,#0x118]
000042  69b8              LDR      r0,[r7,#0x18]
000044  6801              LDR      r1,[r0,#0]
000046  9142              STR      r1,[sp,#0x108]
000048  6840              LDR      r0,[r0,#4]
00004a  9043              STR      r0,[sp,#0x10c]
00004c  e9d64004          LDRD     r4,r0,[r6,#0x10]
;;;519        EOBRUN = entropy->saved.EOBRUN; /* only part of saved state we need */
000050  ea5f0800          MOVS     r8,r0
000054  f8d6900c          LDR      r9,[r6,#0xc]
;;;520    
;;;521        /* There is always only one block per MCU */
;;;522        block = MCU_data[0];
000058  6828              LDR      r0,[r5,#0]
;;;523        tbl = entropy->ac_derived_tbl;
00005a  9041              STR      r0,[sp,#0x104]
00005c  6bf0              LDR      r0,[r6,#0x3c]
;;;524    
;;;525        /* If we are forced to suspend, we must undo the assignments to any newly
;;;526         * nonzero coefficients in the block, because otherwise we'd get confused
;;;527         * next time about which coefficients were already nonzero.
;;;528         * But we need not undo addition of bits to already-nonzero coefficients;
;;;529         * instead, we can test the current bit to see if we already did it.
;;;530         */
;;;531        num_newnz = 0;
00005e  904b              STR      r0,[sp,#0x12c]
000060  f04f0000          MOV      r0,#0
;;;532    
;;;533        /* initialize coefficient loop counter to start of band */
;;;534        k = cinfo->Ss;
000064  904a              STR      r0,[sp,#0x128]
;;;535    
;;;536        if (EOBRUN == 0) {
000066  f8d75190          LDR      r5,[r7,#0x190]
00006a  d07d              BEQ      |L2.360|
00006c  e0f2              B        |L2.596|
                  |L2.110|
;;;537          for (; k <= Se; k++) {
;;;538    	HUFF_DECODE(s, br_state, tbl, goto undoit, label3);
00006e  2c08              CMP      r4,#8
000070  da0e              BGE      |L2.144|
000072  2300              MOVS     r3,#0
000074  4622              MOV      r2,r4
000076  4649              MOV      r1,r9
000078  a842              ADD      r0,sp,#0x108
00007a  f7fffffe          BL       jpeg_fill_bit_buffer
00007e  2800              CMP      r0,#0
000080  d073              BEQ      |L2.362|
000082  9c45              LDR      r4,[sp,#0x114]
000084  f8dd9110          LDR      r9,[sp,#0x110]
000088  2c08              CMP      r4,#8
00008a  da01              BGE      |L2.144|
00008c  2001              MOVS     r0,#1
00008e  e011              B        |L2.180|
                  |L2.144|
000090  f1a40108          SUB      r1,r4,#8
000094  fa49f001          ASR      r0,r9,r1
000098  994b              LDR      r1,[sp,#0x12c]
00009a  b2c0              UXTB     r0,r0
00009c  eb010180          ADD      r1,r1,r0,LSL #2
0000a0  f8d11090          LDR      r1,[r1,#0x90]
0000a4  b129              CBZ      r1,|L2.178|
0000a6  1a64              SUBS     r4,r4,r1
0000a8  994b              LDR      r1,[sp,#0x12c]
0000aa  4408              ADD      r0,r0,r1
0000ac  f8900490          LDRB     r0,[r0,#0x490]
0000b0  e00c              B        |L2.204|
                  |L2.178|
0000b2  2009              MOVS     r0,#9
                  |L2.180|
0000b4  9000              STR      r0,[sp,#0]
0000b6  4622              MOV      r2,r4
0000b8  4649              MOV      r1,r9
0000ba  a842              ADD      r0,sp,#0x108
0000bc  9b4b              LDR      r3,[sp,#0x12c]
0000be  f7fffffe          BL       jpeg_huff_decode
0000c2  2800              CMP      r0,#0
0000c4  db51              BLT      |L2.362|
0000c6  f8dd9110          LDR      r9,[sp,#0x110]
0000ca  9c45              LDR      r4,[sp,#0x114]
                  |L2.204|
;;;539    	r = s >> 4;
0000cc  ea4f1a20          ASR      r10,r0,#4
;;;540    	s &= 15;
0000d0  f010000f          ANDS     r0,r0,#0xf
;;;541    	if (s) {
0000d4  9000              STR      r0,[sp,#0]
0000d6  d023              BEQ      |L2.288|
;;;542    	  if (s != 1)		/* size of new coef should always be 1 */
0000d8  2801              CMP      r0,#1
0000da  d008              BEQ      |L2.238|
;;;543    	    WARNMS(cinfo, JWRN_HUFF_BAD_CODE);
0000dc  6839              LDR      r1,[r7,#0]
0000de  2076              MOVS     r0,#0x76
0000e0  6148              STR      r0,[r1,#0x14]
0000e2  6838              LDR      r0,[r7,#0]
0000e4  f04f31ff          MOV      r1,#0xffffffff
0000e8  6842              LDR      r2,[r0,#4]
0000ea  4638              MOV      r0,r7
0000ec  4790              BLX      r2
                  |L2.238|
;;;544    	  CHECK_BIT_BUFFER(br_state, 1, goto undoit);
0000ee  2c01              CMP      r4,#1
0000f0  da0a              BGE      |L2.264|
0000f2  2301              MOVS     r3,#1
0000f4  4622              MOV      r2,r4
0000f6  4649              MOV      r1,r9
0000f8  a842              ADD      r0,sp,#0x108
0000fa  f7fffffe          BL       jpeg_fill_bit_buffer
0000fe  2800              CMP      r0,#0
000100  d033              BEQ      |L2.362|
000102  f8dd9110          LDR      r9,[sp,#0x110]
000106  9c45              LDR      r4,[sp,#0x114]
                  |L2.264|
000108  1e64              SUBS     r4,r4,#1
;;;545    	  if (GET_BITS(1))
00010a  fa49f004          ASR      r0,r9,r4
00010e  07c0              LSLS     r0,r0,#31
000110  d001              BEQ      |L2.278|
;;;546    	    s = p1;		/* newly nonzero coef is positive */
000112  9847              LDR      r0,[sp,#0x11c]
000114  e000              B        |L2.280|
                  |L2.278|
;;;547    	  else
;;;548    	    s = m1;		/* newly nonzero coef is negative */
000116  9848              LDR      r0,[sp,#0x120]
                  |L2.280|
000118  9000              STR      r0,[sp,#0]
00011a  e027              B        |L2.364|
                  |L2.284|
00011c  e0ad              B        |L2.634|
                  |L2.286|
00011e  e0a8              B        |L2.626|
                  |L2.288|
;;;549    	} else {
;;;550    	  if (r != 15) {
000120  f1ba0f0f          CMP      r10,#0xf
000124  d022              BEQ      |L2.364|
;;;551    	    EOBRUN = 1 << r;	/* EOBr, run length is 2^r + appended bits */
000126  ea5f010a          MOVS     r1,r10
00012a  f04f0001          MOV      r0,#1
00012e  fa00f801          LSL      r8,r0,r1
;;;552    	    if (r) {
000132  4650              MOV      r0,r10
000134  d014              BEQ      |L2.352|
;;;553    	      CHECK_BIT_BUFFER(br_state, r, goto undoit);
000136  4554              CMP      r4,r10
000138  da0a              BGE      |L2.336|
00013a  4603              MOV      r3,r0
00013c  4622              MOV      r2,r4
00013e  4649              MOV      r1,r9
000140  a842              ADD      r0,sp,#0x108
000142  f7fffffe          BL       jpeg_fill_bit_buffer
000146  2800              CMP      r0,#0
000148  d00f              BEQ      |L2.362|
00014a  f8dd9110          LDR      r9,[sp,#0x110]
00014e  9c45              LDR      r4,[sp,#0x114]
                  |L2.336|
;;;554    	      r = GET_BITS(r);
000150  f1a80101          SUB      r1,r8,#1
000154  eba4040a          SUB      r4,r4,r10
000158  fa49f004          ASR      r0,r9,r4
00015c  4008              ANDS     r0,r0,r1
;;;555    	      EOBRUN += r;
00015e  4480              ADD      r8,r8,r0
                  |L2.352|
;;;556    	    }
;;;557    	    break;		/* rest of block is handled by EOB logic */
;;;558    	  }
;;;559    	  /* note s = 0 for processing ZRL */
;;;560    	}
;;;561    	/* Advance over already-nonzero coefs and r still-zero coefs,
;;;562    	 * appending correction bits to the nonzeroes.  A correction bit is 1
;;;563    	 * if the absolute value of the coefficient must be increased.
;;;564    	 */
;;;565    	do {
;;;566    	  thiscoef = *block + jpeg_natural_order[k];
;;;567    	  if (*thiscoef != 0) {
;;;568    	    CHECK_BIT_BUFFER(br_state, 1, goto undoit);
;;;569    	    if (GET_BITS(1)) {
;;;570    	      if ((*thiscoef & p1) == 0) { /* do nothing if already set it */
;;;571    		if (*thiscoef >= 0)
;;;572    		  *thiscoef += p1;
;;;573    		else
;;;574    		  *thiscoef += m1;
;;;575    	      }
;;;576    	    }
;;;577    	  } else {
;;;578    	    if (--r < 0)
;;;579    	      break;		/* reached target zero coefficient */
;;;580    	  }
;;;581    	  k++;
;;;582    	} while (k <= Se);
;;;583    	if (s) {
;;;584    	  int pos = jpeg_natural_order[k];
;;;585    	  /* Output newly nonzero coefficient */
;;;586    	  (*block)[pos] = (JCOEF) s;
;;;587    	  /* Remember its position in case we have to suspend */
;;;588    	  newnz_pos[num_newnz++] = pos;
;;;589    	}
;;;590          }
;;;591        }
;;;592    
;;;593        if (EOBRUN > 0) {
000160  f1b80f00          CMP      r8,#0
000164  d176              BNE      |L2.596|
000166  e07a              B        |L2.606|
                  |L2.360|
000168  e045              B        |L2.502|
                  |L2.362|
00016a  e049              B        |L2.512|
                  |L2.364|
00016c  484c              LDR      r0,|L2.672|
00016e  9941              LDR      r1,[sp,#0x104]        ;566
000170  f8500025          LDR      r0,[r0,r5,LSL #2]     ;566
000174  eb010b40          ADD      r11,r1,r0,LSL #1      ;566
000178  f8bb0000          LDRH     r0,[r11,#0]           ;567
00017c  b308              CBZ      r0,|L2.450|
00017e  2c01              CMP      r4,#1                 ;568
000180  da09              BGE      |L2.406|
000182  2301              MOVS     r3,#1                 ;568
000184  4622              MOV      r2,r4                 ;568
000186  4649              MOV      r1,r9                 ;568
000188  a842              ADD      r0,sp,#0x108          ;568
00018a  f7fffffe          BL       jpeg_fill_bit_buffer
00018e  b3b8              CBZ      r0,|L2.512|
000190  f8dd9110          LDR      r9,[sp,#0x110]        ;568
000194  9c45              LDR      r4,[sp,#0x114]        ;568
                  |L2.406|
000196  1e64              SUBS     r4,r4,#1              ;568
000198  fa49f004          ASR      r0,r9,r4              ;569
00019c  07c0              LSLS     r0,r0,#31             ;569
00019e  d015              BEQ      |L2.460|
0001a0  f9bb0000          LDRSH    r0,[r11,#0]           ;570
0001a4  9947              LDR      r1,[sp,#0x11c]        ;570
0001a6  4208              TST      r0,r1                 ;570
0001a8  d110              BNE      |L2.460|
0001aa  2800              CMP      r0,#0                 ;571
0001ac  db04              BLT      |L2.440|
0001ae  9947              LDR      r1,[sp,#0x11c]        ;572
0001b0  4401              ADD      r1,r1,r0              ;572
0001b2  f8ab1000          STRH     r1,[r11,#0]           ;572
0001b6  e009              B        |L2.460|
                  |L2.440|
0001b8  9948              LDR      r1,[sp,#0x120]        ;574
0001ba  4408              ADD      r0,r0,r1              ;574
0001bc  f8ab0000          STRH     r0,[r11,#0]           ;574
0001c0  e004              B        |L2.460|
                  |L2.450|
0001c2  f1aa0001          SUB      r0,r10,#1             ;578
0001c6  ea5f0a00          MOVS     r10,r0                ;578
0001ca  d403              BMI      |L2.468|
                  |L2.460|
0001cc  9849              LDR      r0,[sp,#0x124]        ;582
0001ce  1c6d              ADDS     r5,r5,#1              ;582
0001d0  4285              CMP      r5,r0                 ;582
0001d2  ddcb              BLE      |L2.364|
                  |L2.468|
0001d4  9800              LDR      r0,[sp,#0]            ;583
0001d6  b168              CBZ      r0,|L2.500|
0001d8  4831              LDR      r0,|L2.672|
0001da  9a41              LDR      r2,[sp,#0x104]        ;586
0001dc  9900              LDR      r1,[sp,#0]            ;586
0001de  f8500025          LDR      r0,[r0,r5,LSL #2]     ;584
0001e2  f8221010          STRH     r1,[r2,r0,LSL #1]     ;586
0001e6  9a4a              LDR      r2,[sp,#0x128]        ;588
0001e8  a901              ADD      r1,sp,#4              ;588
0001ea  f8410022          STR      r0,[r1,r2,LSL #2]     ;588
0001ee  984a              LDR      r0,[sp,#0x128]        ;588
0001f0  1c40              ADDS     r0,r0,#1              ;588
0001f2  904a              STR      r0,[sp,#0x128]        ;588
                  |L2.500|
0001f4  1c6d              ADDS     r5,r5,#1              ;588
                  |L2.502|
0001f6  9849              LDR      r0,[sp,#0x124]        ;537
0001f8  4285              CMP      r5,r0                 ;537
0001fa  f77faf38          BLE      |L2.110|
0001fe  e02e              B        |L2.606|
                  |L2.512|
000200  e046              B        |L2.656|
                  |L2.514|
;;;594          /* Scan any remaining coefficient positions after the end-of-band
;;;595           * (the last newly nonzero coefficient, if any).  Append a correction
;;;596           * bit to each already-nonzero coefficient.  A correction bit is 1
;;;597           * if the absolute value of the coefficient must be increased.
;;;598           */
;;;599          for (; k <= Se; k++) {
;;;600    	thiscoef = *block + jpeg_natural_order[k];
000202  4827              LDR      r0,|L2.672|
000204  f8501025          LDR      r1,[r0,r5,LSL #2]
000208  9841              LDR      r0,[sp,#0x104]
00020a  eb000a41          ADD      r10,r0,r1,LSL #1
;;;601    	if (*thiscoef != 0) {
00020e  f8ba0000          LDRH     r0,[r10,#0]
000212  b1f0              CBZ      r0,|L2.594|
;;;602    	  CHECK_BIT_BUFFER(br_state, 1, goto undoit);
000214  2c01              CMP      r4,#1
000216  da09              BGE      |L2.556|
000218  2301              MOVS     r3,#1
00021a  4622              MOV      r2,r4
00021c  4649              MOV      r1,r9
00021e  a842              ADD      r0,sp,#0x108
000220  f7fffffe          BL       jpeg_fill_bit_buffer
000224  b3a0              CBZ      r0,|L2.656|
000226  f8dd9110          LDR      r9,[sp,#0x110]
00022a  9c45              LDR      r4,[sp,#0x114]
                  |L2.556|
00022c  1e64              SUBS     r4,r4,#1
;;;603    	  if (GET_BITS(1)) {
00022e  fa49f004          ASR      r0,r9,r4
000232  07c0              LSLS     r0,r0,#31
000234  d00d              BEQ      |L2.594|
;;;604    	    if ((*thiscoef & p1) == 0) { /* do nothing if already changed it */
000236  f9ba0000          LDRSH    r0,[r10,#0]
00023a  9947              LDR      r1,[sp,#0x11c]
00023c  4208              TST      r0,r1
00023e  d108              BNE      |L2.594|
;;;605    	      if (*thiscoef >= 0)
000240  2800              CMP      r0,#0
000242  db02              BLT      |L2.586|
;;;606    		*thiscoef += p1;
000244  9947              LDR      r1,[sp,#0x11c]
000246  e001              B        |L2.588|
000248  e004              B        |L2.596|
                  |L2.586|
;;;607    	      else
;;;608    		*thiscoef += m1;
00024a  9948              LDR      r1,[sp,#0x120]
                  |L2.588|
00024c  4408              ADD      r0,r0,r1              ;606
00024e  f8aa0000          STRH     r0,[r10,#0]           ;606
                  |L2.594|
000252  1c6d              ADDS     r5,r5,#1              ;606
                  |L2.596|
000254  9849              LDR      r0,[sp,#0x124]        ;599
000256  4285              CMP      r5,r0                 ;599
000258  ddd3              BLE      |L2.514|
;;;609    	    }
;;;610    	  }
;;;611    	}
;;;612          }
;;;613          /* Count one block completed in EOB run */
;;;614          EOBRUN--;
00025a  f1a80801          SUB      r8,r8,#1
                  |L2.606|
;;;615        }
;;;616    
;;;617        /* Completed MCU, so update state */
;;;618        BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
00025e  69b9              LDR      r1,[r7,#0x18]
000260  9842              LDR      r0,[sp,#0x108]
000262  6008              STR      r0,[r1,#0]
000264  69b9              LDR      r1,[r7,#0x18]
000266  9843              LDR      r0,[sp,#0x10c]
000268  6048              STR      r0,[r1,#4]
00026a  f8c6900c          STR      r9,[r6,#0xc]
00026e  e9c64804          STRD     r4,r8,[r6,#0x10]
                  |L2.626|
;;;619        entropy->saved.EOBRUN = EOBRUN; /* only part of saved state we need */
;;;620      }
;;;621    
;;;622      /* Account for restart interval (no-op if not using restarts) */
;;;623      entropy->restarts_to_go--;
000272  6ab0              LDR      r0,[r6,#0x28]
000274  1e40              SUBS     r0,r0,#1
;;;624    
;;;625      return TRUE;
000276  62b0              STR      r0,[r6,#0x28]
000278  2001              MOVS     r0,#1
                  |L2.634|
;;;626    
;;;627    undoit:
;;;628      /* Re-zero any output coefficients that we made newly nonzero */
;;;629      while (num_newnz > 0)
;;;630        (*block)[newnz_pos[--num_newnz]] = 0;
;;;631    
;;;632      return FALSE;
;;;633    }
00027a  b04d              ADD      sp,sp,#0x134
00027c  e8bd8ff0          POP      {r4-r11,pc}
                  |L2.640|
000280  1e49              SUBS     r1,r1,#1
000282  914a              STR      r1,[sp,#0x128]        ;630
000284  f8501021          LDR      r1,[r0,r1,LSL #2]     ;630
000288  9b41              LDR      r3,[sp,#0x104]        ;630
00028a  f8232011          STRH     r2,[r3,r1,LSL #1]     ;630
00028e  e002              B        |L2.662|
                  |L2.656|
000290  e7ff              B        |L2.658|
                  |L2.658|
000292  2200              MOVS     r2,#0                 ;630
000294  a801              ADD      r0,sp,#4              ;504
                  |L2.662|
000296  994a              LDR      r1,[sp,#0x128]        ;629
000298  2900              CMP      r1,#0                 ;629
00029a  dcf1              BGT      |L2.640|
00029c  2000              MOVS     r0,#0                 ;632
00029e  e7ec              B        |L2.634|
;;;634    
                          ENDP

                  |L2.672|
                          DCD      jpeg_natural_order

                          AREA ||i.decode_mcu_DC_first||, CODE, READONLY, ALIGN=2

                  decode_mcu_DC_first PROC
;;;285    METHODDEF(boolean)
;;;286    decode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;287    {   
000004  b095              SUB      sp,sp,#0x54
000006  4606              MOV      r6,r0
;;;288      phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
;;;289      int Al = cinfo->Al;
000008  f8d051bc          LDR      r5,[r0,#0x1bc]
00000c  f8d0019c          LDR      r0,[r0,#0x19c]
;;;290      register int s, r;
;;;291      int blkn, ci;
;;;292      JBLOCKROW block;
;;;293      BITREAD_STATE_VARS;
;;;294      savable_state state;
;;;295      d_derived_tbl * tbl;
;;;296      jpeg_component_info * compptr;
;;;297    
;;;298      /* Process restart marker if needed; may have to suspend */
;;;299      if (cinfo->restart_interval) {
000010  900a              STR      r0,[sp,#0x28]
000012  f8d60114          LDR      r0,[r6,#0x114]        ;287
000016  b130              CBZ      r0,|L3.38|
;;;300        if (entropy->restarts_to_go == 0)
000018  6aa8              LDR      r0,[r5,#0x28]
00001a  b920              CBNZ     r0,|L3.38|
;;;301          if (! process_restart(cinfo))
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       process_restart
000022  2800              CMP      r0,#0
000024  d04e              BEQ      |L3.196|
                  |L3.38|
;;;302    	return FALSE;
;;;303      }
;;;304    
;;;305      /* If we've run out of data, just leave the MCU set to zeroes.
;;;306       * This way, we return uniform gray for the remainder of the segment.
;;;307       */
;;;308      if (! entropy->pub.insufficient_data) {
000026  68a8              LDR      r0,[r5,#8]
000028  2800              CMP      r0,#0
00002a  d17c              BNE      |L3.294|
;;;309    
;;;310        /* Load up working state */
;;;311        BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
00002c  9608              STR      r6,[sp,#0x20]
00002e  69b0              LDR      r0,[r6,#0x18]
;;;312        ASSIGN_STATE(state, entropy->saved);
000030  2214              MOVS     r2,#0x14
000032  6801              LDR      r1,[r0,#0]            ;311
000034  9104              STR      r1,[sp,#0x10]         ;311
000036  6840              LDR      r0,[r0,#4]            ;311
000038  9005              STR      r0,[sp,#0x14]         ;311
00003a  e9d58403          LDRD     r8,r4,[r5,#0xc]
00003e  f1050114          ADD      r1,r5,#0x14
000042  a80d              ADD      r0,sp,#0x34
000044  9113              STR      r1,[sp,#0x4c]
000046  f7fffffe          BL       __aeabi_memcpy4
;;;313    
;;;314        /* Outer loop handles each block in the MCU */
;;;315    
;;;316        for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
00004a  2700              MOVS     r7,#0
00004c  e06f              B        |L3.302|
                  |L3.78|
;;;317          block = MCU_data[blkn];
00004e  9816              LDR      r0,[sp,#0x58]
;;;318          ci = cinfo->MCU_membership[blkn];
;;;319          compptr = cinfo->cur_comp_info[ci];
;;;320          tbl = entropy->derived_tbls[compptr->dc_tbl_no];
;;;321    
;;;322          /* Decode a single block's worth of coefficients */
;;;323    
;;;324          /* Section F.2.2.1: decode the DC coefficient difference */
;;;325          HUFF_DECODE(s, br_state, tbl, return FALSE, label1);
000050  2c08              CMP      r4,#8
000052  f850b027          LDR      r11,[r0,r7,LSL #2]    ;317
000056  eb060087          ADD      r0,r6,r7,LSL #2       ;318
00005a  f8d0a168          LDR      r10,[r0,#0x168]       ;319
00005e  eb06008a          ADD      r0,r6,r10,LSL #2      ;319
000062  f8d0014c          LDR      r0,[r0,#0x14c]        ;319
000066  6940              LDR      r0,[r0,#0x14]         ;320
000068  eb050080          ADD      r0,r5,r0,LSL #2       ;320
00006c  f8d0902c          LDR      r9,[r0,#0x2c]
000070  da0d              BGE      |L3.142|
000072  2300              MOVS     r3,#0
000074  4622              MOV      r2,r4
000076  4641              MOV      r1,r8
000078  a804              ADD      r0,sp,#0x10
00007a  f7fffffe          BL       jpeg_fill_bit_buffer
00007e  2800              CMP      r0,#0
000080  d020              BEQ      |L3.196|
000082  e9dd8406          LDRD     r8,r4,[sp,#0x18]
000086  2c08              CMP      r4,#8
000088  da01              BGE      |L3.142|
00008a  2001              MOVS     r0,#1
00008c  e00f              B        |L3.174|
                  |L3.142|
00008e  f1a40108          SUB      r1,r4,#8
000092  fa48f001          ASR      r0,r8,r1
000096  b2c0              UXTB     r0,r0
000098  eb090180          ADD      r1,r9,r0,LSL #2
00009c  f8d11090          LDR      r1,[r1,#0x90]
0000a0  b121              CBZ      r1,|L3.172|
0000a2  4448              ADD      r0,r0,r9
0000a4  1a64              SUBS     r4,r4,r1
0000a6  f8909490          LDRB     r9,[r0,#0x490]
0000aa  e010              B        |L3.206|
                  |L3.172|
0000ac  2009              MOVS     r0,#9
                  |L3.174|
0000ae  9000              STR      r0,[sp,#0]
0000b0  464b              MOV      r3,r9
0000b2  4622              MOV      r2,r4
0000b4  4641              MOV      r1,r8
0000b6  a804              ADD      r0,sp,#0x10
0000b8  f7fffffe          BL       jpeg_huff_decode
0000bc  ea5f0900          MOVS     r9,r0
0000c0  d503              BPL      |L3.202|
0000c2  2000              MOVS     r0,#0
                  |L3.196|
;;;326          if (s) {
;;;327    	CHECK_BIT_BUFFER(br_state, s, return FALSE);
;;;328    	r = GET_BITS(s);
;;;329    	s = HUFF_EXTEND(r, s);
;;;330          }
;;;331    
;;;332          /* Convert DC difference to actual value, update last_dc_val */
;;;333          s += state.last_dc_val[ci];
;;;334          state.last_dc_val[ci] = s;
;;;335          /* Scale and output the coefficient (assumes jpeg_natural_order[0]=0) */
;;;336          (*block)[0] = (JCOEF) (s << Al);
;;;337        }
;;;338    
;;;339        /* Completed MCU, so update state */
;;;340        BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
;;;341        ASSIGN_STATE(entropy->saved, state);
;;;342      }
;;;343    
;;;344      /* Account for restart interval (no-op if not using restarts) */
;;;345      entropy->restarts_to_go--;
;;;346    
;;;347      return TRUE;
;;;348    }
0000c4  b017              ADD      sp,sp,#0x5c
0000c6  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.202|
0000ca  e9dd8406          LDRD     r8,r4,[sp,#0x18]      ;325
                  |L3.206|
0000ce  ea5f0009          MOVS     r0,r9                 ;326
0000d2  d01e              BEQ      |L3.274|
0000d4  454c              CMP      r4,r9                 ;327
0000d6  da09              BGE      |L3.236|
0000d8  4603              MOV      r3,r0                 ;327
0000da  4622              MOV      r2,r4                 ;327
0000dc  4641              MOV      r1,r8                 ;327
0000de  a804              ADD      r0,sp,#0x10           ;327
0000e0  f7fffffe          BL       jpeg_fill_bit_buffer
0000e4  2800              CMP      r0,#0                 ;327
0000e6  d0ed              BEQ      |L3.196|
0000e8  e9dd8406          LDRD     r8,r4,[sp,#0x18]      ;327
                  |L3.236|
0000ec  eba40409          SUB      r4,r4,r9              ;328
0000f0  2101              MOVS     r1,#1                 ;328
0000f2  fa48f004          ASR      r0,r8,r4              ;328
0000f6  fa01f109          LSL      r1,r1,r9              ;328
0000fa  4a18              LDR      r2,|L3.348|
0000fc  1e49              SUBS     r1,r1,#1              ;328
0000fe  4008              ANDS     r0,r0,r1              ;328
000100  f8521029          LDR      r1,[r2,r9,LSL #2]     ;329
000104  4281              CMP      r1,r0                 ;329
000106  dd03              BLE      |L3.272|
000108  3240              ADDS     r2,r2,#0x40           ;329
00010a  f8521029          LDR      r1,[r2,r9,LSL #2]     ;329
00010e  4408              ADD      r0,r0,r1              ;329
                  |L3.272|
000110  4681              MOV      r9,r0                 ;329
                  |L3.274|
000112  a90d              ADD      r1,sp,#0x34           ;333
000114  eb01018a          ADD      r1,r1,r10,LSL #2      ;333
000118  684a              LDR      r2,[r1,#4]            ;333
00011a  eb020009          ADD      r0,r2,r9              ;333
00011e  6048              STR      r0,[r1,#4]            ;336
000120  990a              LDR      r1,[sp,#0x28]         ;336
000122  4088              LSLS     r0,r0,r1              ;336
000124  e000              B        |L3.296|
                  |L3.294|
000126  e013              B        |L3.336|
                  |L3.296|
000128  f8ab0000          STRH     r0,[r11,#0]           ;336
00012c  1c7f              ADDS     r7,r7,#1              ;336
                  |L3.302|
00012e  f8d60164          LDR      r0,[r6,#0x164]        ;316
000132  42b8              CMP      r0,r7                 ;316
000134  dc8b              BGT      |L3.78|
000136  69b1              LDR      r1,[r6,#0x18]         ;340
000138  9804              LDR      r0,[sp,#0x10]         ;340
00013a  2214              MOVS     r2,#0x14              ;341
00013c  6008              STR      r0,[r1,#0]            ;340
00013e  69b1              LDR      r1,[r6,#0x18]         ;340
000140  9805              LDR      r0,[sp,#0x14]         ;340
000142  6048              STR      r0,[r1,#4]            ;341
000144  e9c58403          STRD     r8,r4,[r5,#0xc]       ;341
000148  a90d              ADD      r1,sp,#0x34           ;341
00014a  9813              LDR      r0,[sp,#0x4c]         ;341
00014c  f7fffffe          BL       __aeabi_memcpy4
                  |L3.336|
000150  6aa8              LDR      r0,[r5,#0x28]         ;345
000152  1e40              SUBS     r0,r0,#1              ;345
000154  62a8              STR      r0,[r5,#0x28]         ;347
000156  2001              MOVS     r0,#1                 ;347
000158  e7b4              B        |L3.196|
;;;349    
                          ENDP

00015a  0000              DCW      0x0000
                  |L3.348|
                          DCD      ||.constdata||

                          AREA ||i.decode_mcu_DC_refine||, CODE, READONLY, ALIGN=1

                  decode_mcu_DC_refine PROC
;;;441    METHODDEF(boolean)
;;;442    decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;443    {   
000004  4689              MOV      r9,r1
000006  4604              MOV      r4,r0
;;;444      phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
;;;445      int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
000008  f890119c          LDRB     r1,[r0,#0x19c]
00000c  f8d051bc          LDR      r5,[r0,#0x1bc]
000010  2001              MOVS     r0,#1
000012  fa00f801          LSL      r8,r0,r1
000016  f8d40114          LDR      r0,[r4,#0x114]        ;443
00001a  b085              SUB      sp,sp,#0x14           ;443
00001c  b130              CBZ      r0,|L4.44|
;;;446      int blkn;
;;;447      JBLOCKROW block;
;;;448      BITREAD_STATE_VARS;
;;;449    
;;;450      /* Process restart marker if needed; may have to suspend */
;;;451      if (cinfo->restart_interval) {
;;;452        if (entropy->restarts_to_go == 0)
00001e  6aa8              LDR      r0,[r5,#0x28]
000020  b920              CBNZ     r0,|L4.44|
;;;453          if (! process_restart(cinfo))
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       process_restart
000028  2800              CMP      r0,#0
00002a  d02f              BEQ      |L4.140|
                  |L4.44|
;;;454    	return FALSE;
;;;455      }
;;;456    
;;;457      /* Not worth the cycles to check insufficient_data here,
;;;458       * since we will not change the data anyway if we read zeroes.
;;;459       */
;;;460    
;;;461      /* Load up working state */
;;;462      BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
00002c  9404              STR      r4,[sp,#0x10]
00002e  69a0              LDR      r0,[r4,#0x18]
;;;463    
;;;464      /* Outer loop handles each block in the MCU */
;;;465    
;;;466      for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
000030  2600              MOVS     r6,#0
000032  6801              LDR      r1,[r0,#0]            ;462
000034  9100              STR      r1,[sp,#0]            ;462
000036  6840              LDR      r0,[r0,#4]            ;462
000038  9001              STR      r0,[sp,#4]
00003a  e9d51203          LDRD     r1,r2,[r5,#0xc]
00003e  e015              B        |L4.108|
                  |L4.64|
;;;467        block = MCU_data[blkn];
000040  f8597026          LDR      r7,[r9,r6,LSL #2]
;;;468    
;;;469        /* Encoded data is simply the next bit of the two's-complement DC value */
;;;470        CHECK_BIT_BUFFER(br_state, 1, return FALSE);
000044  2a01              CMP      r2,#1
000046  da07              BGE      |L4.88|
000048  2301              MOVS     r3,#1
00004a  4668              MOV      r0,sp
00004c  f7fffffe          BL       jpeg_fill_bit_buffer
000050  2800              CMP      r0,#0
000052  d01b              BEQ      |L4.140|
000054  e9dd1202          LDRD     r1,r2,[sp,#8]
                  |L4.88|
000058  1e52              SUBS     r2,r2,#1
;;;471        if (GET_BITS(1))
00005a  fa41f002          ASR      r0,r1,r2
00005e  07c0              LSLS     r0,r0,#31
000060  d003              BEQ      |L4.106|
;;;472          (*block)[0] |= p1;
000062  8838              LDRH     r0,[r7,#0]
000064  ea400008          ORR      r0,r0,r8
000068  8038              STRH     r0,[r7,#0]
                  |L4.106|
00006a  1c76              ADDS     r6,r6,#1
                  |L4.108|
00006c  f8d40164          LDR      r0,[r4,#0x164]        ;466
000070  42b0              CMP      r0,r6                 ;466
000072  dce5              BGT      |L4.64|
;;;473        /* Note: since we use |=, repeating the assignment later is safe */
;;;474      }
;;;475    
;;;476      /* Completed MCU, so update state */
;;;477      BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
000074  69a3              LDR      r3,[r4,#0x18]
000076  9800              LDR      r0,[sp,#0]
000078  6018              STR      r0,[r3,#0]
00007a  69a3              LDR      r3,[r4,#0x18]
00007c  9801              LDR      r0,[sp,#4]
00007e  6058              STR      r0,[r3,#4]
000080  e9c51203          STRD     r1,r2,[r5,#0xc]
;;;478    
;;;479      /* Account for restart interval (no-op if not using restarts) */
;;;480      entropy->restarts_to_go--;
000084  6aa8              LDR      r0,[r5,#0x28]
000086  1e40              SUBS     r0,r0,#1
;;;481    
;;;482      return TRUE;
000088  62a8              STR      r0,[r5,#0x28]
00008a  2001              MOVS     r0,#1
                  |L4.140|
;;;483    }
00008c  b005              ADD      sp,sp,#0x14
00008e  e8bd83f0          POP      {r4-r9,pc}
;;;484    
                          ENDP


                          AREA ||i.jinit_phuff_decoder||, CODE, READONLY, ALIGN=2

                  jinit_phuff_decoder PROC
;;;640    GLOBAL(void)
;;;641    jinit_phuff_decoder (j_decompress_ptr cinfo)
000000  b510              PUSH     {r4,lr}
;;;642    {
000002  4604              MOV      r4,r0
;;;643      phuff_entropy_ptr entropy;
;;;644      int *coef_bit_ptr;
;;;645      int ci, i;
;;;646    
;;;647      entropy = (phuff_entropy_ptr)
000004  6840              LDR      r0,[r0,#4]
000006  2240              MOVS     r2,#0x40
000008  2101              MOVS     r1,#1
00000a  6803              LDR      r3,[r0,#0]
00000c  4620              MOV      r0,r4
00000e  4798              BLX      r3
000010  4601              MOV      r1,r0
;;;648        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;649    				SIZEOF(phuff_entropy_decoder));
;;;650      cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
;;;651      entropy->pub.start_pass = start_pass_phuff_decoder;
000012  f8c401bc          STR      r0,[r4,#0x1bc]
000016  4810              LDR      r0,|L5.88|
;;;652    
;;;653      /* Mark derived tables unallocated */
;;;654      for (i = 0; i < NUM_HUFF_TBLS; i++) {
000018  6008              STR      r0,[r1,#0]
00001a  2000              MOVS     r0,#0
00001c  ea4f0200          MOV.W    r2,r0
                  |L5.32|
;;;655        entropy->derived_tbls[i] = NULL;
000020  eb010380          ADD      r3,r1,r0,LSL #2
000024  1c40              ADDS     r0,r0,#1
000026  62da              STR      r2,[r3,#0x2c]         ;654
000028  2804              CMP      r0,#4                 ;654
00002a  dbf9              BLT      |L5.32|
;;;656      }
;;;657    
;;;658      /* Create progression status table */
;;;659      cinfo->coef_bits = (int (*)[DCTSIZE2])
00002c  6a60              LDR      r0,[r4,#0x24]
00002e  0202              LSLS     r2,r0,#8
000030  6860              LDR      r0,[r4,#4]
000032  2101              MOVS     r1,#1
000034  6803              LDR      r3,[r0,#0]
000036  4620              MOV      r0,r4
000038  4798              BLX      r3
;;;660        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;661    				cinfo->num_components*DCTSIZE2*SIZEOF(int));
;;;662      coef_bit_ptr = & cinfo->coef_bits[0][0];
;;;663      for (ci = 0; ci < cinfo->num_components; ci++) 
00003a  2200              MOVS     r2,#0
;;;664        for (i = 0; i < DCTSIZE2; i++)
;;;665          *coef_bit_ptr++ = -1;
00003c  1e53              SUBS     r3,r2,#1
00003e  f8c400a0          STR      r0,[r4,#0xa0]         ;663
000042  e005              B        |L5.80|
                  |L5.68|
000044  2100              MOVS     r1,#0                 ;664
                  |L5.70|
000046  c008              STM      r0!,{r3}
000048  1c49              ADDS     r1,r1,#1
00004a  2940              CMP      r1,#0x40              ;664
00004c  dbfb              BLT      |L5.70|
00004e  1c52              ADDS     r2,r2,#1              ;664
                  |L5.80|
000050  6a61              LDR      r1,[r4,#0x24]         ;663
000052  4291              CMP      r1,r2                 ;663
000054  dcf6              BGT      |L5.68|
;;;666    }
000056  bd10              POP      {r4,pc}
;;;667    
                          ENDP

                  |L5.88|
                          DCD      start_pass_phuff_decoder

                          AREA ||i.process_restart||, CODE, READONLY, ALIGN=2

                  process_restart PROC
;;;227    LOCAL(boolean)
;;;228    process_restart (j_decompress_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;229    {
;;;230      phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
;;;231      int ci;
;;;232    
;;;233      /* Throw away any unused bits remaining in bit buffer; */
;;;234      /* include any full bytes in next_marker's count of discarded bytes */
;;;235      cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
000002  f8d041bc          LDR      r4,[r0,#0x1bc]
000006  4605              MOV      r5,r0                 ;229
000008  6920              LDR      r0,[r4,#0x10]
00000a  f8d511b8          LDR      r1,[r5,#0x1b8]
00000e  17c3              ASRS     r3,r0,#31
000010  eb007053          ADD      r0,r0,r3,LSR #29
000014  698a              LDR      r2,[r1,#0x18]
;;;236      entropy->bitstate.bits_left = 0;
000016  2600              MOVS     r6,#0
000018  eb0200e0          ADD      r0,r2,r0,ASR #3       ;235
00001c  6188              STR      r0,[r1,#0x18]
;;;237    
;;;238      /* Advance past the RSTn marker */
;;;239      if (! (*cinfo->marker->read_restart_marker) (cinfo))
00001e  6126              STR      r6,[r4,#0x10]
000020  f8d501b8          LDR      r0,[r5,#0x1b8]
000024  6881              LDR      r1,[r0,#8]
000026  4628              MOV      r0,r5
000028  4788              BLX      r1
00002a  2800              CMP      r0,#0
00002c  d013              BEQ      |L6.86|
;;;240        return FALSE;
;;;241    
;;;242      /* Re-initialize DC predictions to 0 */
;;;243      for (ci = 0; ci < cinfo->comps_in_scan; ci++)
00002e  2000              MOVS     r0,#0
000030  e004              B        |L6.60|
;;;244        entropy->saved.last_dc_val[ci] = 0;
000032  bf00              NOP      
                  |L6.52|
000034  eb040180          ADD      r1,r4,r0,LSL #2
000038  1c40              ADDS     r0,r0,#1
00003a  618e              STR      r6,[r1,#0x18]
                  |L6.60|
00003c  f8d51148          LDR      r1,[r5,#0x148]        ;243
000040  4281              CMP      r1,r0                 ;243
000042  dcf7              BGT      |L6.52|
;;;245      /* Re-init EOB run count, too */
;;;246      entropy->saved.EOBRUN = 0;
;;;247    
;;;248      /* Reset restart counter */
;;;249      entropy->restarts_to_go = cinfo->restart_interval;
000044  6166              STR      r6,[r4,#0x14]
000046  f8d50114          LDR      r0,[r5,#0x114]
;;;250    
;;;251      /* Reset out-of-data flag, unless read_restart_marker left us smack up
;;;252       * against a marker.  In that case we will end up treating the next data
;;;253       * segment as empty, and we can avoid producing bogus output pixels by
;;;254       * leaving the flag set.
;;;255       */
;;;256      if (cinfo->unread_marker == 0)
00004a  62a0              STR      r0,[r4,#0x28]
00004c  f8d501a0          LDR      r0,[r5,#0x1a0]
000050  b900              CBNZ     r0,|L6.84|
;;;257        entropy->pub.insufficient_data = FALSE;
000052  60a6              STR      r6,[r4,#8]
                  |L6.84|
;;;258    
;;;259      return TRUE;
000054  2001              MOVS     r0,#1
                  |L6.86|
;;;260    }
000056  bd70              POP      {r4-r6,pc}
;;;261    
                          ENDP


                          AREA ||i.start_pass_phuff_decoder||, CODE, READONLY, ALIGN=2

                  start_pass_phuff_decoder PROC
;;;91     METHODDEF(void)
;;;92     start_pass_phuff_decoder (j_decompress_ptr cinfo)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;93     {
000004  4604              MOV      r4,r0
000006  f8d051bc          LDR      r5,[r0,#0x1bc]
;;;94       phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
00000a  e9d42164          LDRD     r2,r1,[r4,#0x190]
00000e  b37a              CBZ      r2,|L7.112|
;;;95       boolean is_DC_band, bad;
;;;96       int ci, coefi, tbl;
;;;97       int *coef_bit_ptr;
;;;98       jpeg_component_info * compptr;
;;;99     
;;;100      is_DC_band = (cinfo->Ss == 0);
000010  2700              MOVS     r7,#0
;;;101    
;;;102      /* Validate scan parameters */
;;;103      bad = FALSE;
000012  4638              MOV      r0,r7
;;;104      if (is_DC_band) {
;;;105        if (cinfo->Se != 0)
;;;106          bad = TRUE;
;;;107      } else {
;;;108        /* need not check Ss/Se < 0 since they came from unsigned bytes */
;;;109        if (cinfo->Ss > cinfo->Se || cinfo->Se >= DCTSIZE2)
000014  428a              CMP      r2,r1
000016  dc01              BGT      |L7.28|
000018  2940              CMP      r1,#0x40
00001a  db00              BLT      |L7.30|
                  |L7.28|
;;;110          bad = TRUE;
00001c  2001              MOVS     r0,#1
                  |L7.30|
;;;111        /* AC scans may have only one component */
;;;112        if (cinfo->comps_in_scan != 1)
00001e  f8d41148          LDR      r1,[r4,#0x148]
000022  2901              CMP      r1,#1
000024  d000              BEQ      |L7.40|
                  |L7.38|
;;;113          bad = TRUE;
000026  2001              MOVS     r0,#1
                  |L7.40|
000028  e9d42166          LDRD     r2,r1,[r4,#0x198]
;;;114      }
;;;115      if (cinfo->Ah != 0) {
00002c  b112              CBZ      r2,|L7.52|
00002e  1e52              SUBS     r2,r2,#1
;;;116        /* Successive approximation refinement scan: must have Al = Ah-1. */
;;;117        if (cinfo->Al != cinfo->Ah-1)
000030  4291              CMP      r1,r2
000032  d102              BNE      |L7.58|
                  |L7.52|
;;;118          bad = TRUE;
;;;119      }
;;;120      if (cinfo->Al > 13)		/* need not check for < 0 */
000034  290d              CMP      r1,#0xd
000036  dc00              BGT      |L7.58|
;;;121        bad = TRUE;
;;;122      /* Arguably the maximum Al value should be less than 13 for 8-bit precision,
;;;123       * but the spec doesn't say so, and we try to be liberal about what we
;;;124       * accept.  Note: large Al values could result in out-of-range DC
;;;125       * coefficients during early scans, leading to bizarre displays due to
;;;126       * overflows in the IDCT math.  But we won't crash.
;;;127       */
;;;128      if (bad)
000038  b1b0              CBZ      r0,|L7.104|
                  |L7.58|
;;;129        ERREXIT4(cinfo, JERR_BAD_PROGRESSION,
00003a  6821              LDR      r1,[r4,#0]
00003c  2010              MOVS     r0,#0x10
00003e  6148              STR      r0,[r1,#0x14]
000040  6821              LDR      r1,[r4,#0]
000042  f8d40190          LDR      r0,[r4,#0x190]
000046  6188              STR      r0,[r1,#0x18]
000048  6821              LDR      r1,[r4,#0]
00004a  f8d40194          LDR      r0,[r4,#0x194]
00004e  61c8              STR      r0,[r1,#0x1c]
000050  6821              LDR      r1,[r4,#0]
000052  f8d40198          LDR      r0,[r4,#0x198]
000056  6208              STR      r0,[r1,#0x20]
000058  6821              LDR      r1,[r4,#0]
00005a  f8d4019c          LDR      r0,[r4,#0x19c]
00005e  6248              STR      r0,[r1,#0x24]
000060  6820              LDR      r0,[r4,#0]
000062  6801              LDR      r1,[r0,#0]
000064  4620              MOV      r0,r4
000066  4788              BLX      r1
                  |L7.104|
;;;130    	     cinfo->Ss, cinfo->Se, cinfo->Ah, cinfo->Al);
;;;131      /* Update progression status, and verify that scan order is legal.
;;;132       * Note that inter-scan inconsistencies are treated as warnings
;;;133       * not fatal errors ... not clear if this is right way to behave.
;;;134       */
;;;135      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
000068  f04f0800          MOV      r8,#0
00006c  46c3              MOV      r11,r8
00006e  e049              B        |L7.260|
                  |L7.112|
000070  e7ff              B        |L7.114|
                  |L7.114|
000072  2701              MOVS     r7,#1                 ;100
000074  2000              MOVS     r0,#0                 ;103
000076  2900              CMP      r1,#0                 ;100
000078  d1d5              BNE      |L7.38|
00007a  e7d5              B        |L7.40|
                  |L7.124|
;;;136        int cindex = cinfo->cur_comp_info[ci]->component_index;
00007c  eb040088          ADD      r0,r4,r8,LSL #2
;;;137        coef_bit_ptr = & cinfo->coef_bits[cindex][0];
000080  f8d410a0          LDR      r1,[r4,#0xa0]
000084  f8d0014c          LDR      r0,[r0,#0x14c]        ;136
000088  f8d0a004          LDR      r10,[r0,#4]
00008c  eb01290a          ADD      r9,r1,r10,LSL #8
;;;138        if (!is_DC_band && coef_bit_ptr[0] < 0) /* AC without prior DC scan */
000090  b997              CBNZ     r7,|L7.184|
000092  f8d90000          LDR      r0,[r9,#0]
000096  2800              CMP      r0,#0
000098  da0e              BGE      |L7.184|
;;;139          WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, 0);
00009a  6821              LDR      r1,[r4,#0]
00009c  2073              MOVS     r0,#0x73
00009e  6148              STR      r0,[r1,#0x14]
0000a0  6821              LDR      r1,[r4,#0]
0000a2  f8c1a018          STR      r10,[r1,#0x18]
0000a6  6821              LDR      r1,[r4,#0]
0000a8  f8c1b01c          STR      r11,[r1,#0x1c]
0000ac  6820              LDR      r0,[r4,#0]
0000ae  f04f31ff          MOV      r1,#0xffffffff
0000b2  6842              LDR      r2,[r0,#4]
0000b4  4620              MOV      r0,r4
0000b6  4790              BLX      r2
                  |L7.184|
;;;140        for (coefi = cinfo->Ss; coefi <= cinfo->Se; coefi++) {
0000b8  f8d46190          LDR      r6,[r4,#0x190]
0000bc  e01c              B        |L7.248|
;;;141          int expected = (coef_bit_ptr[coefi] < 0) ? 0 : coef_bit_ptr[coefi];
0000be  bf00              NOP      
                  |L7.192|
0000c0  f8590026          LDR      r0,[r9,r6,LSL #2]
0000c4  2800              CMP      r0,#0
0000c6  da00              BGE      |L7.202|
0000c8  2000              MOVS     r0,#0
                  |L7.202|
;;;142          if (cinfo->Ah != expected)
0000ca  f8d41198          LDR      r1,[r4,#0x198]
0000ce  4281              CMP      r1,r0
0000d0  d00d              BEQ      |L7.238|
;;;143    	WARNMS2(cinfo, JWRN_BOGUS_PROGRESSION, cindex, coefi);
0000d2  6821              LDR      r1,[r4,#0]
0000d4  2073              MOVS     r0,#0x73
0000d6  6148              STR      r0,[r1,#0x14]
0000d8  6821              LDR      r1,[r4,#0]
0000da  f8c1a018          STR      r10,[r1,#0x18]
0000de  6820              LDR      r0,[r4,#0]
0000e0  f04f31ff          MOV      r1,#0xffffffff
0000e4  61c6              STR      r6,[r0,#0x1c]
0000e6  6820              LDR      r0,[r4,#0]
0000e8  6842              LDR      r2,[r0,#4]
0000ea  4620              MOV      r0,r4
0000ec  4790              BLX      r2
                  |L7.238|
;;;144          coef_bit_ptr[coefi] = cinfo->Al;
0000ee  f8d4119c          LDR      r1,[r4,#0x19c]
0000f2  f8491026          STR      r1,[r9,r6,LSL #2]
0000f6  1c76              ADDS     r6,r6,#1
                  |L7.248|
0000f8  f8d40194          LDR      r0,[r4,#0x194]        ;140
0000fc  42b0              CMP      r0,r6                 ;140
0000fe  dadf              BGE      |L7.192|
000100  f1080801          ADD      r8,r8,#1              ;135
                  |L7.260|
000104  f8d41148          LDR      r1,[r4,#0x148]        ;135
000108  4541              CMP      r1,r8                 ;135
00010a  dcb7              BGT      |L7.124|
;;;145        }
;;;146      }
;;;147    
;;;148      /* Select MCU decoding routine */
;;;149      if (cinfo->Ah == 0) {
00010c  f8d40198          LDR      r0,[r4,#0x198]
000110  b110              CBZ      r0,|L7.280|
;;;150        if (is_DC_band)
;;;151          entropy->pub.decode_mcu = decode_mcu_DC_first;
;;;152        else
;;;153          entropy->pub.decode_mcu = decode_mcu_AC_first;
;;;154      } else {
;;;155        if (is_DC_band)
000112  b137              CBZ      r7,|L7.290|
;;;156          entropy->pub.decode_mcu = decode_mcu_DC_refine;
000114  481f              LDR      r0,|L7.404|
000116  e005              B        |L7.292|
                  |L7.280|
000118  b10f              CBZ      r7,|L7.286|
00011a  481f              LDR      r0,|L7.408|
00011c  e002              B        |L7.292|
                  |L7.286|
00011e  481f              LDR      r0,|L7.412|
000120  e000              B        |L7.292|
                  |L7.290|
;;;157        else
;;;158          entropy->pub.decode_mcu = decode_mcu_AC_refine;
000122  481f              LDR      r0,|L7.416|
                  |L7.292|
;;;159      }
;;;160    
;;;161      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
000124  2600              MOVS     r6,#0
000126  46d8              MOV      r8,r11
000128  6068              STR      r0,[r5,#4]
00012a  e021              B        |L7.368|
                  |L7.300|
;;;162        compptr = cinfo->cur_comp_info[ci];
00012c  eb040086          ADD      r0,r4,r6,LSL #2
000130  f8d0014c          LDR      r0,[r0,#0x14c]
;;;163        /* Make sure requested tables are present, and compute derived tables.
;;;164         * We may build same derived table more than once, but it's not expensive.
;;;165         */
;;;166        if (is_DC_band) {
000134  b15f              CBZ      r7,|L7.334|
;;;167          if (cinfo->Ah == 0) {	/* DC refinement needs no table */
000136  f8d41198          LDR      r1,[r4,#0x198]
00013a  b9a1              CBNZ     r1,|L7.358|
;;;168    	tbl = compptr->dc_tbl_no;
;;;169    	jpeg_make_d_derived_tbl(cinfo, TRUE, tbl,
00013c  6942              LDR      r2,[r0,#0x14]
00013e  2101              MOVS     r1,#1
000140  eb050382          ADD      r3,r5,r2,LSL #2
000144  4620              MOV      r0,r4
000146  332c              ADDS     r3,r3,#0x2c
000148  f7fffffe          BL       jpeg_make_d_derived_tbl
00014c  e00b              B        |L7.358|
                  |L7.334|
;;;170    				& entropy->derived_tbls[tbl]);
;;;171          }
;;;172        } else {
;;;173          tbl = compptr->ac_tbl_no;
;;;174          jpeg_make_d_derived_tbl(cinfo, FALSE, tbl,
00014e  6982              LDR      r2,[r0,#0x18]
000150  2100              MOVS     r1,#0
000152  eb050982          ADD      r9,r5,r2,LSL #2
000156  f109032c          ADD      r3,r9,#0x2c
00015a  4620              MOV      r0,r4
00015c  f7fffffe          BL       jpeg_make_d_derived_tbl
;;;175    			      & entropy->derived_tbls[tbl]);
;;;176          /* remember the single active table */
;;;177          entropy->ac_derived_tbl = entropy->derived_tbls[tbl];
000160  f8d9002c          LDR      r0,[r9,#0x2c]
000164  63e8              STR      r0,[r5,#0x3c]
                  |L7.358|
;;;178        }
;;;179        /* Initialize DC predictions to 0 */
;;;180        entropy->saved.last_dc_val[ci] = 0;
000166  eb050186          ADD      r1,r5,r6,LSL #2
00016a  1c76              ADDS     r6,r6,#1
00016c  f8c18018          STR      r8,[r1,#0x18]
                  |L7.368|
000170  f8d40148          LDR      r0,[r4,#0x148]        ;161
000174  42b0              CMP      r0,r6                 ;161
000176  dcd9              BGT      |L7.300|
;;;181      }
;;;182    
;;;183      /* Initialize bitread state variables */
;;;184      entropy->bitstate.bits_left = 0;
;;;185      entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
000178  f8c58010          STR      r8,[r5,#0x10]
;;;186      entropy->pub.insufficient_data = FALSE;
00017c  f8c5800c          STR      r8,[r5,#0xc]
;;;187    
;;;188      /* Initialize private state variables */
;;;189      entropy->saved.EOBRUN = 0;
000180  f8c58008          STR      r8,[r5,#8]
;;;190    
;;;191      /* Initialize restart counter */
;;;192      entropy->restarts_to_go = cinfo->restart_interval;
000184  f8c58014          STR      r8,[r5,#0x14]
000188  f8d40114          LDR      r0,[r4,#0x114]
00018c  62a8              STR      r0,[r5,#0x28]
;;;193    }
00018e  e8bd9ff0          POP      {r4-r12,pc}
;;;194    
                          ENDP

000192  0000              DCW      0x0000
                  |L7.404|
                          DCD      decode_mcu_DC_refine
                  |L7.408|
                          DCD      decode_mcu_DC_first
                  |L7.412|
                          DCD      decode_mcu_AC_first
                  |L7.416|
                          DCD      decode_mcu_AC_refine

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  extend_test
                          DCD      0x00000000
                          DCD      0x00000001
                          DCD      0x00000002
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x00000010
                          DCD      0x00000020
                          DCD      0x00000040
                          DCD      0x00000080
                          DCD      0x00000100
                          DCD      0x00000200
                          DCD      0x00000400
                          DCD      0x00000800
                          DCD      0x00001000
                          DCD      0x00002000
                          DCD      0x00004000
                  extend_offset
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0xfffffffd
                          DCD      0xfffffff9
                          DCD      0xfffffff1
                          DCD      0xffffffe1
                          DCD      0xffffffc1
                          DCD      0xffffff81
                          DCD      0xffffff01
                          DCD      0xfffffe01
                          DCD      0xfffffc01
                          DCD      0xfffff801
                          DCD      0xfffff001
                          DCD      0xffffe001
                          DCD      0xffffc001
                          DCD      0xffff8001
