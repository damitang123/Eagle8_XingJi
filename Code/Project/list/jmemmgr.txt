; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\jmemmgr.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jmemmgr.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\JPEG\jmemmgr.c]
                          THUMB

                          AREA ||i.access_virt_barray||, CODE, READONLY, ALIGN=1

                  access_virt_barray PROC
;;;799    /* caller intends to modify the accessed area. */
;;;800    METHODDEF(JBLOCKARRAY) access_virt_barray (j_common_ptr cinfo, jvirt_barray_ptr ptr, JDIMENSION start_row, JDIMENSION num_rows,  boolean writable) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4606              MOV      r6,r0
;;;801      JDIMENSION end_row = start_row + num_rows;
;;;802      JDIMENSION undef_row;
;;;803    
;;;804      /* debugging check */
;;;805      if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
000006  6848              LDR      r0,[r1,#4]
000008  18d7              ADDS     r7,r2,r3              ;801
00000a  f8dd8020          LDR      r8,[sp,#0x20]
00000e  4615              MOV      r5,r2                 ;800
000010  460c              MOV      r4,r1                 ;800
;;;806          ptr->mem_buffer == NULL)
;;;807        ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
000012  f04f0916          MOV      r9,#0x16
000016  42b8              CMP      r0,r7                 ;805
000018  d304              BCC      |L1.36|
00001a  68e0              LDR      r0,[r4,#0xc]          ;805
00001c  4298              CMP      r0,r3                 ;805
00001e  d301              BCC      |L1.36|
000020  6820              LDR      r0,[r4,#0]            ;806
000022  b930              CBNZ     r0,|L1.50|
                  |L1.36|
000024  6831              LDR      r1,[r6,#0]
000026  f8c19014          STR      r9,[r1,#0x14]
00002a  6830              LDR      r0,[r6,#0]
00002c  6801              LDR      r1,[r0,#0]
00002e  4630              MOV      r0,r6
000030  4788              BLX      r1
                  |L1.50|
;;;808    
;;;809      /* Make the desired part of the virtual array accessible */
;;;810      if (start_row < ptr->cur_start_row ||
000032  69a0              LDR      r0,[r4,#0x18]
000034  42a8              CMP      r0,r5
000036  d803              BHI      |L1.64|
;;;811          end_row > ptr->cur_start_row+ptr->rows_in_mem) {
000038  6921              LDR      r1,[r4,#0x10]
00003a  4408              ADD      r0,r0,r1
00003c  42b8              CMP      r0,r7
00003e  d220              BCS      |L1.130|
                  |L1.64|
;;;812        if (! ptr->b_s_open)
000040  6aa0              LDR      r0,[r4,#0x28]
000042  b930              CBNZ     r0,|L1.82|
;;;813          ERREXIT(cinfo, JERR_VIRTUAL_BUG);
000044  6831              LDR      r1,[r6,#0]
000046  2045              MOVS     r0,#0x45
000048  6148              STR      r0,[r1,#0x14]
00004a  6830              LDR      r0,[r6,#0]
00004c  6801              LDR      r1,[r0,#0]
00004e  4630              MOV      r0,r6
000050  4788              BLX      r1
                  |L1.82|
;;;814        /* Flush old buffer contents if necessary */
;;;815        if (ptr->dirty) {
000052  6a60              LDR      r0,[r4,#0x24]
000054  b130              CBZ      r0,|L1.100|
;;;816          do_barray_io(cinfo, ptr, TRUE);
000056  2201              MOVS     r2,#1
000058  4621              MOV      r1,r4
00005a  4630              MOV      r0,r6
00005c  f7fffffe          BL       do_barray_io
;;;817          ptr->dirty = FALSE;
000060  2000              MOVS     r0,#0
000062  6260              STR      r0,[r4,#0x24]
                  |L1.100|
;;;818        }
;;;819        /* Decide what part of virtual array to access.
;;;820         * Algorithm: if target address > current window, assume forward scan,
;;;821         * load starting at target address.  If target address < current window,
;;;822         * assume backward scan, load so that target area is top of window.
;;;823         * Note that when switching from forward write to forward read, will have
;;;824         * start_row = 0, so the limiting case applies and we load from 0 anyway.
;;;825         */
;;;826        if (start_row > ptr->cur_start_row) {
000064  69a0              LDR      r0,[r4,#0x18]
000066  42a8              CMP      r0,r5
000068  d201              BCS      |L1.110|
;;;827          ptr->cur_start_row = start_row;
00006a  61a5              STR      r5,[r4,#0x18]
00006c  e004              B        |L1.120|
                  |L1.110|
;;;828        } else {
;;;829          /* use long arithmetic here to avoid overflow & unsigned problems */
;;;830          long ltemp;
;;;831    
;;;832          ltemp = (long) end_row - (long) ptr->rows_in_mem;
00006e  6920              LDR      r0,[r4,#0x10]
000070  1a38              SUBS     r0,r7,r0
;;;833          if (ltemp < 0)
000072  d500              BPL      |L1.118|
;;;834    	ltemp = 0;		/* don't fall off front end of file */
000074  2000              MOVS     r0,#0
                  |L1.118|
;;;835          ptr->cur_start_row = (JDIMENSION) ltemp;
000076  61a0              STR      r0,[r4,#0x18]
                  |L1.120|
;;;836        }
;;;837        /* Read in the selected part of the array.
;;;838         * During the initial write pass, we will do no actual read
;;;839         * because the selected part is all undefined.
;;;840         */
;;;841        do_barray_io(cinfo, ptr, FALSE);
000078  2200              MOVS     r2,#0
00007a  4621              MOV      r1,r4
00007c  4630              MOV      r0,r6
00007e  f7fffffe          BL       do_barray_io
                  |L1.130|
;;;842      }
;;;843      /* Ensure the accessed part of the array is defined; prezero if needed.
;;;844       * To improve locality of access, we only prezero the part of the array
;;;845       * that the caller is about to access, not the entire in-memory array.
;;;846       */
;;;847      if (ptr->first_undef_row < end_row) {
000082  69e0              LDR      r0,[r4,#0x1c]
000084  42b8              CMP      r0,r7
000086  d225              BCS      |L1.212|
;;;848        if (ptr->first_undef_row < start_row) {
000088  42a8              CMP      r0,r5
00008a  d20d              BCS      |L1.168|
;;;849          if (writable)		/* writer skipped over a section of array */
00008c  f1b80f00          CMP      r8,#0
000090  d008              BEQ      |L1.164|
;;;850    	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
000092  6831              LDR      r1,[r6,#0]
000094  f8c19014          STR      r9,[r1,#0x14]
000098  6830              LDR      r0,[r6,#0]
00009a  6801              LDR      r1,[r0,#0]
00009c  4630              MOV      r0,r6
00009e  4788              BLX      r1
;;;851          undef_row = start_row;	/* but reader is allowed to read ahead */
0000a0  4628              MOV      r0,r5
0000a2  e004              B        |L1.174|
                  |L1.164|
0000a4  4628              MOV      r0,r5
0000a6  e003              B        |L1.176|
                  |L1.168|
;;;852        } else {
;;;853          undef_row = ptr->first_undef_row;
;;;854        }
;;;855        if (writable)
0000a8  f1b80f00          CMP      r8,#0
0000ac  d000              BEQ      |L1.176|
                  |L1.174|
;;;856          ptr->first_undef_row = end_row;
0000ae  61e7              STR      r7,[r4,#0x1c]
                  |L1.176|
;;;857        if (ptr->pre_zero) {
0000b0  6a21              LDR      r1,[r4,#0x20]
0000b2  b1d9              CBZ      r1,|L1.236|
;;;858          size_t bytesperrow = (size_t) ptr->blocksperrow * SIZEOF(JBLOCK);
0000b4  68a1              LDR      r1,[r4,#8]
0000b6  ea4f19c1          LSL      r9,r1,#7
;;;859          undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
0000ba  69a1              LDR      r1,[r4,#0x18]
0000bc  1a46              SUBS     r6,r0,r1
;;;860          end_row -= ptr->cur_start_row;
0000be  1a7f              SUBS     r7,r7,r1
;;;861          while (undef_row < end_row) {
0000c0  e006              B        |L1.208|
                  |L1.194|
;;;862    	jzero_far((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
0000c2  6820              LDR      r0,[r4,#0]
0000c4  4649              MOV      r1,r9
0000c6  f8500026          LDR      r0,[r0,r6,LSL #2]
0000ca  f7fffffe          BL       jzero_far
0000ce  1c76              ADDS     r6,r6,#1
                  |L1.208|
0000d0  42be              CMP      r6,r7                 ;861
0000d2  d3f6              BCC      |L1.194|
                  |L1.212|
;;;863    	undef_row++;
;;;864          }
;;;865        } else {
;;;866          if (! writable)		/* reader looking at undefined data */
;;;867    	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
;;;868        }
;;;869      }
;;;870      /* Flag the buffer dirty if caller will write in it */
;;;871      if (writable)
0000d4  f1b80f00          CMP      r8,#0
0000d8  d001              BEQ      |L1.222|
                  |L1.218|
;;;872        ptr->dirty = TRUE;
0000da  2001              MOVS     r0,#1
0000dc  6260              STR      r0,[r4,#0x24]
                  |L1.222|
;;;873      /* Return address of proper part of the buffer */
;;;874      return ptr->mem_buffer + (start_row - ptr->cur_start_row);
0000de  69a1              LDR      r1,[r4,#0x18]
0000e0  6820              LDR      r0,[r4,#0]
0000e2  1a69              SUBS     r1,r5,r1
0000e4  eb000081          ADD      r0,r0,r1,LSL #2
;;;875    }
0000e8  e8bd87f0          POP      {r4-r10,pc}
                  |L1.236|
0000ec  f1b80f00          CMP      r8,#0                 ;866
0000f0  d1f3              BNE      |L1.218|
0000f2  6831              LDR      r1,[r6,#0]            ;867
0000f4  f8c19014          STR      r9,[r1,#0x14]         ;867
0000f8  6830              LDR      r0,[r6,#0]            ;867
0000fa  6801              LDR      r1,[r0,#0]            ;867
0000fc  4630              MOV      r0,r6                 ;867
0000fe  4788              BLX      r1                    ;867
000100  e7ed              B        |L1.222|
;;;876    
                          ENDP


                          AREA ||i.access_virt_sarray||, CODE, READONLY, ALIGN=1

                  access_virt_sarray PROC
;;;718    /* caller intends to modify the accessed area. */
;;;719    METHODDEF(JSAMPARRAY) access_virt_sarray (j_common_ptr cinfo, jvirt_sarray_ptr ptr, JDIMENSION start_row, JDIMENSION num_rows, boolean writable) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4606              MOV      r6,r0
;;;720      JDIMENSION end_row = start_row + num_rows;
;;;721      JDIMENSION undef_row;
;;;722    
;;;723      /* debugging check */
;;;724      if (end_row > ptr->rows_in_array || num_rows > ptr->maxaccess ||
000006  6848              LDR      r0,[r1,#4]
000008  18d7              ADDS     r7,r2,r3              ;720
00000a  f8dd8020          LDR      r8,[sp,#0x20]
00000e  4615              MOV      r5,r2                 ;719
000010  460c              MOV      r4,r1                 ;719
;;;725          ptr->mem_buffer == NULL)
;;;726        ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
000012  f04f0916          MOV      r9,#0x16
000016  42b8              CMP      r0,r7                 ;724
000018  d304              BCC      |L2.36|
00001a  68e0              LDR      r0,[r4,#0xc]          ;724
00001c  4298              CMP      r0,r3                 ;724
00001e  d301              BCC      |L2.36|
000020  6820              LDR      r0,[r4,#0]            ;725
000022  b930              CBNZ     r0,|L2.50|
                  |L2.36|
000024  6831              LDR      r1,[r6,#0]
000026  f8c19014          STR      r9,[r1,#0x14]
00002a  6830              LDR      r0,[r6,#0]
00002c  6801              LDR      r1,[r0,#0]
00002e  4630              MOV      r0,r6
000030  4788              BLX      r1
                  |L2.50|
;;;727    
;;;728      /* Make the desired part of the virtual array accessible */
;;;729      if (start_row < ptr->cur_start_row ||
000032  69a0              LDR      r0,[r4,#0x18]
000034  42a8              CMP      r0,r5
000036  d803              BHI      |L2.64|
;;;730          end_row > ptr->cur_start_row+ptr->rows_in_mem) {
000038  6921              LDR      r1,[r4,#0x10]
00003a  4408              ADD      r0,r0,r1
00003c  42b8              CMP      r0,r7
00003e  d220              BCS      |L2.130|
                  |L2.64|
;;;731        if (! ptr->b_s_open)
000040  6aa0              LDR      r0,[r4,#0x28]
000042  b930              CBNZ     r0,|L2.82|
;;;732          ERREXIT(cinfo, JERR_VIRTUAL_BUG);
000044  6831              LDR      r1,[r6,#0]
000046  2045              MOVS     r0,#0x45
000048  6148              STR      r0,[r1,#0x14]
00004a  6830              LDR      r0,[r6,#0]
00004c  6801              LDR      r1,[r0,#0]
00004e  4630              MOV      r0,r6
000050  4788              BLX      r1
                  |L2.82|
;;;733        /* Flush old buffer contents if necessary */
;;;734        if (ptr->dirty) {
000052  6a60              LDR      r0,[r4,#0x24]
000054  b130              CBZ      r0,|L2.100|
;;;735          do_sarray_io(cinfo, ptr, TRUE);
000056  2201              MOVS     r2,#1
000058  4621              MOV      r1,r4
00005a  4630              MOV      r0,r6
00005c  f7fffffe          BL       do_sarray_io
;;;736          ptr->dirty = FALSE;
000060  2000              MOVS     r0,#0
000062  6260              STR      r0,[r4,#0x24]
                  |L2.100|
;;;737        }
;;;738        /* Decide what part of virtual array to access.
;;;739         * Algorithm: if target address > current window, assume forward scan,
;;;740         * load starting at target address.  If target address < current window,
;;;741         * assume backward scan, load so that target area is top of window.
;;;742         * Note that when switching from forward write to forward read, will have
;;;743         * start_row = 0, so the limiting case applies and we load from 0 anyway.
;;;744         */
;;;745        if (start_row > ptr->cur_start_row) {
000064  69a0              LDR      r0,[r4,#0x18]
000066  42a8              CMP      r0,r5
000068  d201              BCS      |L2.110|
;;;746          ptr->cur_start_row = start_row;
00006a  61a5              STR      r5,[r4,#0x18]
00006c  e004              B        |L2.120|
                  |L2.110|
;;;747        } else {
;;;748          /* use long arithmetic here to avoid overflow & unsigned problems */
;;;749          long ltemp;
;;;750    
;;;751          ltemp = (long) end_row - (long) ptr->rows_in_mem;
00006e  6920              LDR      r0,[r4,#0x10]
000070  1a38              SUBS     r0,r7,r0
;;;752          if (ltemp < 0)
000072  d500              BPL      |L2.118|
;;;753    	ltemp = 0;		/* don't fall off front end of file */
000074  2000              MOVS     r0,#0
                  |L2.118|
;;;754          ptr->cur_start_row = (JDIMENSION) ltemp;
000076  61a0              STR      r0,[r4,#0x18]
                  |L2.120|
;;;755        }
;;;756        /* Read in the selected part of the array.
;;;757         * During the initial write pass, we will do no actual read
;;;758         * because the selected part is all undefined.
;;;759         */
;;;760        do_sarray_io(cinfo, ptr, FALSE);
000078  2200              MOVS     r2,#0
00007a  4621              MOV      r1,r4
00007c  4630              MOV      r0,r6
00007e  f7fffffe          BL       do_sarray_io
                  |L2.130|
;;;761      }
;;;762      /* Ensure the accessed part of the array is defined; prezero if needed.
;;;763       * To improve locality of access, we only prezero the part of the array
;;;764       * that the caller is about to access, not the entire in-memory array.
;;;765       */
;;;766      if (ptr->first_undef_row < end_row) {
000082  69e0              LDR      r0,[r4,#0x1c]
000084  42b8              CMP      r0,r7
000086  d224              BCS      |L2.210|
;;;767        if (ptr->first_undef_row < start_row) {
000088  42a8              CMP      r0,r5
00008a  d20d              BCS      |L2.168|
;;;768          if (writable)		/* writer skipped over a section of array */
00008c  f1b80f00          CMP      r8,#0
000090  d008              BEQ      |L2.164|
;;;769    	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
000092  6831              LDR      r1,[r6,#0]
000094  f8c19014          STR      r9,[r1,#0x14]
000098  6830              LDR      r0,[r6,#0]
00009a  6801              LDR      r1,[r0,#0]
00009c  4630              MOV      r0,r6
00009e  4788              BLX      r1
;;;770          undef_row = start_row;	/* but reader is allowed to read ahead */
0000a0  4628              MOV      r0,r5
0000a2  e004              B        |L2.174|
                  |L2.164|
0000a4  4628              MOV      r0,r5
0000a6  e003              B        |L2.176|
                  |L2.168|
;;;771        } else {
;;;772          undef_row = ptr->first_undef_row;
;;;773        }
;;;774        if (writable)
0000a8  f1b80f00          CMP      r8,#0
0000ac  d000              BEQ      |L2.176|
                  |L2.174|
;;;775          ptr->first_undef_row = end_row;
0000ae  61e7              STR      r7,[r4,#0x1c]
                  |L2.176|
;;;776        if (ptr->pre_zero) {
0000b0  6a21              LDR      r1,[r4,#0x20]
0000b2  b1d1              CBZ      r1,|L2.234|
;;;777          size_t bytesperrow = (size_t) ptr->samplesperrow * SIZEOF(JSAMPLE);
;;;778          undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
0000b4  69a1              LDR      r1,[r4,#0x18]
;;;779          end_row -= ptr->cur_start_row;
;;;780          while (undef_row < end_row) {
0000b6  f8d49008          LDR      r9,[r4,#8]
0000ba  1a46              SUBS     r6,r0,r1              ;778
0000bc  1a7f              SUBS     r7,r7,r1              ;779
0000be  e006              B        |L2.206|
                  |L2.192|
;;;781    	jzero_far((void FAR *) ptr->mem_buffer[undef_row], bytesperrow);
0000c0  6820              LDR      r0,[r4,#0]
0000c2  4649              MOV      r1,r9
0000c4  f8500026          LDR      r0,[r0,r6,LSL #2]
0000c8  f7fffffe          BL       jzero_far
0000cc  1c76              ADDS     r6,r6,#1
                  |L2.206|
0000ce  42be              CMP      r6,r7                 ;780
0000d0  d3f6              BCC      |L2.192|
                  |L2.210|
;;;782    	undef_row++;
;;;783          }
;;;784        } else {
;;;785          if (! writable)		/* reader looking at undefined data */
;;;786    	ERREXIT(cinfo, JERR_BAD_VIRTUAL_ACCESS);
;;;787        }
;;;788      }
;;;789      /* Flag the buffer dirty if caller will write in it */
;;;790      if (writable)
0000d2  f1b80f00          CMP      r8,#0
0000d6  d001              BEQ      |L2.220|
                  |L2.216|
;;;791        ptr->dirty = TRUE;
0000d8  2001              MOVS     r0,#1
0000da  6260              STR      r0,[r4,#0x24]
                  |L2.220|
;;;792      /* Return address of proper part of the buffer */
;;;793      return ptr->mem_buffer + (start_row - ptr->cur_start_row);
0000dc  69a1              LDR      r1,[r4,#0x18]
0000de  6820              LDR      r0,[r4,#0]
0000e0  1a69              SUBS     r1,r5,r1
0000e2  eb000081          ADD      r0,r0,r1,LSL #2
;;;794    }
0000e6  e8bd87f0          POP      {r4-r10,pc}
                  |L2.234|
0000ea  f1b80f00          CMP      r8,#0                 ;785
0000ee  d1f3              BNE      |L2.216|
0000f0  6831              LDR      r1,[r6,#0]            ;786
0000f2  f8c19014          STR      r9,[r1,#0x14]         ;786
0000f6  6830              LDR      r0,[r6,#0]            ;786
0000f8  6801              LDR      r1,[r0,#0]            ;786
0000fa  4630              MOV      r0,r6                 ;786
0000fc  4788              BLX      r1                    ;786
0000fe  e7ed              B        |L2.220|
;;;795    
                          ENDP


                          AREA ||i.alloc_barray||, CODE, READONLY, ALIGN=2

                  alloc_barray PROC
;;;425    
;;;426    METHODDEF(JBLOCKARRAY) alloc_barray (j_common_ptr cinfo, int pool_id,  JDIMENSION blocksperrow, JDIMENSION numrows) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  468a              MOV      r10,r1
000006  4681              MOV      r9,r0
;;;427      /* Allocate a 2-D coefficient-block array */
;;;428      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
;;;429      JBLOCKARRAY result;
;;;430      JBLOCKROW workspace;
;;;431      JDIMENSION rowsperchunk, currow, i;
;;;432      long ltemp;
;;;433    
;;;434      /* Calculate max # of rows allowed in one allocation chunk */
;;;435      ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
000008  6846              LDR      r6,[r0,#4]
00000a  491c              LDR      r1,|L3.124|
00000c  01d0              LSLS     r0,r2,#7
00000e  fbb1f4f0          UDIV     r4,r1,r0
000012  461d              MOV      r5,r3                 ;426
000014  4617              MOV      r7,r2                 ;426
;;;436    	  ((long) blocksperrow * SIZEOF(JBLOCK));
;;;437      if (ltemp <= 0)
000016  2c00              CMP      r4,#0
000018  dc08              BGT      |L3.44|
;;;438        ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
00001a  f8d90000          LDR      r0,[r9,#0]
00001e  2146              MOVS     r1,#0x46
000020  6141              STR      r1,[r0,#0x14]
000022  f8d90000          LDR      r0,[r9,#0]
000026  6801              LDR      r1,[r0,#0]
000028  4648              MOV      r0,r9
00002a  4788              BLX      r1
                  |L3.44|
;;;439      if (ltemp < (long) numrows)
00002c  42ac              CMP      r4,r5
00002e  db00              BLT      |L3.50|
;;;440        rowsperchunk = (JDIMENSION) ltemp;
;;;441      else
;;;442        rowsperchunk = numrows;
000030  462c              MOV      r4,r5
                  |L3.50|
;;;443      mem->last_rowsperchunk = rowsperchunk;
000032  00aa              LSLS     r2,r5,#2
;;;444    
;;;445      /* Get space for row pointers (small object) */
;;;446      result = (JBLOCKARRAY) alloc_small(cinfo, pool_id,
000034  4651              MOV      r1,r10
000036  4648              MOV      r0,r9
000038  6534              STR      r4,[r6,#0x50]
00003a  f7fffffe          BL       alloc_small
00003e  4680              MOV      r8,r0
;;;447    				     (size_t) (numrows * SIZEOF(JBLOCKROW)));
;;;448    
;;;449      /* Get the rows themselves (large objects) */
;;;450      currow = 0;
000040  2600              MOVS     r6,#0
;;;451      while (currow < numrows) {
000042  e015              B        |L3.112|
                  |L3.68|
;;;452        rowsperchunk = MIN(rowsperchunk, numrows - currow);
000044  1ba8              SUBS     r0,r5,r6
000046  42a0              CMP      r0,r4
000048  d800              BHI      |L3.76|
00004a  4604              MOV      r4,r0
                  |L3.76|
;;;453        workspace = (JBLOCKROW) alloc_large(cinfo, pool_id,
00004c  fb04f007          MUL      r0,r4,r7
000050  01c2              LSLS     r2,r0,#7
000052  4651              MOV      r1,r10
000054  4648              MOV      r0,r9
000056  f7fffffe          BL       alloc_large
;;;454    	(size_t) ((size_t) rowsperchunk * (size_t) blocksperrow
;;;455    		  * SIZEOF(JBLOCK)));
;;;456        for (i = rowsperchunk; i > 0; i--) {
00005a  0021              MOVS     r1,r4
00005c  d008              BEQ      |L3.112|
;;;457          result[currow++] = workspace;
00005e  bf00              NOP      
                  |L3.96|
000060  f8480026          STR      r0,[r8,r6,LSL #2]
;;;458          workspace += blocksperrow;
000064  eb0010c7          ADD      r0,r0,r7,LSL #7
000068  1e49              SUBS     r1,r1,#1
00006a  f1060601          ADD      r6,r6,#1
00006e  d1f7              BNE      |L3.96|
                  |L3.112|
000070  42ae              CMP      r6,r5                 ;451
000072  d3e7              BCC      |L3.68|
;;;459        }
;;;460      }
;;;461    
;;;462      return result;
000074  4640              MOV      r0,r8
;;;463    }
000076  e8bd87f0          POP      {r4-r10,pc}
;;;464    
                          ENDP

00007a  0000              DCW      0x0000
                  |L3.124|
                          DCD      0x3b9ac9f0

                          AREA ||i.alloc_large||, CODE, READONLY, ALIGN=2

                  alloc_large PROC
;;;332    
;;;333    METHODDEF(void FAR *) alloc_large (j_common_ptr cinfo, int pool_id, size_t sizeofobject) /* Allocate a "large" object */ {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4606              MOV      r6,r0
;;;334      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
;;;335      large_pool_ptr hdr_ptr;
;;;336      size_t odd_bytes;
;;;337    
;;;338      /* Check for unsatisfiable request (do now to ensure no overflow below) */
;;;339      if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr))) {
000006  6847              LDR      r7,[r0,#4]
000008  481b              LDR      r0,|L4.120|
00000a  4615              MOV      r5,r2                 ;333
00000c  4688              MOV      r8,r1                 ;333
00000e  4282              CMP      r2,r0
000010  d903              BLS      |L4.26|
;;;340        out_of_memory(cinfo, 3);	/* request exceeds malloc's ability */
000012  2103              MOVS     r1,#3
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       out_of_memory
                  |L4.26|
;;;341      }
;;;342      /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
;;;343      odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
00001a  f0150007          ANDS     r0,r5,#7
;;;344      if (odd_bytes > 0) {
00001e  d002              BEQ      |L4.38|
;;;345        sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
000020  f1c00008          RSB      r0,r0,#8
000024  4405              ADD      r5,r5,r0
                  |L4.38|
;;;346      }
;;;347      /* Always make a new pool */
;;;348      if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS) {
000026  f1b80f02          CMP      r8,#2
00002a  d309              BCC      |L4.64|
;;;349        ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
00002c  6831              LDR      r1,[r6,#0]
00002e  200e              MOVS     r0,#0xe
000030  6148              STR      r0,[r1,#0x14]
000032  6831              LDR      r1,[r6,#0]
000034  f8c18018          STR      r8,[r1,#0x18]
000038  6830              LDR      r0,[r6,#0]
00003a  6801              LDR      r1,[r0,#0]
00003c  4630              MOV      r0,r6
00003e  4788              BLX      r1
                  |L4.64|
;;;350      }
;;;351    
;;;352      hdr_ptr = (large_pool_ptr) jpeg_get_small/*RS: Changed from jpeg_get_large*/ (cinfo, sizeofobject +  SIZEOF(large_pool_hdr));
000040  f1050110          ADD      r1,r5,#0x10
000044  4689              MOV      r9,r1
000046  4630              MOV      r0,r6
000048  f7fffffe          BL       jpeg_get_small
00004c  0004              MOVS     r4,r0
;;;353      if (hdr_ptr == NULL) {
00004e  d103              BNE      |L4.88|
;;;354        out_of_memory(cinfo, 4);	/* jpeg_get_large failed */
000050  2104              MOVS     r1,#4
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       out_of_memory
                  |L4.88|
;;;355      }
;;;356      mem->total_space_allocated += sizeofobject + SIZEOF(large_pool_hdr);
000058  6cf9              LDR      r1,[r7,#0x4c]
00005a  eb010009          ADD      r0,r1,r9
;;;357      /* Success, initialize the new pool header and add to list */
;;;358      hdr_ptr->hdr.next = mem->large_list[pool_id];
00005e  64f8              STR      r0,[r7,#0x4c]
000060  eb070088          ADD      r0,r7,r8,LSL #2
000064  6bc1              LDR      r1,[r0,#0x3c]
000066  e9c41500          STRD     r1,r5,[r4,#0]
;;;359      /* We maintain space counts in each pool header for statistical purposes,
;;;360       * even though they are not needed for allocation.
;;;361       */
;;;362      hdr_ptr->hdr.bytes_used = sizeofobject;
;;;363      hdr_ptr->hdr.bytes_left = 0;
00006a  2100              MOVS     r1,#0
;;;364      mem->large_list[pool_id] = hdr_ptr;
00006c  60a1              STR      r1,[r4,#8]
;;;365    
;;;366      return (void FAR *) (hdr_ptr + 1); /* point to first data byte in pool */
00006e  63c4              STR      r4,[r0,#0x3c]
000070  f1040010          ADD      r0,r4,#0x10
;;;367    }
000074  e8bd87f0          POP      {r4-r10,pc}
;;;368    
                          ENDP

                  |L4.120|
                          DCD      0x3b9ac9f0

                          AREA ||i.alloc_sarray||, CODE, READONLY, ALIGN=2

                  alloc_sarray PROC
;;;382    
;;;383    METHODDEF(JSAMPARRAY) alloc_sarray (j_common_ptr cinfo, int pool_id, JDIMENSION samplesperrow, JDIMENSION numrows) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4681              MOV      r9,r0
;;;384    /* Allocate a 2-D sample array */
;;;385      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
;;;386      JSAMPARRAY result;
;;;387      JSAMPROW workspace;
;;;388      JDIMENSION rowsperchunk, currow, i;
;;;389      long ltemp;
;;;390    
;;;391      /* Calculate max # of rows allowed in one allocation chunk */
;;;392      ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
000006  6846              LDR      r6,[r0,#4]
000008  481a              LDR      r0,|L5.116|
00000a  4617              MOV      r7,r2                 ;383
00000c  fbb0f4f7          UDIV     r4,r0,r7
000010  461d              MOV      r5,r3                 ;383
000012  468a              MOV      r10,r1                ;383
;;;393    	  ((long) samplesperrow * SIZEOF(JSAMPLE));
;;;394      if (ltemp <= 0)
000014  2c00              CMP      r4,#0
000016  dc08              BGT      |L5.42|
;;;395        ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
000018  f8d90000          LDR      r0,[r9,#0]
00001c  2146              MOVS     r1,#0x46
00001e  6141              STR      r1,[r0,#0x14]
000020  f8d90000          LDR      r0,[r9,#0]
000024  6801              LDR      r1,[r0,#0]
000026  4648              MOV      r0,r9
000028  4788              BLX      r1
                  |L5.42|
;;;396      if (ltemp < (long) numrows)
00002a  42ac              CMP      r4,r5
00002c  db00              BLT      |L5.48|
;;;397        rowsperchunk = (JDIMENSION) ltemp;
;;;398      else
;;;399        rowsperchunk = numrows;
00002e  462c              MOV      r4,r5
                  |L5.48|
;;;400      mem->last_rowsperchunk = rowsperchunk;
000030  00aa              LSLS     r2,r5,#2
;;;401    
;;;402      /* Get space for row pointers (small object) */
;;;403      result = (JSAMPARRAY) alloc_small(cinfo, pool_id, (size_t) (numrows * SIZEOF(JSAMPROW)));
000032  4651              MOV      r1,r10
000034  4648              MOV      r0,r9
000036  6534              STR      r4,[r6,#0x50]
000038  f7fffffe          BL       alloc_small
00003c  4680              MOV      r8,r0
;;;404      /* Get the rows themselves (large objects) */
;;;405      currow = 0;
00003e  2600              MOVS     r6,#0
;;;406      while (currow < numrows) {
000040  e013              B        |L5.106|
                  |L5.66|
;;;407        rowsperchunk = MIN(rowsperchunk, numrows - currow);
000042  1baa              SUBS     r2,r5,r6
000044  42a2              CMP      r2,r4
000046  d900              BLS      |L5.74|
000048  4622              MOV      r2,r4
                  |L5.74|
00004a  4614              MOV      r4,r2
;;;408        workspace = (JSAMPROW) alloc_large(cinfo, pool_id,
00004c  437a              MULS     r2,r7,r2
00004e  4651              MOV      r1,r10
000050  4648              MOV      r0,r9
000052  f7fffffe          BL       alloc_large
;;;409    	(size_t) ((size_t) rowsperchunk * (size_t) samplesperrow
;;;410    		  * SIZEOF(JSAMPLE)));
;;;411        for (i = rowsperchunk; i > 0; i--) {
000056  0022              MOVS     r2,r4
000058  d007              BEQ      |L5.106|
;;;412          result[currow++] = workspace;
00005a  bf00              NOP      
                  |L5.92|
00005c  f8480026          STR      r0,[r8,r6,LSL #2]
;;;413          workspace += samplesperrow;
000060  4438              ADD      r0,r0,r7
000062  1e52              SUBS     r2,r2,#1
000064  f1060601          ADD      r6,r6,#1
000068  d1f8              BNE      |L5.92|
                  |L5.106|
00006a  42ae              CMP      r6,r5                 ;406
00006c  d3e9              BCC      |L5.66|
;;;414        }
;;;415      }
;;;416    
;;;417      return result;
00006e  4640              MOV      r0,r8
;;;418    }
000070  e8bd87f0          POP      {r4-r10,pc}
;;;419    
                          ENDP

                  |L5.116|
                          DCD      0x3b9ac9f0

                          AREA ||i.alloc_small||, CODE, READONLY, ALIGN=2

                  alloc_small PROC
;;;248    
;;;249    METHODDEF(void *) alloc_small (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;250    /* Allocate a "small" object */
;;;251    {
000004  4680              MOV      r8,r0
;;;252      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
;;;253      small_pool_ptr hdr_ptr, prev_hdr_ptr;
;;;254      char * data_ptr;
;;;255      size_t odd_bytes, min_request, slop;
;;;256    
;;;257      /* Check for unsatisfiable request (do now to ensure no overflow below) */
;;;258      if (sizeofobject > (size_t) (MAX_ALLOC_CHUNK-SIZEOF(small_pool_hdr)))
000006  f8d09004          LDR      r9,[r0,#4]
00000a  4832              LDR      r0,|L6.212|
00000c  4616              MOV      r6,r2                 ;251
00000e  460d              MOV      r5,r1                 ;251
000010  4282              CMP      r2,r0
000012  d903              BLS      |L6.28|
;;;259        out_of_memory(cinfo, 1);	/* request exceeds malloc's ability */
000014  2101              MOVS     r1,#1
000016  4640              MOV      r0,r8
000018  f7fffffe          BL       out_of_memory
                  |L6.28|
;;;260    
;;;261      /* Round up the requested size to a multiple of SIZEOF(ALIGN_TYPE) */
;;;262      odd_bytes = sizeofobject % SIZEOF(ALIGN_TYPE);
00001c  f0160007          ANDS     r0,r6,#7
;;;263      if (odd_bytes > 0)
000020  d002              BEQ      |L6.40|
;;;264        sizeofobject += SIZEOF(ALIGN_TYPE) - odd_bytes;
000022  f1c00008          RSB      r0,r0,#8
000026  4406              ADD      r6,r6,r0
                  |L6.40|
;;;265    
;;;266      /* See if space is available in any existing pool */
;;;267      if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
000028  2d02              CMP      r5,#2
00002a  d30b              BCC      |L6.68|
;;;268        ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
00002c  f8d80000          LDR      r0,[r8,#0]
000030  210e              MOVS     r1,#0xe
000032  6141              STR      r1,[r0,#0x14]
000034  f8d80000          LDR      r0,[r8,#0]
000038  6185              STR      r5,[r0,#0x18]
00003a  f8d80000          LDR      r0,[r8,#0]
00003e  6801              LDR      r1,[r0,#0]
000040  4640              MOV      r0,r8
000042  4788              BLX      r1
                  |L6.68|
;;;269      prev_hdr_ptr = NULL;
;;;270      hdr_ptr = mem->small_list[pool_id];
000044  eb090a85          ADD      r10,r9,r5,LSL #2
000048  2400              MOVS     r4,#0                 ;269
;;;271      while (hdr_ptr != NULL) {
00004a  f8da0034          LDR      r0,[r10,#0x34]
00004e  e004              B        |L6.90|
                  |L6.80|
;;;272        if (hdr_ptr->hdr.bytes_left >= sizeofobject)
000050  6881              LDR      r1,[r0,#8]
000052  42b1              CMP      r1,r6
000054  d204              BCS      |L6.96|
;;;273          break;			/* found pool with enough space */
;;;274        prev_hdr_ptr = hdr_ptr;
000056  4604              MOV      r4,r0
;;;275        hdr_ptr = hdr_ptr->hdr.next;
000058  6800              LDR      r0,[r0,#0]
                  |L6.90|
00005a  2800              CMP      r0,#0                 ;271
00005c  d1f8              BNE      |L6.80|
00005e  e000              B        |L6.98|
                  |L6.96|
;;;276      }
;;;277    
;;;278      /* Time to make a new pool? */
;;;279      if (hdr_ptr == NULL) {
000060  b9f0              CBNZ     r0,|L6.160|
                  |L6.98|
;;;280        /* min_request is what we need now, slop is what will be leftover */
;;;281        min_request = sizeofobject + SIZEOF(small_pool_hdr);
000062  f1060710          ADD      r7,r6,#0x10
;;;282        if (prev_hdr_ptr == NULL)	/* first pool in class? */
000066  b33c              CBZ      r4,|L6.184|
;;;283          slop = first_pool_slop[pool_id];
;;;284        else
;;;285          slop = extra_pool_slop[pool_id];
000068  481b              LDR      r0,|L6.216|
00006a  bf00              NOP      
                  |L6.108|
00006c  f8505025          LDR      r5,[r0,r5,LSL #2]
;;;286        /* Don't ask for more than MAX_ALLOC_CHUNK */
;;;287        if (slop > (size_t) (MAX_ALLOC_CHUNK-min_request))
000070  4818              LDR      r0,|L6.212|
000072  3010              ADDS     r0,r0,#0x10
000074  1bc0              SUBS     r0,r0,r7
000076  42a8              CMP      r0,r5
000078  d200              BCS      |L6.124|
;;;288          slop = (size_t) (MAX_ALLOC_CHUNK-min_request);
00007a  4605              MOV      r5,r0
                  |L6.124|
;;;289        /* Try to get space, if fail reduce slop and try again */
;;;290        while(1) {
;;;291          hdr_ptr = (small_pool_ptr) jpeg_get_small(cinfo, min_request + slop);
00007c  1979              ADDS     r1,r7,r5
00007e  4640              MOV      r0,r8
000080  f7fffffe          BL       jpeg_get_small
;;;292          if (hdr_ptr != NULL)
000084  b1d8              CBZ      r0,|L6.190|
;;;293    	break;
;;;294          slop /= 2;
;;;295          if (slop < MIN_SLOP)	/* give up when it gets real small */
;;;296    	out_of_memory(cinfo, 2); /* jpeg_get_small failed */
;;;297        }
;;;298        mem->total_space_allocated += min_request + slop;
000086  f8d9104c          LDR      r1,[r9,#0x4c]
00008a  197a              ADDS     r2,r7,r5
00008c  440a              ADD      r2,r2,r1
;;;299        /* Success, initialize the new pool header and add to end of list */
;;;300        hdr_ptr->hdr.next = NULL;
00008e  2100              MOVS     r1,#0
000090  f8c9204c          STR      r2,[r9,#0x4c]
;;;301        hdr_ptr->hdr.bytes_used = 0;
000094  6001              STR      r1,[r0,#0]
;;;302        hdr_ptr->hdr.bytes_left = sizeofobject + slop;
000096  6041              STR      r1,[r0,#4]
000098  1971              ADDS     r1,r6,r5
;;;303        if (prev_hdr_ptr == NULL)	/* first pool in class? */
00009a  6081              STR      r1,[r0,#8]
00009c  b1bc              CBZ      r4,|L6.206|
;;;304          mem->small_list[pool_id] = hdr_ptr;
;;;305        else
;;;306          prev_hdr_ptr->hdr.next = hdr_ptr;
00009e  6020              STR      r0,[r4,#0]
                  |L6.160|
;;;307      }
;;;308    
;;;309      /* OK, allocate the object from the current pool */
;;;310      data_ptr = (char *) (hdr_ptr + 1); /* point to first data byte in pool */
;;;311      data_ptr += hdr_ptr->hdr.bytes_used; /* point to place for object */
0000a0  6841              LDR      r1,[r0,#4]
0000a2  f1000210          ADD      r2,r0,#0x10           ;310
0000a6  440a              ADD      r2,r2,r1
;;;312      hdr_ptr->hdr.bytes_used += sizeofobject;
0000a8  4431              ADD      r1,r1,r6
;;;313      hdr_ptr->hdr.bytes_left -= sizeofobject;
0000aa  6041              STR      r1,[r0,#4]
0000ac  6881              LDR      r1,[r0,#8]
0000ae  1b89              SUBS     r1,r1,r6
;;;314    
;;;315      return (void *) data_ptr;
0000b0  6081              STR      r1,[r0,#8]
0000b2  4610              MOV      r0,r2
;;;316    }
0000b4  e8bd87f0          POP      {r4-r10,pc}
                  |L6.184|
0000b8  4807              LDR      r0,|L6.216|
0000ba  3808              SUBS     r0,r0,#8              ;283
0000bc  e7d6              B        |L6.108|
                  |L6.190|
0000be  086d              LSRS     r5,r5,#1              ;294
0000c0  2d32              CMP      r5,#0x32              ;295
0000c2  d2db              BCS      |L6.124|
0000c4  2102              MOVS     r1,#2                 ;296
0000c6  4640              MOV      r0,r8                 ;296
0000c8  f7fffffe          BL       out_of_memory
0000cc  e7d6              B        |L6.124|
                  |L6.206|
0000ce  f8ca0034          STR      r0,[r10,#0x34]        ;304
0000d2  e7e5              B        |L6.160|
;;;317    
                          ENDP

                  |L6.212|
                          DCD      0x3b9ac9f0
                  |L6.216|
                          DCD      ||.constdata||+0x8

                          AREA ||i.do_barray_io||, CODE, READONLY, ALIGN=1

                  do_barray_io PROC
;;;685    /* Do backing store read or write of a virtual coefficient-block array */
;;;686    LOCAL(void) do_barray_io (j_common_ptr cinfo, jvirt_barray_ptr ptr, boolean writing) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
000004  4683              MOV      r11,r0
;;;687      long bytesperrow, file_offset, byte_count, rows, thisrow, i;
;;;688    
;;;689      bytesperrow = (long) ptr->blocksperrow * SIZEOF(JBLOCK);
000006  6888              LDR      r0,[r1,#8]
;;;690      file_offset = ptr->cur_start_row * bytesperrow;
000008  698e              LDR      r6,[r1,#0x18]
00000a  01c7              LSLS     r7,r0,#7              ;689
00000c  437e              MULS     r6,r7,r6
00000e  4692              MOV      r10,r2                ;686
000010  460c              MOV      r4,r1                 ;686
;;;691      /* Loop to read or write each allocation chunk in mem_buffer */
;;;692      for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
000012  2500              MOVS     r5,#0
;;;693        /* One chunk, but check for short chunk at end of buffer */
;;;694        rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
;;;695        /* Transfer no more than is currently defined */
;;;696        thisrow = (long) ptr->cur_start_row + i;
;;;697        rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
;;;698        /* Transfer no more than fits in file */
;;;699        rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
;;;700        if (rows <= 0)		/* this chunk might be past end of file! */
;;;701          break;
;;;702        byte_count = rows * bytesperrow;
;;;703        if (writing)
;;;704          (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
000014  f1010930          ADD      r9,r1,#0x30
000018  e028              B        |L7.108|
                  |L7.26|
00001a  6960              LDR      r0,[r4,#0x14]         ;694
00001c  1b49              SUBS     r1,r1,r5              ;694
00001e  4288              CMP      r0,r1                 ;694
000020  db00              BLT      |L7.36|
000022  4608              MOV      r0,r1                 ;694
                  |L7.36|
000024  69a1              LDR      r1,[r4,#0x18]         ;696
000026  69e2              LDR      r2,[r4,#0x1c]         ;697
000028  4429              ADD      r1,r1,r5              ;696
00002a  1a52              SUBS     r2,r2,r1              ;697
00002c  4282              CMP      r2,r0                 ;697
00002e  dc00              BGT      |L7.50|
000030  4610              MOV      r0,r2                 ;697
                  |L7.50|
000032  6862              LDR      r2,[r4,#4]            ;699
000034  1a51              SUBS     r1,r2,r1              ;699
000036  4281              CMP      r1,r0                 ;699
000038  dc00              BGT      |L7.60|
00003a  4608              MOV      r0,r1                 ;699
                  |L7.60|
00003c  2800              CMP      r0,#0                 ;700
00003e  dd18              BLE      |L7.114|
000040  fb00f807          MUL      r8,r0,r7              ;702
;;;705    					    (void FAR *) ptr->mem_buffer[i],
;;;706    					    file_offset, byte_count);
;;;707        else
;;;708          (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
000044  f8cd8000          STR      r8,[sp,#0]
000048  6820              LDR      r0,[r4,#0]
00004a  f1ba0f00          CMP      r10,#0                ;703
00004e  f8502025          LDR      r2,[r0,r5,LSL #2]
000052  d002              BEQ      |L7.90|
000054  f8d4c034          LDR      r12,[r4,#0x34]        ;704
000058  e001              B        |L7.94|
                  |L7.90|
00005a  f8d4c030          LDR      r12,[r4,#0x30]
                  |L7.94|
00005e  4633              MOV      r3,r6
000060  4649              MOV      r1,r9
000062  4658              MOV      r0,r11
000064  47e0              BLX      r12
000066  6960              LDR      r0,[r4,#0x14]         ;692
;;;709    					   (void FAR *) ptr->mem_buffer[i],
;;;710    					   file_offset, byte_count);
;;;711        file_offset += byte_count;
000068  4446              ADD      r6,r6,r8
00006a  4405              ADD      r5,r5,r0              ;692
                  |L7.108|
00006c  6921              LDR      r1,[r4,#0x10]         ;692
00006e  42a9              CMP      r1,r5                 ;692
000070  dcd3              BGT      |L7.26|
                  |L7.114|
;;;712      }
;;;713    }
000072  e8bd8ff8          POP      {r3-r11,pc}
;;;714    
                          ENDP


                          AREA ||i.do_sarray_io||, CODE, READONLY, ALIGN=1

                  do_sarray_io PROC
;;;653    
;;;654    LOCAL(void) do_sarray_io (j_common_ptr cinfo, jvirt_sarray_ptr ptr, boolean writing) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;655    /* Do backing store read or write of a virtual sample array */
;;;656      long bytesperrow, file_offset, byte_count, rows, thisrow, i;
;;;657    
;;;658      bytesperrow = (long) ptr->samplesperrow * SIZEOF(JSAMPLE);
;;;659      file_offset = ptr->cur_start_row * bytesperrow;
000004  688f              LDR      r7,[r1,#8]
000006  698e              LDR      r6,[r1,#0x18]
000008  4692              MOV      r10,r2                ;654
00000a  437e              MULS     r6,r7,r6
00000c  460c              MOV      r4,r1                 ;654
00000e  4683              MOV      r11,r0                ;654
;;;660      /* Loop to read or write each allocation chunk in mem_buffer */
;;;661      for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
000010  2500              MOVS     r5,#0
;;;662        /* One chunk, but check for short chunk at end of buffer */
;;;663        rows = MIN((long) ptr->rowsperchunk, (long) ptr->rows_in_mem - i);
;;;664        /* Transfer no more than is currently defined */
;;;665        thisrow = (long) ptr->cur_start_row + i;
;;;666        rows = MIN(rows, (long) ptr->first_undef_row - thisrow);
;;;667        /* Transfer no more than fits in file */
;;;668        rows = MIN(rows, (long) ptr->rows_in_array - thisrow);
;;;669        if (rows <= 0)		/* this chunk might be past end of file! */
;;;670          break;
;;;671        byte_count = rows * bytesperrow;
;;;672        if (writing)
;;;673          (*ptr->b_s_info.write_backing_store) (cinfo, & ptr->b_s_info,
000012  f1010930          ADD      r9,r1,#0x30
000016  e028              B        |L8.106|
                  |L8.24|
000018  6961              LDR      r1,[r4,#0x14]         ;663
00001a  1b40              SUBS     r0,r0,r5              ;663
00001c  4281              CMP      r1,r0                 ;663
00001e  da00              BGE      |L8.34|
000020  4608              MOV      r0,r1                 ;663
                  |L8.34|
000022  69a1              LDR      r1,[r4,#0x18]         ;665
000024  69e2              LDR      r2,[r4,#0x1c]         ;666
000026  4429              ADD      r1,r1,r5              ;665
000028  1a52              SUBS     r2,r2,r1              ;666
00002a  4282              CMP      r2,r0                 ;666
00002c  dc00              BGT      |L8.48|
00002e  4610              MOV      r0,r2                 ;666
                  |L8.48|
000030  6862              LDR      r2,[r4,#4]            ;668
000032  1a51              SUBS     r1,r2,r1              ;668
000034  4281              CMP      r1,r0                 ;668
000036  dc00              BGT      |L8.58|
000038  4608              MOV      r0,r1                 ;668
                  |L8.58|
00003a  2800              CMP      r0,#0                 ;669
00003c  dd18              BLE      |L8.112|
00003e  fb00f807          MUL      r8,r0,r7              ;671
;;;674    					    (void FAR *) ptr->mem_buffer[i],
;;;675    					    file_offset, byte_count);
;;;676        else
;;;677          (*ptr->b_s_info.read_backing_store) (cinfo, & ptr->b_s_info,
000042  f8cd8000          STR      r8,[sp,#0]
000046  6820              LDR      r0,[r4,#0]
000048  f1ba0f00          CMP      r10,#0                ;672
00004c  f8502025          LDR      r2,[r0,r5,LSL #2]
000050  d002              BEQ      |L8.88|
000052  f8d4c034          LDR      r12,[r4,#0x34]        ;673
000056  e001              B        |L8.92|
                  |L8.88|
000058  f8d4c030          LDR      r12,[r4,#0x30]
                  |L8.92|
00005c  4633              MOV      r3,r6
00005e  4649              MOV      r1,r9
000060  4658              MOV      r0,r11
000062  47e0              BLX      r12
000064  6960              LDR      r0,[r4,#0x14]         ;661
;;;678    					   (void FAR *) ptr->mem_buffer[i],
;;;679    					   file_offset, byte_count);
;;;680        file_offset += byte_count;
000066  4446              ADD      r6,r6,r8
000068  4405              ADD      r5,r5,r0              ;661
                  |L8.106|
00006a  6920              LDR      r0,[r4,#0x10]         ;661
00006c  42a8              CMP      r0,r5                 ;661
00006e  dcd3              BGT      |L8.24|
                  |L8.112|
;;;681      }
;;;682    }
000070  e8bd8ff8          POP      {r3-r11,pc}
;;;683    
                          ENDP


                          AREA ||i.free_pool||, CODE, READONLY, ALIGN=2

                  free_pool PROC
;;;882    METHODDEF(void)
;;;883    free_pool (j_common_ptr cinfo, int pool_id)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;884    {
;;;885      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
;;;886      small_pool_ptr shdr_ptr;
;;;887      large_pool_ptr lhdr_ptr;
;;;888      size_t space_freed;
;;;889    
;;;890      if (pool_id < 0 || pool_id >= JPOOL_NUMPOOLS)
000004  6844              LDR      r4,[r0,#4]
000006  460e              MOV      r6,r1                 ;884
000008  4607              MOV      r7,r0                 ;884
00000a  2902              CMP      r1,#2
00000c  d308              BCC      |L9.32|
;;;891        ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
00000e  6839              LDR      r1,[r7,#0]
000010  200e              MOVS     r0,#0xe
000012  6148              STR      r0,[r1,#0x14]
000014  6838              LDR      r0,[r7,#0]
000016  6186              STR      r6,[r0,#0x18]
000018  6838              LDR      r0,[r7,#0]
00001a  6801              LDR      r1,[r0,#0]
00001c  4638              MOV      r0,r7
00001e  4788              BLX      r1
                  |L9.32|
000020  f04f0900          MOV      r9,#0
;;;892    
;;;893    #ifdef MEM_STATS
;;;894      if (cinfo->err->trace_level > 1)
;;;895        print_mem_stats(cinfo, pool_id); /* print pool's memory usage statistics */
;;;896    #endif
;;;897    
;;;898      /* If freeing IMAGE pool, close any virtual arrays first */
;;;899      if (pool_id == JPOOL_IMAGE) {
000024  2e01              CMP      r6,#1
000026  d120              BNE      |L9.106|
;;;900        jvirt_sarray_ptr sptr;
;;;901        jvirt_barray_ptr bptr;
;;;902    
;;;903        for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
000028  6c65              LDR      r5,[r4,#0x44]
00002a  e009              B        |L9.64|
                  |L9.44|
;;;904          if (sptr->b_s_open) {	/* there may be no backing store */
00002c  6aa8              LDR      r0,[r5,#0x28]
00002e  b130              CBZ      r0,|L9.62|
;;;905    	sptr->b_s_open = FALSE;	/* prevent recursive close if error */
;;;906    	(*sptr->b_s_info.close_backing_store) (cinfo, & sptr->b_s_info);
000030  f8c59028          STR      r9,[r5,#0x28]
000034  6baa              LDR      r2,[r5,#0x38]
000036  f1050130          ADD      r1,r5,#0x30
00003a  4638              MOV      r0,r7
00003c  4790              BLX      r2
                  |L9.62|
00003e  6aed              LDR      r5,[r5,#0x2c]         ;903
                  |L9.64|
000040  2d00              CMP      r5,#0                 ;903
000042  d1f3              BNE      |L9.44|
;;;907          }
;;;908        }
;;;909        mem->virt_sarray_list = NULL;
;;;910        for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
000044  f8c49044          STR      r9,[r4,#0x44]
000048  46c8              MOV      r8,r9
00004a  6ca5              LDR      r5,[r4,#0x48]
00004c  e009              B        |L9.98|
                  |L9.78|
;;;911          if (bptr->b_s_open) {	/* there may be no backing store */
00004e  6aa8              LDR      r0,[r5,#0x28]
000050  b130              CBZ      r0,|L9.96|
;;;912    	bptr->b_s_open = FALSE;	/* prevent recursive close if error */
;;;913    	(*bptr->b_s_info.close_backing_store) (cinfo, & bptr->b_s_info);
000052  f8c58028          STR      r8,[r5,#0x28]
000056  6baa              LDR      r2,[r5,#0x38]
000058  f1050130          ADD      r1,r5,#0x30
00005c  4638              MOV      r0,r7
00005e  4790              BLX      r2
                  |L9.96|
000060  6aed              LDR      r5,[r5,#0x2c]         ;910
                  |L9.98|
000062  2d00              CMP      r5,#0                 ;910
000064  d1f3              BNE      |L9.78|
;;;914          }
;;;915        }
;;;916        mem->virt_barray_list = NULL;
000066  f8c48048          STR      r8,[r4,#0x48]
                  |L9.106|
;;;917      }
;;;918    
;;;919      /* Release large objects */
;;;920      lhdr_ptr = mem->large_list[pool_id];
00006a  eb040686          ADD      r6,r4,r6,LSL #2
;;;921      mem->large_list[pool_id] = NULL;
00006e  6bf1              LDR      r1,[r6,#0x3c]
;;;922    
;;;923      while (lhdr_ptr != NULL) {
000070  f8c6903c          STR      r9,[r6,#0x3c]
000074  e00f              B        |L9.150|
;;;924        large_pool_ptr next_lhdr_ptr = lhdr_ptr->hdr.next;
000076  bf00              NOP      
                  |L9.120|
000078  e9d10201          LDRD     r0,r2,[r1,#4]
;;;925        space_freed = lhdr_ptr->hdr.bytes_used +
00007c  4410              ADD      r0,r0,r2
00007e  3010              ADDS     r0,r0,#0x10
000080  4680              MOV      r8,r0
;;;926    		  lhdr_ptr->hdr.bytes_left +
;;;927    		  SIZEOF(large_pool_hdr);
;;;928        jpeg_free_small/*RS: Changed from jpeg_free_large*/(cinfo, (void FAR *) lhdr_ptr, space_freed);
000082  4602              MOV      r2,r0
000084  4638              MOV      r0,r7
000086  680d              LDR      r5,[r1,#0]
000088  f7fffffe          BL       jpeg_free_small
;;;929        mem->total_space_allocated -= space_freed;
00008c  6ce1              LDR      r1,[r4,#0x4c]
00008e  eba10008          SUB      r0,r1,r8
;;;930        lhdr_ptr = next_lhdr_ptr;
000092  4629              MOV      r1,r5
000094  64e0              STR      r0,[r4,#0x4c]
                  |L9.150|
000096  2900              CMP      r1,#0                 ;923
000098  d1ee              BNE      |L9.120|
;;;931      }
;;;932    
;;;933      /* Release small objects */
;;;934      shdr_ptr = mem->small_list[pool_id];
;;;935      mem->small_list[pool_id] = NULL;
00009a  6b71              LDR      r1,[r6,#0x34]
;;;936    
;;;937      while (shdr_ptr != NULL) {
00009c  f8c69034          STR      r9,[r6,#0x34]
0000a0  e00d              B        |L9.190|
;;;938        small_pool_ptr next_shdr_ptr = shdr_ptr->hdr.next;
0000a2  bf00              NOP      
                  |L9.164|
0000a4  e9d10201          LDRD     r0,r2,[r1,#4]
;;;939        space_freed = shdr_ptr->hdr.bytes_used +
0000a8  1886              ADDS     r6,r0,r2
0000aa  3610              ADDS     r6,r6,#0x10
;;;940    		  shdr_ptr->hdr.bytes_left +
;;;941    		  SIZEOF(small_pool_hdr);
;;;942        jpeg_free_small(cinfo, (void *) shdr_ptr, space_freed);
0000ac  4632              MOV      r2,r6
0000ae  4638              MOV      r0,r7
0000b0  680d              LDR      r5,[r1,#0]
0000b2  f7fffffe          BL       jpeg_free_small
;;;943        mem->total_space_allocated -= space_freed;
0000b6  6ce0              LDR      r0,[r4,#0x4c]
;;;944        shdr_ptr = next_shdr_ptr;
0000b8  4629              MOV      r1,r5
0000ba  1b80              SUBS     r0,r0,r6              ;943
0000bc  64e0              STR      r0,[r4,#0x4c]
                  |L9.190|
0000be  2900              CMP      r1,#0                 ;937
0000c0  d1f0              BNE      |L9.164|
;;;945      }
;;;946    }
0000c2  e8bd87f0          POP      {r4-r10,pc}
;;;947    
                          ENDP


                          AREA ||i.jinit_memory_mgr||, CODE, READONLY, ALIGN=2

                  jinit_memory_mgr PROC
;;;980    GLOBAL(void)
;;;981    jinit_memory_mgr (j_common_ptr cinfo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;982    {
;;;983      my_mem_ptr mem;
;;;984      long max_to_use;
;;;985      int pool;
;;;986      size_t test_mac;
;;;987    
;;;988      cinfo->mem = NULL;		/* for safety if init fails */
000004  2500              MOVS     r5,#0
000006  4606              MOV      r6,r0                 ;982
;;;989    
;;;990      /* Check for configuration errors.
;;;991       * SIZEOF(ALIGN_TYPE) should be a power of 2; otherwise, it probably
;;;992       * doesn't reflect any real hardware alignment requirement.
;;;993       * The test is a little tricky: for X>0, X and X-1 have no one-bits
;;;994       * in common if and only if X is a power of 2, ie has only one one-bit.
;;;995       * Some compilers may give an "unreachable code" warning here; ignore it.
;;;996       */
;;;997      if ((SIZEOF(ALIGN_TYPE) & (SIZEOF(ALIGN_TYPE)-1)) != 0)
;;;998        ERREXIT(cinfo, JERR_BAD_ALIGN_TYPE);
;;;999      /* MAX_ALLOC_CHUNK must be representable as type size_t, and must be
;;;1000      * a multiple of SIZEOF(ALIGN_TYPE).
;;;1001      * Again, an "unreachable code" warning may be ignored here.
;;;1002      * But a "constant too large" warning means you need to fix MAX_ALLOC_CHUNK.
;;;1003      */
;;;1004     test_mac = (size_t) MAX_ALLOC_CHUNK;
000008  4f1e              LDR      r7,|L10.132|
;;;1005     if ((long) test_mac != MAX_ALLOC_CHUNK ||
;;;1006         (MAX_ALLOC_CHUNK % SIZEOF(ALIGN_TYPE)) != 0)
;;;1007       ERREXIT(cinfo, JERR_BAD_ALLOC_CHUNK);
;;;1008   
;;;1009     max_to_use = jpeg_mem_init(cinfo); /* system-dependent initialization */
00000a  6045              STR      r5,[r0,#4]
00000c  f7fffffe          BL       jpeg_mem_init
000010  4680              MOV      r8,r0
;;;1010   
;;;1011     /* Attempt to allocate memory manager's control block */
;;;1012     mem = (my_mem_ptr) jpeg_get_small(cinfo, SIZEOF(my_memory_mgr));
000012  2154              MOVS     r1,#0x54
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       jpeg_get_small
00001a  0004              MOVS     r4,r0
00001c  d10b              BNE      |L10.54|
;;;1013   
;;;1014     if (mem == NULL) {
;;;1015       jpeg_mem_term(cinfo);	/* system-dependent cleanup */
00001e  4630              MOV      r0,r6
000020  f7fffffe          BL       jpeg_mem_term
;;;1016       ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, 0);
000024  6831              LDR      r1,[r6,#0]
000026  2036              MOVS     r0,#0x36
000028  6148              STR      r0,[r1,#0x14]
00002a  6830              LDR      r0,[r6,#0]
00002c  6185              STR      r5,[r0,#0x18]
00002e  6830              LDR      r0,[r6,#0]
000030  6801              LDR      r1,[r0,#0]
000032  4630              MOV      r0,r6
000034  4788              BLX      r1
                  |L10.54|
;;;1017     }
;;;1018   
;;;1019     /* OK, fill in the method pointers */
;;;1020     mem->pub.alloc_small = alloc_small;
000036  4814              LDR      r0,|L10.136|
;;;1021     mem->pub.alloc_large = alloc_large;
000038  6020              STR      r0,[r4,#0]
00003a  4814              LDR      r0,|L10.140|
;;;1022     mem->pub.alloc_sarray = alloc_sarray;
00003c  6060              STR      r0,[r4,#4]
00003e  4814              LDR      r0,|L10.144|
;;;1023     mem->pub.alloc_barray = alloc_barray;
000040  60a0              STR      r0,[r4,#8]
000042  4814              LDR      r0,|L10.148|
;;;1024     mem->pub.request_virt_sarray = request_virt_sarray;
000044  60e0              STR      r0,[r4,#0xc]
000046  4814              LDR      r0,|L10.152|
;;;1025     mem->pub.request_virt_barray = request_virt_barray;
000048  6120              STR      r0,[r4,#0x10]
00004a  4814              LDR      r0,|L10.156|
;;;1026     mem->pub.realize_virt_arrays = realize_virt_arrays;
00004c  6160              STR      r0,[r4,#0x14]
00004e  4814              LDR      r0,|L10.160|
;;;1027     mem->pub.access_virt_sarray = access_virt_sarray;
000050  61a0              STR      r0,[r4,#0x18]
000052  4814              LDR      r0,|L10.164|
;;;1028     mem->pub.access_virt_barray = access_virt_barray;
000054  61e0              STR      r0,[r4,#0x1c]
000056  4814              LDR      r0,|L10.168|
;;;1029     mem->pub.free_pool = free_pool;
000058  6220              STR      r0,[r4,#0x20]
00005a  4814              LDR      r0,|L10.172|
;;;1030     mem->pub.self_destruct = self_destruct;
00005c  6260              STR      r0,[r4,#0x24]
00005e  4814              LDR      r0,|L10.176|
;;;1031   
;;;1032     /* Make MAX_ALLOC_CHUNK accessible to other modules */
;;;1033     mem->pub.max_alloc_chunk = MAX_ALLOC_CHUNK;
000060  6327              STR      r7,[r4,#0x30]
000062  e9c4080a          STRD     r0,r8,[r4,#0x28]
;;;1034   
;;;1035     /* Initialize working state */
;;;1036     mem->pub.max_memory_to_use = max_to_use;
;;;1037   
;;;1038     for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
000066  2001              MOVS     r0,#1
                  |L10.104|
;;;1039       mem->small_list[pool] = NULL;
000068  eb040180          ADD      r1,r4,r0,LSL #2
;;;1040       mem->large_list[pool] = NULL;
00006c  1e40              SUBS     r0,r0,#1
00006e  634d              STR      r5,[r1,#0x34]
000070  63cd              STR      r5,[r1,#0x3c]
000072  d5f9              BPL      |L10.104|
;;;1041     }
;;;1042     mem->virt_sarray_list = NULL;
;;;1043     mem->virt_barray_list = NULL;
;;;1044   
;;;1045     mem->total_space_allocated = SIZEOF(my_memory_mgr);
000074  2054              MOVS     r0,#0x54
000076  6465              STR      r5,[r4,#0x44]
000078  e9c45012          STRD     r5,r0,[r4,#0x48]
;;;1046   
;;;1047     /* Declare ourselves open for business */
;;;1048     cinfo->mem = & mem->pub;
00007c  6074              STR      r4,[r6,#4]
;;;1049   
;;;1050     /* Check for an environment variable JPEGMEM; if found, override the
;;;1051      * default max_memory setting from jpeg_mem_init.  Note that the
;;;1052      * surrounding application may again override this value.
;;;1053      * If your system doesn't support getenv(), define NO_GETENV to disable
;;;1054      * this feature.
;;;1055      */
;;;1056   #if 0 /* RS ndef NO_GETENV */
;;;1057     { char * memenv;
;;;1058   
;;;1059       if ((memenv = getenv("JPEGMEM")) != NULL) {
;;;1060         char ch = 'x';
;;;1061   
;;;1062         if (sscanf(memenv, "%ld%c", &max_to_use, &ch) > 0) {
;;;1063   	if (ch == 'm' || ch == 'M')
;;;1064   	  max_to_use *= 1000L;
;;;1065   	mem->pub.max_memory_to_use = max_to_use * 1000L;
;;;1066         }
;;;1067       }
;;;1068     }
;;;1069   #endif
;;;1070   
;;;1071   }
00007e  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

000082  0000              DCW      0x0000
                  |L10.132|
                          DCD      0x3b9aca00
                  |L10.136|
                          DCD      alloc_small
                  |L10.140|
                          DCD      alloc_large
                  |L10.144|
                          DCD      alloc_sarray
                  |L10.148|
                          DCD      alloc_barray
                  |L10.152|
                          DCD      request_virt_sarray
                  |L10.156|
                          DCD      request_virt_barray
                  |L10.160|
                          DCD      realize_virt_arrays
                  |L10.164|
                          DCD      access_virt_sarray
                  |L10.168|
                          DCD      access_virt_barray
                  |L10.172|
                          DCD      free_pool
                  |L10.176|
                          DCD      self_destruct

                          AREA ||i.out_of_memory||, CODE, READONLY, ALIGN=1

                  out_of_memory PROC
;;;209    LOCAL(void)
;;;210    out_of_memory (j_common_ptr cinfo, int which)
000000  6803              LDR      r3,[r0,#0]
;;;211    /* Report an out-of-memory error and stop execution */
;;;212    /* If we compiled MEM_STATS support, report alloc requests before dying */
;;;213    {
;;;214    #ifdef MEM_STATS
;;;215      cinfo->err->trace_level = 2;	/* force self_destruct to report stats */
;;;216    #endif
;;;217      ERREXIT1(cinfo, JERR_OUT_OF_MEMORY, which);
000002  2236              MOVS     r2,#0x36
000004  615a              STR      r2,[r3,#0x14]
000006  6802              LDR      r2,[r0,#0]
000008  6191              STR      r1,[r2,#0x18]
00000a  6801              LDR      r1,[r0,#0]
00000c  6809              LDR      r1,[r1,#0]
00000e  4708              BX       r1
;;;218    }
;;;219    
                          ENDP


                          AREA ||i.realize_virt_arrays||, CODE, READONLY, ALIGN=1

                  realize_virt_arrays PROC
;;;549    
;;;550    METHODDEF(void) realize_virt_arrays (j_common_ptr cinfo) {
000000  b430              PUSH     {r4,r5}
;;;551    /* Allocate the in-memory buffers for any unrealized virtual arrays */
;;;552      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
;;;553      long space_per_minheight, maximum_space/*, avail_mem*/;
;;;554    /*  long minheights, max_minheights;*/
;;;555      jvirt_sarray_ptr sptr;
;;;556      jvirt_barray_ptr bptr;
;;;557    
;;;558      /* Compute the minimum space needed (maxaccess rows in each buffer)
;;;559       * and the maximum space needed (full image height in each buffer).
;;;560       * These may be of use to the system-dependent jpeg_mem_available routine.
;;;561       */
;;;562      space_per_minheight = 0;
;;;563      maximum_space = 0;
;;;564      for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
000002  6843              LDR      r3,[r0,#4]
000004  2200              MOVS     r2,#0                 ;562
000006  6c59              LDR      r1,[r3,#0x44]         ;550
000008  e006              B        |L12.24|
                  |L12.10|
;;;565        if (sptr->mem_buffer == NULL) { /* if not realized yet */
00000a  680c              LDR      r4,[r1,#0]
00000c  b91c              CBNZ     r4,|L12.22|
00000e  e9d14502          LDRD     r4,r5,[r1,#8]
;;;566          space_per_minheight += (long) sptr->maxaccess *
000012  fb052204          MLA      r2,r5,r4,r2
                  |L12.22|
000016  6ac9              LDR      r1,[r1,#0x2c]         ;564
                  |L12.24|
000018  2900              CMP      r1,#0                 ;564
00001a  d1f6              BNE      |L12.10|
;;;567    			     (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
;;;568          maximum_space += (long) sptr->rows_in_array *
;;;569    		       (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
;;;570        }
;;;571      }
;;;572      for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
00001c  6c99              LDR      r1,[r3,#0x48]
00001e  e007              B        |L12.48|
                  |L12.32|
;;;573        if (bptr->mem_buffer == NULL) { /* if not realized yet */
000020  680b              LDR      r3,[r1,#0]
000022  b923              CBNZ     r3,|L12.46|
000024  e9d14302          LDRD     r4,r3,[r1,#8]
;;;574          space_per_minheight += (long) bptr->maxaccess *
000028  4363              MULS     r3,r4,r3
00002a  eb0212c3          ADD      r2,r2,r3,LSL #7
                  |L12.46|
00002e  6ac9              LDR      r1,[r1,#0x2c]         ;572
                  |L12.48|
000030  2900              CMP      r1,#0                 ;572
000032  d1f5              BNE      |L12.32|
;;;575    			     (long) bptr->blocksperrow * SIZEOF(JBLOCK);
;;;576          maximum_space += (long) bptr->rows_in_array *
;;;577    		       (long) bptr->blocksperrow * SIZEOF(JBLOCK);
;;;578        }
;;;579      }
;;;580    
;;;581      if (space_per_minheight <= 0)
000034  2a00              CMP      r2,#0
000036  dd06              BLE      |L12.70|
;;;582        return;			/* no unrealized arrays, no work */
;;;583    
;;;584    #if 0  /*RS*/
;;;585      /* Determine amount of memory to actually use; this is system-dependent. */
;;;586      avail_mem = jpeg_mem_available(cinfo, space_per_minheight, maximum_space, mem->total_space_allocated);
;;;587    
;;;588      /* If the maximum space needed is available, make all the buffers full
;;;589       * height; otherwise parcel it out with the same number of minheights
;;;590       * in each buffer.
;;;591       */
;;;592      if (avail_mem >= maximum_space)
;;;593        max_minheights = 1000000000L;
;;;594      else {
;;;595        max_minheights = avail_mem / space_per_minheight;
;;;596        /* If there doesn't seem to be enough space, try to get the minimum
;;;597         * anyway.  This allows a "stub" implementation of jpeg_mem_available().
;;;598         */
;;;599        if (max_minheights <= 0)
;;;600          max_minheights = 1;
;;;601      }
;;;602    
;;;603      /* Allocate the in-memory buffers and initialize backing store as needed. */
;;;604      for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
;;;605        if (sptr->mem_buffer == NULL) { /* if not realized yet */
;;;606          minheights = ((long) sptr->rows_in_array - 1L) / sptr->maxaccess + 1L;
;;;607          if (minheights <= max_minheights) {
;;;608    	/* This buffer fits in memory */
;;;609    	sptr->rows_in_mem = sptr->rows_in_array;
;;;610          } else {
;;;611    	/* It doesn't fit in memory, create backing store. */
;;;612    	sptr->rows_in_mem = (JDIMENSION) (max_minheights * sptr->maxaccess);
;;;613    	jpeg_open_backing_store(cinfo, & sptr->b_s_info, (long) sptr->rows_in_array * (long) sptr->samplesperrow * (long) SIZEOF(JSAMPLE));
;;;614    	sptr->b_s_open = TRUE;
;;;615          }
;;;616          sptr->mem_buffer = alloc_sarray(cinfo, JPOOL_IMAGE,
;;;617    				      sptr->samplesperrow, sptr->rows_in_mem);
;;;618          sptr->rowsperchunk = mem->last_rowsperchunk;
;;;619          sptr->cur_start_row = 0;
;;;620          sptr->first_undef_row = 0;
;;;621          sptr->dirty = FALSE;
;;;622        }
;;;623      }
;;;624    
;;;625      for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
;;;626        if (bptr->mem_buffer == NULL) { /* if not realized yet */
;;;627          minheights = ((long) bptr->rows_in_array - 1L) / bptr->maxaccess + 1L;
;;;628          if (minheights <= max_minheights) {
;;;629    	/* This buffer fits in memory */
;;;630    	bptr->rows_in_mem = bptr->rows_in_array;
;;;631          } else {
;;;632    	/* It doesn't fit in memory, create backing store. */
;;;633    	bptr->rows_in_mem = (JDIMENSION) (max_minheights * bptr->maxaccess);
;;;634    	jpeg_open_backing_store(cinfo, & bptr->b_s_info,
;;;635    				(long) bptr->rows_in_array *
;;;636    				(long) bptr->blocksperrow *
;;;637    				(long) SIZEOF(JBLOCK));
;;;638    	bptr->b_s_open = TRUE;
;;;639          }
;;;640          bptr->mem_buffer = alloc_barray(cinfo, JPOOL_IMAGE,
;;;641    				      bptr->blocksperrow, bptr->rows_in_mem);
;;;642          bptr->rowsperchunk = mem->last_rowsperchunk;
;;;643          bptr->cur_start_row = 0;
;;;644          bptr->first_undef_row = 0;
;;;645          bptr->dirty = FALSE;
;;;646        }
;;;647      }
;;;648    # else
;;;649      ERREXIT(cinfo, JERR_NO_BACKING_STORE);
000038  6802              LDR      r2,[r0,#0]
00003a  2131              MOVS     r1,#0x31
00003c  6151              STR      r1,[r2,#0x14]
00003e  6801              LDR      r1,[r0,#0]
000040  6809              LDR      r1,[r1,#0]
000042  bc30              POP      {r4,r5}
000044  4708              BX       r1
                  |L12.70|
;;;650    #endif
;;;651    }
000046  bc30              POP      {r4,r5}
000048  4770              BX       lr
;;;652    
                          ENDP


                          AREA ||i.request_virt_barray||, CODE, READONLY, ALIGN=1

                  request_virt_barray PROC
;;;526    
;;;527    METHODDEF(jvirt_barray_ptr) request_virt_barray (j_common_ptr cinfo, int pool_id, boolean pre_zero, JDIMENSION blocksperrow, JDIMENSION numrows, JDIMENSION maxaccess) {
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;528      /* Request a virtual 2-D coefficient-block array */
;;;529      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
;;;530      jvirt_barray_ptr result;
;;;531      /* Only IMAGE-lifetime virtual arrays are currently supported */
;;;532      if (pool_id != JPOOL_IMAGE)
000004  6844              LDR      r4,[r0,#4]
000006  e9dd9a08          LDRD     r9,r10,[sp,#0x20]     ;527
00000a  461d              MOV      r5,r3                 ;527
00000c  4690              MOV      r8,r2                 ;527
00000e  460f              MOV      r7,r1                 ;527
000010  4606              MOV      r6,r0                 ;527
000012  2901              CMP      r1,#1
000014  d008              BEQ      |L13.40|
;;;533        ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
000016  6831              LDR      r1,[r6,#0]
000018  200e              MOVS     r0,#0xe
00001a  6148              STR      r0,[r1,#0x14]
00001c  6830              LDR      r0,[r6,#0]
00001e  6187              STR      r7,[r0,#0x18]
000020  6830              LDR      r0,[r6,#0]
000022  6801              LDR      r1,[r0,#0]
000024  4630              MOV      r0,r6
000026  4788              BLX      r1
                  |L13.40|
;;;534    
;;;535      /* get control block */
;;;536      result = (jvirt_barray_ptr) alloc_small(cinfo, pool_id, SIZEOF(struct jvirt_barray_control));
000028  227c              MOVS     r2,#0x7c
00002a  4639              MOV      r1,r7
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       alloc_small
;;;537      result->mem_buffer = NULL;	/* marks array not yet realized */
000032  2100              MOVS     r1,#0
;;;538      result->rows_in_array = numrows;
;;;539      result->blocksperrow = blocksperrow;
;;;540      result->maxaccess = maxaccess;
;;;541      result->pre_zero = pre_zero;
000034  f8c08020          STR      r8,[r0,#0x20]
000038  e9c01900          STRD     r1,r9,[r0,#0]
;;;542      result->b_s_open = FALSE;	/* no associated backing-store object */
00003c  6281              STR      r1,[r0,#0x28]
00003e  e9c05a02          STRD     r5,r10,[r0,#8]
;;;543      result->next = mem->virt_barray_list; /* add to list of virtual arrays */
000042  6ca1              LDR      r1,[r4,#0x48]
;;;544      mem->virt_barray_list = result;
000044  62c1              STR      r1,[r0,#0x2c]
000046  64a0              STR      r0,[r4,#0x48]
;;;545    
;;;546      return result;
;;;547    }
000048  e8bd87f0          POP      {r4-r10,pc}
;;;548    
                          ENDP


                          AREA ||i.request_virt_sarray||, CODE, READONLY, ALIGN=1

                  request_virt_sarray PROC
;;;502    
;;;503    METHODDEF(jvirt_sarray_ptr) request_virt_sarray (j_common_ptr cinfo, int pool_id, boolean pre_zero, JDIMENSION samplesperrow, JDIMENSION numrows, JDIMENSION maxaccess) {
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;504      /* Request a virtual 2-D sample array */
;;;505      my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
;;;506      jvirt_sarray_ptr result;
;;;507    
;;;508      /* Only IMAGE-lifetime virtual arrays are currently supported */
;;;509      if (pool_id != JPOOL_IMAGE) {
000004  6844              LDR      r4,[r0,#4]
000006  e9dd9a08          LDRD     r9,r10,[sp,#0x20]     ;503
00000a  461d              MOV      r5,r3                 ;503
00000c  4690              MOV      r8,r2                 ;503
00000e  460f              MOV      r7,r1                 ;503
000010  4606              MOV      r6,r0                 ;503
000012  2901              CMP      r1,#1
000014  d008              BEQ      |L14.40|
;;;510        ERREXIT1(cinfo, JERR_BAD_POOL_ID, pool_id);	/* safety check */
000016  6831              LDR      r1,[r6,#0]
000018  200e              MOVS     r0,#0xe
00001a  6148              STR      r0,[r1,#0x14]
00001c  6830              LDR      r0,[r6,#0]
00001e  6187              STR      r7,[r0,#0x18]
000020  6830              LDR      r0,[r6,#0]
000022  6801              LDR      r1,[r0,#0]
000024  4630              MOV      r0,r6
000026  4788              BLX      r1
                  |L14.40|
;;;511      }
;;;512      /* get control block */
;;;513      result = (jvirt_sarray_ptr) alloc_small(cinfo, pool_id, SIZEOF(struct jvirt_sarray_control));
000028  227c              MOVS     r2,#0x7c
00002a  4639              MOV      r1,r7
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       alloc_small
;;;514      result->mem_buffer = NULL;	/* marks array not yet realized */
000032  2100              MOVS     r1,#0
;;;515      result->rows_in_array = numrows;
;;;516      result->samplesperrow = samplesperrow;
;;;517      result->maxaccess = maxaccess;
;;;518      result->pre_zero = pre_zero;
000034  f8c08020          STR      r8,[r0,#0x20]
000038  e9c01900          STRD     r1,r9,[r0,#0]
;;;519      result->b_s_open = FALSE;	/* no associated backing-store object */
00003c  6281              STR      r1,[r0,#0x28]
00003e  e9c05a02          STRD     r5,r10,[r0,#8]
;;;520      result->next = mem->virt_sarray_list; /* add to list of virtual arrays */
000042  6c61              LDR      r1,[r4,#0x44]
;;;521      mem->virt_sarray_list = result;
000044  62c1              STR      r1,[r0,#0x2c]
000046  6460              STR      r0,[r4,#0x44]
;;;522    
;;;523      return result;
;;;524    }
000048  e8bd87f0          POP      {r4-r10,pc}
;;;525    
                          ENDP


                          AREA ||i.self_destruct||, CODE, READONLY, ALIGN=1

                  self_destruct PROC
;;;954    METHODDEF(void)
;;;955    self_destruct (j_common_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;956    {
000002  4605              MOV      r5,r0
;;;957      int pool;
;;;958    
;;;959      /* Close all backing store, release all memory.
;;;960       * Releasing pools in reverse order might help avoid fragmentation
;;;961       * with some (brain-damaged) malloc libraries.
;;;962       */
;;;963      for (pool = JPOOL_NUMPOOLS-1; pool >= JPOOL_PERMANENT; pool--) {
000004  2401              MOVS     r4,#1
                  |L15.6|
;;;964        free_pool(cinfo, pool);
000006  4621              MOV      r1,r4
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       free_pool
00000e  1e64              SUBS     r4,r4,#1
000010  d5f9              BPL      |L15.6|
;;;965      }
;;;966    
;;;967      /* Release the memory manager control block too. */
;;;968      jpeg_free_small(cinfo, (void *) cinfo->mem, SIZEOF(my_memory_mgr));
000012  2254              MOVS     r2,#0x54
000014  4628              MOV      r0,r5
000016  6869              LDR      r1,[r5,#4]
000018  f7fffffe          BL       jpeg_free_small
;;;969      cinfo->mem = NULL;		/* ensures I will be called only once */
00001c  2000              MOVS     r0,#0
;;;970    
;;;971      jpeg_mem_term(cinfo);		/* system-dependent cleanup */
00001e  6068              STR      r0,[r5,#4]
000020  4628              MOV      r0,r5
000022  e8bd4070          POP      {r4-r6,lr}
000026  f7ffbffe          B.W      jpeg_mem_term
;;;972    }
;;;973    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  first_pool_slop
                          DCD      0x00000640
                          DCD      0x00003e80
                  extra_pool_slop
                          DCD      0x00000000
                          DCD      0x00001388
