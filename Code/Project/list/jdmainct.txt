; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\jdmainct.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jdmainct.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\JPEG\jdmainct.c]
                          THUMB

                          AREA ||i.alloc_funny_pointers||, CODE, READONLY, ALIGN=1

                  alloc_funny_pointers PROC
;;;156    LOCAL(void)
;;;157    alloc_funny_pointers (j_decompress_ptr cinfo)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;158    /* Allocate space for the funny pointer lists.
;;;159     * This is done only once, not once per pass.
;;;160     */
;;;161    {
000004  4604              MOV      r4,r0
;;;162      my_main_ptr pMain = (my_main_ptr) cinfo->main;
;;;163      int ci, rgroup;
;;;164      int M = cinfo->min_DCT_scaled_size;
;;;165      jpeg_component_info *compptr;
;;;166      JSAMPARRAY xbuf;
;;;167    
;;;168      /* Get top-level space for component array pointers.
;;;169       * We alloc both arrays with one call to save a few cycles.
;;;170       */
;;;171      pMain->xbuffer[0] = (JSAMPIMAGE)
000006  f8d0a13c          LDR      r10,[r0,#0x13c]
00000a  f8d071a8          LDR      r7,[r0,#0x1a8]
00000e  6a40              LDR      r0,[r0,#0x24]
000010  00c2              LSLS     r2,r0,#3
000012  6860              LDR      r0,[r4,#4]
000014  2101              MOVS     r1,#1
000016  6803              LDR      r3,[r0,#0]
000018  4620              MOV      r0,r4
00001a  4798              BLX      r3
;;;172        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;173    				cinfo->num_components * 2 * SIZEOF(JSAMPARRAY));
;;;174      pMain->xbuffer[1] = pMain->xbuffer[0] + cinfo->num_components;
00001c  6238              STR      r0,[r7,#0x20]
00001e  6a61              LDR      r1,[r4,#0x24]
;;;175    
;;;176      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
000020  2500              MOVS     r5,#0
000022  eb000081          ADD      r0,r0,r1,LSL #2       ;174
000026  6278              STR      r0,[r7,#0x24]
000028  f8d460d8          LDR      r6,[r4,#0xd8]
00002c  e01d              B        |L1.106|
                  |L1.46|
;;;177           ci++, compptr++) {
;;;178        rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
00002e  6a71              LDR      r1,[r6,#0x24]
000030  68f0              LDR      r0,[r6,#0xc]
000032  4348              MULS     r0,r1,r0
000034  f8d4113c          LDR      r1,[r4,#0x13c]
000038  fb90f8f1          SDIV     r8,r0,r1
;;;179          cinfo->min_DCT_scaled_size; /* height of a row group of component */
;;;180        /* Get space for pointer lists --- M+4 row groups in each list.
;;;181         * We alloc both pointer lists with one call to save a few cycles.
;;;182         */
;;;183        xbuf = (JSAMPARRAY)
00003c  6860              LDR      r0,[r4,#4]
00003e  f10a0104          ADD      r1,r10,#4
000042  fb08f901          MUL      r9,r8,r1
000046  6803              LDR      r3,[r0,#0]
000048  ea4f02c9          LSL      r2,r9,#3
00004c  2101              MOVS     r1,#1
00004e  4620              MOV      r0,r4
000050  4798              BLX      r3
;;;184          (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;185    				  2 * (rgroup * (M + 4)) * SIZEOF(JSAMPROW));
;;;186        xbuf += rgroup;		/* want one row group at negative offsets */
000052  eb000188          ADD      r1,r0,r8,LSL #2
;;;187        pMain->xbuffer[0][ci] = xbuf;
000056  6a38              LDR      r0,[r7,#0x20]
000058  f8401025          STR      r1,[r0,r5,LSL #2]
;;;188        xbuf += rgroup * (M + 4);
00005c  eb010089          ADD      r0,r1,r9,LSL #2
;;;189        pMain->xbuffer[1][ci] = xbuf;
000060  6a79              LDR      r1,[r7,#0x24]
000062  f8410025          STR      r0,[r1,r5,LSL #2]
000066  1c6d              ADDS     r5,r5,#1
000068  3654              ADDS     r6,r6,#0x54
                  |L1.106|
00006a  6a60              LDR      r0,[r4,#0x24]         ;176
00006c  42a8              CMP      r0,r5                 ;176
00006e  dcde              BGT      |L1.46|
;;;190      }
;;;191    }
000070  e8bd87f0          POP      {r4-r10,pc}
;;;192    
                          ENDP


                          AREA ||i.jinit_d_main_controller||, CODE, READONLY, ALIGN=2

                  jinit_d_main_controller PROC
;;;475    GLOBAL(void)
;;;476    jinit_d_main_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;477    {
000004  4604              MOV      r4,r0
;;;478      my_main_ptr pMain;
;;;479      int ci, rgroup, ngroups;
;;;480      jpeg_component_info *compptr;
;;;481    
;;;482      pMain = (my_main_ptr)
000006  6840              LDR      r0,[r0,#4]
000008  460d              MOV      r5,r1                 ;477
00000a  2238              MOVS     r2,#0x38
00000c  6803              LDR      r3,[r0,#0]
00000e  2101              MOVS     r1,#1
000010  4620              MOV      r0,r4
000012  4798              BLX      r3
;;;483        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;484    				SIZEOF(my_main_controller));
;;;485      cinfo->main = (struct jpeg_d_main_controller *) pMain;
;;;486      pMain->pub.start_pass = start_pass_main;
000014  4921              LDR      r1,|L2.156|
000016  f8c401a8          STR      r0,[r4,#0x1a8]
00001a  4607              MOV      r7,r0                 ;482
;;;487    
;;;488      if (need_full_buffer)		/* shouldn't happen */
00001c  6001              STR      r1,[r0,#0]
00001e  b135              CBZ      r5,|L2.46|
;;;489        ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
000020  6821              LDR      r1,[r4,#0]
000022  2004              MOVS     r0,#4
000024  6148              STR      r0,[r1,#0x14]
000026  6820              LDR      r0,[r4,#0]
000028  6801              LDR      r1,[r0,#0]
00002a  4620              MOV      r0,r4
00002c  4788              BLX      r1
                  |L2.46|
;;;490    
;;;491      /* Allocate the workspace.
;;;492       * ngroups is the number of row groups we need.
;;;493       */
;;;494      if (cinfo->upsample->need_context_rows) {
00002e  f8d401c4          LDR      r0,[r4,#0x1c4]
000032  6880              LDR      r0,[r0,#8]
000034  2800              CMP      r0,#0
000036  f8d4013c          LDR      r0,[r4,#0x13c]
00003a  d00e              BEQ      |L2.90|
;;;495        if (cinfo->min_DCT_scaled_size < 2) /* unsupported, see comments above */
00003c  2802              CMP      r0,#2
00003e  da06              BGE      |L2.78|
;;;496          ERREXIT(cinfo, JERR_NOTIMPL);
000040  6821              LDR      r1,[r4,#0]
000042  202f              MOVS     r0,#0x2f
000044  6148              STR      r0,[r1,#0x14]
000046  6820              LDR      r0,[r4,#0]
000048  6801              LDR      r1,[r0,#0]
00004a  4620              MOV      r0,r4
00004c  4788              BLX      r1
                  |L2.78|
;;;497        alloc_funny_pointers(cinfo); /* Alloc space for xbuffer[] lists */
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       alloc_funny_pointers
;;;498        ngroups = cinfo->min_DCT_scaled_size + 2;
000054  f8d4013c          LDR      r0,[r4,#0x13c]
000058  1c80              ADDS     r0,r0,#2
                  |L2.90|
;;;499      } else {
;;;500        ngroups = cinfo->min_DCT_scaled_size;
00005a  4680              MOV      r8,r0
;;;501      }
;;;502    
;;;503      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
00005c  2600              MOVS     r6,#0
00005e  f8d450d8          LDR      r5,[r4,#0xd8]
000062  e015              B        |L2.144|
                  |L2.100|
;;;504           ci++, compptr++) {
;;;505        rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
000064  68e9              LDR      r1,[r5,#0xc]
000066  6a68              LDR      r0,[r5,#0x24]
000068  f8d4213c          LDR      r2,[r4,#0x13c]
00006c  4341              MULS     r1,r0,r1
00006e  fb91f3f2          SDIV     r3,r1,r2
;;;506          cinfo->min_DCT_scaled_size; /* height of a row group of component */
;;;507        pMain->buffer[ci] = (*cinfo->mem->alloc_sarray)
000072  69ea              LDR      r2,[r5,#0x1c]
000074  fb03f308          MUL      r3,r3,r8
000078  4342              MULS     r2,r0,r2
00007a  6860              LDR      r0,[r4,#4]
00007c  2101              MOVS     r1,#1
00007e  f8d0c008          LDR      r12,[r0,#8]
000082  4620              MOV      r0,r4
000084  47e0              BLX      r12
000086  eb070186          ADD      r1,r7,r6,LSL #2
00008a  3554              ADDS     r5,r5,#0x54
00008c  1c76              ADDS     r6,r6,#1
00008e  6088              STR      r0,[r1,#8]
                  |L2.144|
000090  6a60              LDR      r0,[r4,#0x24]         ;503
000092  42b0              CMP      r0,r6                 ;503
000094  dce6              BGT      |L2.100|
;;;508    			((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;509    			 compptr->width_in_blocks * compptr->DCT_scaled_size,
;;;510    			 (JDIMENSION) (rgroup * ngroups));
;;;511      }
;;;512    }
000096  e8bd81f0          POP      {r4-r8,pc}
                          ENDP

00009a  0000              DCW      0x0000
                  |L2.156|
                          DCD      start_pass_main

                          AREA ||i.make_funny_pointers||, CODE, READONLY, ALIGN=2

                  make_funny_pointers PROC
;;;194    LOCAL(void)
;;;195    make_funny_pointers (j_decompress_ptr cinfo)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;196    /* Create the funny pointer lists discussed in the comments above.
;;;197     * The actual workspace is already allocated (in pMain->buffer),
;;;198     * and the space for the pointer lists is allocated too.
;;;199     * This routine just fills in the curiously ordered lists.
;;;200     * This will be repeated at the beginning of each pass.
;;;201     */
;;;202    {
;;;203      my_main_ptr pMain = (my_main_ptr) cinfo->main;
;;;204      int ci, i, rgroup;
;;;205      int M = cinfo->min_DCT_scaled_size;
;;;206      jpeg_component_info *compptr;
;;;207      JSAMPARRAY buf, xbuf0, xbuf1;
;;;208    
;;;209      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
000004  2200              MOVS     r2,#0
000006  f8d0a0d8          LDR      r10,[r0,#0xd8]        ;202
00000a  f8d091a8          LDR      r9,[r0,#0x1a8]        ;202
00000e  f8d0813c          LDR      r8,[r0,#0x13c]        ;202
000012  e043              B        |L3.156|
                  |L3.20|
;;;210           ci++, compptr++) {
;;;211        rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
000014  f8da3024          LDR      r3,[r10,#0x24]
000018  f8da100c          LDR      r1,[r10,#0xc]
;;;212          cinfo->min_DCT_scaled_size; /* height of a row group of component */
;;;213        xbuf0 = pMain->xbuffer[0][ci];
;;;214        xbuf1 = pMain->xbuffer[1][ci];
;;;215        /* First copy the workspace pointers as-is */
;;;216        buf = pMain->buffer[ci];
;;;217        for (i = 0; i < rgroup * (M + 2); i++) {
00001c  f1080702          ADD      r7,r8,#2
000020  4359              MULS     r1,r3,r1              ;211
000022  f8d0313c          LDR      r3,[r0,#0x13c]        ;211
000026  fb91f1f3          SDIV     r1,r1,r3              ;211
00002a  f8d93020          LDR      r3,[r9,#0x20]         ;213
00002e  fb01fc07          MUL      r12,r1,r7
000032  f8536022          LDR      r6,[r3,r2,LSL #2]     ;213
000036  f8d93024          LDR      r3,[r9,#0x24]         ;214
00003a  f8535022          LDR      r5,[r3,r2,LSL #2]     ;214
00003e  eb090382          ADD      r3,r9,r2,LSL #2       ;216
000042  689c              LDR      r4,[r3,#8]
000044  2300              MOVS     r3,#0
000046  e006              B        |L3.86|
                  |L3.72|
;;;218          xbuf0[i] = xbuf1[i] = buf[i];
000048  f8547023          LDR      r7,[r4,r3,LSL #2]
00004c  f8457023          STR      r7,[r5,r3,LSL #2]
000050  f8467023          STR      r7,[r6,r3,LSL #2]
000054  1c5b              ADDS     r3,r3,#1
                  |L3.86|
000056  459c              CMP      r12,r3                ;217
000058  dcf6              BGT      |L3.72|
;;;219        }
;;;220        /* In the second list, put the last four row groups in swapped order */
;;;221        for (i = 0; i < rgroup * 2; i++) {
00005a  2300              MOVS     r3,#0
;;;222          xbuf1[rgroup*(M-2) + i] = buf[rgroup*M + i];
00005c  f1a80e02          SUB      lr,r8,#2
000060  e00d              B        |L3.126|
000062  bf00              NOP      
                  |L3.100|
000064  fb013b08          MLA      r11,r1,r8,r3
000068  fb01370e          MLA      r7,r1,lr,r3
00006c  f854c02b          LDR      r12,[r4,r11,LSL #2]
000070  f845c027          STR      r12,[r5,r7,LSL #2]
;;;223          xbuf1[rgroup*M + i] = buf[rgroup*(M-2) + i];
000074  f854c027          LDR      r12,[r4,r7,LSL #2]
000078  f845c02b          STR      r12,[r5,r11,LSL #2]
00007c  1c5b              ADDS     r3,r3,#1
                  |L3.126|
00007e  ebb30f41          CMP      r3,r1,LSL #1          ;221
000082  dbef              BLT      |L3.100|
;;;224        }
;;;225        /* The wraparound pointers at top and bottom will be filled later
;;;226         * (see set_wraparound_pointers, below).  Initially we want the "above"
;;;227         * pointers to duplicate the first actual data line.  This only needs
;;;228         * to happen in xbuffer[0].
;;;229         */
;;;230        for (i = 0; i < rgroup; i++) {
000084  2300              MOVS     r3,#0
000086  e004              B        |L3.146|
                  |L3.136|
;;;231          xbuf0[i - rgroup] = xbuf0[0];
000088  1a5d              SUBS     r5,r3,r1
00008a  6834              LDR      r4,[r6,#0]
00008c  f8464025          STR      r4,[r6,r5,LSL #2]
000090  1c5b              ADDS     r3,r3,#1
                  |L3.146|
000092  428b              CMP      r3,r1                 ;230
000094  dbf8              BLT      |L3.136|
000096  f10a0a54          ADD      r10,r10,#0x54         ;210
00009a  1c52              ADDS     r2,r2,#1              ;210
                  |L3.156|
00009c  6a41              LDR      r1,[r0,#0x24]         ;209
00009e  4291              CMP      r1,r2                 ;209
0000a0  dcb8              BGT      |L3.20|
;;;232        }
;;;233      }
;;;234    }
0000a2  e8bd8ff0          POP      {r4-r11,pc}
;;;235    
                          ENDP


                          AREA ||i.process_data_context_main||, CODE, READONLY, ALIGN=2

                  process_data_context_main PROC
;;;384    METHODDEF(void)
;;;385    process_data_context_main (j_decompress_ptr cinfo,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;386    			   JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;387    			   JDIMENSION out_rows_avail)
;;;388    {
;;;389      my_main_ptr pMain = (my_main_ptr) cinfo->main;
;;;390    
;;;391      /* Read input data if we haven't filled the main buffer yet */
;;;392      if (! pMain->buffer_full) {
000004  f8d041a8          LDR      r4,[r0,#0x1a8]
000008  4605              MOV      r5,r0                 ;388
00000a  b083              SUB      sp,sp,#0xc            ;388
00000c  69a0              LDR      r0,[r4,#0x18]         ;388
00000e  469a              MOV      r10,r3                ;388
000010  4693              MOV      r11,r2                ;388
000012  b978              CBNZ     r0,|L4.52|
;;;393        if (! (*cinfo->coef->decompress_data) (cinfo,
000014  6aa0              LDR      r0,[r4,#0x28]
000016  eb040080          ADD      r0,r4,r0,LSL #2
00001a  6a01              LDR      r1,[r0,#0x20]
00001c  f8d501ac          LDR      r0,[r5,#0x1ac]
000020  68c2              LDR      r2,[r0,#0xc]
000022  4628              MOV      r0,r5
000024  4790              BLX      r2
000026  2800              CMP      r0,#0
000028  d07e              BEQ      |L4.296|
;;;394    					   pMain->xbuffer[pMain->whichptr]))
;;;395          return;			/* suspension forced, can do nothing more */
;;;396        pMain->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
00002a  2001              MOVS     r0,#1
;;;397        pMain->iMCU_row_ctr++;	/* count rows received */
00002c  61a0              STR      r0,[r4,#0x18]
00002e  6b60              LDR      r0,[r4,#0x34]
000030  1c40              ADDS     r0,r0,#1
000032  6360              STR      r0,[r4,#0x34]
                  |L4.52|
;;;398      }
;;;399    
;;;400      /* Postprocessor typically will not swallow all the input data it is handed
;;;401       * in one call (due to filling the output buffer first).  Must be prepared
;;;402       * to exit and restart.  This switch lets us keep track of how far we got.
;;;403       * Note that each case falls through to the next on successful completion.
;;;404       */
;;;405      switch (pMain->context_state) {
000034  6ae0              LDR      r0,[r4,#0x2c]
000036  b1f0              CBZ      r0,|L4.118|
000038  2801              CMP      r0,#1
00003a  d05e              BEQ      |L4.250|
00003c  2802              CMP      r0,#2
00003e  d173              BNE      |L4.296|
;;;406      case CTX_POSTPONED_ROW:
;;;407        /* Call postprocessor using previously set pointers for postponed row */
;;;408        (*cinfo->post->post_process_data) (cinfo, pMain->xbuffer[pMain->whichptr],
000040  9a04              LDR      r2,[sp,#0x10]
000042  e9cd2b00          STRD     r2,r11,[sp,#0]
000046  f8cda008          STR      r10,[sp,#8]
00004a  6aa0              LDR      r0,[r4,#0x28]
00004c  6b23              LDR      r3,[r4,#0x30]
00004e  eb040080          ADD      r0,r4,r0,LSL #2
000052  f104021c          ADD      r2,r4,#0x1c
000056  6a01              LDR      r1,[r0,#0x20]
000058  f8d501b0          LDR      r0,[r5,#0x1b0]
00005c  6846              LDR      r6,[r0,#4]
00005e  4628              MOV      r0,r5
000060  47b0              BLX      r6
;;;409    			&pMain->rowgroup_ctr, pMain->rowgroups_avail,
;;;410    			output_buf, out_row_ctr, out_rows_avail);
;;;411        if (pMain->rowgroup_ctr < pMain->rowgroups_avail)
000062  6b21              LDR      r1,[r4,#0x30]
000064  69e0              LDR      r0,[r4,#0x1c]
000066  4288              CMP      r0,r1
000068  d35e              BCC      |L4.296|
;;;412          return;			/* Need to suspend */
;;;413        pMain->context_state = CTX_PREPARE_FOR_IMCU;
00006a  2000              MOVS     r0,#0
;;;414        if (*out_row_ctr >= out_rows_avail)
00006c  62e0              STR      r0,[r4,#0x2c]
00006e  f8db1000          LDR      r1,[r11,#0]
000072  4551              CMP      r1,r10
000074  d258              BCS      |L4.296|
                  |L4.118|
;;;415          return;			/* Postprocessor exactly filled output buf */
;;;416        /*FALLTHROUGH*/
;;;417      case CTX_PREPARE_FOR_IMCU:
;;;418        /* Prepare to process first M-1 row groups of this iMCU row */
;;;419        pMain->rowgroup_ctr = 0;
000076  2000              MOVS     r0,#0
;;;420        pMain->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_scaled_size - 1);
000078  61e0              STR      r0,[r4,#0x1c]
00007a  f8d5013c          LDR      r0,[r5,#0x13c]
00007e  1e40              SUBS     r0,r0,#1
;;;421        /* Check for bottom of image: if so, tweak pointers to "duplicate"
;;;422         * the last sample row, and adjust rowgroups_avail to ignore padding rows.
;;;423         */
;;;424        if (pMain->iMCU_row_ctr == cinfo->total_iMCU_rows)
000080  6320              STR      r0,[r4,#0x30]
000082  6b60              LDR      r0,[r4,#0x34]
000084  f8d51140          LDR      r1,[r5,#0x140]
000088  4288              CMP      r0,r1
00008a  d134              BNE      |L4.246|
00008c  2100              MOVS     r1,#0
;;;425          set_bottom_pointers(cinfo);
00008e  f8d591a8          LDR      r9,[r5,#0x1a8]
000092  f8d520d8          LDR      r2,[r5,#0xd8]
000096  e02b              B        |L4.240|
                  |L4.152|
000098  68d3              LDR      r3,[r2,#0xc]
00009a  6a50              LDR      r0,[r2,#0x24]
00009c  4343              MULS     r3,r0,r3
00009e  f8d5013c          LDR      r0,[r5,#0x13c]
0000a2  fb93f6f0          SDIV     r6,r3,r0
0000a6  6ad0              LDR      r0,[r2,#0x2c]
0000a8  fbb0f7f3          UDIV     r7,r0,r3
0000ac  fb030017          MLS      r0,r3,r7,r0
0000b0  b900              CBNZ     r0,|L4.180|
0000b2  4618              MOV      r0,r3
                  |L4.180|
0000b4  b929              CBNZ     r1,|L4.194|
0000b6  1e43              SUBS     r3,r0,#1
0000b8  fb93f3f6          SDIV     r3,r3,r6
0000bc  1c5b              ADDS     r3,r3,#1
0000be  f8c93030          STR      r3,[r9,#0x30]
                  |L4.194|
0000c2  f8d97028          LDR      r7,[r9,#0x28]
0000c6  eb090387          ADD      r3,r9,r7,LSL #2
0000ca  6a1b              LDR      r3,[r3,#0x20]
0000cc  f8537021          LDR      r7,[r3,r1,LSL #2]
0000d0  2300              MOVS     r3,#0
0000d2  eb070e80          ADD      lr,r7,r0,LSL #2
0000d6  e006              B        |L4.230|
                  |L4.216|
0000d8  eb000803          ADD      r8,r0,r3
0000dc  f85ecc04          LDR      r12,[lr,#-4]
0000e0  f847c028          STR      r12,[r7,r8,LSL #2]
0000e4  1c5b              ADDS     r3,r3,#1
                  |L4.230|
0000e6  ebb30f46          CMP      r3,r6,LSL #1
0000ea  dbf5              BLT      |L4.216|
0000ec  1c49              ADDS     r1,r1,#1
0000ee  3254              ADDS     r2,r2,#0x54
                  |L4.240|
0000f0  6a68              LDR      r0,[r5,#0x24]
0000f2  4288              CMP      r0,r1
0000f4  dcd0              BGT      |L4.152|
                  |L4.246|
;;;426        pMain->context_state = CTX_PROCESS_IMCU;
0000f6  2001              MOVS     r0,#1
0000f8  62e0              STR      r0,[r4,#0x2c]
                  |L4.250|
;;;427        /*FALLTHROUGH*/
;;;428      case CTX_PROCESS_IMCU:
;;;429        /* Call postprocessor using previously set pointers */
;;;430        (*cinfo->post->post_process_data) (cinfo, pMain->xbuffer[pMain->whichptr],
0000fa  9a04              LDR      r2,[sp,#0x10]
0000fc  e9cd2b00          STRD     r2,r11,[sp,#0]
000100  f8cda008          STR      r10,[sp,#8]
000104  6aa0              LDR      r0,[r4,#0x28]
000106  6b23              LDR      r3,[r4,#0x30]
000108  eb040080          ADD      r0,r4,r0,LSL #2
00010c  f104021c          ADD      r2,r4,#0x1c
000110  6a01              LDR      r1,[r0,#0x20]
000112  f8d501b0          LDR      r0,[r5,#0x1b0]
000116  6846              LDR      r6,[r0,#4]
000118  4628              MOV      r0,r5
00011a  47b0              BLX      r6
;;;431    			&pMain->rowgroup_ctr, pMain->rowgroups_avail,
;;;432    			output_buf, out_row_ctr, out_rows_avail);
;;;433        if (pMain->rowgroup_ctr < pMain->rowgroups_avail)
00011c  6b21              LDR      r1,[r4,#0x30]
00011e  69e0              LDR      r0,[r4,#0x1c]
000120  4288              CMP      r0,r1
000122  d354              BCC      |L4.462|
;;;434          return;			/* Need to suspend */
;;;435        /* After the first iMCU, change wraparound pointers to normal state */
;;;436        if (pMain->iMCU_row_ctr == 1)
000124  6b60              LDR      r0,[r4,#0x34]
000126  e000              B        |L4.298|
                  |L4.296|
000128  e051              B        |L4.462|
                  |L4.298|
00012a  2801              CMP      r0,#1
00012c  d13f              BNE      |L4.430|
00012e  2100              MOVS     r1,#0
;;;437          set_wraparound_pointers(cinfo);
000130  f8d5a1a8          LDR      r10,[r5,#0x1a8]
000134  f8d5913c          LDR      r9,[r5,#0x13c]
000138  f8d580d8          LDR      r8,[r5,#0xd8]
00013c  e034              B        |L4.424|
00013e  bf00              NOP      
                  |L4.320|
000140  f8d82024          LDR      r2,[r8,#0x24]
000144  f8d8000c          LDR      r0,[r8,#0xc]
000148  f1090702          ADD      r7,r9,#2
00014c  4350              MULS     r0,r2,r0
00014e  f8d5213c          LDR      r2,[r5,#0x13c]
000152  f1090e01          ADD      lr,r9,#1
000156  fb90f2f2          SDIV     r2,r0,r2
00015a  f8da0020          LDR      r0,[r10,#0x20]
00015e  f8506021          LDR      r6,[r0,r1,LSL #2]
000162  f8da0024          LDR      r0,[r10,#0x24]
000166  f8503021          LDR      r3,[r0,r1,LSL #2]
00016a  2000              MOVS     r0,#0
00016c  9700              STR      r7,[sp,#0]
00016e  e016              B        |L4.414|
                  |L4.368|
000170  fb020b0e          MLA      r11,r2,lr,r0
000174  1a87              SUBS     r7,r0,r2
000176  f856c02b          LDR      r12,[r6,r11,LSL #2]
00017a  f846c027          STR      r12,[r6,r7,LSL #2]
00017e  f853c02b          LDR      r12,[r3,r11,LSL #2]
000182  f843c027          STR      r12,[r3,r7,LSL #2]
000186  9f00              LDR      r7,[sp,#0]
000188  f856c020          LDR      r12,[r6,r0,LSL #2]
00018c  fb020707          MLA      r7,r2,r7,r0
000190  f846c027          STR      r12,[r6,r7,LSL #2]
000194  f853c020          LDR      r12,[r3,r0,LSL #2]
000198  f843c027          STR      r12,[r3,r7,LSL #2]
00019c  1c40              ADDS     r0,r0,#1
                  |L4.414|
00019e  4290              CMP      r0,r2
0001a0  dbe6              BLT      |L4.368|
0001a2  1c49              ADDS     r1,r1,#1
0001a4  f1080854          ADD      r8,r8,#0x54
                  |L4.424|
0001a8  6a68              LDR      r0,[r5,#0x24]
0001aa  4288              CMP      r0,r1
0001ac  dcc8              BGT      |L4.320|
                  |L4.430|
;;;438        /* Prepare to load new iMCU row using other xbuffer list */
;;;439        pMain->whichptr ^= 1;	/* 0=>1 or 1=>0 */
0001ae  6aa0              LDR      r0,[r4,#0x28]
0001b0  f0800001          EOR      r0,r0,#1
;;;440        pMain->buffer_full = FALSE;
0001b4  62a0              STR      r0,[r4,#0x28]
0001b6  2000              MOVS     r0,#0
;;;441        /* Still need to process last row group of this iMCU row, */
;;;442        /* which is saved at index M+1 of the other xbuffer */
;;;443        pMain->rowgroup_ctr = (JDIMENSION) (cinfo->min_DCT_scaled_size + 1);
0001b8  61a0              STR      r0,[r4,#0x18]
0001ba  f8d5013c          LDR      r0,[r5,#0x13c]
0001be  1c40              ADDS     r0,r0,#1
;;;444        pMain->rowgroups_avail = (JDIMENSION) (cinfo->min_DCT_scaled_size + 2);
0001c0  61e0              STR      r0,[r4,#0x1c]
0001c2  f8d5013c          LDR      r0,[r5,#0x13c]
0001c6  1c80              ADDS     r0,r0,#2
;;;445        pMain->context_state = CTX_POSTPONED_ROW;
0001c8  6320              STR      r0,[r4,#0x30]
0001ca  2002              MOVS     r0,#2
0001cc  62e0              STR      r0,[r4,#0x2c]
                  |L4.462|
;;;446      }
;;;447    }
0001ce  b007              ADD      sp,sp,#0x1c
0001d0  e8bd8ff0          POP      {r4-r11,pc}
;;;448    
                          ENDP


                          AREA ||i.process_data_crank_post||, CODE, READONLY, ALIGN=1

                  process_data_crank_post PROC
;;;458    METHODDEF(void)
;;;459    process_data_crank_post (j_decompress_ptr cinfo,
000000  b53e              PUSH     {r1-r5,lr}
;;;460    			 JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;461    			 JDIMENSION out_rows_avail)
;;;462    {
000002  e88d000e          STM      sp,{r1-r3}
;;;463      (*cinfo->post->post_process_data) (cinfo, (JSAMPIMAGE) NULL,
000006  f8d011b0          LDR      r1,[r0,#0x1b0]
00000a  2300              MOVS     r3,#0
00000c  461a              MOV      r2,r3
00000e  684c              LDR      r4,[r1,#4]
000010  4619              MOV      r1,r3
000012  47a0              BLX      r4
;;;464    				     (JDIMENSION *) NULL, (JDIMENSION) 0,
;;;465    				     output_buf, out_row_ctr, out_rows_avail);
;;;466    }
000014  bd3e              POP      {r1-r5,pc}
;;;467    
                          ENDP


                          AREA ||i.process_data_simple_main||, CODE, READONLY, ALIGN=1

                  process_data_simple_main PROC
;;;344    METHODDEF(void)
;;;345    process_data_simple_main (j_decompress_ptr cinfo,
000000  e92d43fe          PUSH     {r1-r9,lr}
;;;346    			  JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;347    			  JDIMENSION out_rows_avail)
;;;348    {
;;;349      my_main_ptr pMain = (my_main_ptr) cinfo->main;
;;;350      JDIMENSION rowgroups_avail;
;;;351    
;;;352      /* Read input data if we haven't filled the main buffer yet */
;;;353      if (! pMain->buffer_full) {
000004  f8d041a8          LDR      r4,[r0,#0x1a8]
000008  4605              MOV      r5,r0                 ;348
00000a  461f              MOV      r7,r3                 ;348
00000c  69a0              LDR      r0,[r4,#0x18]         ;348
00000e  4690              MOV      r8,r2                 ;348
000010  4689              MOV      r9,r1                 ;348
000012  b950              CBNZ     r0,|L6.42|
;;;354        if (! (*cinfo->coef->decompress_data) (cinfo, pMain->buffer))
000014  f8d501ac          LDR      r0,[r5,#0x1ac]
000018  f1040108          ADD      r1,r4,#8
00001c  68c2              LDR      r2,[r0,#0xc]
00001e  4628              MOV      r0,r5
000020  4790              BLX      r2
000022  2800              CMP      r0,#0
000024  d017              BEQ      |L6.86|
;;;355          return;			/* suspension forced, can do nothing more */
;;;356        pMain->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
000026  2001              MOVS     r0,#1
000028  61a0              STR      r0,[r4,#0x18]
                  |L6.42|
;;;357      }
;;;358    
;;;359      /* There are always min_DCT_scaled_size row groups in an iMCU row. */
;;;360      rowgroups_avail = (JDIMENSION) cinfo->min_DCT_scaled_size;
;;;361      /* Note: at the bottom of the image, we may pass extra garbage row groups
;;;362       * to the postprocessor.  The postprocessor has to check for bottom
;;;363       * of image anyway (at row resolution), so no point in us doing it too.
;;;364       */
;;;365    
;;;366      /* Feed the postprocessor */
;;;367      (*cinfo->post->post_process_data) (cinfo, pMain->buffer,
00002a  f8d5613c          LDR      r6,[r5,#0x13c]
00002e  f8cd9000          STR      r9,[sp,#0]
000032  e9cd8701          STRD     r8,r7,[sp,#4]
000036  f8d501b0          LDR      r0,[r5,#0x1b0]
00003a  4633              MOV      r3,r6
00003c  f104021c          ADD      r2,r4,#0x1c
000040  6847              LDR      r7,[r0,#4]
000042  f1040108          ADD      r1,r4,#8
000046  4628              MOV      r0,r5
000048  47b8              BLX      r7
;;;368    				     &pMain->rowgroup_ctr, rowgroups_avail,
;;;369    				     output_buf, out_row_ctr, out_rows_avail);
;;;370    
;;;371      /* Has postprocessor consumed all the data yet? If so, mark buffer empty */
;;;372      if (pMain->rowgroup_ctr >= rowgroups_avail) {
00004a  69e0              LDR      r0,[r4,#0x1c]
00004c  42b0              CMP      r0,r6
00004e  d302              BCC      |L6.86|
;;;373        pMain->buffer_full = FALSE;
000050  2000              MOVS     r0,#0
;;;374        pMain->rowgroup_ctr = 0;
000052  61a0              STR      r0,[r4,#0x18]
000054  61e0              STR      r0,[r4,#0x1c]
                  |L6.86|
;;;375      }
;;;376    }
000056  e8bd83fe          POP      {r1-r9,pc}
;;;377    
                          ENDP


                          AREA ||i.start_pass_main||, CODE, READONLY, ALIGN=2

                  start_pass_main PROC
;;;306    METHODDEF(void)
;;;307    start_pass_main (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
000000  b570              PUSH     {r4-r6,lr}
;;;308    {
000002  f8d041a8          LDR      r4,[r0,#0x1a8]
000006  b149              CBZ      r1,|L7.28|
;;;309      my_main_ptr pMain = (my_main_ptr) cinfo->main;
;;;310    
;;;311      switch (pass_mode) {
000008  2902              CMP      r1,#2
00000a  d019              BEQ      |L7.64|
;;;312      case JBUF_PASS_THRU:
;;;313        if (cinfo->upsample->need_context_rows) {
;;;314          pMain->pub.process_data = process_data_context_main;
;;;315          make_funny_pointers(cinfo); /* Create the xbuffer[] lists */
;;;316          pMain->whichptr = 0;	/* Read first iMCU row into xbuffer[0] */
;;;317          pMain->context_state = CTX_PREPARE_FOR_IMCU;
;;;318          pMain->iMCU_row_ctr = 0;
;;;319        } else {
;;;320          /* Simple case with no context needed */
;;;321          pMain->pub.process_data = process_data_simple_main;
;;;322        }
;;;323        pMain->buffer_full = FALSE;	/* Mark buffer empty */
;;;324        pMain->rowgroup_ctr = 0;
;;;325        break;
;;;326    #ifdef QUANT_2PASS_SUPPORTED
;;;327      case JBUF_CRANK_DEST:
;;;328        /* For last pass of 2-pass quantization, just crank the postprocessor */
;;;329        pMain->pub.process_data = process_data_crank_post;
;;;330        break;
;;;331    #endif
;;;332      default:
;;;333        ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
00000c  6802              LDR      r2,[r0,#0]
00000e  2104              MOVS     r1,#4
000010  6151              STR      r1,[r2,#0x14]
000012  6801              LDR      r1,[r0,#0]
000014  6809              LDR      r1,[r1,#0]
000016  e8bd4070          POP      {r4-r6,lr}
00001a  4708              BX       r1
                  |L7.28|
00001c  f8d011c4          LDR      r1,[r0,#0x1c4]        ;313
000020  2500              MOVS     r5,#0                 ;313
000022  6889              LDR      r1,[r1,#8]            ;313
000024  b139              CBZ      r1,|L7.54|
000026  4908              LDR      r1,|L7.72|
000028  6061              STR      r1,[r4,#4]            ;315
00002a  f7fffffe          BL       make_funny_pointers
00002e  62a5              STR      r5,[r4,#0x28]         ;317
000030  62e5              STR      r5,[r4,#0x2c]         ;318
000032  6365              STR      r5,[r4,#0x34]         ;318
000034  e001              B        |L7.58|
                  |L7.54|
000036  4805              LDR      r0,|L7.76|
000038  6060              STR      r0,[r4,#4]            ;321
                  |L7.58|
00003a  61a5              STR      r5,[r4,#0x18]         ;324
00003c  61e5              STR      r5,[r4,#0x1c]         ;325
;;;334        break;
;;;335      }
;;;336    }
00003e  bd70              POP      {r4-r6,pc}
                  |L7.64|
000040  4803              LDR      r0,|L7.80|
000042  6060              STR      r0,[r4,#4]            ;329
000044  bd70              POP      {r4-r6,pc}
;;;337    
                          ENDP

000046  0000              DCW      0x0000
                  |L7.72|
                          DCD      process_data_context_main
                  |L7.76|
                          DCD      process_data_simple_main
                  |L7.80|
                          DCD      process_data_crank_post
