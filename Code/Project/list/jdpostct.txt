; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\jdpostct.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jdpostct.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\JPEG\jdpostct.c]
                          THUMB

                          AREA ||i.jinit_d_post_controller||, CODE, READONLY, ALIGN=2

                  jinit_d_post_controller PROC
;;;254    GLOBAL(void)
;;;255    jinit_d_post_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
000000  b57c              PUSH     {r2-r6,lr}
;;;256    {
000002  4604              MOV      r4,r0
;;;257      my_post_ptr post;
;;;258    
;;;259      post = (my_post_ptr)
000004  6840              LDR      r0,[r0,#4]
000006  460e              MOV      r6,r1                 ;256
000008  221c              MOVS     r2,#0x1c
00000a  6803              LDR      r3,[r0,#0]
00000c  2101              MOVS     r1,#1
00000e  4620              MOV      r0,r4
000010  4798              BLX      r3
;;;260        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;261    				SIZEOF(my_post_controller));
;;;262      cinfo->post = (struct jpeg_d_post_controller *) post;
;;;263      post->pub.start_pass = start_pass_dpost;
000012  4915              LDR      r1,|L1.104|
000014  f8c401b0          STR      r0,[r4,#0x1b0]
;;;264      post->whole_image = NULL;	/* flag for no virtual arrays */
000018  6001              STR      r1,[r0,#0]
00001a  2100              MOVS     r1,#0
;;;265      post->buffer = NULL;		/* flag for no strip buffer */
00001c  6081              STR      r1,[r0,#8]
00001e  4605              MOV      r5,r0                 ;259
;;;266    
;;;267      /* Create the quantization buffer, if needed */
;;;268      if (cinfo->quantize_colors) {
000020  60c1              STR      r1,[r0,#0xc]
000022  6d60              LDR      r0,[r4,#0x54]
000024  2800              CMP      r0,#0
000026  d013              BEQ      |L1.80|
;;;269        /* The buffer strip height is max_v_samp_factor, which is typically
;;;270         * an efficient number of rows for upsampling to return.
;;;271         * (In the presence of output rescaling, we might want to be smarter?)
;;;272         */
;;;273        post->strip_height = (JDIMENSION) cinfo->max_v_samp_factor;
000028  f8d41138          LDR      r1,[r4,#0x138]
;;;274        if (need_full_buffer) {
00002c  6129              STR      r1,[r5,#0x10]
00002e  b186              CBZ      r6,|L1.82|
;;;275          /* Two-pass color quantization: need full-image storage. */
;;;276          /* We round up the number of rows to a multiple of the strip height. */
;;;277    #ifdef QUANT_2PASS_SUPPORTED
;;;278          post->whole_image = (*cinfo->mem->request_virt_sarray)
000030  6f60              LDR      r0,[r4,#0x74]
000032  f7fffffe          BL       jround_up
000036  6929              LDR      r1,[r5,#0x10]
000038  2200              MOVS     r2,#0
00003a  e9cd0100          STRD     r0,r1,[sp,#0]
00003e  6f23              LDR      r3,[r4,#0x70]
000040  6fa0              LDR      r0,[r4,#0x78]
000042  4343              MULS     r3,r0,r3
000044  6860              LDR      r0,[r4,#4]
000046  2101              MOVS     r1,#1
000048  6906              LDR      r6,[r0,#0x10]
00004a  4620              MOV      r0,r4
00004c  47b0              BLX      r6
00004e  60a8              STR      r0,[r5,#8]
                  |L1.80|
;;;279    	((j_common_ptr) cinfo, JPOOL_IMAGE, FALSE,
;;;280    	 cinfo->output_width * cinfo->out_color_components,
;;;281    	 (JDIMENSION) jround_up((long) cinfo->output_height,
;;;282    				(long) post->strip_height),
;;;283    	 post->strip_height);
;;;284    #else
;;;285          ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
;;;286    #endif /* QUANT_2PASS_SUPPORTED */
;;;287        } else {
;;;288          /* One-pass color quantization: just make a strip buffer. */
;;;289          post->buffer = (*cinfo->mem->alloc_sarray)
;;;290    	((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;291    	 cinfo->output_width * cinfo->out_color_components,
;;;292    	 post->strip_height);
;;;293        }
;;;294      }
;;;295    }
000050  bd7c              POP      {r2-r6,pc}
                  |L1.82|
000052  6f22              LDR      r2,[r4,#0x70]         ;289
000054  6fa0              LDR      r0,[r4,#0x78]         ;289
000056  460b              MOV      r3,r1                 ;289
000058  4342              MULS     r2,r0,r2              ;289
00005a  6860              LDR      r0,[r4,#4]            ;289
00005c  2101              MOVS     r1,#1                 ;289
00005e  6886              LDR      r6,[r0,#8]            ;289
000060  4620              MOV      r0,r4                 ;289
000062  47b0              BLX      r6                    ;289
000064  60e8              STR      r0,[r5,#0xc]          ;289
000066  bd7c              POP      {r2-r6,pc}
                          ENDP

                  |L1.104|
                          DCD      start_pass_dpost

                          AREA ||i.post_process_1pass||, CODE, READONLY, ALIGN=1

                  post_process_1pass PROC
;;;125    METHODDEF(void)
;;;126    post_process_1pass (j_decompress_ptr cinfo,
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;127    		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
;;;128    		    JDIMENSION in_row_groups_avail,
;;;129    		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;130    		    JDIMENSION out_rows_avail)
;;;131    {
000004  4606              MOV      r6,r0
000006  e9dd500b          LDRD     r5,r0,[sp,#0x2c]
;;;132      my_post_ptr post = (my_post_ptr) cinfo->post;
;;;133      JDIMENSION num_rows, max_rows;
;;;134    
;;;135      /* Fill the buffer, but not more than what we can dump out in one go. */
;;;136      /* Note we rely on the upsampler to detect bottom of image. */
;;;137      max_rows = out_rows_avail - *out_row_ctr;
00000a  f8d641b0          LDR      r4,[r6,#0x1b0]
00000e  682f              LDR      r7,[r5,#0]
000010  f8dd8028          LDR      r8,[sp,#0x28]         ;132
000014  1bc0              SUBS     r0,r0,r7
;;;138      if (max_rows > post->strip_height)
000016  6927              LDR      r7,[r4,#0x10]
000018  4287              CMP      r7,r0
00001a  d200              BCS      |L2.30|
00001c  4638              MOV      r0,r7                 ;131
                  |L2.30|
;;;139        max_rows = post->strip_height;
;;;140      num_rows = 0;
00001e  2700              MOVS     r7,#0
;;;141      (*cinfo->upsample->upsample) (cinfo,
000020  9703              STR      r7,[sp,#0xc]
000022  68e7              LDR      r7,[r4,#0xc]
000024  f10d0c0c          ADD      r12,sp,#0xc
000028  9700              STR      r7,[sp,#0]
00002a  e9cdc001          STRD     r12,r0,[sp,#4]
00002e  f8d601c4          LDR      r0,[r6,#0x1c4]
000032  6847              LDR      r7,[r0,#4]
000034  4630              MOV      r0,r6
000036  47b8              BLX      r7
;;;142    		input_buf, in_row_group_ctr, in_row_groups_avail,
;;;143    		post->buffer, &num_rows, max_rows);
;;;144      /* Quantize and emit data. */
;;;145      (*cinfo->cquantize->color_quantize) (cinfo,
000038  6829              LDR      r1,[r5,#0]
00003a  f8d601cc          LDR      r0,[r6,#0x1cc]
00003e  eb080281          ADD      r2,r8,r1,LSL #2
000042  68e1              LDR      r1,[r4,#0xc]
000044  6844              LDR      r4,[r0,#4]
000046  4630              MOV      r0,r6
000048  9b03              LDR      r3,[sp,#0xc]
00004a  47a0              BLX      r4
;;;146    		post->buffer, output_buf + *out_row_ctr, (int) num_rows);
;;;147      *out_row_ctr += num_rows;
00004c  6828              LDR      r0,[r5,#0]
00004e  9903              LDR      r1,[sp,#0xc]
000050  4408              ADD      r0,r0,r1
000052  6028              STR      r0,[r5,#0]
;;;148    }
000054  e8bd81ff          POP      {r0-r8,pc}
;;;149    
                          ENDP


                          AREA ||i.post_process_2pass||, CODE, READONLY, ALIGN=1

                  post_process_2pass PROC
;;;203    METHODDEF(void)
;;;204    post_process_2pass (j_decompress_ptr cinfo,
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;205    		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
;;;206    		    JDIMENSION in_row_groups_avail,
;;;207    		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;208    		    JDIMENSION out_rows_avail)
;;;209    {
;;;210      my_post_ptr post = (my_post_ptr) cinfo->post;
;;;211      JDIMENSION num_rows, max_rows;
;;;212    
;;;213      GUI_USE_PARA(in_row_groups_avail);
;;;214      GUI_USE_PARA(in_row_group_ctr);
;;;215      GUI_USE_PARA(input_buf);
;;;216      /* Reposition virtual buffer if at start of strip. */
;;;217      if (post->next_row == 0) {
000004  f8d041b0          LDR      r4,[r0,#0x1b0]
000008  4606              MOV      r6,r0                 ;209
00000a  e9dd790b          LDRD     r7,r9,[sp,#0x2c]      ;209
00000e  f8dda028          LDR      r10,[sp,#0x28]        ;210
000012  69a0              LDR      r0,[r4,#0x18]         ;209
000014  f04f0800          MOV      r8,#0
000018  b948              CBNZ     r0,|L3.46|
;;;218        post->buffer = (*cinfo->mem->access_virt_sarray)
00001a  f8cd8000          STR      r8,[sp,#0]
00001e  6870              LDR      r0,[r6,#4]
000020  e9d43204          LDRD     r3,r2,[r4,#0x10]
000024  69c5              LDR      r5,[r0,#0x1c]
000026  68a1              LDR      r1,[r4,#8]
000028  4630              MOV      r0,r6
00002a  47a8              BLX      r5
00002c  60e0              STR      r0,[r4,#0xc]
                  |L3.46|
;;;219    	((j_common_ptr) cinfo, post->whole_image,
;;;220    	 post->starting_row, post->strip_height, FALSE);
;;;221      }
;;;222    
;;;223      /* Determine number of rows to emit. */
;;;224      num_rows = post->strip_height - post->next_row; /* available in strip */
00002e  69a1              LDR      r1,[r4,#0x18]
000030  6920              LDR      r0,[r4,#0x10]
;;;225      max_rows = out_rows_avail - *out_row_ctr; /* available in output area */
000032  683a              LDR      r2,[r7,#0]
000034  1a45              SUBS     r5,r0,r1              ;224
000036  eba90002          SUB      r0,r9,r2
;;;226      if (num_rows > max_rows)
00003a  4285              CMP      r5,r0
00003c  d900              BLS      |L3.64|
;;;227        num_rows = max_rows;
00003e  4605              MOV      r5,r0
                  |L3.64|
;;;228      /* We have to check bottom of image here, can't depend on upsampler. */
;;;229      max_rows = cinfo->output_height - post->starting_row;
000040  6f70              LDR      r0,[r6,#0x74]
000042  6963              LDR      r3,[r4,#0x14]
000044  1ac0              SUBS     r0,r0,r3
;;;230      if (num_rows > max_rows)
000046  4285              CMP      r5,r0
000048  d900              BLS      |L3.76|
;;;231        num_rows = max_rows;
00004a  4605              MOV      r5,r0
                  |L3.76|
;;;232    
;;;233      /* Quantize and emit data. */
;;;234      (*cinfo->cquantize->color_quantize) (cinfo,
00004c  68e0              LDR      r0,[r4,#0xc]
00004e  eb0a0282          ADD      r2,r10,r2,LSL #2
000052  eb000181          ADD      r1,r0,r1,LSL #2
000056  f8d601cc          LDR      r0,[r6,#0x1cc]
00005a  462b              MOV      r3,r5
00005c  f8d0c004          LDR      r12,[r0,#4]
000060  4630              MOV      r0,r6
000062  47e0              BLX      r12
;;;235    		post->buffer + post->next_row, output_buf + *out_row_ctr,
;;;236    		(int) num_rows);
;;;237      *out_row_ctr += num_rows;
000064  6838              LDR      r0,[r7,#0]
000066  4428              ADD      r0,r0,r5
;;;238    
;;;239      /* Advance if we filled the strip. */
;;;240      post->next_row += num_rows;
000068  6038              STR      r0,[r7,#0]
00006a  69a0              LDR      r0,[r4,#0x18]
00006c  1941              ADDS     r1,r0,r5
;;;241      if (post->next_row >= post->strip_height) {
00006e  61a1              STR      r1,[r4,#0x18]
000070  6920              LDR      r0,[r4,#0x10]
000072  4281              CMP      r1,r0
000074  d303              BCC      |L3.126|
;;;242        post->starting_row += post->strip_height;
000076  6961              LDR      r1,[r4,#0x14]
000078  4408              ADD      r0,r0,r1
00007a  e9c40805          STRD     r0,r8,[r4,#0x14]
                  |L3.126|
;;;243        post->next_row = 0;
;;;244      }
;;;245    }
00007e  e8bd8ff8          POP      {r3-r11,pc}
;;;246    
                          ENDP


                          AREA ||i.post_process_prepass||, CODE, READONLY, ALIGN=1

                  post_process_prepass PROC
;;;157    METHODDEF(void)
;;;158    post_process_prepass (j_decompress_ptr cinfo,
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;159    		      JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
;;;160    		      JDIMENSION in_row_groups_avail,
;;;161    		      JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
;;;162    		      JDIMENSION out_rows_avail)
;;;163    {
;;;164      my_post_ptr post = (my_post_ptr) cinfo->post;
;;;165      JDIMENSION old_next_row, num_rows;
;;;166    
;;;167      GUI_USE_PARA(out_rows_avail);
;;;168      GUI_USE_PARA(output_buf);
;;;169      /* Reposition virtual buffer if at start of strip. */
;;;170      if (post->next_row == 0) {
000004  f8d041b0          LDR      r4,[r0,#0x1b0]
000008  4605              MOV      r5,r0                 ;163
00000a  f8dd8034          LDR      r8,[sp,#0x34]         ;164
00000e  69a0              LDR      r0,[r4,#0x18]         ;163
000010  461f              MOV      r7,r3                 ;163
000012  4691              MOV      r9,r2                 ;163
000014  468a              MOV      r10,r1                ;163
000016  b948              CBNZ     r0,|L4.44|
;;;171        post->buffer = (*cinfo->mem->access_virt_sarray)
000018  2001              MOVS     r0,#1
00001a  9000              STR      r0,[sp,#0]
00001c  6868              LDR      r0,[r5,#4]
00001e  e9d43204          LDRD     r3,r2,[r4,#0x10]
000022  69c6              LDR      r6,[r0,#0x1c]
000024  68a1              LDR      r1,[r4,#8]
000026  4628              MOV      r0,r5
000028  47b0              BLX      r6
00002a  60e0              STR      r0,[r4,#0xc]
                  |L4.44|
;;;172    	((j_common_ptr) cinfo, post->whole_image,
;;;173    	 post->starting_row, post->strip_height, TRUE);
;;;174      }
;;;175    
;;;176      /* Upsample some data (up to a strip height's worth). */
;;;177      old_next_row = post->next_row;
;;;178      (*cinfo->upsample->upsample) (cinfo,
00002c  e9d40203          LDRD     r0,r2,[r4,#0xc]
000030  f1040118          ADD      r1,r4,#0x18
000034  69a6              LDR      r6,[r4,#0x18]
000036  e88d0007          STM      sp,{r0-r2}
00003a  f8d501c4          LDR      r0,[r5,#0x1c4]
00003e  463b              MOV      r3,r7
000040  464a              MOV      r2,r9
000042  f8d0c004          LDR      r12,[r0,#4]
000046  4651              MOV      r1,r10
000048  4628              MOV      r0,r5
00004a  47e0              BLX      r12
;;;179    		input_buf, in_row_group_ctr, in_row_groups_avail,
;;;180    		post->buffer, &post->next_row, post->strip_height);
;;;181    
;;;182      /* Allow quantizer to scan new data.  No data is emitted, */
;;;183      /* but we advance out_row_ctr so outer loop can tell when we're done. */
;;;184      if (post->next_row > old_next_row) {
00004c  69a0              LDR      r0,[r4,#0x18]
00004e  42b0              CMP      r0,r6
000050  d90f              BLS      |L4.114|
;;;185        num_rows = post->next_row - old_next_row;
000052  1b87              SUBS     r7,r0,r6
;;;186        (*cinfo->cquantize->color_quantize) (cinfo, post->buffer + old_next_row,
000054  68e0              LDR      r0,[r4,#0xc]
000056  463b              MOV      r3,r7
000058  eb000186          ADD      r1,r0,r6,LSL #2
00005c  f8d501cc          LDR      r0,[r5,#0x1cc]
000060  2200              MOVS     r2,#0
000062  6846              LDR      r6,[r0,#4]
000064  4628              MOV      r0,r5
000066  47b0              BLX      r6
;;;187    					 (JSAMPARRAY) NULL, (int) num_rows);
;;;188        *out_row_ctr += num_rows;
000068  f8d80000          LDR      r0,[r8,#0]
00006c  19c1              ADDS     r1,r0,r7
00006e  f8c81000          STR      r1,[r8,#0]
                  |L4.114|
;;;189      }
;;;190    
;;;191      /* Advance if we filled the strip. */
;;;192      if (post->next_row >= post->strip_height) {
000072  69a1              LDR      r1,[r4,#0x18]
000074  6920              LDR      r0,[r4,#0x10]
000076  4281              CMP      r1,r0
000078  d304              BCC      |L4.132|
;;;193        post->starting_row += post->strip_height;
00007a  6961              LDR      r1,[r4,#0x14]
00007c  4408              ADD      r0,r0,r1
;;;194        post->next_row = 0;
00007e  6160              STR      r0,[r4,#0x14]
000080  2000              MOVS     r0,#0
000082  61a0              STR      r0,[r4,#0x18]
                  |L4.132|
;;;195      }
;;;196    }
000084  e8bd8ffe          POP      {r1-r11,pc}
;;;197    
                          ENDP


                          AREA ||i.start_pass_dpost||, CODE, READONLY, ALIGN=2

                  start_pass_dpost PROC
;;;72     METHODDEF(void)
;;;73     start_pass_dpost (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
000000  b538              PUSH     {r3-r5,lr}
;;;74     {
000002  f8d041b0          LDR      r4,[r0,#0x1b0]
000006  b169              CBZ      r1,|L5.36|
;;;75       my_post_ptr post = (my_post_ptr) cinfo->post;
;;;76     
;;;77       switch (pass_mode) {
;;;78       case JBUF_PASS_THRU:
;;;79         if (cinfo->quantize_colors) {
;;;80           /* Single-pass processing with color quantization. */
;;;81           post->pub.post_process_data = post_process_1pass;
;;;82           /* We could be doing buffered-image output before starting a 2-pass
;;;83            * color quantization; in that case, jinit_d_post_controller did not
;;;84            * allocate a strip buffer.  Use the virtual-array buffer as workspace.
;;;85            */
;;;86           if (post->buffer == NULL) {
;;;87     	post->buffer = (*cinfo->mem->access_virt_sarray)
;;;88     	  ((j_common_ptr) cinfo, post->whole_image,
;;;89     	   (JDIMENSION) 0, post->strip_height, TRUE);
;;;90           }
;;;91         } else {
;;;92           /* For single-pass processing without color quantization,
;;;93            * I have no work to do; just call the upsampler directly.
;;;94            */
;;;95           post->pub.post_process_data = cinfo->upsample->upsample;
;;;96         }
;;;97         break;
;;;98     #ifdef QUANT_2PASS_SUPPORTED
;;;99       case JBUF_SAVE_AND_PASS:
;;;100        /* First pass of 2-pass quantization */
;;;101        if (post->whole_image == NULL)
;;;102          ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
000008  2204              MOVS     r2,#4
00000a  2902              CMP      r1,#2                 ;77
00000c  d029              BEQ      |L5.98|
00000e  2903              CMP      r1,#3                 ;77
000010  d01d              BEQ      |L5.78|
;;;103        post->pub.post_process_data = post_process_prepass;
;;;104        break;
;;;105      case JBUF_CRANK_DEST:
;;;106        /* Second pass of 2-pass quantization */
;;;107        if (post->whole_image == NULL)
;;;108          ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
;;;109        post->pub.post_process_data = post_process_2pass;
;;;110        break;
;;;111    #endif /* QUANT_2PASS_SUPPORTED */
;;;112      default:
;;;113        ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
000012  6801              LDR      r1,[r0,#0]
000014  614a              STR      r2,[r1,#0x14]
000016  6801              LDR      r1,[r0,#0]
000018  6809              LDR      r1,[r1,#0]
00001a  4788              BLX      r1
                  |L5.28|
;;;114        break;
;;;115      }
;;;116      post->starting_row = post->next_row = 0;
00001c  2000              MOVS     r0,#0
00001e  61a0              STR      r0,[r4,#0x18]
;;;117    }
000020  6160              STR      r0,[r4,#0x14]
000022  bd38              POP      {r3-r5,pc}
                  |L5.36|
000024  6d41              LDR      r1,[r0,#0x54]         ;79
000026  b171              CBZ      r1,|L5.70|
000028  4912              LDR      r1,|L5.116|
00002a  6061              STR      r1,[r4,#4]            ;86
00002c  68e1              LDR      r1,[r4,#0xc]          ;86
00002e  2900              CMP      r1,#0                 ;86
000030  d1f4              BNE      |L5.28|
000032  2101              MOVS     r1,#1                 ;87
000034  9100              STR      r1,[sp,#0]            ;87
000036  6842              LDR      r2,[r0,#4]            ;87
000038  6923              LDR      r3,[r4,#0x10]         ;87
00003a  68a1              LDR      r1,[r4,#8]            ;87
00003c  69d5              LDR      r5,[r2,#0x1c]         ;87
00003e  2200              MOVS     r2,#0                 ;87
000040  47a8              BLX      r5                    ;87
000042  60e0              STR      r0,[r4,#0xc]          ;87
000044  e7ea              B        |L5.28|
                  |L5.70|
000046  f8d001c4          LDR      r0,[r0,#0x1c4]        ;95
00004a  6840              LDR      r0,[r0,#4]            ;95
00004c  e007              B        |L5.94|
                  |L5.78|
00004e  68a1              LDR      r1,[r4,#8]            ;101
000050  b921              CBNZ     r1,|L5.92|
000052  6801              LDR      r1,[r0,#0]            ;102
000054  614a              STR      r2,[r1,#0x14]         ;102
000056  6801              LDR      r1,[r0,#0]            ;102
000058  6809              LDR      r1,[r1,#0]            ;102
00005a  4788              BLX      r1                    ;102
                  |L5.92|
00005c  4806              LDR      r0,|L5.120|
                  |L5.94|
00005e  6060              STR      r0,[r4,#4]            ;95
000060  e7dc              B        |L5.28|
                  |L5.98|
000062  68a1              LDR      r1,[r4,#8]            ;107
000064  b921              CBNZ     r1,|L5.112|
000066  6801              LDR      r1,[r0,#0]            ;108
000068  614a              STR      r2,[r1,#0x14]         ;108
00006a  6801              LDR      r1,[r0,#0]            ;108
00006c  6809              LDR      r1,[r1,#0]            ;108
00006e  4788              BLX      r1                    ;108
                  |L5.112|
000070  4802              LDR      r0,|L5.124|
000072  e7f4              B        |L5.94|
;;;118    
                          ENDP

                  |L5.116|
                          DCD      post_process_1pass
                  |L5.120|
                          DCD      post_process_prepass
                  |L5.124|
                          DCD      post_process_2pass
