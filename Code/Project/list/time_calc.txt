; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\time_calc.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\time_calc.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\Board_Support_Package\time_calc.c]
                          THUMB

                          AREA ||i.Calc_DiffTime||, CODE, READONLY, ALIGN=2

                  Calc_DiffTime PROC
;;;20     /*计算两个日期的时间差,返回秒数或者分钟数或者小时数或者天数*/
;;;21     signed long Calc_DiffTime(sDateTime *sStart, sDateTime *sEnd, eTimeCalcMode eCalc_mode)
000000  b570              PUSH     {r4-r6,lr}
;;;22     {
000002  b096              SUB      sp,sp,#0x58
000004  460c              MOV      r4,r1
000006  4605              MOV      r5,r0
000008  4616              MOV      r6,r2
;;;23     	time_t nStart;
;;;24     	time_t nEnd;
;;;25     	struct tm tmStart, tmEnd;
;;;26     
;;;27     	memset(&tmStart, 0, sizeof(tmStart));
00000a  212c              MOVS     r1,#0x2c
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memclr4
;;;28     	memset(&tmEnd, 0, sizeof(tmStart));
000012  212c              MOVS     r1,#0x2c
000014  a80b              ADD      r0,sp,#0x2c
000016  f7fffffe          BL       __aeabi_memclr4
;;;29     
;;;30     	tmStart.tm_year 	= sStart->wYear + 100;
00001a  7828              LDRB     r0,[r5,#0]
00001c  3064              ADDS     r0,r0,#0x64
;;;31     	tmStart.tm_mon 	= sStart->wMonth - 1;
00001e  9005              STR      r0,[sp,#0x14]
000020  7868              LDRB     r0,[r5,#1]
000022  1e40              SUBS     r0,r0,#1
;;;32     	tmStart.tm_mday	= sStart->wDay;
000024  9004              STR      r0,[sp,#0x10]
000026  78a8              LDRB     r0,[r5,#2]
;;;33     	tmStart.tm_hour 	= sStart->wHour;
000028  9003              STR      r0,[sp,#0xc]
00002a  78e8              LDRB     r0,[r5,#3]
;;;34     	tmStart.tm_min 	= sStart->wMinute;
00002c  9002              STR      r0,[sp,#8]
00002e  7928              LDRB     r0,[r5,#4]
;;;35     	tmStart.tm_sec 	= sStart->wSecond;
000030  9001              STR      r0,[sp,#4]
000032  7968              LDRB     r0,[r5,#5]
;;;36     
;;;37     
;;;38     	tmEnd.tm_year 	= sEnd->wYear + 100;
000034  9000              STR      r0,[sp,#0]
000036  7820              LDRB     r0,[r4,#0]
000038  3064              ADDS     r0,r0,#0x64
;;;39     	tmEnd.tm_mon 	= sEnd->wMonth - 1;
00003a  9010              STR      r0,[sp,#0x40]
00003c  7860              LDRB     r0,[r4,#1]
00003e  1e40              SUBS     r0,r0,#1
;;;40     	tmEnd.tm_mday 	= sEnd->wDay;
000040  900f              STR      r0,[sp,#0x3c]
000042  78a0              LDRB     r0,[r4,#2]
;;;41     	tmEnd.tm_hour 	= sEnd->wHour;
000044  900e              STR      r0,[sp,#0x38]
000046  78e0              LDRB     r0,[r4,#3]
;;;42     	tmEnd.tm_min 	= sEnd->wMinute;
000048  900d              STR      r0,[sp,#0x34]
00004a  7920              LDRB     r0,[r4,#4]
;;;43     	tmEnd.tm_sec 	= sEnd->wSecond;
00004c  900c              STR      r0,[sp,#0x30]
00004e  7960              LDRB     r0,[r4,#5]
;;;44     
;;;45     	nStart = mktime(&tmStart);
000050  900b              STR      r0,[sp,#0x2c]
000052  4668              MOV      r0,sp
000054  f7fffffe          BL       mktime
000058  4604              MOV      r4,r0
;;;46     	nEnd = mktime(&tmEnd);
00005a  a80b              ADD      r0,sp,#0x2c
00005c  f7fffffe          BL       mktime
;;;47     
;;;48     	if(eCalc_mode == eTimeCalc_By_Seconds)	/*秒*/
000060  2e03              CMP      r6,#3
000062  d004              BEQ      |L1.110|
;;;49     	{
;;;50     		return difftime(nEnd, nStart);
;;;51     	}
;;;52     	else if(eCalc_mode == eTimeCalc_By_Minites)	/*分钟*/
000064  2e02              CMP      r6,#2
000066  d006              BEQ      |L1.118|
;;;53     	{
;;;54     		return difftime(nEnd, nStart) / 60;
;;;55     	}
;;;56     	else if(eCalc_mode == eTimeCalc_By_Hours)	/*小时*/
000068  2e01              CMP      r6,#1
00006a  d00a              BEQ      |L1.130|
;;;57     	{
;;;58     		return difftime(nEnd, nStart) / (3600);
;;;59     	}
;;;60     	else if(eCalc_mode == eTimeCalc_By_Days)	/*天数*/
00006c  b1ae              CBZ      r6,|L1.154|
                  |L1.110|
00006e  4621              MOV      r1,r4                 ;50
000070  f7fffffe          BL       difftime
000074  e00c              B        |L1.144|
                  |L1.118|
000076  4621              MOV      r1,r4                 ;54
000078  f7fffffe          BL       difftime
00007c  2200              MOVS     r2,#0                 ;54
00007e  4b0a              LDR      r3,|L1.168|
000080  e004              B        |L1.140|
                  |L1.130|
000082  4621              MOV      r1,r4                 ;58
000084  f7fffffe          BL       difftime
000088  2200              MOVS     r2,#0                 ;58
00008a  4b08              LDR      r3,|L1.172|
                  |L1.140|
00008c  f7fffffe          BL       __aeabi_ddiv
                  |L1.144|
;;;61     	{
;;;62     		return difftime(nEnd, nStart) / 86400;
;;;63     	}
;;;64     
;;;65     	return difftime(nEnd, nStart);
000090  b016              ADD      sp,sp,#0x58
000092  e8bd4070          POP      {r4-r6,lr}
000096  f7ffbffe          B.W      __aeabi_d2iz
                  |L1.154|
00009a  4621              MOV      r1,r4                 ;62
00009c  f7fffffe          BL       difftime
0000a0  2200              MOVS     r2,#0                 ;62
0000a2  4b03              LDR      r3,|L1.176|
0000a4  e7f2              B        |L1.140|
;;;66     }
;;;67     
                          ENDP

0000a6  0000              DCW      0x0000
                  |L1.168|
                          DCD      0x404e0000
                  |L1.172|
                          DCD      0x40ac2000
                  |L1.176|
                          DCD      0x40f51800

                          AREA ||i.Calc_NdaysDiff||, CODE, READONLY, ALIGN=2

                  Calc_NdaysDiff PROC
;;;68     /*获取某个特定日期后或前N天的日期时间.*/
;;;69     void Calc_NdaysDiff(sDateTime *pResultDate, sDateTime *pStartDate, float fDays)
000000  b5f0              PUSH     {r4-r7,lr}
;;;70     {
000002  b08d              SUB      sp,sp,#0x34
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
000008  4617              MOV      r7,r2
;;;71     	time_t nDT;
;;;72     	struct tm tmDT, *p_tmDT;
;;;73     
;;;74     	memset(&tmDT, 0, sizeof(tmDT));
00000a  212c              MOVS     r1,#0x2c
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memclr4
;;;75     
;;;76     	tmDT.tm_year		= pStartDate->wYear + 100;
000012  7828              LDRB     r0,[r5,#0]
000014  3064              ADDS     r0,r0,#0x64
;;;77     	tmDT.tm_mon 	= pStartDate->wMonth - 1;
000016  9005              STR      r0,[sp,#0x14]
000018  7868              LDRB     r0,[r5,#1]
00001a  1e40              SUBS     r0,r0,#1
;;;78     	tmDT.tm_mday	= pStartDate->wDay;
00001c  9004              STR      r0,[sp,#0x10]
00001e  78a8              LDRB     r0,[r5,#2]
;;;79     	tmDT.tm_hour 	= pStartDate->wHour;
000020  9003              STR      r0,[sp,#0xc]
000022  78e8              LDRB     r0,[r5,#3]
;;;80     	tmDT.tm_min 		= pStartDate->wMinute;
000024  9002              STR      r0,[sp,#8]
000026  7928              LDRB     r0,[r5,#4]
;;;81     	tmDT.tm_sec 		= pStartDate->wSecond;
000028  9001              STR      r0,[sp,#4]
00002a  7968              LDRB     r0,[r5,#5]
;;;82     
;;;83     	nDT = mktime(&tmDT);
00002c  9000              STR      r0,[sp,#0]
00002e  4668              MOV      r0,sp
000030  f7fffffe          BL       mktime
000034  4606              MOV      r6,r0
;;;84     
;;;85     	nDT += (86400 * fDays);
000036  4910              LDR      r1,|L2.120|
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       __aeabi_fmul
00003e  4605              MOV      r5,r0
000040  4630              MOV      r0,r6
000042  f7fffffe          BL       __aeabi_ui2f
000046  4629              MOV      r1,r5
000048  f7fffffe          BL       __aeabi_fadd
00004c  f7fffffe          BL       __aeabi_f2uiz
;;;86     
;;;87     	p_tmDT = localtime(&nDT);
000050  900b              STR      r0,[sp,#0x2c]
000052  a80b              ADD      r0,sp,#0x2c
000054  f7fffffe          BL       localtime
;;;88     
;;;89     	pResultDate->wYear		= p_tmDT->tm_year - 100;
000058  7d01              LDRB     r1,[r0,#0x14]
00005a  3964              SUBS     r1,r1,#0x64
00005c  7021              STRB     r1,[r4,#0]
;;;90     	pResultDate->wMonth		= p_tmDT->tm_mon + 1;
00005e  7c01              LDRB     r1,[r0,#0x10]
000060  1c49              ADDS     r1,r1,#1
000062  7061              STRB     r1,[r4,#1]
;;;91     	pResultDate->wDay		= p_tmDT->tm_mday;
000064  7b01              LDRB     r1,[r0,#0xc]
000066  70a1              STRB     r1,[r4,#2]
;;;92     	pResultDate->wHour		= p_tmDT->tm_hour;
000068  7a01              LDRB     r1,[r0,#8]
00006a  70e1              STRB     r1,[r4,#3]
;;;93     	pResultDate->wMinute	= p_tmDT->tm_min;
00006c  7901              LDRB     r1,[r0,#4]
00006e  7121              STRB     r1,[r4,#4]
;;;94     	pResultDate->wSecond	= p_tmDT->tm_sec;
000070  7800              LDRB     r0,[r0,#0]
000072  7160              STRB     r0,[r4,#5]
;;;95     }
000074  b00d              ADD      sp,sp,#0x34
000076  bdf0              POP      {r4-r7,pc}
;;;96     
                          ENDP

                  |L2.120|
                          DCD      0x47a8c000

                          AREA ||i.Calc_NdaysDiff_Date||, CODE, READONLY, ALIGN=1

                  Calc_NdaysDiff_Date PROC
;;;215    /*其中nDays为正为向后多少天,nDays为负为向前多少天*/
;;;216    void Calc_NdaysDiff_Date(sDateTime *pResultDate, sDateTime *pStartDate, signed short nDays)
000000  b570              PUSH     {r4-r6,lr}
;;;217    {
000002  b08c              SUB      sp,sp,#0x30
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
000008  4616              MOV      r6,r2
;;;218    	time_t t;
;;;219    	struct tm tm_start = {0}, * p_tm_result = NULL;
00000a  212c              MOVS     r1,#0x2c
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memclr4
;;;220    
;;;221    	tm_start.tm_year = pStartDate->wYear + 100;
000012  7828              LDRB     r0,[r5,#0]
000014  3064              ADDS     r0,r0,#0x64
;;;222    	tm_start.tm_mon = pStartDate->wMonth - 1;
000016  9005              STR      r0,[sp,#0x14]
000018  7868              LDRB     r0,[r5,#1]
00001a  1e40              SUBS     r0,r0,#1
;;;223    	tm_start.tm_mday = pStartDate->wDay;
00001c  9004              STR      r0,[sp,#0x10]
00001e  78a8              LDRB     r0,[r5,#2]
;;;224    	tm_start.tm_hour = pStartDate->wHour;
000020  9003              STR      r0,[sp,#0xc]
000022  78e8              LDRB     r0,[r5,#3]
;;;225    	tm_start.tm_min = pStartDate->wMinute;
000024  9002              STR      r0,[sp,#8]
000026  7928              LDRB     r0,[r5,#4]
;;;226    	tm_start.tm_sec = pStartDate->wSecond;
000028  9001              STR      r0,[sp,#4]
00002a  7968              LDRB     r0,[r5,#5]
;;;227    
;;;228    	t = mktime(&tm_start);
00002c  9000              STR      r0,[sp,#0]
00002e  4668              MOV      r0,sp
000030  f7fffffe          BL       mktime
;;;229    
;;;230    	t += (nDays * 24 * 60 * 60);
000034  f24021a3          MOV      r1,#0x2a3
000038  434e              MULS     r6,r1,r6
00003a  eb0010c6          ADD      r0,r0,r6,LSL #7
;;;231    
;;;232    	p_tm_result = gmtime(&t);
00003e  900b              STR      r0,[sp,#0x2c]
000040  a80b              ADD      r0,sp,#0x2c
000042  f7fffffe          BL       gmtime
;;;233    
;;;234    	pResultDate->wYear = p_tm_result->tm_year - 100 + 1900 - 2000;
000046  7d01              LDRB     r1,[r0,#0x14]
000048  39c8              SUBS     r1,r1,#0xc8
00004a  7021              STRB     r1,[r4,#0]
;;;235    	pResultDate->wMonth = p_tm_result->tm_mon + 1;
00004c  7c01              LDRB     r1,[r0,#0x10]
00004e  1c49              ADDS     r1,r1,#1
000050  7061              STRB     r1,[r4,#1]
;;;236    	pResultDate->wDay = p_tm_result->tm_mday;
000052  7b01              LDRB     r1,[r0,#0xc]
000054  70a1              STRB     r1,[r4,#2]
;;;237    	pResultDate->wHour = p_tm_result->tm_hour;
000056  7a01              LDRB     r1,[r0,#8]
000058  70e1              STRB     r1,[r4,#3]
;;;238    	pResultDate->wMinute = p_tm_result->tm_min;
00005a  7901              LDRB     r1,[r0,#4]
00005c  7121              STRB     r1,[r4,#4]
;;;239    	pResultDate->wSecond = p_tm_result->tm_sec;
00005e  7800              LDRB     r0,[r0,#0]
000060  7160              STRB     r0,[r4,#5]
;;;240    }
000062  b00c              ADD      sp,sp,#0x30
000064  bd70              POP      {r4-r6,pc}
;;;241    
                          ENDP


                          AREA ||i.Get_ElapseDaysFromJan1st||, CODE, READONLY, ALIGN=1

                  Get_ElapseDaysFromJan1st PROC
;;;189    /* 获得某一特定日期从当前1月1日起过了多少天*/
;;;190    unsigned short Get_ElapseDaysFromJan1st(sDateTime *pCurDate)
000000  b51c              PUSH     {r2-r4,lr}
;;;191    {
;;;192    	unsigned short ret;
;;;193    	sDateTime sDateTemp;
;;;194    	sDateTemp = *pCurDate;
000002  6801              LDR      r1,[r0,#0]
000004  9100              STR      r1,[sp,#0]
000006  8881              LDRH     r1,[r0,#4]
000008  f8ad1004          STRH     r1,[sp,#4]
;;;195    	sDateTemp.wMonth = 1;
00000c  2101              MOVS     r1,#1
00000e  f88d1001          STRB     r1,[sp,#1]
;;;196    	sDateTemp.wDay = 1;
000012  f88d1002          STRB     r1,[sp,#2]
;;;197    	ret = (unsigned short)Calc_DiffTime(&sDateTemp, pCurDate, eTimeCalc_By_Days);
000016  4601              MOV      r1,r0
000018  2200              MOVS     r2,#0
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       Calc_DiffTime
000020  b280              UXTH     r0,r0
;;;198    	return ret;
;;;199    }
000022  bd1c              POP      {r2-r4,pc}
;;;200    
                          ENDP


                          AREA ||i.Get_LocalTime_From_UTC||, CODE, READONLY, ALIGN=1

                  Get_LocalTime_From_UTC PROC
;;;112    /*从UTC得到相应的时间*/
;;;113    sDateTime Get_LocalTime_From_UTC(unsigned long nUTCValue)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;114    {
000002  b082              SUB      sp,sp,#8
000004  4604              MOV      r4,r0
;;;115    	struct tm *pTime_t;
;;;116    	sDateTime sDateTimeTemp;
;;;117    
;;;118    	pTime_t = localtime((const time_t *)&nUTCValue);
000006  a803              ADD      r0,sp,#0xc
000008  f7fffffe          BL       localtime
;;;119    
;;;120    	sDateTimeTemp.wYear = pTime_t -> tm_year  - 100;
00000c  7d01              LDRB     r1,[r0,#0x14]
00000e  3964              SUBS     r1,r1,#0x64
000010  f88d1000          STRB     r1,[sp,#0]
;;;121    	sDateTimeTemp.wMonth = pTime_t -> tm_mon  + 1;
000014  7c01              LDRB     r1,[r0,#0x10]
000016  1c49              ADDS     r1,r1,#1
000018  f88d1001          STRB     r1,[sp,#1]
;;;122    	sDateTimeTemp.wDay = pTime_t -> tm_mday;
00001c  7b01              LDRB     r1,[r0,#0xc]
00001e  f88d1002          STRB     r1,[sp,#2]
;;;123    	sDateTimeTemp.wHour = pTime_t -> tm_hour;
000022  7a01              LDRB     r1,[r0,#8]
000024  f88d1003          STRB     r1,[sp,#3]
;;;124    	sDateTimeTemp.wMinute = pTime_t -> tm_min;
000028  7901              LDRB     r1,[r0,#4]
00002a  f88d1004          STRB     r1,[sp,#4]
;;;125    	sDateTimeTemp.wSecond = pTime_t -> tm_sec;
00002e  7800              LDRB     r0,[r0,#0]
000030  f88d0005          STRB     r0,[sp,#5]
;;;126    	//	sDateTimeTemp.wWeekday = pTime_t -> tm_wday;
;;;127    
;;;128    	return sDateTimeTemp;
000034  9800              LDR      r0,[sp,#0]
000036  6020              STR      r0,[r4,#0]
000038  f8bd0004          LDRH     r0,[sp,#4]
00003c  80a0              STRH     r0,[r4,#4]
;;;129    }
00003e  bd1f              POP      {r0-r4,pc}
;;;130    
                          ENDP


                          AREA ||i.Get_RemainDaysToEndOfThisYear||, CODE, READONLY, ALIGN=1

                  Get_RemainDaysToEndOfThisYear PROC
;;;201    /* 获得某一特定日期的当年还剩下多少天*/
;;;202    unsigned short Get_RemainDaysToEndOfThisYear(sDateTime *pCurDate)
000000  b51c              PUSH     {r2-r4,lr}
;;;203    {
;;;204    	unsigned short ret;
;;;205    	sDateTime sDateTemp;
;;;206    	sDateTemp = *pCurDate;
000002  6801              LDR      r1,[r0,#0]
000004  9100              STR      r1,[sp,#0]
000006  8881              LDRH     r1,[r0,#4]
000008  f8ad1004          STRH     r1,[sp,#4]
;;;207    	sDateTemp.wYear += 1;
00000c  f89d1000          LDRB     r1,[sp,#0]
;;;208    	sDateTemp.wMonth = 1;
;;;209    	sDateTemp.wDay = 1;
;;;210    	ret = (unsigned short)Calc_DiffTime(&sDateTemp, pCurDate, eTimeCalc_By_Days);
000010  2200              MOVS     r2,#0
000012  1c49              ADDS     r1,r1,#1              ;207
000014  f88d1000          STRB     r1,[sp,#0]            ;207
000018  2101              MOVS     r1,#1                 ;208
00001a  f88d1001          STRB     r1,[sp,#1]            ;208
00001e  f88d1002          STRB     r1,[sp,#2]            ;209
000022  4601              MOV      r1,r0
000024  4668              MOV      r0,sp
000026  f7fffffe          BL       Calc_DiffTime
00002a  b280              UXTH     r0,r0
;;;211    	return ret;
;;;212    }
00002c  bd1c              POP      {r2-r4,pc}
;;;213    
                          ENDP


                          AREA ||i.Get_UTC_Value||, CODE, READONLY, ALIGN=1

                  Get_UTC_Value PROC
;;;97     /*获取某个时间的UTC值.*/
;;;98     unsigned long Get_UTC_Value(sDateTime *sTime)
000000  b500              PUSH     {lr}
;;;99     {
;;;100    	struct tm sTime_t;
;;;101    
;;;102    	sTime_t.tm_year 	= sTime->wYear + 100;
000002  7801              LDRB     r1,[r0,#0]
000004  b08b              SUB      sp,sp,#0x2c           ;99
000006  3164              ADDS     r1,r1,#0x64
;;;103    	sTime_t.tm_mon 	= sTime->wMonth - 1;
000008  9105              STR      r1,[sp,#0x14]
00000a  7841              LDRB     r1,[r0,#1]
00000c  1e49              SUBS     r1,r1,#1
;;;104    	sTime_t.tm_mday	= sTime->wDay;
00000e  9104              STR      r1,[sp,#0x10]
000010  7881              LDRB     r1,[r0,#2]
;;;105    	sTime_t.tm_hour 	= sTime->wHour;
000012  9103              STR      r1,[sp,#0xc]
000014  78c1              LDRB     r1,[r0,#3]
;;;106    	sTime_t.tm_min 	= sTime->wMinute;
000016  9102              STR      r1,[sp,#8]
000018  7901              LDRB     r1,[r0,#4]
;;;107    	sTime_t.tm_sec 	= sTime->wSecond;
00001a  9101              STR      r1,[sp,#4]
00001c  7940              LDRB     r0,[r0,#5]
;;;108    
;;;109    	return mktime(&sTime_t);
00001e  9000              STR      r0,[sp,#0]
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       mktime
;;;110    }
000026  b00b              ADD      sp,sp,#0x2c
000028  bd00              POP      {pc}
;;;111    
                          ENDP


                          AREA ||i.Get_Weekday||, CODE, READONLY, ALIGN=1

                  Get_Weekday PROC
;;;176    /*获得某天的星期数*/
;;;177    unsigned char Get_Weekday(char nDay, char nMonth, char nYear)
000000  b510              PUSH     {r4,lr}
;;;178    {
;;;179    	if(nMonth <= 2)
000002  2902              CMP      r1,#2
000004  d803              BHI      |L8.14|
000006  310c              ADDS     r1,r1,#0xc            ;178
;;;180    	{
;;;181    		nMonth += 12;
000008  1e52              SUBS     r2,r2,#1
00000a  b2c9              UXTB     r1,r1
;;;182    		nYear--;
00000c  b2d2              UXTB     r2,r2
                  |L8.14|
;;;183    	}
;;;184    
;;;185    	/*周一为1,周日为7*/
;;;186    	return (nDay + 2 * nMonth + 3 * (nMonth + 1) / 5 + nYear + nYear / 4 - nYear / 100 + nYear / 400) % 7 + 1;
00000e  1c4b              ADDS     r3,r1,#1
000010  eb000041          ADD      r0,r0,r1,LSL #1
000014  eb030343          ADD      r3,r3,r3,LSL #1
000018  2405              MOVS     r4,#5
00001a  fbb3f3f4          UDIV     r3,r3,r4
00001e  2164              MOVS     r1,#0x64
000020  fbb2f1f1          UDIV     r1,r2,r1
000024  4418              ADD      r0,r0,r3
000026  4410              ADD      r0,r0,r2
000028  eb000092          ADD      r0,r0,r2,LSR #2
00002c  1a40              SUBS     r0,r0,r1
00002e  f44f71c8          MOV      r1,#0x190
000032  fbb2f1f1          UDIV     r1,r2,r1
000036  4408              ADD      r0,r0,r1
000038  2107              MOVS     r1,#7
00003a  fb90f2f1          SDIV     r2,r0,r1
00003e  fb010012          MLS      r0,r1,r2,r0
000042  1c40              ADDS     r0,r0,#1
000044  b2c0              UXTB     r0,r0
;;;187    }
000046  bd10              POP      {r4,pc}
;;;188    
                          ENDP


                          AREA ||i.Is_Leapyear||, CODE, READONLY, ALIGN=1

                  Is_Leapyear PROC
;;;167    /*判断一个年份是否为闰年*/
;;;168    unsigned char Is_Leapyear(int nYear)
000000  f44f71c8          MOV      r1,#0x190
;;;169    {
;;;170    	if((nYear % 400 == 0 ) || (nYear % 4 == 0 && nYear % 100 != 0))
000004  fb90f2f1          SDIV     r2,r0,r1
000008  fb010112          MLS      r1,r1,r2,r0
00000c  b139              CBZ      r1,|L9.30|
00000e  0781              LSLS     r1,r0,#30
000010  d107              BNE      |L9.34|
000012  2164              MOVS     r1,#0x64
000014  fb90f2f1          SDIV     r2,r0,r1
000018  fb010012          MLS      r0,r1,r2,r0
00001c  b108              CBZ      r0,|L9.34|
                  |L9.30|
;;;171    		return 1;
00001e  2001              MOVS     r0,#1
;;;172    	else
;;;173    		return 0;
;;;174    }
000020  4770              BX       lr
                  |L9.34|
000022  2000              MOVS     r0,#0                 ;173
000024  4770              BX       lr
;;;175    
                          ENDP


                          AREA ||i.Is_Valid_DateTime||, CODE, READONLY, ALIGN=1

                  Is_Valid_DateTime PROC
;;;131    /*判断一个日期是否有效.*/
;;;132    unsigned char Is_Valid_DateTime(sDateTime *sDT)
000000  b510              PUSH     {r4,lr}
;;;133    {
000002  b098              SUB      sp,sp,#0x60
000004  4604              MOV      r4,r0
;;;134    	time_t nDT;
;;;135    	struct tm tmDT, tmDT1, *p_tmDT;
;;;136    
;;;137    	memset(&tmDT, 0, sizeof(tmDT));
000006  212c              MOVS     r1,#0x2c
000008  a80b              ADD      r0,sp,#0x2c
00000a  f7fffffe          BL       __aeabi_memclr4
;;;138    
;;;139    	tmDT.tm_year		= sDT->wYear + 100;
00000e  7820              LDRB     r0,[r4,#0]
;;;140    	tmDT.tm_mon 	= sDT->wMonth - 1;
;;;141    	tmDT.tm_mday	= sDT->wDay;
;;;142    	tmDT.tm_hour 	= sDT->wHour;
;;;143    	tmDT.tm_min 		= sDT->wMinute;
;;;144    	tmDT.tm_sec 		= sDT->wSecond;
;;;145    
;;;146    	tmDT1 = tmDT;
000010  222c              MOVS     r2,#0x2c
000012  3064              ADDS     r0,r0,#0x64           ;139
000014  9010              STR      r0,[sp,#0x40]         ;140
000016  7860              LDRB     r0,[r4,#1]            ;140
000018  a90b              ADD      r1,sp,#0x2c
00001a  1e40              SUBS     r0,r0,#1              ;140
00001c  900f              STR      r0,[sp,#0x3c]         ;141
00001e  78a0              LDRB     r0,[r4,#2]            ;141
000020  900e              STR      r0,[sp,#0x38]         ;142
000022  78e0              LDRB     r0,[r4,#3]            ;142
000024  900d              STR      r0,[sp,#0x34]         ;143
000026  7920              LDRB     r0,[r4,#4]            ;143
000028  900c              STR      r0,[sp,#0x30]         ;144
00002a  7960              LDRB     r0,[r4,#5]            ;144
00002c  900b              STR      r0,[sp,#0x2c]
00002e  4668              MOV      r0,sp
000030  f7fffffe          BL       __aeabi_memcpy4
;;;147    
;;;148    	nDT = mktime(&tmDT);
000034  a80b              ADD      r0,sp,#0x2c
000036  f7fffffe          BL       mktime
;;;149    
;;;150    	p_tmDT = localtime(&nDT);
00003a  9016              STR      r0,[sp,#0x58]
00003c  a816              ADD      r0,sp,#0x58
00003e  f7fffffe          BL       localtime
;;;151    
;;;152    	if(p_tmDT->tm_year != tmDT1.tm_year) return 0;
000042  6941              LDR      r1,[r0,#0x14]
000044  9a05              LDR      r2,[sp,#0x14]
000046  4291              CMP      r1,r2
000048  d113              BNE      |L10.114|
;;;153    
;;;154    	if(p_tmDT->tm_mon != tmDT1.tm_mon) return 0;
00004a  6901              LDR      r1,[r0,#0x10]
00004c  9a04              LDR      r2,[sp,#0x10]
00004e  4291              CMP      r1,r2
000050  d10f              BNE      |L10.114|
;;;155    
;;;156    	if(p_tmDT->tm_mday != tmDT1.tm_mday) return 0;
000052  68c1              LDR      r1,[r0,#0xc]
000054  9a03              LDR      r2,[sp,#0xc]
000056  4291              CMP      r1,r2
000058  d10b              BNE      |L10.114|
;;;157    
;;;158    	if(p_tmDT->tm_hour != tmDT1.tm_hour) return 0;
00005a  6881              LDR      r1,[r0,#8]
00005c  9a02              LDR      r2,[sp,#8]
00005e  4291              CMP      r1,r2
000060  d107              BNE      |L10.114|
;;;159    
;;;160    	if(p_tmDT->tm_min != tmDT1.tm_min) return 0;
000062  6841              LDR      r1,[r0,#4]
000064  9a01              LDR      r2,[sp,#4]
000066  4291              CMP      r1,r2
000068  d103              BNE      |L10.114|
;;;161    
;;;162    	if(p_tmDT->tm_sec != tmDT1.tm_sec) return 0;
00006a  6800              LDR      r0,[r0,#0]
00006c  9900              LDR      r1,[sp,#0]
00006e  4288              CMP      r0,r1
000070  d002              BEQ      |L10.120|
                  |L10.114|
000072  2000              MOVS     r0,#0
                  |L10.116|
;;;163    
;;;164    	return 1;
;;;165    }
000074  b018              ADD      sp,sp,#0x60
000076  bd10              POP      {r4,pc}
                  |L10.120|
000078  2001              MOVS     r0,#1                 ;164
00007a  e7fb              B        |L10.116|
;;;166    
                          ENDP

