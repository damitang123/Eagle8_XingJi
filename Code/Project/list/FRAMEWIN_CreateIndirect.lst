L 1 "..\GUI\Widget\FRAMEWIN_CreateIndirect.c"
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : FRAMEWIN_CreateIndirect.c
NPurpose     : Implementation of framewin widget
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#include "FRAMEWIN.h"
L 1 "..\GUI\Widget\FRAMEWIN.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : FRAMEWIN.h
NPurpose     : Frame window include
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef FRAMEWIN_H
N#define FRAMEWIN_H
N
N#include "WM.h"
L 1 "..\GUI\WM\WM.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : WM.h
NPurpose     : Windows manager include
N----------------------------------------------------------------------
N*/
N
N#ifndef WM_H            /* Make sure we only include it once */
N#define WM_H
N
N
N#include "GUI_ConfDefaults.h"
L 1 "..\GUI\Core\GUI_ConfDefaults.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : GUI_ConfDefaults.h
NPurpose     : Defaults for GUI config switches.
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N#ifndef  GUI_CONFDEFAULTS_H
N#define  GUI_CONFDEFAULTS_H
N
N#include "GUIConf.h"
L 1 "..\Config\GUIConf.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/GUI
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : GUIConf.h
NPurpose     : Configures abilities, fonts etc.
N----------------------------------------------------------------------
N*/
N
N
N#ifndef GUICONF_H
N#define GUICONF_H
N
N#define GUI_OS                    (0)  /* Compile with multitasking support */
N#define GUI_SUPPORT_TOUCH         (1)  /* Support a touch screen (req. win-manager) */
N#define GUI_SUPPORT_UNICODE       (1)  /* Support mixed ASCII/UNICODE strings */
N
N#define GUI_DEFAULT_FONT          &GUI_Font6x8
N#define GUI_ALLOC_SIZE          	(1024*30)  /* Size of dynamic memory ... For WM and memory devices*/
N/*********************************************************************
N*
N*         Configuration of available packages
N*/
N
N#define GUI_WINSUPPORT            1  /* Window manager package available */
N#define GUI_SUPPORT_MEMDEV       1  /* Memory devices available */
N#define GUI_SUPPORT_AA            1  /* Anti aliasing available */
N
N#endif  /* Avoid multiple inclusion */
N
N
N
L 28 "..\GUI\Core\GUI_ConfDefaults.h" 2
N
N/**********************************************************************
N*
N*       Defaults for config switches
N*
N***********************************************************************
N*/
N
N/* Define "universal pointer". Normally, this is not needed (define will expand to nothing)
N   However, on some systems (AVR - IAR compiler) it can be necessary ( -> __generic),
N   since a default pointer can access RAM only, not the built-in Flash
N*/
N#ifndef GUI_UNI_PTR
N  #define GUI_UNI_PTR
N  #define GUI_UNI_PTR_USED 0
N#else
S  #define GUI_UNI_PTR_USED 1
N#endif
N
N/* Define const storage. Normally, this is not needed (define will expand to const)
N   However, on some systems (AVR - IAR compiler) it can be necessary ( -> __flash const),
N   since otherwise constants are copied into RAM
N*/
N#ifndef GUI_USE_MEMDEV_1BPP_FOR_SCREEN
N  #define GUI_USE_MEMDEV_1BPP_FOR_SCREEN 0
N#endif
N
N#ifndef GUI_SUPPORT_UNICODE
S  #define GUI_SUPPORT_UNICODE 1
N#endif
N
N#ifndef GUI_SUPPORT_ARABIC
N  #define GUI_SUPPORT_ARABIC 0
N#endif
N
N#ifndef GUI_ALLOC_SIZE
S  #define GUI_ALLOC_SIZE      1000
N#endif
N
N#ifndef GUI_MAXBLOCKS
N  #define GUI_MAXBLOCKS (2 + GUI_ALLOC_SIZE / 32)
N#endif
N
N#ifndef GUI_CONST_STORAGE
N  #define GUI_CONST_STORAGE const
N#endif
N
N#ifndef GUI_SUPPORT_TOUCH
S  #define GUI_SUPPORT_TOUCH   0
N#endif
N
N#ifndef GUI_SUPPORT_MOUSE
N  #define GUI_SUPPORT_MOUSE   0
N#endif
N
N#ifndef GUI_SUPPORT_MEMDEV
S  #define GUI_SUPPORT_MEMDEV  0
N#endif
N
N#ifndef GUI_SUPPORT_AA
S  #define GUI_SUPPORT_AA      0
N#endif
N
N#ifndef GUI_OS
S  #define GUI_OS              0
N#endif
N
N#ifndef GUI_SUPPORT_LARGE_BITMAPS
N  #if GUI_ALLOC_SIZE > 65535
X  #if (1024*30) > 65535
S    #define GUI_SUPPORT_LARGE_BITMAPS 1
N  #else
N    #define GUI_SUPPORT_LARGE_BITMAPS 0
N  #endif
N#endif
N
N#ifndef GUI_COMPATIBLE_MODE
N  #define GUI_COMPATIBLE_MODE 1
N#endif
N
N#ifndef GUI_NUM_LAYERS
N  #define GUI_NUM_LAYERS      1
N#endif
N
N#ifndef GUI_SUPPORT_CURSOR
N  #define GUI_SUPPORT_CURSOR  (GUI_SUPPORT_MOUSE | GUI_SUPPORT_TOUCH)
N#endif
N
N#ifndef GUI_SUPPORT_DEVICES
N  #ifdef __C51__               /* Keil C51 limitation ... Indirect function calls are limited */
S    #define GUI_SUPPORT_DEVICES 0
N  #else
N    #define GUI_SUPPORT_DEVICES (GUI_SUPPORT_MEMDEV | (GUI_NUM_LAYERS > 1))
N  #endif
N#endif
N
N/* Some compilers for very simple chips can not generate code for function pointers
Nwith parameters. In this case, we do not use function pointers, but limit the functionality slightly */
N#ifndef GUI_COMPILER_SUPPORTS_FP
N  #ifdef __C51__
S    #define GUI_COMPILER_SUPPORTS_FP 0
N  #else
N    #define GUI_COMPILER_SUPPORTS_FP 1
N  #endif
N#endif
N
N#ifndef GUI_SUPPORT_ROTATION
N  #if GUI_COMPILER_SUPPORTS_FP
X  #if 1
N    #define GUI_SUPPORT_ROTATION 1
N  #else
S    #define GUI_SUPPORT_ROTATION 0
N  #endif
N#endif
N
N/* In order to avoid warnings for undefined parameters */
N#ifndef GUI_USE_PARA
N  #if defined (__BORLANDC__) || defined(NC30) || defined(NC308)
X  #if 0L || 0L || 0L
S    #define GUI_USE_PARA(para)
N  #else
N    #define GUI_USE_PARA(para) para=para;
N  #endif
N#endif
N
N/* Default for types */
N#ifndef GUI_TIMER_TIME
N  #define GUI_TIMER_TIME int  /* default is to use 16 bits for 16 bit CPUs,
N	                           32 bits on 32 bit CPUs for timing */
N#endif
N
N/* Types used for memory allocation */
N#if GUI_ALLOC_SIZE <32767
X#if (1024*30) <32767
N  #define GUI_ALLOC_DATATYPE   I16
N  #define GUI_ALLOC_DATATYPE_U U16
N#else
S  #define GUI_ALLOC_DATATYPE   I32
S  #define GUI_ALLOC_DATATYPE_U U32
N#endif
N
N#ifndef   GUI_MEMSET
N  #define GUI_MEMSET GUI__memset
N#endif
N
N
N#endif   /* ifdef GUI_CONFDEFAULTS_H */
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 25 "..\GUI\WM\WM.h" 2
N#include "GUIType.h"      /* Needed because of typedefs only */
L 1 "..\GUI\Core\GUIType.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : GUIType.h
NPurpose     : Include file define the types used for GUI
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N#ifndef  GUITYPE_H_INCLUDED
N#define  GUITYPE_H_INCLUDED
N
N#include "LCD.h"
L 1 "..\GUI\Core\LCD.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : LCD.h
NPurpose     : Declares LCD interface functions
N----------------------------------------------------------------------
N*/
N
N#ifndef LCD_H
N#define LCD_H
N
N#include "GUI_ConfDefaults.h" /* Used for GUI_UNI_PTR */
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*
N  ********************************************************************
N  *                                                                  *
N  *                   Basic type defines                             *
N  *                                                                  *
N  ********************************************************************
N
NThe follwing are defines for types used in the LCD-driver and the
NGUI layers on top of that. Since "C" does not provide data types of
Nfixed length which are identical on all platforms, this is done here.
NFor most 16/32 controllers, the settings will work fine. However, if
Nyou have similar defines in other sections of your program, you might
Nwant to change or relocate these defines, e.g. in a TYPE.h file.
N*/
N 
N#define I8    signed char
N#define U8  unsigned char     /* unsigned 8  bits. */
N#define I16   signed short    /*   signed 16 bits. */
N#define U16 unsigned short    /* unsigned 16 bits. */
N#define I32   signed long   /*   signed 32 bits. */
N#define U32 unsigned long   /* unsigned 32 bits. */
N#define I16P I16              /*   signed 16 bits OR MORE ! */
N#define U16P U16              /* unsigned 16 bits OR MORE ! */
N
N/*
N  ********************************************************************
N  *                                                                  *
N  *               Settings for windows simulation                    *
N  *                                                                  *
N  ********************************************************************
N
NSome settings in the configuration may conflict with the values required
Nin the Simulation. This is why we ignore the target settings for data
Ntypes and use the correct settings for the simulation.
N(U32 could be defined as long, which would yield a 64 bit type on
Nthe PC)
N*/
N
N#ifdef WIN32
S  #pragma warning( disable : 4244 )  // Disable warning messages in simulation
S  #pragma warning( disable : 4761 )  // Disable warning "integral size mismatch in argument; conversion supplied"
N#endif                                      
N
N
N/*      *************************************************************
N        *                                                           *
N        *                Constants                                  *
N        *                                                           *
N        *************************************************************
N*/
N#define LCD_ERR0 (0x10)
N#define LCD_ERR_CONTROLLER_NOT_FOUND (LCD_ERR0+1)
N#define LCD_ERR_MEMORY               (LCD_ERR0+2)
N
N/*
N      *********************************
N      *                               *
N      *      Drawing modes            *
N      *                               *
N      *********************************
N*/
N
N#define LCD_DRAWMODE_NORMAL (0)
N#define LCD_DRAWMODE_XOR    (1<<0)
N#define LCD_DRAWMODE_TRANS  (1<<1)
N#define LCD_DRAWMODE_REV    (1<<2)
N
N
N 
N/*      *************************************************************
N        *                                                           *
N        *                Typedefs                                   *
N        *                                                           *
N        *************************************************************
N*/
N
Ntypedef int LCD_DRAWMODE;
Ntypedef U32 LCD_COLOR;
Xtypedef unsigned long LCD_COLOR;
N
N 
N/********************************************************
N*
N*     Data structures
N*
N*********************************************************
N*/
N
Ntypedef struct { I16P x,y; } GUI_POINT;
Xtypedef struct { signed short x,y; } GUI_POINT;
Ntypedef struct { I16 x0,y0,x1,y1; } LCD_RECT;
Xtypedef struct { signed short x0,y0,x1,y1; } LCD_RECT;
N/*typedef struct { GUI_POINT P0, P1; } LCD_RECT; */
N
Ntypedef struct {
N  int              NumEntries; 
N  char             HasTrans;         
N  const LCD_COLOR GUI_UNI_PTR * pPalEntries; 
X  const LCD_COLOR  * pPalEntries; 
N} LCD_LOGPALETTE; 
N
N/* This is used for the simulation only ! */
Ntypedef struct {
N  int x,y;
N  unsigned char KeyStat;
N} LCD_tMouseState;
N
N/*********************************************************************
N*
N*     Index2Color
N
N  This function needs to be int the public part of the software
N  since it is needed by the simulation. Most other driver
N  functions are hidden in the private header file.
N*/
N
Ntypedef LCD_COLOR      tLCDDEV_Index2Color  (int Index);
Ntypedef unsigned int   tLCDDEV_Color2Index  (LCD_COLOR Color);
Ntypedef unsigned int   tLCDDEV_GetIndexMask (void);
NLCD_COLOR      LCD_L0_Index2Color  (int Index);
NLCD_COLOR      LCD_L0_1_Index2Color(int Index);
NLCD_COLOR      LCD_L0_2_Index2Color(int Index);
NLCD_COLOR      LCD_L0_3_Index2Color(int Index);
NLCD_COLOR      LCD_L0_4_Index2Color(int Index);
Nunsigned int   LCD_L0_Color2Index  (LCD_COLOR Color);
Nunsigned int   LCD_L0_1_Color2Index(LCD_COLOR Color);
Nunsigned int   LCD_L0_2_Color2Index(LCD_COLOR Color);
Nunsigned int   LCD_L0_3_Color2Index(LCD_COLOR Color);
Nunsigned int   LCD_L0_4_Color2Index(LCD_COLOR Color);
Nunsigned int   LCD_L0_GetIndexMask  (void);
Nunsigned int   LCD_L0_1_GetIndexMask(void);
Nunsigned int   LCD_L0_2_GetIndexMask(void);
Nunsigned int   LCD_L0_3_GetIndexMask(void);
Nunsigned int   LCD_L0_4_GetIndexMask(void);
N
N
N/*********************************************************************
N*
N*     Color conversion API tables
N*/
N
Ntypedef struct {
N  tLCDDEV_Color2Index*  pfColor2Index;
N  tLCDDEV_Index2Color*  pfIndex2Color;
N  tLCDDEV_GetIndexMask* pfGetIndexMask;
N} LCD_API_COLOR_CONV;
N
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_2;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_4;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8666;
N
N#define GUI_COLOR_CONV_1    &LCD_API_ColorConv_1
N#define GUI_COLOR_CONV_2    &LCD_API_ColorConv_2
N#define GUI_COLOR_CONV_4    &LCD_API_ColorConv_4
N#define GUI_COLOR_CONV_8666 &LCD_API_ColorConv_8666
N
N/*********************************************************************
N*
N*      LCDDEV function table
N*
N**********************************************************************
N
N  Below the routines which need to in an LCDDEV routine table are
N  defined. All of these routines have to be in the low-level driver
N  (LCD_L0) or in the memory device which can be used to replace the
N  driver.
N  The one exception to this is the SetClipRect routine, which would
N  be identical for all drivers and is therefor contained in the
N  level above (LCD).
N*/
Ntypedef void         tLCDDEV_DrawHLine    (int x0, int y0,  int x1);
Ntypedef void         tLCDDEV_DrawVLine    (int x , int y0,  int y1);
Ntypedef void         tLCDDEV_FillRect     (int x0, int y0, int x1, int y1);
Ntypedef unsigned int tLCDDEV_GetPixelIndex(int x, int y);
Ntypedef void         tLCDDEV_SetPixelIndex(int x, int y, int ColorIndex);
Ntypedef void         tLCDDEV_XorPixel     (int x, int y);
Ntypedef void         tLCDDEV_FillPolygon  (const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Ntypedef void         tLCDDEV_FillPolygonAA(const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Ntypedef void         tLCDDEV_GetRect      (LCD_RECT*pRect);
Ntypedef int          tLCDDEV_Init         (void);
Ntypedef void         tLCDDEV_On           (void);
Ntypedef void         tLCDDEV_Off          (void);
Ntypedef void         tLCDDEV_SetLUTEntry  (U8 Pos, LCD_COLOR color);
Xtypedef void         tLCDDEV_SetLUTEntry  (unsigned char Pos, LCD_COLOR color);
Ntypedef void *       tLCDDEV_GetDevFunc   (int Index);
N
N/*********************************************************************
N*
N*     Memory device API tables
N*/
N#if GUI_COMPILER_SUPPORTS_FP
X#if 1
N  typedef struct tLCDDEV_APIList_struct tLCDDEV_APIList;
N#endif
N
Ntypedef void tLCDDEV_DrawBitmap   (int x0, int y0, int xsize, int ysize,
N                       int BitsPerPixel, int BytesPerLine,
N                       const U8 GUI_UNI_PTR * pData, int Diff,
X                       const unsigned char  * pData, int Diff,
N                       const void* pTrans);   /* Really LCD_PIXELINDEX, but is void to avoid compiler warnings*/
N
Nstruct tLCDDEV_APIList_struct {
N  tLCDDEV_Color2Index*        pfColor2Index;
N  tLCDDEV_Index2Color*        pfIndex2Color;
N  tLCDDEV_GetIndexMask*       pfGetIndexMask;
N  tLCDDEV_DrawBitmap*         pfDrawBitmap;
N  tLCDDEV_DrawHLine*          pfDrawHLine;
N  tLCDDEV_DrawVLine*          pfDrawVLine;
N  tLCDDEV_FillRect*           pfFillRect;
N  tLCDDEV_GetPixelIndex*      pfGetPixelIndex;
N  tLCDDEV_GetRect*            pfGetRect;
N  tLCDDEV_SetPixelIndex*      pfSetPixelIndex;
N  tLCDDEV_XorPixel*           pfXorPixel;
N  tLCDDEV_SetLUTEntry*        pfSetLUTEntry;
N  tLCDDEV_GetDevFunc*         pfGetDevFunc;
N  #if GUI_SUPPORT_MEMDEV
X  #if 1
N    tLCDDEV_FillPolygon*      pfFillPolygon;
N    tLCDDEV_FillPolygonAA*    pfFillPolygonAA;
N    const tLCDDEV_APIList*    pMemDevAPI;
N    unsigned                  BitsPerPixel;
N  #endif
N};
N#if GUI_COMPILER_SUPPORTS_FP
X#if 1
N  extern const struct tLCDDEV_APIList_struct GUI_MEMDEV__APIList1;
N  extern const struct tLCDDEV_APIList_struct GUI_MEMDEV__APIList8;
N  extern const struct tLCDDEV_APIList_struct GUI_MEMDEV__APIList16;
N
N  #define GUI_MEMDEV_APILIST_1  &GUI_MEMDEV__APIList1
N  #define GUI_MEMDEV_APILIST_8  &GUI_MEMDEV__APIList8
N  #define GUI_MEMDEV_APILIST_16 &GUI_MEMDEV__APIList16
N#endif
N
N/*      *************************************************************
N        *                                                           *
N        *                   Defines                                 *
N        *                                                           *
N        *    for device capabilities                                *
N        *                                                           *
N        *************************************************************
N
NThe following is the list of device capabilities which can, but do
Nnot have to be implemented in the driver. This way the driver can be
Nenhanced in the future without affecting the driver interface,
Nkeeping older drivers compatible.
NMore DevCaps can always be added in the future, as older drivers
Nare guaranteed to return 0 for all unimplemented features or queries.
N
NThe values below define the legal parameters to the LCD_GetDeviceCaps
Nand the LCD_GetpCapFunc routines.
N*/
N
N#define LCD_DEVCAP_NUMCOLORS    0x0     /* Quest number of colors
N                                           which LCD can display */
N#define LCD_DEVCAP_XSIZE        0x1     /* Quest horiz. res. of display */
N#define LCD_DEVCAP_YSIZE        0x2     /* Quest vert. res. of display */
N#define LCD_DEVCAP_VXSIZE       0x3     /* Quest vert. res. of virtual disp.*/
N#define LCD_DEVCAP_VYSIZE       0x4     /* Quest vert. res. of virtual disp.*/
N#define LCD_DEVCAP_XORG         0x5     /* X-origin ... usually 0 */
N#define LCD_DEVCAP_YORG         0x6     /* Y-origin ... usually 0 */
N#define LCD_DEVCAP_CONTROLLER   0x7     /* LCD Controller (Numerical) */
N#define LCD_DEVCAP_BITSPERPIXEL 0x8     /* Bits per pixel ... 1/2/4/8 */
N#define LCD_DEVCAP_NUMPAGES     0x10    /* Quest number of pages of display */
N
N#define LCD_DEVCAP_COLOR        0x1000  /* Quest Color[0]
N                                0x1001     Quest Color[1]
N                                0x1002     Quest Color[2]
N                                         ...                    */
N /* The next 4095 entries are reserved so up to 4096 colors
N    can be queried          ...*/
N
Nint LCD_GetXSize(void);
Nint LCD_GetXSize_1(void);
Nint LCD_GetXSizeEx(int Index);
N
Nint LCD_GetYSize(void);
Nint LCD_GetYSize_1(void);
Nint LCD_GetYSizeEx(int Index);
N
Nint LCD_GetVXSize(void);
Nint LCD_GetVXSize_1(void);
Nint LCD_GetVXSizeEx(int Index);
N
Nint LCD_GetVYSize(void);
Nint LCD_GetVYSize_1(void);
Nint LCD_GetVYSizeEx(int Index);
N
NU32 LCD_GetNumColors(void);
Xunsigned long LCD_GetNumColors(void);
NU32 LCD_GetNumColors_1(void);
Xunsigned long LCD_GetNumColors_1(void);
NU32 LCD_GetNumColorsEx(int Index);
Xunsigned long LCD_GetNumColorsEx(int Index);
N
Nint LCD_GetBitsPerPixel(void);
Nint LCD_GetBitsPerPixel_1(void);
Nint LCD_GetBitsPerPixelEx(int Index);
N
Nint LCD_GetFixedPalette(void);
Nint LCD_GetFixedPalette_1(void);
NI32 LCD_GetFixedPaletteEx(int Index);
Xsigned long LCD_GetFixedPaletteEx(int Index);
N
Nint LCD_GetXMag(void);
Nint LCD_GetXMag_1(void);
Nint LCD_GetXMagEx(int Index);
N
Nint LCD_GetYMag(void);
Nint LCD_GetYMag_1(void);
Nint LCD_GetYMagEx(int Index);
N
Nint LCD_GetMirrorXEx(int LayerIndex);
Nint LCD_GetMirrorYEx(int LayerIndex);
Nint LCD_GetSwapXYEx(int LayerIndex);
N
Nint LCD_GetSwapRBEx(int LayerIndex);
Nint LCD_GetDeltaModeEx(int LayerIndex);
Nint LCD_GetBitsPerPixel_L0Ex(int LayerIndex);
N
NtLCDDEV_Index2Color * LCD_GetpfIndex2ColorEx(int LayerIndex);
N
Nint LCD_GetNumLayers(void);
N
N#define LCD_GetNumDisplays() LCD_GetNumLayers()
N
N#define LCD_GET_XSIZE()        LCD_GetXSize()
N#define LCD_GET_YSIZE()        LCD_GetYSize()
N#define LCD_GET_VXSIZE()       LCD_GetVXSize()
N#define LCD_GET_VYSIZE()       LCD_GetVYSize()
N#define LCD_GET_NUMCOLORS()    LCD_GetNumColors()
N#define LCD_GET_BITSPERPIXEL() LCD_GetBitsPerPixel()
N
N#define LCD_DEVFUNC_READRECT  0x1     /* Request of a function pointer for reading a rectangular display area */
N
Nvoid * LCD_L0_GetDevFunc(int Index);
N
N/*********************************************************************
N*
N*      LCD_CLIP function table
N*
N**********************************************************************
N*/
Ntypedef void         tLCD_HL_DrawHLine    (int x0, int y0,  int x1);
Ntypedef void         tLCD_HL_DrawPixel    (int x0, int y0);
N
Ntypedef struct {
N  tLCD_HL_DrawHLine*          pfDrawHLine;
N  tLCD_HL_DrawPixel*          pfDrawPixel;
N} tLCD_HL_APIList;
N
Nvoid LCD_DrawHLine(int x0, int y0,  int x1);
Nvoid LCD_DrawPixel(int x0, int y0);
Nvoid LCD_DrawVLine  (int x, int y0,  int y1);
N
N
N
N/*********************************************************************
N*
N*              Declarations for LCD_
N*
N**********************************************************************
N*/
N
Nvoid LCD_SetClipRectEx(const LCD_RECT* pRect);
Nvoid LCD_SetClipRectMax(void);
N
N/* Get device capabilities (0 if not supported) */
NI32  LCD_GetDevCap(int Index);
Xsigned long  LCD_GetDevCap(int Index);
N
N/* Initialize LCD using config-paramters */
Nint LCD_Init(void);
N
Nvoid LCD_SetBkColor   (LCD_COLOR Color); /* Set background color */
Nvoid LCD_SetColor     (LCD_COLOR Color); /* Set foreground color */
Nvoid LCD_SetPixelIndex(int x, int y, int ColorIndex);
N
N/* Palette routines (Not available on all drivers) */
Nvoid LCD_InitLUT(void);
N
N/* Decompressors */
N//typedef void tfDrawSpecialBitmap(int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR *pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
Nvoid         LCD_DrawBitmap_RLE8(int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR *pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
Xvoid         LCD_DrawBitmap_RLE8(int x0,int y0,int xsize, int ysize, const unsigned char  *pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag);
Nvoid         LCD_DrawBitmap_RLE4(int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR *pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
Xvoid         LCD_DrawBitmap_RLE4(int x0,int y0,int xsize, int ysize, const unsigned char  *pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag);
Nvoid         LCD_DrawBitmap_565 (int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR *pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
Xvoid         LCD_DrawBitmap_565 (int x0,int y0,int xsize, int ysize, const unsigned char  *pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag);
Nvoid         LCD_DrawBitmap_M565(int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR *pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
Xvoid         LCD_DrawBitmap_M565(int x0,int y0,int xsize, int ysize, const unsigned char  *pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag);
N
NLCD_DRAWMODE LCD_SetDrawMode  (LCD_DRAWMODE dm);
Nvoid LCD_SetColorIndex(int Index);
Nvoid LCD_SetBkColorIndex(int Index);
Nvoid LCD_FillRect(int x0, int y0, int x1, int y1);
Ntypedef void tLCD_SetPixelAA(int x, int y, U8 Intens);
Xtypedef void tLCD_SetPixelAA(int x, int y, unsigned char Intens);
N
Nvoid LCD_SetPixelAA(int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA(int x, int y, unsigned char Intens);
Nvoid LCD_SetPixelAA_NoTrans(int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA_NoTrans(int x, int y, unsigned char Intens);
N
NLCD_COLOR    LCD_AA_MixColors(LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
XLCD_COLOR    LCD_AA_MixColors(LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
NLCD_COLOR    LCD_MixColors256(LCD_COLOR Color, LCD_COLOR BkColor, unsigned Intens);
NLCD_COLOR    LCD_GetPixelColor(int x, int y);     /* Get RGB color of pixel */
Nunsigned int LCD_GetPixelIndex(int x, int y);
Nint          LCD_GetBkColorIndex (void);
Nint          LCD_GetColorIndex (void);
N
N/*********************************************************************
N*
N*       Optional support for rotatation
N*
N**********************************************************************
N*/
N
N#if GUI_SUPPORT_ROTATION
X#if 1
N
Ntypedef void tLCD_DrawBitmap(int x0, int y0, int xsize, int ysize,
N                             int xMul, int yMul, int BitsPerPixel, int BytesPerLine,
N                             const U8 GUI_UNI_PTR * pPixel, const void * pTrans);
X                             const unsigned char  * pPixel, const void * pTrans);
Ntypedef void tRect2TextRect (LCD_RECT * pRect);
N
Nstruct tLCD_APIList_struct {
N  tLCD_DrawBitmap   * pfDrawBitmap;
N  tRect2TextRect    * pfRect2TextRect;
N};
N
Ntypedef struct tLCD_APIList_struct tLCD_APIList;
N
Nextern tLCD_APIList LCD_APIListCCW;
Nextern tLCD_APIList LCD_APIListCW;
Nextern tLCD_APIList LCD_APIList180;
N
N#define GUI_ROTATION   tLCD_APIList
N#define GUI_ROTATE_CCW &LCD_APIListCCW
N#define GUI_ROTATE_CW  &LCD_APIListCW
N#define GUI_ROTATE_180 &LCD_APIList180
N#define GUI_ROTATE_0   0
N#endif
N
N
N/*      *************************************************************
N        *                                                           *
N        *      LCD  publics not used by GUI                         *
N        *                                                           *
N        *************************************************************
N  
N
NThe following functions can, but do not have to be defined in the LCD driver
Nas they are not used by the GUI level.
N
N*/
N
N
N
N#define LCD_On          LCD_L0_On
N#define LCD_Off         LCD_L0_Off
N#define LCD_ReInit      LCD_L0_ReInit
N#define LCD_SetLUTEntry LCD_L0_SetLUTEntry
N
N
N#define LCD_CC_UNLOCK (0)    /* Default mode: Cache is transparent */
N#define LCD_CC_LOCK   (1)    /* Cache is locked, no write operations */
N#define LCD_CC_FLUSH  (2)    /* Flush cache, do not change mode */
NU8 LCD_L0_ControlCache(U8 mode);
Xunsigned char LCD_L0_ControlCache(unsigned char mode);
NU8 LCD_L0_1_ControlCache(U8 mode);
Xunsigned char LCD_L0_1_ControlCache(unsigned char mode);
NU8 LCD_L0_2_ControlCache(U8 mode);
Xunsigned char LCD_L0_2_ControlCache(unsigned char mode);
NU8 LCD_L0_3_ControlCache(U8 mode);
Xunsigned char LCD_L0_3_ControlCache(unsigned char mode);
NU8 LCD_L0_4_ControlCache(U8 mode);
Xunsigned char LCD_L0_4_ControlCache(unsigned char mode);
Nvoid LCD_L0_Refresh(void);
Nvoid LCD_L0_1_Refresh(void);
Nvoid LCD_L0_2_Refresh(void);
Nvoid LCD_L0_3_Refresh(void);
Nvoid LCD_L0_4_Refresh(void);
N/* Check if controller is still properly initialized */
Nint  LCD_L0_CheckInit(void);        /* returns if init is still O.K.
N                                      by reading all available registers of
N                                      Display controller.
N                                      0: Init O.K.
N                                    */
N
N#define LCD_ControlCache LCD_L0_ControlCache
N
N/*
N        ******************************************
N        *                                        *
N        *        Support for paging              *
N        *                                        *
N        ******************************************
N*/
N
Nint LCD_SelPage  (int NewPage);    /* returns formerly sel. page */
Nint LCD_ShowPage (int NewPage);    /* sets / returns visible page */
Nint LCD_GetSelPage (void);         /* returns selected page */
Nint LCD_GetVisPage (void);         /* returns visible page */
N
N
N/*      *************************************************************
N        *                                                           *
N        *      LCD  imports                                         *
N        *                  (for routines in LCDColor)               *
N        *                                                           *
N        *************************************************************
N*/
N  
N
Nint              LCD_Color2Index     (LCD_COLOR Color);
NLCD_COLOR        LCD_Index2Color     (int Index);
NLCD_COLOR        LCD_Index2ColorEx   (int i, unsigned int LayerIndex);
N
N/*********************************************************************
N*
N*       LCD_X_...
N*
N**********************************************************************
N*/
N
Nvoid LCD_X_Init(void);
Nvoid LCD_X_On  (void);
Nvoid LCD_X_Off (void);
N
Nchar LCD_X_Read00(void);
Nchar LCD_X_Read01(void);
Nvoid LCD_X_Write00(char c);
Nvoid LCD_X_Write01(char c);
Nvoid LCD_X_WriteM01(char * pData, int NumBytes);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif /* LCD_H */
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 28 "..\GUI\Core\GUIType.h" 2
N#include "GUIConf.h"
N
N/*      *************************************************************
N        *                                                           *
N        *                Simple types                               *
N        *                                                           *
N        *************************************************************
N*/
N
Ntypedef const char *  GUI_ConstString;
N
N
N/*      *************************************************************
N        *                                                           *
N        *                Structures                                 *
N        *                                                           *
N        *************************************************************
N*/
N
Ntypedef LCD_COLOR       GUI_COLOR;
Ntypedef LCD_LOGPALETTE  GUI_LOGPALETTE;
Ntypedef LCD_DRAWMODE    GUI_DRAWMODE;
Ntypedef LCD_RECT        GUI_RECT;
N
Ntypedef struct {
N  void      (* pfDraw)(int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR * pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
X  void      (* pfDraw)(int x0,int y0,int xsize, int ysize, const unsigned char  * pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag);
N  GUI_COLOR (* pfIndex2Color)(int Index);
N} GUI_BITMAP_METHODS;
N
Ntypedef struct {
N  U16P XSize;
X  unsigned short XSize;
N  U16P YSize;
X  unsigned short YSize;
N  U16P BytesPerLine;
X  unsigned short BytesPerLine;
N  U16P BitsPerPixel;
X  unsigned short BitsPerPixel;
N  const U8 GUI_UNI_PTR * pData;
X  const unsigned char  * pData;
N  const GUI_LOGPALETTE GUI_UNI_PTR * pPal;
X  const GUI_LOGPALETTE  * pPal;
N  const GUI_BITMAP_METHODS * pMethods;
N} GUI_BITMAP;
N
N/* This structure may not be changed because the data that it
N   expects is read in binary form (via any kind of interface,
N   at runtime).
N   This structure should therefor not be changed.
N*/
Ntypedef struct {
N  U16 ID;           /* Version 1.00 => 100*/
X  unsigned short ID;            
N  U16 Version;
X  unsigned short Version;
N  U16 XSize;
X  unsigned short XSize;
N  U16 YSize;
X  unsigned short YSize;
N  U16 BytesPerLine;
X  unsigned short BytesPerLine;
N  U16 BitsPerPixel;
X  unsigned short BitsPerPixel;
N  U16 NumColors;
X  unsigned short NumColors;
N  U16 HasTrans;
X  unsigned short HasTrans;
N} GUI_BITMAP_STREAM;
N
Ntypedef struct {
N  int x,y;
N  unsigned char Pressed;
N} GUI_PID_STATE;
N
Ntypedef struct {
N  int xPos;
N  int yPos;
N  int xSize;
N  int ySize;
N  int Delay;
N} GUI_GIF_IMAGE_INFO;
N
Ntypedef struct {
N  int xSize;
N  int ySize;
N  int NumImages;
N} GUI_GIF_INFO;
N
N/*
N      ****************************************
N      *                                      *
N      *      FONT structures (new in V1.10)  *
N      *                                      *
N      ****************************************
N*/
N
N/* Translation list. Translates a character code into up to 2
N   indices of images to display on top of each other;
N   'á' -> index('a'), index('´') */
Ntypedef struct {
N  I16P c0;
X  signed short c0;
N  I16P c1;
X  signed short c1;
N} GUI_FONT_TRANSLIST;
N
Ntypedef struct {
N  U16P FirstChar;
X  unsigned short FirstChar;
N  U16P LastChar;
X  unsigned short LastChar;
N  const GUI_FONT_TRANSLIST GUI_UNI_PTR * pList;
X  const GUI_FONT_TRANSLIST  * pList;
N} GUI_FONT_TRANSINFO;
N
Ntypedef struct {
N  U8 XSize;
X  unsigned char XSize;
N  U8 XDist;
X  unsigned char XDist;
N  U8 BytesPerLine;
X  unsigned char BytesPerLine;
N  const unsigned char GUI_UNI_PTR * pData;
X  const unsigned char  * pData;
N} GUI_CHARINFO;
N
Ntypedef struct GUI_FONT_PROP {
N  U16P First;                                /* first character               */
X  unsigned short First;                                 
N  U16P Last;                                 /* last character                */
X  unsigned short Last;                                  
N  const GUI_CHARINFO GUI_UNI_PTR * paCharInfo;            /* address of first character    */
X  const GUI_CHARINFO  * paCharInfo;             
N  const struct GUI_FONT_PROP GUI_UNI_PTR * pNext;        /* pointer to next */
X  const struct GUI_FONT_PROP  * pNext;         
N} GUI_FONT_PROP;
N
Ntypedef struct {
N  const unsigned char GUI_UNI_PTR * pData;
X  const unsigned char  * pData;
N  const U8 GUI_UNI_PTR * pTransData;
X  const unsigned char  * pTransData;
N  const GUI_FONT_TRANSINFO GUI_UNI_PTR * pTrans;
X  const GUI_FONT_TRANSINFO  * pTrans;
N  U16P FirstChar;
X  unsigned short FirstChar;
N  U16P LastChar;
X  unsigned short LastChar;
N  U8 XSize;
X  unsigned char XSize;
N  U8 XDist;
X  unsigned char XDist;
N  U8 BytesPerLine;
X  unsigned char BytesPerLine;
N} GUI_FONT_MONO;
N
N
Ntypedef struct GUI_FONT_INFO {
N  U16P First;                        /* first character               */
X  unsigned short First;                         
N  U16P Last;                         /* last character                */
X  unsigned short Last;                          
N  const GUI_CHARINFO* paCharInfo;    /* address of first character    */
N  const struct GUI_FONT_INFO* pNext; /* pointer to next */
N} GUI_FONT_INFO;
N
N/*
N      ****************************************
N      *                                      *
N      *      FONT info structure             *
N      *                                      *
N      ****************************************
N
NThis structure is used when retrieving information about a font.
NIt is designed for future expansion without incompatibilities.
N*/
Ntypedef struct {
N  U16 Flags;
X  unsigned short Flags;
N  U8 Baseline;
X  unsigned char Baseline;
N  U8 LHeight;     /* height of a small lower case character (a,x) */
X  unsigned char LHeight;      
N  U8 CHeight;     /* height of a small upper case character (A,X) */
X  unsigned char CHeight;      
N} GUI_FONTINFO;
N
N#define GUI_FONTINFO_FLAG_PROP (1<<0)    /* Is proportional */
N#define GUI_FONTINFO_FLAG_MONO (1<<1)    /* Is monospaced */
N#define GUI_FONTINFO_FLAG_AA   (1<<2)    /* Is an antialiased font */
N#define GUI_FONTINFO_FLAG_AA2  (1<<3)    /* Is an antialiased font, 2bpp */
N#define GUI_FONTINFO_FLAG_AA4  (1<<4)    /* Is an antialiased font, 4bpp */
N
N
N/**********************************************************************
N*
N*         UNICODE Encoding
N*
N***********************************************************************
N*/
Ntypedef U16  tGUI_GetCharCode(const char GUI_UNI_PTR *s);
Xtypedef unsigned short  tGUI_GetCharCode(const char  *s);
Ntypedef int  tGUI_GetCharSize(const char GUI_UNI_PTR *s);
Xtypedef int  tGUI_GetCharSize(const char  *s);
Ntypedef int  tGUI_CalcSizeOfChar(U16 Char);
Xtypedef int  tGUI_CalcSizeOfChar(unsigned short Char);
Ntypedef int  tGUI_Encode(char *s, U16 Char);
Xtypedef int  tGUI_Encode(char *s, unsigned short Char);
N
Ntypedef struct {
N  tGUI_GetCharCode*            pfGetCharCode;
N  tGUI_GetCharSize*            pfGetCharSize;
N  tGUI_CalcSizeOfChar*         pfCalcSizeOfChar;
N  tGUI_Encode*                 pfEncode;
N} GUI_UC_ENC_APILIST;
N
N/**********************************************************************
N*
N*                 FONT Encoding
N*
N***********************************************************************
N*/
N
Ntypedef int  tGUI_GetLineDistX(const char GUI_UNI_PTR *s, int Len);
Xtypedef int  tGUI_GetLineDistX(const char  *s, int Len);
Ntypedef int  tGUI_GetLineLen(const char GUI_UNI_PTR *s, int MaxLen);
Xtypedef int  tGUI_GetLineLen(const char  *s, int MaxLen);
Ntypedef void tGL_DispLine(const char GUI_UNI_PTR *s, int Len);
Xtypedef void tGL_DispLine(const char  *s, int Len);
N
Ntypedef struct {
N  tGUI_GetLineDistX*          pfGetLineDistX;
N  tGUI_GetLineLen*            pfGetLineLen;
N  tGL_DispLine*               pfDispLine;
N} tGUI_ENC_APIList;
N
Nextern const tGUI_ENC_APIList GUI_ENC_APIList_SJIS;
N
N
N/*
N      ****************************************
N      *                                      *
N      *      FONT methods                    *
N      *                                      *
N      ****************************************
N
NThe parameter to the methods called pFont should be of type
NGUI_FONT, but unfortunately a lot of compilers can not handle
Nforward declarations right ...
NSo it ends up to be a void pointer.
N*/
N
Ntypedef struct GUI_FONT GUI_FONT;
N
Ntypedef void GUI_DISPCHAR(U16 c);
Xtypedef void GUI_DISPCHAR(unsigned short c);
Ntypedef int  GUI_GETCHARDISTX(U16P c);
Xtypedef int  GUI_GETCHARDISTX(unsigned short c);
Ntypedef void GUI_GETFONTINFO(const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO * pfi);
Xtypedef void GUI_GETFONTINFO(const GUI_FONT  * pFont, GUI_FONTINFO * pfi);
Ntypedef char GUI_ISINFONT   (const GUI_FONT GUI_UNI_PTR * pFont, U16 c);
Xtypedef char GUI_ISINFONT   (const GUI_FONT  * pFont, unsigned short c);
N
N#define DECLARE_FONT(Type)                                     \
Nvoid GUI##Type##_DispChar    (U16P c);                         \
Nint  GUI##Type##_GetCharDistX(U16P c);                         \
Nvoid GUI##Type##_GetFontInfo (const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO * pfi); \
Nchar GUI##Type##_IsInFont    (const GUI_FONT GUI_UNI_PTR * pFont, U16 c)
X#define DECLARE_FONT(Type)                                     void GUI##Type##_DispChar    (U16P c);                         int  GUI##Type##_GetCharDistX(U16P c);                         void GUI##Type##_GetFontInfo (const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO * pfi); char GUI##Type##_IsInFont    (const GUI_FONT GUI_UNI_PTR * pFont, U16 c)
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/* MONO: Monospaced fonts */
NDECLARE_FONT(MONO);
Xvoid GUIMONO_DispChar (unsigned short c); int GUIMONO_GetCharDistX(unsigned short c); void GUIMONO_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIMONO_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_MONO       \
N  GUIMONO_DispChar,             \
N	GUIMONO_GetCharDistX,         \
N	GUIMONO_GetFontInfo,          \
N	GUIMONO_IsInFont,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_MONO         GUIMONO_DispChar,             	GUIMONO_GetCharDistX,         	GUIMONO_GetFontInfo,          	GUIMONO_IsInFont,               (tGUI_ENC_APIList*)0
N
N/* PROP: Proportional fonts */
NDECLARE_FONT(PROP);
Xvoid GUIPROP_DispChar (unsigned short c); int GUIPROP_GetCharDistX(unsigned short c); void GUIPROP_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_PROP       \
N  GUIPROP_DispChar,             \
N	GUIPROP_GetCharDistX,         \
N	GUIPROP_GetFontInfo,          \
N	GUIPROP_IsInFont,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP         GUIPROP_DispChar,             	GUIPROP_GetCharDistX,         	GUIPROP_GetFontInfo,          	GUIPROP_IsInFont,               (tGUI_ENC_APIList*)0
N
N/* PROP: Proportional fonts SJIS */
NDECLARE_FONT(PROP);
Xvoid GUIPROP_DispChar (unsigned short c); int GUIPROP_GetCharDistX(unsigned short c); void GUIPROP_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_PROP_SJIS  \
N  GUIPROP_DispChar,             \
N	GUIPROP_GetCharDistX,         \
N	GUIPROP_GetFontInfo,          \
N	GUIPROP_IsInFont,             \
N  &GUI_ENC_APIList_SJIS
X#define GUI_FONTTYPE_PROP_SJIS    GUIPROP_DispChar,             	GUIPROP_GetCharDistX,         	GUIPROP_GetFontInfo,          	GUIPROP_IsInFont,               &GUI_ENC_APIList_SJIS
N
N/* PROPAA: Proportional, antialiased fonts */
NDECLARE_FONT(PROPAA);
Xvoid GUIPROPAA_DispChar (unsigned short c); int GUIPROPAA_GetCharDistX(unsigned short c); void GUIPROPAA_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROPAA_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_PROPAA       \
N  GUIPROPAA_DispChar,             \
N	GUIPROPAA_GetCharDistX,         \
N	GUIPROPAA_GetFontInfo,          \
N	GUIPROPAA_IsInFont,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROPAA         GUIPROPAA_DispChar,             	GUIPROPAA_GetCharDistX,         	GUIPROPAA_GetFontInfo,          	GUIPROPAA_IsInFont,               (tGUI_ENC_APIList*)0
N
N/* PROPAA: Proportional, antialiased fonts, 2bpp */
NDECLARE_FONT(PROP_AA2);
Xvoid GUIPROP_AA2_DispChar (unsigned short c); int GUIPROP_AA2_GetCharDistX(unsigned short c); void GUIPROP_AA2_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA2_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_PROP_AA2       \
N  GUIPROP_AA2_DispChar,             \
N	GUIPROP_AA2_GetCharDistX,         \
N	GUIPROP_AA2_GetFontInfo,          \
N	GUIPROP_AA2_IsInFont,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_AA2         GUIPROP_AA2_DispChar,             	GUIPROP_AA2_GetCharDistX,         	GUIPROP_AA2_GetFontInfo,          	GUIPROP_AA2_IsInFont,               (tGUI_ENC_APIList*)0
N
N/* PROPAA: Proportional, antialiased fonts, 2bpp, SJIS encoding */
NDECLARE_FONT(PROP_AA2);
Xvoid GUIPROP_AA2_DispChar (unsigned short c); int GUIPROP_AA2_GetCharDistX(unsigned short c); void GUIPROP_AA2_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA2_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_PROP_AA2_SJIS  \
N  GUIPROP_AA2_DispChar,             \
N	GUIPROP_AA2_GetCharDistX,         \
N	GUIPROP_AA2_GetFontInfo,          \
N	GUIPROP_AA2_IsInFont,             \
N  GUI_ENCODE_SJIS
X#define GUI_FONTTYPE_PROP_AA2_SJIS    GUIPROP_AA2_DispChar,             	GUIPROP_AA2_GetCharDistX,         	GUIPROP_AA2_GetFontInfo,          	GUIPROP_AA2_IsInFont,               GUI_ENCODE_SJIS
N
N/* PROPAA: Proportional, antialiased fonts, 4bpp */
NDECLARE_FONT(PROP_AA4);
Xvoid GUIPROP_AA4_DispChar (unsigned short c); int GUIPROP_AA4_GetCharDistX(unsigned short c); void GUIPROP_AA4_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA4_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_PROP_AA4       \
N  GUIPROP_AA4_DispChar,             \
N	GUIPROP_AA4_GetCharDistX,         \
N	GUIPROP_AA4_GetFontInfo,          \
N	GUIPROP_AA4_IsInFont,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_AA4         GUIPROP_AA4_DispChar,             	GUIPROP_AA4_GetCharDistX,         	GUIPROP_AA4_GetFontInfo,          	GUIPROP_AA4_IsInFont,               (tGUI_ENC_APIList*)0
N
N/* PROPAA: Proportional, antialiased fonts, 4bpp, SJIS encoding */
NDECLARE_FONT(PROP_AA4);
Xvoid GUIPROP_AA4_DispChar (unsigned short c); int GUIPROP_AA4_GetCharDistX(unsigned short c); void GUIPROP_AA4_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA4_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_PROP_AA4_SJIS  \
N  GUIPROP_AA4_DispChar,             \
N	GUIPROP_AA4_GetCharDistX,         \
N	GUIPROP_AA4_GetFontInfo,          \
N	GUIPROP_AA4_IsInFont,             \
N  GUI_ENCODE_SJIS
X#define GUI_FONTTYPE_PROP_AA4_SJIS    GUIPROP_AA4_DispChar,             	GUIPROP_AA4_GetCharDistX,         	GUIPROP_AA4_GetFontInfo,          	GUIPROP_AA4_IsInFont,               GUI_ENCODE_SJIS
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
Nstruct GUI_FONT {
N  GUI_DISPCHAR*     pfDispChar; 
N  GUI_GETCHARDISTX* pfGetCharDistX; 
N  GUI_GETFONTINFO*  pfGetFontInfo; 
N  GUI_ISINFONT*     pfIsInFont;
N  const tGUI_ENC_APIList* pafEncode;
N  U8 YSize;
X  unsigned char YSize;
N  U8 YDist;
X  unsigned char YDist;
N  U8 XMag;
X  unsigned char XMag;
N  U8 YMag;
X  unsigned char YMag;
N  union {
N    const void          GUI_UNI_PTR * pFontData;
X    const void           * pFontData;
N    const GUI_FONT_MONO GUI_UNI_PTR * pMono;
X    const GUI_FONT_MONO  * pMono;
N    const GUI_FONT_PROP GUI_UNI_PTR * pProp;
X    const GUI_FONT_PROP  * pProp;
N  } p;
N  U8 Baseline;
X  unsigned char Baseline;
N  U8 LHeight;     /* height of a small lower case character (a,x) */
X  unsigned char LHeight;      
N  U8 CHeight;     /* height of a small upper case character (A,X) */
X  unsigned char CHeight;      
N};
N
N/*********************************************************************
N*
N*       Position independent font structures
N*/
Ntypedef struct {
N  U32 ID;           /* Font file ID */
X  unsigned long ID;            
N  U16 YSize;        /* Height of font */
X  unsigned short YSize;         
N  U16 YDist;        /* Space of font Y */
X  unsigned short YDist;         
N  U16 Baseline;     /* Index of baseline */
X  unsigned short Baseline;      
N  U16 LHeight;      /* Height of a small lower case character (a) */
X  unsigned short LHeight;       
N  U16 CHeight;      /* Height of a upper case character (A) */
X  unsigned short CHeight;       
N  U16 NumAreas;     /* Number of character areas */
X  unsigned short NumAreas;      
N} GUI_SI_FONT;
N
Ntypedef struct {
N  U16 First;        /* Index of first character */
X  unsigned short First;         
N  U16 Last;         /* Index of last character */
X  unsigned short Last;          
N} GUI_SIF_CHAR_AREA;
N
Ntypedef struct {
N  U16 XSize;        /* Size of bitmap data in X */
X  unsigned short XSize;         
N  U16 XDist;        /* Number of pixels for increment cursor in X */
X  unsigned short XDist;         
N  U16 BytesPerLine; /* Number of bytes per line */
X  unsigned short BytesPerLine;  
N  U16 Dummy;
X  unsigned short Dummy;
N  U32 OffData;      /* Offset of pixel data */
X  unsigned long OffData;       
N} GUI_SIF_CHARINFO;
N
Ntypedef struct tGUI_SIF_APIList_struct {
N  GUI_DISPCHAR     * pDispChar;
N  GUI_GETCHARDISTX * pGetCharDistX;
N  GUI_GETFONTINFO  * pGetFontInfo;
N  GUI_ISINFONT     * pIsInFont;
N} tGUI_SIF_APIList;
N
N#define GUI_SIF_TYPE          tGUI_SIF_APIList
N#define GUI_SIF_TYPE_PROP     &GUI_SIF_APIList_Prop
N#define GUI_SIF_TYPE_PROP_AA2 &GUI_SIF_APIList_Prop_AA2
N#define GUI_SIF_TYPE_PROP_AA4 &GUI_SIF_APIList_Prop_AA4
N
N/*
N      *********************************
N      *                               *
N      *      Typedefs                 *
N      *                               *
N      *********************************
N*/
N
N#ifndef     GUI_HMEM
N  #if GUI_MAXBLOCKS < 32768
X  #if (2 + (1024*30) / 32) < 32768
N    #define     GUI_HMEM        I16P
N  #else
S    #define     GUI_HMEM        I32
N  #endif
N#endif
N#define     GUI_HMEM_NULL     (0)
Ntypedef     GUI_HMEM      GUI_HWIN;
Xtypedef     signed short      GUI_HWIN;
N#endif  /* GUITYPE_H_INCLUDED */
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 26 "..\GUI\WM\WM.h" 2
N#include "WM_GUI.h"       /* Some functions needed by GUI routines */
L 1 "..\GUI\WM\WM_GUI.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : WM_GUI.h
NPurpose     : Windows manager include for low level GUI routines
N----------------------------------------------------------------------
N*/
N
N#ifndef WM_GUI_H            /* Make sure we only include it once */
N#define WM_GUI_H
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
Nint       WM__InitIVRSearch(const GUI_RECT* pMaxRect);
Nint       WM__GetNextIVR   (void);
Nint       WM__GetOrgX_AA(void);
Nint       WM__GetOrgY_AA(void);
N
N#define WM_ITERATE_START(pRect)                   \
N  {                                               \
N    if (WM__InitIVRSearch(pRect))                 \
N      do {
X#define WM_ITERATE_START(pRect)                     {                                                   if (WM__InitIVRSearch(pRect))                       do {
N
N#define WM_ITERATE_END()                          \
N    } while (WM__GetNextIVR());                   \
N  }
X#define WM_ITERATE_END()                              } while (WM__GetNextIVR());                     }
N
N#define WM_ADDORGX(x)    x += GUI_Context.xOff
N#define WM_ADDORGY(y)    y += GUI_Context.yOff
N#define WM_ADDORG(x0,y0) WM_ADDORGX(x0); WM_ADDORGY(y0)
N#define WM_ADDORGX_AA(x)    x += WM__GetOrgX_AA()
N#define WM_ADDORGY_AA(y)    y += WM__GetOrgY_AA()
N#define WM_ADDORG_AA(x0,y0) WM_ADDORGX_AA(x0); WM_ADDORGY_AA(y0)
N#define WM_SUBORGX(x)    x -= GUI_Context.xOff
N#define WM_SUBORGY(y)    y -= GUI_Context.yOff
N#define WM_SUBORG(x0,y0) WM_SUBORGX(x0); WM_SUBORGY(y0)
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N
N#endif   /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 27 "..\GUI\WM\WM.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/* Support for transparency. Switching it off makes Wm smaller and faster */
N#ifndef WM_SUPPORT_TRANSPARENCY
N  #define WM_SUPPORT_TRANSPARENCY 1 /* Should be defined outside of GUI_WINSUPPORT because of "#if GUI_WINSUPPORT && WM_SUPPORT_TRANSPARENCY" in some files */
N#endif
N
N/* This is for tests only. It will fill the invalid area of a window.
N   Can be used for debugging. */
N#ifndef WM_SUPPORT_DIAG
N  #ifdef WIN32   /* In simulation */
S    #define WM_SUPPORT_DIAG GUI_WINSUPPORT
N  #else
N    #define WM_SUPPORT_DIAG 0
N  #endif
N#endif
N
N/* Make sure we actually have configured windows. If we have not,
N  there is no point for a windows manager and it will therefor not
N  generate any code !
N*/
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*              Config defaults
N*
N**********************************************************************
N*/
N
N#ifndef WM_ASSERT
N  #define WM_ASSERT(expr) GUI_DEBUG_ASSERT(expr)
N#endif
N
N#ifndef WM_SUPPORT_TOUCH
N  #define WM_SUPPORT_TOUCH        GUI_SUPPORT_TOUCH
N#endif
N
N#ifndef WM_SUPPORT_OBSTRUCT
N  #define WM_SUPPORT_OBSTRUCT 1
N#endif
N
N/* Allow older API calls */
N#ifndef WM_COMPATIBLE_MODE
N  #define WM_COMPATIBLE_MODE 1
N#endif
N
N/* Send a message if visibility of a window has changed */
N#ifndef WM_SUPPORT_NOTIFY_VIS_CHANGED
N  #define WM_SUPPORT_NOTIFY_VIS_CHANGED 0
N#endif
N
N
N/*
N      *************************************************************
N      *                                                           *
N      *               Configuration check                         *
N      *                                                           *
N      *************************************************************
N*/
N
N/*
N      *************************************************************
N      *                                                           *
N      *               Locking macros                              *
N      *                                                           *
N      *************************************************************
N  For performance reasons, the windows manager uses the same locking mechanisms
N  as the GUI layer. The advantage is that wiht a single call to GUI_LOCK both
N  the graphic level and the WM level are covered.
N*/
N
N#define WM_LOCK()   GUI_LOCK()
N#define WM_UNLOCK() GUI_UNLOCK()
N
N/************************************************************
N*
N*          Data types
N*
N*************************************************************
N*/
N
Ntypedef struct {
N  int Key, PressedCnt;
N} WM_KEY_INFO;
N
Ntypedef struct {
N  int NumItems, v, PageSize;
N} WM_SCROLL_STATE;
N
Ntypedef struct {
N  int Done;
N  int ReturnValue;
N} WM_DIALOG_STATUS;
N
Ntypedef struct {
N  int x,y;
N  U8  State;
X  unsigned char  State;
N  U8  StatePrev;
X  unsigned char  StatePrev;
N} WM_PID_STATE_CHANGED_INFO;
N
N
N
N/*********************************************************************
N*
N*               Messages Ids
N
NThe following is the list of windows messages.
N*/
N
N
N#define WM_CREATE                   0x0001  /* The first message received, right after client has actually been created */
N#define WM_MOVE                     0x0003  /* window has been moved (Same as WIN32) */
N
N#define WM_SIZE                     0x0005  /* Is sent to a window after its size has changed (Same as WIN32, do not change !) */
N
N#define WM_DELETE                   11      /* Delete (Destroy) command: This tells the client to free its data strutures since the window
N                                               it is associates with no longer exists.*/
N#define WM_TOUCH                    12      /* Touch screen message */
N#define WM_TOUCH_CHILD              13      /* Touch screen message to ancestors */
N#define WM_KEY                      14      /* Key has been pressed */
N
N#define WM_PAINT                    0x000F  /* Repaint window (because content is (partially) invalid */
N
N#if GUI_SUPPORT_MOUSE
X#if 0
S#define WM_MOUSEOVER                16      /* Mouse has moved, no key pressed */
S#define WM_MOUSEOVER_END            18      /* Mouse has moved, no key pressed */
N#endif
N
N#define WM_PID_STATE_CHANGED        17      /* Pointer input device state has changed */
N
N#define WM_GET_INSIDE_RECT          20      /* get inside rectangle: client rectangle minus pixels lost to effect */
N#define WM_GET_ID                   21      /* Get id of widget */
N#define WM_SET_ID                   22      /* Set id of widget */
N#define WM_GET_CLIENT_WINDOW        23      /* Get window handle of client window. Default is the same as window */
N#define WM_CAPTURE_RELEASED         24      /* Let window know that mouse capture is over */
N
N#define WM_INIT_DIALOG              29      /* Inform dialog that it is ready for init */
N
N#define WM_SET_FOCUS                30      /* Inform window that it has gotten or lost the focus */
N#define WM_GET_ACCEPT_FOCUS         31      /* Find out if window can accept the focus */
N#define WM_NOTIFY_CHILD_HAS_FOCUS   32      /* Sent to parent when child receives / loses focus */
N
N#define WM_NOTIFY_OWNER_KEY         33      /* Some widgets (e.g. listbox) notify owner when receiving key messages */
N
N#define WM_GET_BKCOLOR              34      /* Return back ground color (only frame window and similar) */
N#define WM_GET_SCROLL_STATE         35      /* Query state of scroll bar */
N
N#define WM_SET_SCROLL_STATE         36      /* Set scroll info ... only effective for scrollbars */
N
N#define WM_NOTIFY_CLIENTCHANGE      37      /* Client area may have changed */
N#define WM_NOTIFY_PARENT            38      /* Notify parent. Information is detailed as notification code */
N#define WM_NOTIFY_PARENT_REFLECTION 39      /* Notify parent reflection. 
N                                               Sometimes send back as a result of the WM_NOTIFY_PARENT message
N                                               to let child react on behalf of its parent.
N                                               Information is detailed as notification code */
N#define WM_NOTIFY_ENABLE            40      /* Enable or disable widget */
N#define WM_NOTIFY_VIS_CHANGED       41      /* Visibility of a window has or may have changed */
N
N#define WM_HANDLE_DIALOG_STATUS     42      /* Set or get dialog status */
N#define WM_GET_RADIOGROUP           43      /* Send to all siblings and children of a radio control when
N                                               selection changed */
N#define WM_MENU                     44      /* Send to owner window of menu widget */
N#define WM_SCREENSIZE_CHANGED       45      /* Send to all windows when size of screen has changed */
N
N#define WM_TIMER                    0x0113  /* Timer has expired              (Keep the same as WIN32) */
N#define WM_WIDGET                   0x0300  /* 256 messages reserved for Widget messages */
N#define WM_USER                     0x0400  /* Reserved for user messages ... (Keep the same as WIN32) */
N
N
N/*********************************************************************
N*
N*               Notification codes
N*
N* The following is the list of notification codes send
N* with the WM_NOTIFY_PARENT message
N*/
N#define WM_NOTIFICATION_CLICKED             1
N#define WM_NOTIFICATION_RELEASED            2
N#define WM_NOTIFICATION_MOVED_OUT           3
N#define WM_NOTIFICATION_SEL_CHANGED         4
N#define WM_NOTIFICATION_VALUE_CHANGED       5
N#define WM_NOTIFICATION_SCROLLBAR_ADDED     6      /* Scroller added */
N#define WM_NOTIFICATION_CHILD_DELETED       7      /* Inform window that child is about to be deleted */
N#define WM_NOTIFICATION_GOT_FOCUS           8
N#define WM_NOTIFICATION_LOST_FOCUS          9
N#define WM_NOTIFICATION_SCROLL_CHANGED     10
N
N#define WM_NOTIFICATION_WIDGET             11      /* Space for widget defined notifications */
N#define WM_NOTIFICATION_USER               16      /* Space for  application (user) defined notifications */
N/*********************************************************************
N*
N*       Memory management
N*/
N
N#define WM_HWIN        GUI_HWIN
N#define WM_HWIN_NULL   GUI_HMEM_NULL
N#define WM_HMEM        GUI_HMEM
N#define WM_HMEM_NULL   GUI_HMEM_NULL
N
N/*********************************************************************
N*
N*       Window defines
N*/
N#define WM_HBKWIN      WM_GetDesktopWindow()                /* Handle of background window */
N#define WM_UNATTACHED  ((WM_HMEM)-1)                        /* Do not attach to a window */
N
N
N/*********************************************************************
N*
N*           Window create flags.
N* These flags can be passed to the create window
N* function as flag-parameter. The flags are combinable using the
N* binary or operator.
N*/
N
N#define WM_CF_HASTRANS         (1<<0)  /* Has transparency. Needs to be defined for windows which do not fill the entire
N                                          section of their (client) rectangle. */
N#define WM_CF_HIDE             (0<<1)  /* Hide window after creation (default !) */
N#define WM_CF_SHOW             (1<<1)  /* Show window after creation */
N#define WM_CF_MEMDEV           (1<<2)  /* Use memory device for redraws */
N#define WM_CF_STAYONTOP        (1<<3)  /* Stay on top */
N#define WM_CF_DISABLED         (1<<4)  /* Disabled: Does not receive PID (mouse & touch) input */
N/* Create only flags ... Not available as status flags */
N#define WM_CF_ACTIVATE         (1<<5)  /* If automatic activation upon creation of window is desired */
N#define WM_CF_FGND             (0<<6)  /* Put window in foreground after creation (default !) */
N#define WM_CF_BGND             (1<<6)  /* Put window in background after creation */
N
N/* Anchor flags */
N#define WM_CF_ANCHOR_RIGHT     (1<<7)  /* Right anchor ... If parent is resized, distance to right will remain const (left is default) */
N#define WM_CF_ANCHOR_BOTTOM    (1<<8)  /* Bottom anchor ... If parent is resized, distance to bottom will remain const (top is default) */
N#define WM_CF_ANCHOR_LEFT      (1<<9)  /* Left anchor ... If parent is resized, distance to left will remain const (left is default) */
N#define WM_CF_ANCHOR_TOP       (1<<10) /* Top anchor ... If parent is resized, distance to top will remain const (top is default) */
N
N#define WM_CF_CONST_OUTLINE    (1<<11) /* Constant outline. This is relevant for transparent windows only. If a window is transparent
N                                       and does not have a constant outline, its background is invalided instead of the window itself.
N                                       This causes add. computation time when redrawing. */
N#define WM_CF_LATE_CLIP        (1<<12)
N#define WM_CF_MEMDEV_ON_REDRAW (1<<13)
N#define WM_CF_RESERVED3        (1<<14)
N#define WM_CF_RESERVED4        (1<<15)
N
N/*********************************************************************
N*
N*           Window manager types
N*/
N
Ntypedef struct WM_Obj     WM_Obj;
Ntypedef struct WM_OBJ_X   WM_OBJ_X;
Ntypedef struct WM_MESSAGE WM_MESSAGE;
N
Ntypedef void WM_CALLBACK( WM_MESSAGE* pMsg);
N
Nstruct WM_MESSAGE {
N  int MsgId;            /* type of message */
N  WM_HWIN hWin;         /* Destination window */
X  GUI_HWIN hWin;          
N  WM_HWIN hWinSrc;      /* Source window  */
X  GUI_HWIN hWinSrc;       
N  union {
N    const void* p;            /* Some messages need more info ... Pointer is declared "const" because some systems (M16C) have 4 byte const, byte 2 byte default ptrs */
N    int v;
N    GUI_COLOR Color;
N  } Data;
N};
N
Nstruct WM_Obj {
N  GUI_RECT Rect;        /* Outer dimensions of window */
N  GUI_RECT InvalidRect; /* Invalid rectangle */
N  WM_CALLBACK* cb;      /* Ptr to notification callback */
N  WM_HWIN hNextLin;     /* Next window in linear list */
X  GUI_HWIN hNextLin;      
N  WM_HWIN hParent;
X  GUI_HWIN hParent;
N  WM_HWIN hFirstChild;
X  GUI_HWIN hFirstChild;
N  WM_HWIN hNext;
X  GUI_HWIN hNext;
N  U16 Status;	          /* Some status flags */
X  unsigned short Status;	           
N};
N
Nstruct WM_OBJ_X {       /* For debugging only if a pointer-based memory management is used */
N  int    Dummy;
N  struct WM_Obj Win;
N};
N
Ntypedef void WM_tfPollPID(void);
Ntypedef void WM_tfForEach(WM_HWIN hWin, void * pData);
Xtypedef void WM_tfForEach(GUI_HWIN hWin, void * pData);
N
N/*
N**********************************************************************
N*
N*              General control routines
N*
N**********************************************************************
N*/
N
N
Nvoid WM_Activate  (void);
Nvoid WM_Deactivate(void);
Nvoid WM_Init      (void);
Nint  WM_Exec      (void);    /* Execute all jobs ... Return 0 if nothing was done. */
Nint  WM_Exec1     (void);    /* Execute one job  ... Return 0 if nothing was done. */
NU16  WM_SetCreateFlags(U16 Flags);
Xunsigned short  WM_SetCreateFlags(unsigned short Flags);
NWM_tfPollPID* WM_SetpfPollPID(WM_tfPollPID* pf);
Nvoid WM_SetCapture(WM_HWIN hObj, int AutoRelease);
Xvoid WM_SetCapture(GUI_HWIN hObj, int AutoRelease);
Nvoid WM_SetCaptureMove(WM_HWIN hWin, const GUI_PID_STATE* pState, int MinVisibility, int LimitTop); /* Not yet documented */
Xvoid WM_SetCaptureMove(GUI_HWIN hWin, const GUI_PID_STATE* pState, int MinVisibility, int LimitTop);  
Nvoid WM_ReleaseCapture(void);
N
N/*********************************************************************
N*
N*           Window manager interface
N*
N**********************************************************************
N*/
N
Nvoid    WM_AttachWindow              (WM_HWIN hWin, WM_HWIN hParent);
Xvoid    WM_AttachWindow              (GUI_HWIN hWin, GUI_HWIN hParent);
Nvoid    WM_AttachWindowAt            (WM_HWIN hWin, WM_HWIN hParent, int x, int y);
Xvoid    WM_AttachWindowAt            (GUI_HWIN hWin, GUI_HWIN hParent, int x, int y);
Nint     WM_CheckScrollPos            (WM_SCROLL_STATE* pScrollState, int Pos, int LowerDist, int UpperDist); /* not to be documented (may change in future version) */
Nvoid    WM_ClrHasTrans               (WM_HWIN hWin);
Xvoid    WM_ClrHasTrans               (GUI_HWIN hWin);
NWM_HWIN WM_CreateWindow              (int x0, int y0, int xSize, int ySize, U16 Style, WM_CALLBACK* cb, int NumExtraBytes);
XGUI_HWIN WM_CreateWindow              (int x0, int y0, int xSize, int ySize, unsigned short Style, WM_CALLBACK* cb, int NumExtraBytes);
NWM_HWIN WM_CreateWindowAsChild       (int x0, int y0, int xSize, int ySize, WM_HWIN hWinParent, U16 Style, WM_CALLBACK* cb, int NumExtraBytes);
XGUI_HWIN WM_CreateWindowAsChild       (int x0, int y0, int xSize, int ySize, GUI_HWIN hWinParent, unsigned short Style, WM_CALLBACK* cb, int NumExtraBytes);
Nvoid    WM_DeleteWindow              (WM_HWIN hWin);
Xvoid    WM_DeleteWindow              (GUI_HWIN hWin);
Nvoid    WM_DetachWindow              (WM_HWIN hWin);
Xvoid    WM_DetachWindow              (GUI_HWIN hWin);
Nint     WM_GetHasTrans               (WM_HWIN hWin);
Xint     WM_GetHasTrans               (GUI_HWIN hWin);
NWM_HWIN WM_GetFocussedWindow         (void);
XGUI_HWIN WM_GetFocussedWindow         (void);
Nvoid    WM_HideWindow                (WM_HWIN hWin);
Xvoid    WM_HideWindow                (GUI_HWIN hWin);
Nvoid    WM_InvalidateArea            (const GUI_RECT* pRect);
Nvoid    WM_InvalidateRect            (WM_HWIN hWin, const GUI_RECT*pRect);
Xvoid    WM_InvalidateRect            (GUI_HWIN hWin, const GUI_RECT*pRect);
Nvoid    WM_InvalidateWindow          (WM_HWIN hWin);
Xvoid    WM_InvalidateWindow          (GUI_HWIN hWin);
Nvoid    WM_InvalidateWindowAndDescsEx(WM_HWIN hWin, const GUI_RECT * pInvalidRect);
Xvoid    WM_InvalidateWindowAndDescsEx(GUI_HWIN hWin, const GUI_RECT * pInvalidRect);
Nvoid    WM_InvalidateWindowAndDescs  (WM_HWIN hWin);    /* not to be documented (may change in future version) */
Xvoid    WM_InvalidateWindowAndDescs  (GUI_HWIN hWin);     
Nint     WM_IsEnabled                 (WM_HWIN hObj);
Xint     WM_IsEnabled                 (GUI_HWIN hObj);
Nint     WM_IsFocussable              (WM_HWIN hWin);
Xint     WM_IsFocussable              (GUI_HWIN hWin);
Nint     WM_IsVisible                 (WM_HWIN hWin);
Xint     WM_IsVisible                 (GUI_HWIN hWin);
Nint     WM_IsWindow                  (WM_HWIN hWin);    /* Check validity */
Xint     WM_IsWindow                  (GUI_HWIN hWin);     
Nchar    WM_IsCompletelyVisible       (WM_HWIN hWin);    /* Is the window completely visible ? */
Xchar    WM_IsCompletelyVisible       (GUI_HWIN hWin);     
Nvoid    WM_SetHasTrans               (WM_HWIN hWin);
Xvoid    WM_SetHasTrans               (GUI_HWIN hWin);
Nvoid    WM_SetId                     (WM_HWIN hObj, int Id);
Xvoid    WM_SetId                     (GUI_HWIN hObj, int Id);
Nvoid    WM_SetTransState             (WM_HWIN hWin, unsigned State);
Xvoid    WM_SetTransState             (GUI_HWIN hWin, unsigned State);
Nvoid    WM_ShowWindow                (WM_HWIN hWin);
Xvoid    WM_ShowWindow                (GUI_HWIN hWin);
Nvoid    WM_ValidateRect              (WM_HWIN hWin, const GUI_RECT*pRect);
Xvoid    WM_ValidateRect              (GUI_HWIN hWin, const GUI_RECT*pRect);
Nvoid    WM_ValidateWindow            (WM_HWIN hWin);
Xvoid    WM_ValidateWindow            (GUI_HWIN hWin);
Nint     WM_GetInvalidRect            (WM_HWIN hWin, GUI_RECT * pRect);
Xint     WM_GetInvalidRect            (GUI_HWIN hWin, GUI_RECT * pRect);
Nvoid    WM_SetStayOnTop              (WM_HWIN hWin, int OnOff);
Xvoid    WM_SetStayOnTop              (GUI_HWIN hWin, int OnOff);
Nint     WM_GetStayOnTop              (WM_HWIN hWin);
Xint     WM_GetStayOnTop              (GUI_HWIN hWin);
Nvoid    WM_SetAnchor                 (WM_HWIN hWin, U16 AnchorFlags);
Xvoid    WM_SetAnchor                 (GUI_HWIN hWin, unsigned short AnchorFlags);
N
N/* Move/resize windows */
Nvoid WM_MoveWindow                (WM_HWIN hWin, int dx, int dy);
Xvoid WM_MoveWindow                (GUI_HWIN hWin, int dx, int dy);
Nvoid WM_ResizeWindow              (WM_HWIN hWin, int dx, int dy);
Xvoid WM_ResizeWindow              (GUI_HWIN hWin, int dx, int dy);
Nvoid WM_MoveTo                    (WM_HWIN hWin, int x, int y);
Xvoid WM_MoveTo                    (GUI_HWIN hWin, int x, int y);
Nvoid WM_MoveChildTo               (WM_HWIN hWin, int x, int y);
Xvoid WM_MoveChildTo               (GUI_HWIN hWin, int x, int y);
Nvoid WM_SetSize                   (WM_HWIN hWin, int XSize, int YSize);
Xvoid WM_SetSize                   (GUI_HWIN hWin, int XSize, int YSize);
Nvoid WM_SetWindowPos              (WM_HWIN hWin, int xPos, int yPos, int xSize, int ySize);
Xvoid WM_SetWindowPos              (GUI_HWIN hWin, int xPos, int yPos, int xSize, int ySize);
Nint  WM_SetXSize                  (WM_HWIN hWin, int xSize);
Xint  WM_SetXSize                  (GUI_HWIN hWin, int xSize);
Nint  WM_SetYSize                  (WM_HWIN hWin, int ySize);
Xint  WM_SetYSize                  (GUI_HWIN hWin, int ySize);
Nint  WM_CreateTimer               (WM_HWIN hWin, int UserID, int Period, int Mode); /* not to be documented (may change in future version) */
Xint  WM_CreateTimer               (GUI_HWIN hWin, int UserID, int Period, int Mode);  
Nvoid WM_DeleteTimer               (WM_HWIN hWin, int UserId); /* not to be documented (may change in future version) */
Xvoid WM_DeleteTimer               (GUI_HWIN hWin, int UserId);  
Nint  WM_SetScrollbarH             (WM_HWIN hWin, int OnOff); /* not to be documented (may change in future version) */
Xint  WM_SetScrollbarH             (GUI_HWIN hWin, int OnOff);  
Nint  WM_SetScrollbarV             (WM_HWIN hWin, int OnOff); /* not to be documented (may change in future version) */
Xint  WM_SetScrollbarV             (GUI_HWIN hWin, int OnOff);  
N
N
N/* Diagnostics */
Nint WM_GetNumWindows(void);
Nint WM_GetNumInvalidWindows(void);
N
N/* Scroll state related functions */
Nvoid WM_CheckScrollBounds(WM_SCROLL_STATE* pScrollState); /* not to be documented (may change in future version) */
Nint  WM_GetScrollPosH    (WM_HWIN hWin);
Xint  WM_GetScrollPosH    (GUI_HWIN hWin);
Nint  WM_GetScrollPosV    (WM_HWIN hWin);
Xint  WM_GetScrollPosV    (GUI_HWIN hWin);
Nvoid WM_SetScrollPosH    (WM_HWIN hWin, unsigned ScrollPos);
Xvoid WM_SetScrollPosH    (GUI_HWIN hWin, unsigned ScrollPos);
Nvoid WM_SetScrollPosV    (WM_HWIN hWin, unsigned ScrollPos);
Xvoid WM_SetScrollPosV    (GUI_HWIN hWin, unsigned ScrollPos);
Nint  WM_SetScrollValue   (WM_SCROLL_STATE* pScrollState, int v); /* not to be documented (may change in future version) */
N
N
N/* Get / Set (new) callback function */
NWM_CALLBACK * WM_SetCallback(WM_HWIN hWin, WM_CALLBACK * cb);
XWM_CALLBACK * WM_SetCallback(GUI_HWIN hWin, WM_CALLBACK * cb);
NWM_CALLBACK * WM_GetCallback(WM_HWIN hWin);
XWM_CALLBACK * WM_GetCallback(GUI_HWIN hWin);
N
N/* Get size/origin of a window */
Nvoid WM_GetClientRect             (GUI_RECT* pRect);
Nvoid WM_GetClientRectEx           (WM_HWIN hWin, GUI_RECT* pRect);
Xvoid WM_GetClientRectEx           (GUI_HWIN hWin, GUI_RECT* pRect);
Nvoid WM_GetInsideRect             (GUI_RECT* pRect);
Nvoid WM_GetInsideRectEx           (WM_HWIN hWin, GUI_RECT* pRect);
Xvoid WM_GetInsideRectEx           (GUI_HWIN hWin, GUI_RECT* pRect);
Nvoid WM_GetInsideRectExScrollbar  (WM_HWIN hWin, GUI_RECT* pRect); /* not to be documented (may change in future version) */
Xvoid WM_GetInsideRectExScrollbar  (GUI_HWIN hWin, GUI_RECT* pRect);  
Nvoid WM_GetWindowRect             (GUI_RECT* pRect);
Nvoid WM_GetWindowRectEx           (WM_HWIN hWin, GUI_RECT* pRect);
Xvoid WM_GetWindowRectEx           (GUI_HWIN hWin, GUI_RECT* pRect);
Nint  WM_GetOrgX                   (void);
Nint  WM_GetOrgY                   (void);
Nint  WM_GetWindowOrgX             (WM_HWIN hWin);
Xint  WM_GetWindowOrgX             (GUI_HWIN hWin);
Nint  WM_GetWindowOrgY             (WM_HWIN hWin);
Xint  WM_GetWindowOrgY             (GUI_HWIN hWin);
Nint  WM_GetWindowSizeX            (WM_HWIN hWin);
Xint  WM_GetWindowSizeX            (GUI_HWIN hWin);
Nint  WM_GetWindowSizeY            (WM_HWIN hWin);
Xint  WM_GetWindowSizeY            (GUI_HWIN hWin);
NWM_HWIN WM_GetFirstChild          (WM_HWIN hWin);
XGUI_HWIN WM_GetFirstChild          (GUI_HWIN hWin);
NWM_HWIN WM_GetNextSibling         (WM_HWIN hWin);
XGUI_HWIN WM_GetNextSibling         (GUI_HWIN hWin);
NWM_HWIN WM_GetParent              (WM_HWIN hWin);
XGUI_HWIN WM_GetParent              (GUI_HWIN hWin);
NWM_HWIN WM_GetPrevSibling         (WM_HWIN hWin);
XGUI_HWIN WM_GetPrevSibling         (GUI_HWIN hWin);
Nint     WM_GetId                  (WM_HWIN hWin);
Xint     WM_GetId                  (GUI_HWIN hWin);
NWM_HWIN WM_GetScrollbarV          (WM_HWIN hWin);
XGUI_HWIN WM_GetScrollbarV          (GUI_HWIN hWin);
NWM_HWIN WM_GetScrollbarH          (WM_HWIN hWin);
XGUI_HWIN WM_GetScrollbarH          (GUI_HWIN hWin);
NWM_HWIN WM_GetScrollPartner       (WM_HWIN hWin);
XGUI_HWIN WM_GetScrollPartner       (GUI_HWIN hWin);
NWM_HWIN WM_GetClientWindow        (WM_HWIN hObj);
XGUI_HWIN WM_GetClientWindow        (GUI_HWIN hObj);
NGUI_COLOR WM_GetBkColor           (WM_HWIN hObj);
XGUI_COLOR WM_GetBkColor           (GUI_HWIN hObj);
N
N/* Change Z-Order of windows */
Nvoid WM_BringToBottom(WM_HWIN hWin);
Xvoid WM_BringToBottom(GUI_HWIN hWin);
Nvoid WM_BringToTop(WM_HWIN hWin);
Xvoid WM_BringToTop(GUI_HWIN hWin);
N
NGUI_COLOR WM_SetDesktopColor(GUI_COLOR Color);
NGUI_COLOR WM_SetDesktopColorEx(GUI_COLOR Color, unsigned int LayerIndex);
Nvoid WM_SetDesktopColors(GUI_COLOR Color);
N
N/* Select window used for drawing operations */
NWM_HWIN WM_SelectWindow           (WM_HWIN  hWin);
XGUI_HWIN WM_SelectWindow           (GUI_HWIN  hWin);
NWM_HWIN WM_GetActiveWindow        (void);
XGUI_HWIN WM_GetActiveWindow        (void);
Nvoid    WM_Paint                  (WM_HWIN hObj);
Xvoid    WM_Paint                  (GUI_HWIN hObj);
Nvoid    WM_Update                 (WM_HWIN hWin);
Xvoid    WM_Update                 (GUI_HWIN hWin);
Nvoid    WM_PaintWindowAndDescs    (WM_HWIN hWin);
Xvoid    WM_PaintWindowAndDescs    (GUI_HWIN hWin);
Nvoid    WM_UpdateWindowAndDescs   (WM_HWIN hWin);
Xvoid    WM_UpdateWindowAndDescs   (GUI_HWIN hWin);
N
N/* Get foreground/background windows */
NWM_HWIN WM_GetDesktopWindow    (void);
XGUI_HWIN WM_GetDesktopWindow    (void);
NWM_HWIN WM_GetDesktopWindowEx  (unsigned int LayerIndex);
XGUI_HWIN WM_GetDesktopWindowEx  (unsigned int LayerIndex);
N
N/* Reduce clipping area of a window */
Nconst GUI_RECT* WM_SetUserClipRect(const GUI_RECT* pRect);
Nvoid            WM_SetDefault     (void);
N
N/* Use of memory devices */
Nvoid WM_EnableMemdev              (WM_HWIN hWin);
Xvoid WM_EnableMemdev              (GUI_HWIN hWin);
Nvoid WM_DisableMemdev             (WM_HWIN hWin);
Xvoid WM_DisableMemdev             (GUI_HWIN hWin);
N
Nint WM_OnKey(int Key, int Pressed);
Nvoid WM_MakeModal(WM_HWIN hWin);
Xvoid WM_MakeModal(GUI_HWIN hWin);
N
N
N/******************************************************************
N*
N*           Message related funcions
N*
N*******************************************************************
N  Please note that some of these functions do not yet show up in the
N  documentation, as they should not be required by application program.
N*/
N
Nvoid      WM_NotifyParent         (WM_HWIN hWin, int Notification);
Xvoid      WM_NotifyParent         (GUI_HWIN hWin, int Notification);
Nvoid      WM_SendMessage          (WM_HWIN hWin, WM_MESSAGE* p);
Xvoid      WM_SendMessage          (GUI_HWIN hWin, WM_MESSAGE* p);
Nvoid      WM_SendMessageNoPara    (WM_HWIN hWin, int MsgId);             /* not to be documented (may change in future versionumented */
Xvoid      WM_SendMessageNoPara    (GUI_HWIN hWin, int MsgId);              
Nvoid      WM_DefaultProc          (WM_MESSAGE* pMsg);
Nint       WM_BroadcastMessage     (WM_MESSAGE* pMsg);
Nvoid      WM_SetScrollState       (WM_HWIN hWin, const WM_SCROLL_STATE* pState);
Xvoid      WM_SetScrollState       (GUI_HWIN hWin, const WM_SCROLL_STATE* pState);
Nvoid      WM_SetEnableState       (WM_HWIN hItem, int State);
Xvoid      WM_SetEnableState       (GUI_HWIN hItem, int State);
Nvoid      WM_SendToParent         (WM_HWIN hWin, WM_MESSAGE* pMsg);
Xvoid      WM_SendToParent         (GUI_HWIN hWin, WM_MESSAGE* pMsg);
Nint       WM_HasCaptured          (WM_HWIN hWin);
Xint       WM_HasCaptured          (GUI_HWIN hWin);
Nint       WM_HasFocus             (WM_HWIN hWin);
Xint       WM_HasFocus             (GUI_HWIN hWin);
Nint       WM_SetFocus             (WM_HWIN hWin);
Xint       WM_SetFocus             (GUI_HWIN hWin);
NWM_HWIN   WM_SetFocusOnNextChild  (WM_HWIN hParent);     /* Set the focus to the next child */
XGUI_HWIN   WM_SetFocusOnNextChild  (GUI_HWIN hParent);      
NWM_HWIN   WM_SetFocusOnPrevChild  (WM_HWIN hParent);     /* Set the focus to the previous child */
XGUI_HWIN   WM_SetFocusOnPrevChild  (GUI_HWIN hParent);      
NWM_HWIN   WM_GetDialogItem        (WM_HWIN hWin, int Id);
XGUI_HWIN   WM_GetDialogItem        (GUI_HWIN hWin, int Id);
Nvoid      WM_EnableWindow         (WM_HWIN hWin);
Xvoid      WM_EnableWindow         (GUI_HWIN hWin);
Nvoid      WM_DisableWindow        (WM_HWIN hWin);
Xvoid      WM_DisableWindow        (GUI_HWIN hWin);
Nvoid      WM_GetScrollState       (WM_HWIN hObj, WM_SCROLL_STATE* pScrollState);
Xvoid      WM_GetScrollState       (GUI_HWIN hObj, WM_SCROLL_STATE* pScrollState);
Nint       WM_GetUserData          (WM_HWIN hWin,       void* pDest, int SizeOfBuffer);
Xint       WM_GetUserData          (GUI_HWIN hWin,       void* pDest, int SizeOfBuffer);
Nint       WM_SetUserData          (WM_HWIN hWin, const void* pSrc,  int SizeOfBuffer);
Xint       WM_SetUserData          (GUI_HWIN hWin, const void* pSrc,  int SizeOfBuffer);
N
N
N/*********************************************************************
N*
N*           Misc routines
N*/
N
Nint       WM_HandlePID      (void);
NWM_HWIN   WM_Screen2hWin    (int x, int y);
XGUI_HWIN   WM_Screen2hWin    (int x, int y);
NWM_HWIN   WM_Screen2hWinEx  (WM_HWIN hStop, int x, int y);
XGUI_HWIN   WM_Screen2hWinEx  (GUI_HWIN hStop, int x, int y);
Nvoid      WM_ForEachDesc    (WM_HWIN hWin, WM_tfForEach * pcb, void * pData);
Xvoid      WM_ForEachDesc    (GUI_HWIN hWin, WM_tfForEach * pcb, void * pData);
Nvoid      WM_SetScreenSize  (int xSize, int ySize);
Nint       WM_PollSimMsg     (void);
N
N/*********************************************************************
N*
N*           Diagnostics routines
N*/
N#if (WM_SUPPORT_DIAG)
X#if (0)
Svoid WM_DIAG_EnableInvalidationColoring(int OnOff);
N#endif
N
N/*
N      *************************************************
N      *                                               *
N      *  Macros for compatibility with older versions *
N      *                                               *
N      *************************************************
N*/
N
N#if WM_COMPATIBLE_MODE
X#if 1
N  #define HBWIN             WM_HWIN
N  #define HBWIN_NULL        WM_HWIN_NULL
N
N  #define WM_HideWin        WM_HideWindow
N  #define WM_ShowWin        WM_ShowWindow
N  #define WM_GetKey         GUI_GetKey
N  #define WM_WaitKey        GUI_WaitKey
N
N  #define WM_ExecIdle       WM_Exec
N  #define WM_ExecIdle1      WM_Exec1
N
N  #define WM_Invalidate     WM_InvalidateWindow
N  #define WM_GetWinRect     WM_GetWindowRect
N  #define WM_GetWinOrgX     WM_GetWindowOrgX
N  #define WM_GetWinOrgY     WM_GetWindowOrgY
N  #define WM_GetWinSizeX    WM_GetWindowSizeX
N  #define WM_GetWinSizeY    WM_GetWindowSizeY
N  #define WM_GetXSize       WM_GetWindowSizeX
N  #define WM_GetYSize       WM_GetWindowSizeY
N  #define WM_SelWin         WM_SelectWindow
N  #define WM_GetBackgroundWindow  WM_GetDesktopWindow
N  #define WM_GetForegroundWindow    0
N  #define WM_SetForegroundWindow    WM_BringToTop
N  #define WM_SetUserClipArea WM_SetUserClipRect
N
N
N  #define WM_Start()
N  #define WM_Stop()
N  #define WM_SetBkWindowColor(Color)  WM_SetDesktopColor(Color)
N
N#endif
N
N
N#endif   /* GUI_WINSUPPORT */
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif 
N
N#endif   /* WM_H */
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 24 "..\GUI\Widget\FRAMEWIN.h" 2
N#if GUI_WINSUPPORT
X#if 1
N#include "DIALOG_Intern.h"      /* Req. for Create indirect data structure */
L 1 "..\GUI\Widget\DIALOG_Intern.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : Dialog.h
NPurpose     : Dialog box include
N----------------------------------------------------------------------
NOpen items:
NNone
N--------------------END-OF-HEADER-------------------------------------
N*/
N
N#ifndef DIALOG_INTERN_H
N#define DIALOG_INTERN_H
N
N#include "WM.h"
N
N#if GUI_WINSUPPORT
X#if 1
N
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*           typedefs
N*
N**********************************************************************
N*/
N
Ntypedef struct  GUI_WIDGET_CREATE_INFO_struct GUI_WIDGET_CREATE_INFO;
Ntypedef WM_HWIN GUI_WIDGET_CREATE_FUNC       (const GUI_WIDGET_CREATE_INFO* pCreate, WM_HWIN hWin, int x0, int y0, WM_CALLBACK* cb);
Xtypedef GUI_HWIN GUI_WIDGET_CREATE_FUNC       (const GUI_WIDGET_CREATE_INFO* pCreate, GUI_HWIN hWin, int x0, int y0, WM_CALLBACK* cb);
N
N/*********************************************************************
N*
N*           structures
N*
N**********************************************************************
N*/
Nstruct GUI_WIDGET_CREATE_INFO_struct {
N  GUI_WIDGET_CREATE_FUNC* pfCreateIndirect;
N  const char* pName;                     /* Text ... Not used on all widgets */
N  I16 Id;                                /* ID ... should be unique in a dialog */
X  signed short Id;                                 
N  I16 x0, y0, xSize, ySize;              /* Define position and size */
X  signed short x0, y0, xSize, ySize;               
N  U16 Flags;                             /* Widget specific create flags (opt.) */
X  unsigned short Flags;                              
N  I32 Para;                              /* Widget specific parameter (opt.) */ 
X  signed long Para;                                
N};
N
N/*********************************************************************
N*
N*           Create functions for well known widgets
N*
N**********************************************************************
N*/
N
NWM_HWIN BUTTON_CreateIndirect   (const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
XGUI_HWIN BUTTON_CreateIndirect   (const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
NWM_HWIN CHECKBOX_CreateIndirect (const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
XGUI_HWIN CHECKBOX_CreateIndirect (const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
NWM_HWIN EDIT_CreateIndirect     (const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
XGUI_HWIN EDIT_CreateIndirect     (const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
NWM_HWIN FRAMEWIN_CreateIndirect (const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
XGUI_HWIN FRAMEWIN_CreateIndirect (const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
NWM_HWIN RADIO_CreateIndirect    (const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
XGUI_HWIN RADIO_CreateIndirect    (const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
NWM_HWIN SLIDER_CreateIndirect   (const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
XGUI_HWIN SLIDER_CreateIndirect   (const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
NWM_HWIN SCROLLBAR_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
XGUI_HWIN SCROLLBAR_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
NWM_HWIN TEXT_CreateIndirect     (const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
XGUI_HWIN TEXT_CreateIndirect     (const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
N
N/*********************************************************************
N*
N*           Public API functions
N*
N**********************************************************************
N*/
Nint     GUI_ExecDialogBox     (const GUI_WIDGET_CREATE_INFO* paWidget, int NumWidgets, WM_CALLBACK* cb, WM_HWIN hParent, int x0, int y0);
Xint     GUI_ExecDialogBox     (const GUI_WIDGET_CREATE_INFO* paWidget, int NumWidgets, WM_CALLBACK* cb, GUI_HWIN hParent, int x0, int y0);
Nint     GUI_ExecCreatedDialog (WM_HWIN hDialog);
Xint     GUI_ExecCreatedDialog (GUI_HWIN hDialog);
NWM_HWIN GUI_CreateDialogBox   (const GUI_WIDGET_CREATE_INFO* paWidget, int NumWidgets, WM_CALLBACK* cb, WM_HWIN hParent, int x0, int y0);
XGUI_HWIN GUI_CreateDialogBox   (const GUI_WIDGET_CREATE_INFO* paWidget, int NumWidgets, WM_CALLBACK* cb, GUI_HWIN hParent, int x0, int y0);
Nvoid    GUI_SetDialogStatusPtr(WM_HWIN hDialog, WM_DIALOG_STATUS* pDialogStatus); /* not to documented */
Xvoid    GUI_SetDialogStatusPtr(GUI_HWIN hDialog, WM_DIALOG_STATUS* pDialogStatus);  
NWM_DIALOG_STATUS*  GUI_GetDialogStatusPtr(WM_HWIN hDialog);                       /* not to documented */
XWM_DIALOG_STATUS*  GUI_GetDialogStatusPtr(GUI_HWIN hDialog);                        
Nvoid    GUI_EndDialog(WM_HWIN hWin, int r);
Xvoid    GUI_EndDialog(GUI_HWIN hWin, int r);
NLCD_COLOR DIALOG_GetBkColor(void);                                                /* obsolete */
NLCD_COLOR DIALOG_SetBkColor(LCD_COLOR BkColor);                                   /* obsolete */
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N
N#endif   /* GUI_WINSUPPORT */
N#endif
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 26 "..\GUI\Widget\FRAMEWIN.h" 2
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/************************************************************
N*
N*       Defines
N*
N*************************************************************
N*/
N/************************************************************
N*
N*       Configuration
N*/
N#ifndef   FRAMEWIN_ALLOW_DRAG_ON_FRAME
N  #define FRAMEWIN_ALLOW_DRAG_ON_FRAME 1
N#endif
N
N/************************************************************
N*
N*       Create / Status flags
N*/
N#define FRAMEWIN_CF_ACTIVE     (1<<3)
N#define FRAMEWIN_CF_MOVEABLE   (1<<4)
N#define FRAMEWIN_CF_TITLEVIS   (1<<5)
N#define FRAMEWIN_CF_MINIMIZED  (1<<6)
N#define FRAMEWIN_CF_MAXIMIZED  (1<<7)
N
N#define FRAMEWIN_SF_ACTIVE     FRAMEWIN_CF_ACTIVE
N#define FRAMEWIN_SF_MOVEABLE   FRAMEWIN_CF_MOVEABLE
N#define FRAMEWIN_SF_TITLEVIS   FRAMEWIN_CF_TITLEVIS
N#define FRAMEWIN_SF_MINIMIZED  FRAMEWIN_CF_MINIMIZED
N#define FRAMEWIN_SF_MAXIMIZED  FRAMEWIN_CF_MAXIMIZED
N
N/************************************************************
N*
N*       BUTTON Flags
N*/
N
N#define FRAMEWIN_BUTTON_RIGHT   (1<<0)
N#define FRAMEWIN_BUTTON_LEFT    (1<<1)
N
N/************************************************************
N*                                                           *
N*                         Types                             *
N*                                                           *
N*************************************************************
N*/
N
Ntypedef WM_HMEM FRAMEWIN_Handle;
Xtypedef signed short FRAMEWIN_Handle;
N
N/*********************************************************************
N*
N*       Create functions
N*
N**********************************************************************
N*/
NFRAMEWIN_Handle FRAMEWIN_Create        (const char* pTitle, WM_CALLBACK* cb, int Flags, int x0, int y0, int xsize, int ysize);
NFRAMEWIN_Handle FRAMEWIN_CreateAsChild (int x0, int y0, int xsize, int ysize, WM_HWIN hParent, const char* pText, WM_CALLBACK* cb, int Flags);
XFRAMEWIN_Handle FRAMEWIN_CreateAsChild (int x0, int y0, int xsize, int ysize, GUI_HWIN hParent, const char* pText, WM_CALLBACK* cb, int Flags);
NFRAMEWIN_Handle FRAMEWIN_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
XFRAMEWIN_Handle FRAMEWIN_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent, int x0, int y0, WM_CALLBACK* cb);
NFRAMEWIN_Handle FRAMEWIN_CreateEx      (int x0, int y0, int xsize, int ysize, WM_HWIN hParent,
XFRAMEWIN_Handle FRAMEWIN_CreateEx      (int x0, int y0, int xsize, int ysize, GUI_HWIN hParent,
N                                        int WinFlags, int ExFlags, int Id, const char* pTitle, WM_CALLBACK* cb);
N
N/*********************************************************************
N*
N*       The callback ...
N*
N* Do not call it directly ! It is only to be used from within an
N* overwritten callback.
N*/
Nvoid FRAMEWIN_Callback(WM_MESSAGE * pMsg);
N
N/*********************************************************************
N*
N*       Standard member functions
N*
N**********************************************************************
N*/
N
N#define FRAMEWIN_EnableMemdev(hObj)  WM_EnableMemdev(hObj)
N#define FRAMEWIN_DisableMemdev(hObj) WM_DisableMemdev(hObj)
N#define FRAMEWIN_Delete(hObj)        WM_DeleteWindow(hObj)
N#define FRAMEWIN_Paint(hObj)         WM_Paint(hObj)
N#define FRAMEWIN_Invalidate(hObj)    WM_InvalidateWindow(hObj)
N
NWM_HWIN FRAMEWIN_AddButton     (FRAMEWIN_Handle hObj, int Flags, int Off, int Id);
XGUI_HWIN FRAMEWIN_AddButton     (FRAMEWIN_Handle hObj, int Flags, int Off, int Id);
NWM_HWIN FRAMEWIN_AddCloseButton(FRAMEWIN_Handle hObj, int Flags, int Off);
XGUI_HWIN FRAMEWIN_AddCloseButton(FRAMEWIN_Handle hObj, int Flags, int Off);
NWM_HWIN FRAMEWIN_AddMaxButton  (FRAMEWIN_Handle hObj, int Flags, int Off);
XGUI_HWIN FRAMEWIN_AddMaxButton  (FRAMEWIN_Handle hObj, int Flags, int Off);
Nvoid    FRAMEWIN_AddMenu       (FRAMEWIN_Handle hObj, WM_HWIN hMenu);
Xvoid    FRAMEWIN_AddMenu       (FRAMEWIN_Handle hObj, GUI_HWIN hMenu);
NWM_HWIN FRAMEWIN_AddMinButton  (FRAMEWIN_Handle hObj, int Flags, int Off);
XGUI_HWIN FRAMEWIN_AddMinButton  (FRAMEWIN_Handle hObj, int Flags, int Off);
N
Nvoid    FRAMEWIN_Minimize      (FRAMEWIN_Handle hObj);
Nvoid    FRAMEWIN_Maximize      (FRAMEWIN_Handle hObj);
Nvoid    FRAMEWIN_Restore       (FRAMEWIN_Handle hObj);
N
N/*********************************************************************
N*
N*       Member functions: Set Properties
N*
N**********************************************************************
N*/
Nvoid FRAMEWIN_SetActive      (FRAMEWIN_Handle hObj, int State);
Nvoid FRAMEWIN_SetBarColor    (FRAMEWIN_Handle hObj, unsigned Index, GUI_COLOR Color);
Nvoid FRAMEWIN_SetBorderSize  (FRAMEWIN_Handle hObj, unsigned Size);
Nvoid FRAMEWIN_SetClientColor (FRAMEWIN_Handle hObj, GUI_COLOR Color);
Nvoid FRAMEWIN_SetFont        (FRAMEWIN_Handle hObj, const GUI_FONT GUI_UNI_PTR * pFont);
Xvoid FRAMEWIN_SetFont        (FRAMEWIN_Handle hObj, const GUI_FONT  * pFont);
Nvoid FRAMEWIN_SetMoveable    (FRAMEWIN_Handle hObj, int State);
Nvoid FRAMEWIN_SetResizeable  (FRAMEWIN_Handle hObj, int State);
Nvoid FRAMEWIN_SetText        (FRAMEWIN_Handle hObj, const char* s);
Nvoid FRAMEWIN_SetTextAlign   (FRAMEWIN_Handle hObj, int Align);
Nvoid FRAMEWIN_SetTextColor   (FRAMEWIN_Handle hObj, GUI_COLOR Color);
Nvoid FRAMEWIN_SetTextColorEx (FRAMEWIN_Handle hObj, unsigned Index, GUI_COLOR Color);
Nvoid FRAMEWIN_SetTitleVis    (FRAMEWIN_Handle hObj, int Show);
Nint  FRAMEWIN_SetTitleHeight (FRAMEWIN_Handle hObj, int Height);
N
N/*********************************************************************
N*
N*       Member functions: Get Properties
N*
N**********************************************************************
N*/
Nint FRAMEWIN_GetTitleHeight (FRAMEWIN_Handle hObj);
Nint FRAMEWIN_GetBorderSize  (FRAMEWIN_Handle hObj);
Nint FRAMEWIN_IsMinimized    (FRAMEWIN_Handle hObj);
Nint FRAMEWIN_IsMaximized    (FRAMEWIN_Handle hObj);
N
N/*********************************************************************
N*
N*       Global functions
N*
N**********************************************************************
N*/
NGUI_COLOR       FRAMEWIN_GetDefaultBarColor   (unsigned Index);
Nint             FRAMEWIN_GetDefaultBorderSize (void);
Nint             FRAMEWIN_GetDefaultTitleHeight(void);
NGUI_COLOR       FRAMEWIN_GetDefaultClientColor(void);
Nconst GUI_FONT GUI_UNI_PTR * FRAMEWIN_GetDefaultFont       (void);
Xconst GUI_FONT  * FRAMEWIN_GetDefaultFont       (void);
NGUI_COLOR       FRAMEWIN_GetDefaultTextColor  (unsigned Index);
Nvoid            FRAMEWIN_SetDefaultBarColor   (unsigned Index, GUI_COLOR Color);
Nvoid            FRAMEWIN_SetDefaultBorderSize (int DefaultBorderSize);
Nvoid            FRAMEWIN_SetDefaultTitleHeight(int DefaultTitleHeight);
Nvoid            FRAMEWIN_SetDefaultClientColor(GUI_COLOR Color);
Nvoid            FRAMEWIN_SetDefaultFont       (const GUI_FONT GUI_UNI_PTR * pFont);
Xvoid            FRAMEWIN_SetDefaultFont       (const GUI_FONT  * pFont);
Nint             FRAMEWIN_SetDefaultTextAlign  (int TextAlign);
Nvoid            FRAMEWIN_SetDefaultTextColor  (unsigned Index, GUI_COLOR Color);
N
N/*********************************************************************
N*
N*       Macros for compatibility
N*
N**********************************************************************
N*/
N#define         FRAMEWIN_SetDefaultCaptionSize(Height)       FRAMEWIN_SetDefaultTitleHeight(Height)
N#define         FRAMEWIN_GetDefaultCaptionSize()             FRAMEWIN_GetDefaultTitleHeight()
N#define         FRAMEWIN_CreateButton(hObj, Flags, Off, Id)  FRAMEWIN_AddButton(hObj, Flags, Off, Id) 
N#define         FRAMEWIN_CreateCloseButton(hObj, Flags, Off) FRAMEWIN_AddCloseButton(hObj, Flags, Off)
N#define         FRAMEWIN_CreateMaxButton(hObj, Flags, Off)   FRAMEWIN_AddMaxButton(hObj, Flags, Off)  
N#define         FRAMEWIN_CreateMinButton(hObj, Flags, Off)   FRAMEWIN_AddMinButton(hObj, Flags, Off)  
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif
N#endif   /* FRAMEWIN_H */
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 21 "..\GUI\Widget\FRAMEWIN_CreateIndirect.c" 2
N
N#if GUI_WINSUPPORT
X#if 1
N
N/*********************************************************************
N*
N*       Exported routines
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       FRAMEWIN_CreateIndirect
N*/
NFRAMEWIN_Handle FRAMEWIN_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, WM_HWIN hWinParent,
XFRAMEWIN_Handle FRAMEWIN_CreateIndirect(const GUI_WIDGET_CREATE_INFO* pCreateInfo, GUI_HWIN hWinParent,
N                                       int x0, int y0, WM_CALLBACK* cb) {
N  FRAMEWIN_Handle hObj;
N  hObj = FRAMEWIN_CreateEx(pCreateInfo->x0 + x0, pCreateInfo->y0 + y0, pCreateInfo->xSize, pCreateInfo->ySize,
N                           hWinParent, 0, pCreateInfo->Flags, pCreateInfo->Id, pCreateInfo->pName, cb);
N  return hObj;
N}
N
N#else  /* avoid empty object files */
S  void FRAMEWIN_CreateIndirect_C(void) {}
N#endif
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
