; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\jdmaster.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jdmaster.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\JPEG\jdmaster.c]
                          THUMB

                          AREA ||i.finish_output_pass||, CODE, READONLY, ALIGN=1

                  finish_output_pass PROC
;;;497    METHODDEF(void)
;;;498    finish_output_pass (j_decompress_ptr cinfo)
000000  b510              PUSH     {r4,lr}
;;;499    {
000002  f8d041a4          LDR      r4,[r0,#0x1a4]
000006  6d41              LDR      r1,[r0,#0x54]
000008  b119              CBZ      r1,|L1.18|
;;;500      my_master_ptr master = (my_master_ptr) cinfo->master;
;;;501    
;;;502      if (cinfo->quantize_colors)
;;;503        (*cinfo->cquantize->finish_pass) (cinfo);
00000a  f8d011cc          LDR      r1,[r0,#0x1cc]
00000e  6889              LDR      r1,[r1,#8]
000010  4788              BLX      r1
                  |L1.18|
;;;504      master->pass_number++;
000012  68e0              LDR      r0,[r4,#0xc]
000014  1c40              ADDS     r0,r0,#1
000016  60e0              STR      r0,[r4,#0xc]
;;;505    }
000018  bd10              POP      {r4,pc}
;;;506    
                          ENDP


                          AREA ||i.jinit_master_decompress||, CODE, READONLY, ALIGN=2

                  jinit_master_decompress PROC
;;;542    GLOBAL(void)
;;;543    jinit_master_decompress (j_decompress_ptr cinfo)
000000  b510              PUSH     {r4,lr}
;;;544    {
000002  4604              MOV      r4,r0
;;;545      my_master_ptr master;
;;;546    
;;;547      master = (my_master_ptr)
000004  6840              LDR      r0,[r0,#4]
000006  221c              MOVS     r2,#0x1c
000008  2101              MOVS     r1,#1
00000a  6803              LDR      r3,[r0,#0]
00000c  4620              MOV      r0,r4
00000e  4798              BLX      r3
;;;548          (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;549    				  SIZEOF(my_decomp_master));
;;;550      cinfo->master = (struct jpeg_decomp_master *) master;
;;;551      master->pub.prepare_for_output_pass = prepare_for_output_pass;
000010  4906              LDR      r1,|L2.44|
000012  f8c401a4          STR      r0,[r4,#0x1a4]
;;;552      master->pub.finish_output_pass = finish_output_pass;
000016  6001              STR      r1,[r0,#0]
000018  4905              LDR      r1,|L2.48|
;;;553    
;;;554      master->pub.is_dummy_pass = FALSE;
00001a  6041              STR      r1,[r0,#4]
00001c  2100              MOVS     r1,#0
;;;555    
;;;556      master_selection(cinfo);
00001e  6081              STR      r1,[r0,#8]
000020  4620              MOV      r0,r4
000022  e8bd4010          POP      {r4,lr}
000026  f7ffbffe          B.W      master_selection
;;;557    }
                          ENDP

00002a  0000              DCW      0x0000
                  |L2.44|
                          DCD      prepare_for_output_pass
                  |L2.48|
                          DCD      finish_output_pass

                          AREA ||i.jpeg_calc_output_dimensions||, CODE, READONLY, ALIGN=1

                  jpeg_calc_output_dimensions PROC
;;;83     GLOBAL(void)
;;;84     jpeg_calc_output_dimensions (j_decompress_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;85     /* Do computations that are needed before master selection phase */
;;;86     {
000002  4604              MOV      r4,r0
;;;87     #ifdef IDCT_SCALING_SUPPORTED
;;;88       int ci;
;;;89       jpeg_component_info *compptr;
;;;90     #endif
;;;91     
;;;92       /* Prevent application from calling me at wrong times */
;;;93       if (cinfo->global_state != DSTATE_READY)
000004  6940              LDR      r0,[r0,#0x14]
000006  28ca              CMP      r0,#0xca
000008  d009              BEQ      |L3.30|
;;;94         ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
00000a  6821              LDR      r1,[r4,#0]
00000c  2014              MOVS     r0,#0x14
00000e  6148              STR      r0,[r1,#0x14]
000010  6821              LDR      r1,[r4,#0]
000012  6960              LDR      r0,[r4,#0x14]
000014  6188              STR      r0,[r1,#0x18]
000016  6820              LDR      r0,[r4,#0]
000018  6801              LDR      r1,[r0,#0]
00001a  4620              MOV      r0,r4
00001c  4788              BLX      r1
                  |L3.30|
;;;95     
;;;96     #ifdef IDCT_SCALING_SUPPORTED
;;;97     
;;;98       /* Compute actual output image dimensions and DCT scaling choices. */
;;;99       if (cinfo->scale_num * 8 <= cinfo->scale_denom) {
;;;100        /* Provide 1/8 scaling */
;;;101        cinfo->output_width = (JDIMENSION)
;;;102          jdiv_round_up((long) cinfo->image_width, 8L);
;;;103        cinfo->output_height = (JDIMENSION)
;;;104          jdiv_round_up((long) cinfo->image_height, 8L);
;;;105        cinfo->min_DCT_scaled_size = 1;
;;;106      } else if (cinfo->scale_num * 4 <= cinfo->scale_denom) {
;;;107        /* Provide 1/4 scaling */
;;;108        cinfo->output_width = (JDIMENSION)
;;;109          jdiv_round_up((long) cinfo->image_width, 4L);
;;;110        cinfo->output_height = (JDIMENSION)
;;;111          jdiv_round_up((long) cinfo->image_height, 4L);
;;;112        cinfo->min_DCT_scaled_size = 2;
;;;113      } else if (cinfo->scale_num * 2 <= cinfo->scale_denom) {
;;;114        /* Provide 1/2 scaling */
;;;115        cinfo->output_width = (JDIMENSION)
;;;116          jdiv_round_up((long) cinfo->image_width, 2L);
;;;117        cinfo->output_height = (JDIMENSION)
;;;118          jdiv_round_up((long) cinfo->image_height, 2L);
;;;119        cinfo->min_DCT_scaled_size = 4;
;;;120      } else {
;;;121        /* Provide 1/1 scaling */
;;;122        cinfo->output_width = cinfo->image_width;
;;;123        cinfo->output_height = cinfo->image_height;
;;;124        cinfo->min_DCT_scaled_size = DCTSIZE;
;;;125      }
;;;126      /* In selecting the actual DCT scaling for each component, we try to
;;;127       * scale up the chroma components via IDCT scaling rather than upsampling.
;;;128       * This saves time if the upsampler gets to use 1:1 scaling.
;;;129       * Note this code assumes that the supported DCT scalings are powers of 2.
;;;130       */
;;;131      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
;;;132           ci++, compptr++) {
;;;133        int ssize = cinfo->min_DCT_scaled_size;
;;;134        while (ssize < DCTSIZE &&
;;;135    	   (compptr->h_samp_factor * ssize * 2 <=
;;;136    	    cinfo->max_h_samp_factor * cinfo->min_DCT_scaled_size) &&
;;;137    	   (compptr->v_samp_factor * ssize * 2 <=
;;;138    	    cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size)) {
;;;139          ssize = ssize * 2;
;;;140        }
;;;141        compptr->DCT_scaled_size = ssize;
;;;142      }
;;;143    
;;;144      /* Recompute downsampled dimensions of components;
;;;145       * application needs to know these if using raw downsampled data.
;;;146       */
;;;147      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
;;;148           ci++, compptr++) {
;;;149        /* Size in samples, after IDCT scaling */
;;;150        compptr->downsampled_width = (JDIMENSION)
;;;151          jdiv_round_up((long) cinfo->image_width *
;;;152    		    (long) (compptr->h_samp_factor * compptr->DCT_scaled_size),
;;;153    		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
;;;154        compptr->downsampled_height = (JDIMENSION)
;;;155          jdiv_round_up((long) cinfo->image_height *
;;;156    		    (long) (compptr->v_samp_factor * compptr->DCT_scaled_size),
;;;157    		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
;;;158      }
;;;159    
;;;160    #else /* !IDCT_SCALING_SUPPORTED */
;;;161    
;;;162      /* Hardwire it to "no scaling" */
;;;163      cinfo->output_width = cinfo->image_width;
00001e  69e0              LDR      r0,[r4,#0x1c]
;;;164      cinfo->output_height = cinfo->image_height;
000020  6720              STR      r0,[r4,#0x70]
000022  6a20              LDR      r0,[r4,#0x20]
;;;165      /* jdinput.c has already initialized DCT_scaled_size to DCTSIZE,
;;;166       * and has computed unscaled downsampled_width and downsampled_height.
;;;167       */
;;;168    
;;;169    #endif /* IDCT_SCALING_SUPPORTED */
;;;170    
;;;171      /* Report number of components in selected colorspace. */
;;;172      /* Probably this should be in the color conversion module... */
;;;173      switch (cinfo->out_color_space) {
000024  6760              STR      r0,[r4,#0x74]
000026  f8940029          LDRB     r0,[r4,#0x29]
00002a  2501              MOVS     r5,#1
00002c  2806              CMP      r0,#6
00002e  d20e              BCS      |L3.78|
000030  e8dff000          TBB      [pc,r0]
000034  0d030505          DCB      0x0d,0x03,0x05,0x05
000038  0707              DCB      0x07,0x07
;;;174      case JCS_GRAYSCALE:
;;;175        cinfo->out_color_components = 1;
;;;176        break;
00003a  67a5              STR      r5,[r4,#0x78]
00003c  e003              B        |L3.70|
;;;177      case JCS_RGB:
;;;178    #if RGB_PIXELSIZE != 3
;;;179        cinfo->out_color_components = RGB_PIXELSIZE;
;;;180        break;
;;;181    #endif /* else share code with YCbCr */
;;;182      case JCS_YCbCr:
;;;183        cinfo->out_color_components = 3;
00003e  2003              MOVS     r0,#3
;;;184        break;
000040  e000              B        |L3.68|
;;;185      case JCS_CMYK:
;;;186      case JCS_YCCK:
;;;187        cinfo->out_color_components = 4;
000042  2004              MOVS     r0,#4
                  |L3.68|
000044  67a0              STR      r0,[r4,#0x78]         ;183
                  |L3.70|
;;;188        break;
;;;189      default:			/* else must be same colorspace as in file */
;;;190        cinfo->out_color_components = cinfo->num_components;
;;;191        break;
;;;192      }
;;;193      cinfo->output_components = (cinfo->quantize_colors ? 1 :
000046  6d60              LDR      r0,[r4,#0x54]
000048  b118              CBZ      r0,|L3.82|
00004a  2001              MOVS     r0,#1
00004c  e002              B        |L3.84|
                  |L3.78|
00004e  6a60              LDR      r0,[r4,#0x24]         ;191
000050  e7f8              B        |L3.68|
                  |L3.82|
;;;194    			      cinfo->out_color_components);
000052  6fa0              LDR      r0,[r4,#0x78]
                  |L3.84|
;;;195    
;;;196      /* See if upsampler will want to emit more than one row at a time */
;;;197      if (use_merged_upsample(cinfo))
000054  67e0              STR      r0,[r4,#0x7c]
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       use_merged_upsample
00005c  b120              CBZ      r0,|L3.104|
;;;198        cinfo->rec_outbuf_height = cinfo->max_v_samp_factor;
00005e  f8d40138          LDR      r0,[r4,#0x138]
000062  f8c40080          STR      r0,[r4,#0x80]
;;;199      else
;;;200        cinfo->rec_outbuf_height = 1;
;;;201    }
000066  bd70              POP      {r4-r6,pc}
                  |L3.104|
000068  f8c45080          STR      r5,[r4,#0x80]         ;200
00006c  bd70              POP      {r4-r6,pc}
;;;202    
                          ENDP


                          AREA ||i.jpeg_new_colormap||, CODE, READONLY, ALIGN=1

                  jpeg_new_colormap PROC
;;;514    GLOBAL(void)
;;;515    jpeg_new_colormap (j_decompress_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;516    {
000002  4604              MOV      r4,r0
;;;517      my_master_ptr master = (my_master_ptr) cinfo->master;
;;;518    
;;;519      /* Prevent application from calling me at wrong times */
;;;520      if (cinfo->global_state != DSTATE_BUFIMAGE)
000004  f8d051a4          LDR      r5,[r0,#0x1a4]
000008  6940              LDR      r0,[r0,#0x14]
00000a  28cf              CMP      r0,#0xcf
00000c  d009              BEQ      |L4.34|
;;;521        ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
00000e  6821              LDR      r1,[r4,#0]
000010  2014              MOVS     r0,#0x14
000012  6148              STR      r0,[r1,#0x14]
000014  6821              LDR      r1,[r4,#0]
000016  6960              LDR      r0,[r4,#0x14]
000018  6188              STR      r0,[r1,#0x18]
00001a  6820              LDR      r0,[r4,#0]
00001c  6801              LDR      r1,[r0,#0]
00001e  4620              MOV      r0,r4
000020  4788              BLX      r1
                  |L4.34|
;;;522    
;;;523      if (cinfo->quantize_colors && cinfo->enable_external_quant &&
000022  6d60              LDR      r0,[r4,#0x54]
000024  b168              CBZ      r0,|L4.66|
000026  6ea0              LDR      r0,[r4,#0x68]
000028  b158              CBZ      r0,|L4.66|
;;;524          cinfo->colormap != NULL) {
00002a  f8d40088          LDR      r0,[r4,#0x88]
00002e  b140              CBZ      r0,|L4.66|
;;;525        /* Select 2-pass quantizer for external colormap use */
;;;526        cinfo->cquantize = master->quantizer_2pass;
000030  69a8              LDR      r0,[r5,#0x18]
;;;527        /* Notify quantizer of colormap change */
;;;528        (*cinfo->cquantize->new_color_map) (cinfo);
000032  f8c401cc          STR      r0,[r4,#0x1cc]
000036  68c1              LDR      r1,[r0,#0xc]
000038  4620              MOV      r0,r4
00003a  4788              BLX      r1
;;;529        master->pub.is_dummy_pass = FALSE; /* just in case */
00003c  2000              MOVS     r0,#0
00003e  60a8              STR      r0,[r5,#8]
;;;530      } else
;;;531        ERREXIT(cinfo, JERR_MODE_CHANGE);
;;;532    }
000040  bd70              POP      {r4-r6,pc}
                  |L4.66|
000042  6821              LDR      r1,[r4,#0]            ;531
000044  202e              MOVS     r0,#0x2e              ;531
000046  6148              STR      r0,[r1,#0x14]         ;531
000048  6820              LDR      r0,[r4,#0]            ;531
00004a  6801              LDR      r1,[r0,#0]            ;531
00004c  4620              MOV      r0,r4                 ;531
00004e  e8bd4070          POP      {r4-r6,lr}            ;531
000052  4708              BX       r1                    ;531
;;;533    
                          ENDP


                          AREA ||i.master_selection||, CODE, READONLY, ALIGN=1

                  master_selection PROC
;;;287    LOCAL(void)
;;;288    master_selection (j_decompress_ptr cinfo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;289    {
000004  4604              MOV      r4,r0
;;;290      my_master_ptr master = (my_master_ptr) cinfo->master;
;;;291      boolean use_c_buffer;
;;;292      long samplesperrow;
;;;293      JDIMENSION jd_samplesperrow;
;;;294    
;;;295      /* Initialize dimensions and other stuff */
;;;296      jpeg_calc_output_dimensions(cinfo);
000006  f8d061a4          LDR      r6,[r0,#0x1a4]
00000a  f7fffffe          BL       jpeg_calc_output_dimensions
00000e  6860              LDR      r0,[r4,#4]
000010  f44f62b0          MOV      r2,#0x580
000014  2101              MOVS     r1,#1
000016  6803              LDR      r3,[r0,#0]
000018  4620              MOV      r0,r4
00001a  4798              BLX      r3
00001c  f5007580          ADD      r5,r0,#0x100
000020  f44f7180          MOV      r1,#0x100
000024  f8c45144          STR      r5,[r4,#0x144]
000028  f7fffffe          BL       __aeabi_memclr
00002c  2000              MOVS     r0,#0
                  |L5.46|
00002e  5428              STRB     r0,[r5,r0]
000030  1c40              ADDS     r0,r0,#1
000032  28ff              CMP      r0,#0xff
000034  ddfb              BLE      |L5.46|
000036  2080              MOVS     r0,#0x80
000038  21ff              MOVS     r1,#0xff
00003a  0082              LSLS     r2,r0,#2
00003c  3580              ADDS     r5,r5,#0x80
                  |L5.62|
00003e  5429              STRB     r1,[r5,r0]
000040  1c40              ADDS     r0,r0,#1
000042  4290              CMP      r0,r2
000044  dbfb              BLT      |L5.62|
000046  f44f71c0          MOV      r1,#0x180
00004a  f5057000          ADD      r0,r5,#0x200
00004e  f7fffffe          BL       __aeabi_memclr
000052  2280              MOVS     r2,#0x80
000054  f5057060          ADD      r0,r5,#0x380
000058  f8d41144          LDR      r1,[r4,#0x144]
00005c  f7fffffe          BL       __aeabi_memcpy
;;;297      prepare_range_limit_table(cinfo);
;;;298    
;;;299      /* Width of an output scanline must be representable as JDIMENSION. */
;;;300      samplesperrow = (long) cinfo->output_width * (long) cinfo->out_color_components;
;;;301      jd_samplesperrow = (JDIMENSION) samplesperrow;
;;;302      if ((long) jd_samplesperrow != samplesperrow)
;;;303        ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
;;;304    
;;;305      /* Initialize my private state */
;;;306      master->pass_number = 0;
000060  2500              MOVS     r5,#0
;;;307      master->using_merged_upsample = use_merged_upsample(cinfo);
000062  4620              MOV      r0,r4
000064  60f5              STR      r5,[r6,#0xc]
000066  f7fffffe          BL       use_merged_upsample
00006a  e9c60504          STRD     r0,r5,[r6,#0x10]
;;;308    
;;;309      /* Color quantizer selection */
;;;310      master->quantizer_1pass = NULL;
;;;311      master->quantizer_2pass = NULL;
;;;312      /* No mode changes if not using buffered-image mode. */
;;;313      if (! cinfo->quantize_colors || ! cinfo->buffered_image) {
00006e  61b5              STR      r5,[r6,#0x18]
000070  6d60              LDR      r0,[r4,#0x54]         ;302
000072  2701              MOVS     r7,#1                 ;302
000074  b108              CBZ      r0,|L5.122|
000076  6c21              LDR      r1,[r4,#0x40]
000078  b919              CBNZ     r1,|L5.130|
                  |L5.122|
;;;314        cinfo->enable_1pass_quant = FALSE;
;;;315        cinfo->enable_external_quant = FALSE;
00007a  6665              STR      r5,[r4,#0x64]
;;;316        cinfo->enable_2pass_quant = FALSE;
00007c  66a5              STR      r5,[r4,#0x68]
00007e  66e5              STR      r5,[r4,#0x6c]
000080  b370              CBZ      r0,|L5.224|
                  |L5.130|
;;;317      }
;;;318      if (cinfo->quantize_colors) {
;;;319        if (cinfo->raw_data_out)
000082  6c60              LDR      r0,[r4,#0x44]
000084  b130              CBZ      r0,|L5.148|
;;;320          ERREXIT(cinfo, JERR_NOTIMPL);
000086  6821              LDR      r1,[r4,#0]
000088  202f              MOVS     r0,#0x2f
00008a  6148              STR      r0,[r1,#0x14]
00008c  6820              LDR      r0,[r4,#0]
00008e  6801              LDR      r1,[r0,#0]
000090  4620              MOV      r0,r4
000092  4788              BLX      r1
                  |L5.148|
;;;321        /* 2-pass quantizer only works in 3-component color space. */
;;;322        if (cinfo->out_color_components != 3) {
000094  6fa0              LDR      r0,[r4,#0x78]
000096  2803              CMP      r0,#3
000098  d005              BEQ      |L5.166|
00009a  e9c47519          STRD     r7,r5,[r4,#0x64]
;;;323          cinfo->enable_1pass_quant = TRUE;
;;;324          cinfo->enable_external_quant = FALSE;
;;;325          cinfo->enable_2pass_quant = FALSE;
;;;326          cinfo->colormap = NULL;
00009e  66e5              STR      r5,[r4,#0x6c]
0000a0  f8c45088          STR      r5,[r4,#0x88]
0000a4  e009              B        |L5.186|
                  |L5.166|
;;;327        } else if (cinfo->colormap != NULL) {
0000a6  f8d40088          LDR      r0,[r4,#0x88]
0000aa  b108              CBZ      r0,|L5.176|
;;;328          cinfo->enable_external_quant = TRUE;
0000ac  66a7              STR      r7,[r4,#0x68]
0000ae  e002              B        |L5.182|
                  |L5.176|
;;;329        } else if (cinfo->two_pass_quantize) {
0000b0  6de0              LDR      r0,[r4,#0x5c]
0000b2  b158              CBZ      r0,|L5.204|
;;;330          cinfo->enable_2pass_quant = TRUE;
0000b4  66e7              STR      r7,[r4,#0x6c]
                  |L5.182|
;;;331        } else {
;;;332          cinfo->enable_1pass_quant = TRUE;
;;;333        }
;;;334    
;;;335        if (cinfo->enable_1pass_quant) {
0000b6  6e60              LDR      r0,[r4,#0x64]
0000b8  b128              CBZ      r0,|L5.198|
                  |L5.186|
;;;336    #ifdef QUANT_1PASS_SUPPORTED
;;;337          jinit_1pass_quantizer(cinfo);
0000ba  4620              MOV      r0,r4
0000bc  f7fffffe          BL       jinit_1pass_quantizer
;;;338          master->quantizer_1pass = cinfo->cquantize;
0000c0  f8d401cc          LDR      r0,[r4,#0x1cc]
0000c4  6170              STR      r0,[r6,#0x14]
                  |L5.198|
;;;339    #else
;;;340          ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;341    #endif
;;;342        }
;;;343    
;;;344        /* We use the 2-pass code to map to external colormaps. */
;;;345        if (cinfo->enable_2pass_quant || cinfo->enable_external_quant) {
0000c6  6ee0              LDR      r0,[r4,#0x6c]
0000c8  b920              CBNZ     r0,|L5.212|
0000ca  e001              B        |L5.208|
                  |L5.204|
0000cc  6667              STR      r7,[r4,#0x64]         ;332
0000ce  e7f4              B        |L5.186|
                  |L5.208|
0000d0  6ea0              LDR      r0,[r4,#0x68]
0000d2  b128              CBZ      r0,|L5.224|
                  |L5.212|
;;;346    #ifdef QUANT_2PASS_SUPPORTED
;;;347          jinit_2pass_quantizer(cinfo);
0000d4  4620              MOV      r0,r4
0000d6  f7fffffe          BL       jinit_2pass_quantizer
;;;348          master->quantizer_2pass = cinfo->cquantize;
0000da  f8d401cc          LDR      r0,[r4,#0x1cc]
0000de  61b0              STR      r0,[r6,#0x18]
                  |L5.224|
;;;349    #else
;;;350          ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;351    #endif
;;;352        }
;;;353        /* If both quantizers are initialized, the 2-pass one is left active;
;;;354         * this is necessary for starting with quantization to an external map.
;;;355         */
;;;356      }
;;;357    
;;;358      /* Post-processing: in particular, color conversion first */
;;;359      if (! cinfo->raw_data_out) {
0000e0  6c60              LDR      r0,[r4,#0x44]
0000e2  b978              CBNZ     r0,|L5.260|
;;;360        if (master->using_merged_upsample) {
0000e4  6930              LDR      r0,[r6,#0x10]
0000e6  2800              CMP      r0,#0
;;;361    #ifdef UPSAMPLE_MERGING_SUPPORTED
;;;362          jinit_merged_upsampler(cinfo); /* does color conversion too */
;;;363    #else
;;;364          ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;365    #endif
;;;366        } else {
;;;367          jinit_color_deconverter(cinfo);
0000e8  4620              MOV      r0,r4
0000ea  d002              BEQ      |L5.242|
0000ec  f7fffffe          BL       jinit_merged_upsampler
0000f0  e004              B        |L5.252|
                  |L5.242|
0000f2  f7fffffe          BL       jinit_color_deconverter
;;;368          jinit_upsampler(cinfo);
0000f6  4620              MOV      r0,r4
0000f8  f7fffffe          BL       jinit_upsampler
                  |L5.252|
;;;369        }
;;;370        jinit_d_post_controller(cinfo, cinfo->enable_2pass_quant);
0000fc  4620              MOV      r0,r4
0000fe  6ee1              LDR      r1,[r4,#0x6c]
000100  f7fffffe          BL       jinit_d_post_controller
                  |L5.260|
;;;371      }
;;;372      /* Inverse DCT */
;;;373      jinit_inverse_dct(cinfo);
000104  4620              MOV      r0,r4
000106  f7fffffe          BL       jinit_inverse_dct
;;;374      /* Entropy decoding: either Huffman or arithmetic coding. */
;;;375      if (cinfo->arith_code) {
00010a  f8d400e0          LDR      r0,[r4,#0xe0]
00010e  b130              CBZ      r0,|L5.286|
;;;376        ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
000110  6820              LDR      r0,[r4,#0]
000112  6147              STR      r7,[r0,#0x14]
000114  6820              LDR      r0,[r4,#0]
000116  6801              LDR      r1,[r0,#0]
000118  4620              MOV      r0,r4
00011a  4788              BLX      r1
00011c  e009              B        |L5.306|
                  |L5.286|
;;;377      } else {
;;;378        if (cinfo->progressive_mode) {
00011e  f8d400dc          LDR      r0,[r4,#0xdc]
000122  2800              CMP      r0,#0
;;;379    #ifdef D_PROGRESSIVE_SUPPORTED
;;;380          jinit_phuff_decoder(cinfo);
;;;381    #else
;;;382          ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;383    #endif
;;;384        } else
;;;385          jinit_huff_decoder(cinfo);
000124  4620              MOV      r0,r4
000126  d002              BEQ      |L5.302|
000128  f7fffffe          BL       jinit_phuff_decoder
00012c  e001              B        |L5.306|
                  |L5.302|
00012e  f7fffffe          BL       jinit_huff_decoder
                  |L5.306|
;;;386      }
;;;387    
;;;388      /* Initialize principal buffer controllers. */
;;;389      use_c_buffer = cinfo->inputctl->has_multiple_scans || cinfo->buffered_image;
000132  f8d401b4          LDR      r0,[r4,#0x1b4]
000136  6900              LDR      r0,[r0,#0x10]
000138  b908              CBNZ     r0,|L5.318|
00013a  6c20              LDR      r0,[r4,#0x40]
00013c  b108              CBZ      r0,|L5.322|
                  |L5.318|
00013e  2101              MOVS     r1,#1
000140  e000              B        |L5.324|
                  |L5.322|
000142  2100              MOVS     r1,#0
                  |L5.324|
;;;390      jinit_d_coef_controller(cinfo, use_c_buffer);
000144  4620              MOV      r0,r4
000146  f7fffffe          BL       jinit_d_coef_controller
;;;391    
;;;392      if (! cinfo->raw_data_out)
00014a  6c60              LDR      r0,[r4,#0x44]
00014c  b918              CBNZ     r0,|L5.342|
;;;393        jinit_d_main_controller(cinfo, FALSE /* never need full buffer here */);
00014e  2100              MOVS     r1,#0
000150  4620              MOV      r0,r4
000152  f7fffffe          BL       jinit_d_main_controller
                  |L5.342|
;;;394    
;;;395      /* We can now tell the memory manager to allocate virtual arrays. */
;;;396      (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);
000156  6860              LDR      r0,[r4,#4]
000158  6981              LDR      r1,[r0,#0x18]
00015a  4620              MOV      r0,r4
00015c  4788              BLX      r1
;;;397    
;;;398      /* Initialize input side of decompressor to consume first scan. */
;;;399      (*cinfo->inputctl->start_input_pass) (cinfo);
00015e  f8d401b4          LDR      r0,[r4,#0x1b4]
000162  6881              LDR      r1,[r0,#8]
000164  4620              MOV      r0,r4
000166  4788              BLX      r1
;;;400    
;;;401    #ifdef D_MULTISCAN_FILES_SUPPORTED
;;;402      /* If jpeg_start_decompress will read the whole file, initialize
;;;403       * progress monitoring appropriately.  The input step is counted
;;;404       * as one pass.
;;;405       */
;;;406      if (cinfo->progress != NULL && ! cinfo->buffered_image &&
000168  68a1              LDR      r1,[r4,#8]
00016a  2900              CMP      r1,#0
00016c  d021              BEQ      |L5.434|
00016e  6c20              LDR      r0,[r4,#0x40]
000170  2800              CMP      r0,#0
000172  d11e              BNE      |L5.434|
;;;407          cinfo->inputctl->has_multiple_scans) {
000174  f8d401b4          LDR      r0,[r4,#0x1b4]
000178  6900              LDR      r0,[r0,#0x10]
00017a  2800              CMP      r0,#0
00017c  d019              BEQ      |L5.434|
;;;408        int nscans;
;;;409        /* Estimate number of scans to set pass_limit. */
;;;410        if (cinfo->progressive_mode) {
00017e  f8d400dc          LDR      r0,[r4,#0xdc]
000182  2800              CMP      r0,#0
000184  6a60              LDR      r0,[r4,#0x24]
000186  d002              BEQ      |L5.398|
;;;411          /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
;;;412          nscans = 2 + 3 * cinfo->num_components;
000188  eb000040          ADD      r0,r0,r0,LSL #1
00018c  1c80              ADDS     r0,r0,#2
                  |L5.398|
;;;413        } else {
;;;414          /* For a nonprogressive multiscan file, estimate 1 scan per component. */
;;;415          nscans = cinfo->num_components;
;;;416        }
;;;417        cinfo->progress->pass_counter = 0L;
;;;418        cinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows * nscans;
00018e  604d              STR      r5,[r1,#4]
000190  f8d41140          LDR      r1,[r4,#0x140]
000194  4341              MULS     r1,r0,r1
000196  68a0              LDR      r0,[r4,#8]
;;;419        cinfo->progress->completed_passes = 0;
000198  6081              STR      r1,[r0,#8]
00019a  68a0              LDR      r0,[r4,#8]
;;;420        cinfo->progress->total_passes = (cinfo->enable_2pass_quant ? 3 : 2);
00019c  60c5              STR      r5,[r0,#0xc]
00019e  6ee0              LDR      r0,[r4,#0x6c]
0001a0  b108              CBZ      r0,|L5.422|
0001a2  2003              MOVS     r0,#3
0001a4  e000              B        |L5.424|
                  |L5.422|
0001a6  2002              MOVS     r0,#2
                  |L5.424|
0001a8  68a1              LDR      r1,[r4,#8]
;;;421        /* Count the input pass as done */
;;;422        master->pass_number++;
0001aa  6108              STR      r0,[r1,#0x10]
0001ac  68f0              LDR      r0,[r6,#0xc]
0001ae  1c40              ADDS     r0,r0,#1
0001b0  60f0              STR      r0,[r6,#0xc]
                  |L5.434|
;;;423      }
;;;424    #endif /* D_MULTISCAN_FILES_SUPPORTED */
;;;425    }
0001b2  e8bd81f0          POP      {r4-r8,pc}
;;;426    
                          ENDP


                          AREA ||i.prepare_for_output_pass||, CODE, READONLY, ALIGN=1

                  prepare_for_output_pass PROC
;;;437    METHODDEF(void)
;;;438    prepare_for_output_pass (j_decompress_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;439    {
;;;440      my_master_ptr master = (my_master_ptr) cinfo->master;
;;;441    
;;;442      if (master->pub.is_dummy_pass) {
000002  f8d051a4          LDR      r5,[r0,#0x1a4]
000006  4604              MOV      r4,r0                 ;439
000008  68a8              LDR      r0,[r5,#8]            ;439
00000a  b190              CBZ      r0,|L6.50|
;;;443    #ifdef QUANT_2PASS_SUPPORTED
;;;444        /* Final pass of 2-pass quantization */
;;;445        master->pub.is_dummy_pass = FALSE;
00000c  2000              MOVS     r0,#0
;;;446        (*cinfo->cquantize->start_pass) (cinfo, FALSE);
00000e  60a8              STR      r0,[r5,#8]
000010  f8d401cc          LDR      r0,[r4,#0x1cc]
000014  2100              MOVS     r1,#0
000016  6802              LDR      r2,[r0,#0]
000018  4620              MOV      r0,r4
00001a  4790              BLX      r2
;;;447        (*cinfo->post->start_pass) (cinfo, JBUF_CRANK_DEST);
00001c  f8d401b0          LDR      r0,[r4,#0x1b0]
000020  2102              MOVS     r1,#2
000022  6802              LDR      r2,[r0,#0]
000024  4620              MOV      r0,r4
000026  4790              BLX      r2
;;;448        (*cinfo->main->start_pass) (cinfo, JBUF_CRANK_DEST);
000028  f8d401a8          LDR      r0,[r4,#0x1a8]
00002c  2102              MOVS     r1,#2
00002e  6802              LDR      r2,[r0,#0]
000030  e049              B        |L6.198|
                  |L6.50|
;;;449    #else
;;;450        ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;451    #endif /* QUANT_2PASS_SUPPORTED */
;;;452      } else {
;;;453        if (cinfo->quantize_colors && cinfo->colormap == NULL) {
000032  6d60              LDR      r0,[r4,#0x54]
000034  b1c8              CBZ      r0,|L6.106|
000036  f8d40088          LDR      r0,[r4,#0x88]
00003a  b9b0              CBNZ     r0,|L6.106|
;;;454          /* Select new quantization method */
;;;455          if (cinfo->two_pass_quantize && cinfo->enable_2pass_quant) {
00003c  6de0              LDR      r0,[r4,#0x5c]
00003e  b138              CBZ      r0,|L6.80|
000040  6ee0              LDR      r0,[r4,#0x6c]
000042  b128              CBZ      r0,|L6.80|
;;;456    	cinfo->cquantize = master->quantizer_2pass;
000044  69a8              LDR      r0,[r5,#0x18]
;;;457    	master->pub.is_dummy_pass = TRUE;
000046  f8c401cc          STR      r0,[r4,#0x1cc]
00004a  2001              MOVS     r0,#1
00004c  60a8              STR      r0,[r5,#8]
00004e  e00c              B        |L6.106|
                  |L6.80|
;;;458          } else if (cinfo->enable_1pass_quant) {
000050  6e60              LDR      r0,[r4,#0x64]
000052  b118              CBZ      r0,|L6.92|
;;;459    	cinfo->cquantize = master->quantizer_1pass;
000054  6968              LDR      r0,[r5,#0x14]
000056  f8c401cc          STR      r0,[r4,#0x1cc]
00005a  e006              B        |L6.106|
                  |L6.92|
;;;460          } else {
;;;461    	ERREXIT(cinfo, JERR_MODE_CHANGE);
00005c  6821              LDR      r1,[r4,#0]
00005e  202e              MOVS     r0,#0x2e
000060  6148              STR      r0,[r1,#0x14]
000062  6820              LDR      r0,[r4,#0]
000064  6801              LDR      r1,[r0,#0]
000066  4620              MOV      r0,r4
000068  4788              BLX      r1
                  |L6.106|
;;;462          }
;;;463        }
;;;464        (*cinfo->idct->start_pass) (cinfo);
00006a  f8d401c0          LDR      r0,[r4,#0x1c0]
00006e  6801              LDR      r1,[r0,#0]
000070  4620              MOV      r0,r4
000072  4788              BLX      r1
;;;465        (*cinfo->coef->start_output_pass) (cinfo);
000074  f8d401ac          LDR      r0,[r4,#0x1ac]
000078  6881              LDR      r1,[r0,#8]
00007a  4620              MOV      r0,r4
00007c  4788              BLX      r1
;;;466        if (! cinfo->raw_data_out) {
00007e  6c60              LDR      r0,[r4,#0x44]
000080  bb18              CBNZ     r0,|L6.202|
;;;467          if (! master->using_merged_upsample)
000082  6928              LDR      r0,[r5,#0x10]
000084  b920              CBNZ     r0,|L6.144|
;;;468    	(*cinfo->cconvert->start_pass) (cinfo);
000086  f8d401c8          LDR      r0,[r4,#0x1c8]
00008a  6801              LDR      r1,[r0,#0]
00008c  4620              MOV      r0,r4
00008e  4788              BLX      r1
                  |L6.144|
;;;469          (*cinfo->upsample->start_pass) (cinfo);
000090  f8d401c4          LDR      r0,[r4,#0x1c4]
000094  6801              LDR      r1,[r0,#0]
000096  4620              MOV      r0,r4
000098  4788              BLX      r1
;;;470          if (cinfo->quantize_colors)
00009a  6d60              LDR      r0,[r4,#0x54]
00009c  b128              CBZ      r0,|L6.170|
;;;471    	(*cinfo->cquantize->start_pass) (cinfo, master->pub.is_dummy_pass);
00009e  f8d401cc          LDR      r0,[r4,#0x1cc]
0000a2  68a9              LDR      r1,[r5,#8]
0000a4  6802              LDR      r2,[r0,#0]
0000a6  4620              MOV      r0,r4
0000a8  4790              BLX      r2
                  |L6.170|
;;;472          (*cinfo->post->start_pass) (cinfo,
0000aa  68a8              LDR      r0,[r5,#8]
0000ac  b108              CBZ      r0,|L6.178|
;;;473    	    (master->pub.is_dummy_pass ? JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));
0000ae  2103              MOVS     r1,#3
0000b0  e000              B        |L6.180|
                  |L6.178|
0000b2  2100              MOVS     r1,#0
                  |L6.180|
0000b4  f8d401b0          LDR      r0,[r4,#0x1b0]
0000b8  6802              LDR      r2,[r0,#0]
0000ba  4620              MOV      r0,r4
0000bc  4790              BLX      r2
;;;474          (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);
0000be  f8d401a8          LDR      r0,[r4,#0x1a8]
0000c2  2100              MOVS     r1,#0
0000c4  6802              LDR      r2,[r0,#0]
                  |L6.198|
0000c6  4620              MOV      r0,r4
0000c8  4790              BLX      r2
                  |L6.202|
;;;475        }
;;;476      }
;;;477    
;;;478      /* Set up progress monitor's pass info if present */
;;;479      if (cinfo->progress != NULL) {
0000ca  68a0              LDR      r0,[r4,#8]
0000cc  2800              CMP      r0,#0
0000ce  d01a              BEQ      |L6.262|
;;;480        cinfo->progress->completed_passes = master->pass_number;
0000d0  68e9              LDR      r1,[r5,#0xc]
0000d2  60c1              STR      r1,[r0,#0xc]
0000d4  e9d51002          LDRD     r1,r0,[r5,#8]
;;;481        cinfo->progress->total_passes = master->pass_number +
0000d8  b109              CBZ      r1,|L6.222|
;;;482    				    (master->pub.is_dummy_pass ? 2 : 1);
0000da  2102              MOVS     r1,#2
0000dc  e000              B        |L6.224|
                  |L6.222|
0000de  2101              MOVS     r1,#1
                  |L6.224|
0000e0  4401              ADD      r1,r1,r0
0000e2  68a0              LDR      r0,[r4,#8]
;;;483        /* In buffered-image mode, we assume one more output pass if EOI not
;;;484         * yet reached, but no more passes if EOI has been reached.
;;;485         */
;;;486        if (cinfo->buffered_image && ! cinfo->inputctl->eoi_reached) {
0000e4  6101              STR      r1,[r0,#0x10]
0000e6  6c20              LDR      r0,[r4,#0x40]
0000e8  2800              CMP      r0,#0
0000ea  d00c              BEQ      |L6.262|
0000ec  f8d401b4          LDR      r0,[r4,#0x1b4]
0000f0  6940              LDR      r0,[r0,#0x14]
0000f2  2800              CMP      r0,#0
0000f4  d107              BNE      |L6.262|
;;;487          cinfo->progress->total_passes += (cinfo->enable_2pass_quant ? 2 : 1);
0000f6  6ee2              LDR      r2,[r4,#0x6c]
0000f8  68a0              LDR      r0,[r4,#8]
0000fa  b10a              CBZ      r2,|L6.256|
0000fc  2202              MOVS     r2,#2
0000fe  e000              B        |L6.258|
                  |L6.256|
000100  2201              MOVS     r2,#1
                  |L6.258|
000102  4411              ADD      r1,r1,r2
000104  6101              STR      r1,[r0,#0x10]
                  |L6.262|
;;;488        }
;;;489      }
;;;490    }
000106  bd70              POP      {r4-r6,pc}
;;;491    
                          ENDP


                          AREA ||i.use_merged_upsample||, CODE, READONLY, ALIGN=1

                  use_merged_upsample PROC
;;;43     LOCAL(boolean)
;;;44     use_merged_upsample (j_decompress_ptr cinfo)
000000  6cc1              LDR      r1,[r0,#0x4c]
;;;45     {
000002  bb91              CBNZ     r1,|L7.106|
;;;46     #ifdef UPSAMPLE_MERGING_SUPPORTED
;;;47       /* Merging is the equivalent of plain box-filter upsampling */
;;;48       if (cinfo->do_fancy_upsampling || cinfo->CCIR601_sampling)
000004  f8d0112c          LDR      r1,[r0,#0x12c]
000008  bb79              CBNZ     r1,|L7.106|
;;;49         return FALSE;
;;;50       /* jdmerge.c only supports YCC=>RGB color conversion */
;;;51       if (cinfo->jpeg_color_space != JCS_YCbCr || cinfo->num_components != 3 ||
00000a  f8901028          LDRB     r1,[r0,#0x28]
00000e  2903              CMP      r1,#3
000010  d12b              BNE      |L7.106|
000012  6a41              LDR      r1,[r0,#0x24]
000014  2903              CMP      r1,#3
000016  d128              BNE      |L7.106|
;;;52           cinfo->out_color_space != JCS_RGB ||
000018  f8901029          LDRB     r1,[r0,#0x29]
00001c  2902              CMP      r1,#2
00001e  d124              BNE      |L7.106|
;;;53           cinfo->out_color_components != RGB_PIXELSIZE)
000020  6f81              LDR      r1,[r0,#0x78]
000022  2903              CMP      r1,#3
000024  d121              BNE      |L7.106|
;;;54         return FALSE;
;;;55       /* and it only handles 2h1v or 2h2v sampling ratios */
;;;56       if (cinfo->comp_info[0].h_samp_factor != 2 ||
000026  f8d010d8          LDR      r1,[r0,#0xd8]
00002a  688a              LDR      r2,[r1,#8]
00002c  2a02              CMP      r2,#2
00002e  d11c              BNE      |L7.106|
;;;57           cinfo->comp_info[1].h_samp_factor != 1 ||
000030  6dca              LDR      r2,[r1,#0x5c]
000032  2a01              CMP      r2,#1
000034  d119              BNE      |L7.106|
;;;58           cinfo->comp_info[2].h_samp_factor != 1 ||
000036  f8d120b0          LDR      r2,[r1,#0xb0]
00003a  2a01              CMP      r2,#1
00003c  d115              BNE      |L7.106|
;;;59           cinfo->comp_info[0].v_samp_factor >  2 ||
00003e  68ca              LDR      r2,[r1,#0xc]
000040  2a02              CMP      r2,#2
000042  dc12              BGT      |L7.106|
;;;60           cinfo->comp_info[1].v_samp_factor != 1 ||
000044  6e0a              LDR      r2,[r1,#0x60]
000046  2a01              CMP      r2,#1
000048  d10f              BNE      |L7.106|
;;;61           cinfo->comp_info[2].v_samp_factor != 1)
00004a  f8d120b4          LDR      r2,[r1,#0xb4]
00004e  2a01              CMP      r2,#1
000050  d10b              BNE      |L7.106|
;;;62         return FALSE;
;;;63       /* furthermore, it doesn't work if we've scaled the IDCTs differently */
;;;64       if (cinfo->comp_info[0].DCT_scaled_size != cinfo->min_DCT_scaled_size ||
000052  6a4a              LDR      r2,[r1,#0x24]
000054  f8d0013c          LDR      r0,[r0,#0x13c]
000058  4282              CMP      r2,r0
00005a  d106              BNE      |L7.106|
;;;65           cinfo->comp_info[1].DCT_scaled_size != cinfo->min_DCT_scaled_size ||
00005c  6f8a              LDR      r2,[r1,#0x78]
00005e  4282              CMP      r2,r0
000060  d103              BNE      |L7.106|
;;;66           cinfo->comp_info[2].DCT_scaled_size != cinfo->min_DCT_scaled_size)
000062  f8d110cc          LDR      r1,[r1,#0xcc]
000066  4281              CMP      r1,r0
000068  d001              BEQ      |L7.110|
                  |L7.106|
;;;67         return FALSE;
00006a  2000              MOVS     r0,#0
;;;68       /* ??? also need to test for upsample-time rescaling, when & if supported */
;;;69       return TRUE;			/* by golly, it'll work... */
;;;70     #else
;;;71       return FALSE;
;;;72     #endif
;;;73     }
00006c  4770              BX       lr
                  |L7.110|
00006e  2001              MOVS     r0,#1                 ;69
000070  4770              BX       lr
;;;74     
                          ENDP

