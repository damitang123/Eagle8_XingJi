; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\guiaacircle.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\guiaacircle.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\AntiAlias\GUIAACircle.c]
                          THUMB

                          AREA ||i.FillCircle||, CODE, READONLY, ALIGN=2

                  FillCircle PROC
;;;41     */
;;;42     static void FillCircle(int x0, int y0, int r) {
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
000004  4614              MOV      r4,r2
000006  468a              MOV      r10,r1
;;;43       int i, x;
;;;44       int sqmax = r*r+r/2;
;;;45       int yMin, yMax;
;;;46       /* First step : find uppermost and lowermost coordinates */
;;;47       yMin = y0 - r;
;;;48       yMax = y0 + r;
;;;49       /* Use Clipping rect to reduce calculation (if possible) */
;;;50       if (GUI_Context.pClipRect_HL) {
000008  f8dfb0a0          LDR      r11,|L1.172|
00000c  fb02f004          MUL      r0,r2,r4              ;44
000010  eb0271d4          ADD      r1,r2,r4,LSR #31      ;44
000014  eb000661          ADD      r6,r0,r1,ASR #1       ;44
000018  f8db0014          LDR      r0,[r11,#0x14]        ;42  ; GUI_Context
00001c  ebaa0804          SUB      r8,r10,r4             ;47
000020  eb0a0904          ADD      r9,r10,r4             ;48
000024  b148              CBZ      r0,|L1.58|
;;;51         if (yMax > GUI_Context.pClipRect_HL->y1)
000026  f9b01006          LDRSH    r1,[r0,#6]
00002a  4549              CMP      r1,r9
00002c  da00              BGE      |L1.48|
;;;52           yMax = GUI_Context.pClipRect_HL->y1;
00002e  4689              MOV      r9,r1
                  |L1.48|
;;;53         if (yMin < GUI_Context.pClipRect_HL->y0)
000030  f9b00002          LDRSH    r0,[r0,#2]
000034  4540              CMP      r0,r8
000036  dd00              BLE      |L1.58|
;;;54           yMin = GUI_Context.pClipRect_HL->y0;
000038  4680              MOV      r8,r0
                  |L1.58|
;;;55       }
;;;56       /* Draw top half */
;;;57       for (i=0, x=r; i<r; i++) {
00003a  2500              MOVS     r5,#0
00003c  4627              MOV      r7,r4
00003e  e015              B        |L1.108|
                  |L1.64|
;;;58         int y = y0-i;
000040  ebaa0105          SUB      r1,r10,r5
;;;59         if ((y >= yMin) && (y <= yMax)) {
000044  4541              CMP      r1,r8
000046  db10              BLT      |L1.106|
000048  4549              CMP      r1,r9
00004a  dc0e              BGT      |L1.106|
;;;60           /* calc proper x-value */
;;;61           while ((i*i+x*x) >sqmax)
00004c  fb05f005          MUL      r0,r5,r5
                  |L1.80|
000050  fb070207          MLA      r2,r7,r7,r0
000054  42b2              CMP      r2,r6
000056  dd01              BLE      |L1.92|
000058  1e7f              SUBS     r7,r7,#1
;;;62             --x;
00005a  e7f9              B        |L1.80|
                  |L1.92|
;;;63           LCD_HL_DrawHLine (x0-x, y, x0+x);
00005c  f8db305c          LDR      r3,[r11,#0x5c]  ; GUI_Context
000060  9800              LDR      r0,[sp,#0]
000062  19c2              ADDS     r2,r0,r7
000064  681b              LDR      r3,[r3,#0]
000066  1bc0              SUBS     r0,r0,r7
000068  4798              BLX      r3
                  |L1.106|
00006a  1c6d              ADDS     r5,r5,#1
                  |L1.108|
00006c  42a5              CMP      r5,r4                 ;57
00006e  dbe7              BLT      |L1.64|
;;;64         }
;;;65       }
;;;66       /* Draw bottom half */
;;;67       for (i=0, x=r; i<r; i++) {
000070  2500              MOVS     r5,#0
000072  4627              MOV      r7,r4
000074  e016              B        |L1.164|
;;;68         int y = y0 + i;
000076  bf00              NOP      
                  |L1.120|
000078  eb0a0105          ADD      r1,r10,r5
;;;69         if ((y >= yMin) && (y <= yMax)) {
00007c  4541              CMP      r1,r8
00007e  db10              BLT      |L1.162|
000080  4549              CMP      r1,r9
000082  dc0e              BGT      |L1.162|
000084  fb05f005          MUL      r0,r5,r5              ;61
                  |L1.136|
;;;70           /* calc proper x-value */
;;;71           while ((i*i+x*x) >sqmax)
000088  fb070207          MLA      r2,r7,r7,r0
00008c  42b2              CMP      r2,r6
00008e  dd01              BLE      |L1.148|
000090  1e7f              SUBS     r7,r7,#1
;;;72             --x;
000092  e7f9              B        |L1.136|
                  |L1.148|
;;;73           LCD_HL_DrawHLine (x0-x, y, x0+x);
000094  f8db305c          LDR      r3,[r11,#0x5c]  ; GUI_Context
000098  9800              LDR      r0,[sp,#0]
00009a  19c2              ADDS     r2,r0,r7
00009c  681b              LDR      r3,[r3,#0]
00009e  1bc0              SUBS     r0,r0,r7
0000a0  4798              BLX      r3
                  |L1.162|
0000a2  1c6d              ADDS     r5,r5,#1
                  |L1.164|
0000a4  42a5              CMP      r5,r4                 ;67
0000a6  dbe7              BLT      |L1.120|
;;;74         }
;;;75       }
;;;76     }
0000a8  e8bd8ffe          POP      {r1-r11,pc}
;;;77     
                          ENDP

                  |L1.172|
                          DCD      GUI_Context

                          AREA ||i.GL_FillCircleAA_HiRes||, CODE, READONLY, ALIGN=1

                  GL_FillCircleAA_HiRes PROC
;;;87     */
;;;88     void GL_FillCircleAA_HiRes(int x0, int y0, int r) {
000000  b570              PUSH     {r4-r6,lr}
000002  4614              MOV      r4,r2
000004  460e              MOV      r6,r1
000006  4605              MOV      r5,r0
;;;89     /* Init AA Subsystem, pass horizontal limits */
;;;90       GUI_AA_Init_HiRes(x0-r, x0+r);
000008  1901              ADDS     r1,r0,r4
00000a  1b00              SUBS     r0,r0,r4
00000c  f7fffffe          BL       GUI_AA_Init_HiRes
;;;91     /* Do the actual drawing */
;;;92       FillCircle(x0, y0, r);
000010  4622              MOV      r2,r4
000012  4631              MOV      r1,r6
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       FillCircle
;;;93     /* Cleanup */
;;;94       GUI_AA_Exit();
00001a  e8bd4070          POP      {r4-r6,lr}
00001e  f7ffbffe          B.W      GUI_AA_Exit
;;;95     }
;;;96     
                          ENDP


                          AREA ||i.GUI_AA_FillCircle||, CODE, READONLY, ALIGN=2

                  GUI_AA_FillCircle PROC
;;;100    */
;;;101    void GUI_AA_FillCircle(int x0, int y0, int r) {
000000  b57c              PUSH     {r2-r6,lr}
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
;;;102      #if (GUI_WINSUPPORT)
;;;103        GUI_RECT Rect;
;;;104      #endif
;;;105      GUI_LOCK();
;;;106      #if (GUI_WINSUPPORT)
;;;107        WM_ADDORG_AA(x0,y0);
000008  f7fffffe          BL       WM__GetOrgX_AA
00000c  4406              ADD      r6,r6,r0
00000e  f7fffffe          BL       WM__GetOrgY_AA
000012  4405              ADD      r5,r5,r0
;;;108      #endif
;;;109      if (!GUI_Context.AA_HiResEnable) {
000014  4815              LDR      r0,|L3.108|
000016  f8901061          LDRB     r1,[r0,#0x61]  ; GUI_Context
00001a  b921              CBNZ     r1,|L3.38|
;;;110        x0 *= GUI_Context.AA_Factor;
00001c  f8901060          LDRB     r1,[r0,#0x60]  ; GUI_Context
000020  434e              MULS     r6,r1,r6
;;;111        y0 *= GUI_Context.AA_Factor;
000022  434d              MULS     r5,r1,r5
;;;112        r  *= GUI_Context.AA_Factor;
000024  434c              MULS     r4,r1,r4
                  |L3.38|
;;;113      }
;;;114      #if (GUI_WINSUPPORT)
;;;115        Rect.x0 = GUI_AA_HiRes2Pixel(x0 - r);
000026  1b30              SUBS     r0,r6,r4
000028  f7fffffe          BL       GUI_AA_HiRes2Pixel
00002c  f8ad0000          STRH     r0,[sp,#0]
;;;116        Rect.x1 = GUI_AA_HiRes2Pixel(x0 + r);
000030  1930              ADDS     r0,r6,r4
000032  f7fffffe          BL       GUI_AA_HiRes2Pixel
000036  f8ad0004          STRH     r0,[sp,#4]
;;;117        Rect.y0 = GUI_AA_HiRes2Pixel(y0 - r);
00003a  1b28              SUBS     r0,r5,r4
00003c  f7fffffe          BL       GUI_AA_HiRes2Pixel
000040  f8ad0002          STRH     r0,[sp,#2]
;;;118        Rect.y1 = GUI_AA_HiRes2Pixel(y0 + r);
000044  1928              ADDS     r0,r5,r4
000046  f7fffffe          BL       GUI_AA_HiRes2Pixel
00004a  f8ad0006          STRH     r0,[sp,#6]
;;;119        WM_ITERATE_START(&Rect); {
00004e  4668              MOV      r0,sp
000050  f7fffffe          BL       WM__InitIVRSearch
000054  e006              B        |L3.100|
                  |L3.86|
;;;120      #endif
;;;121      GL_FillCircleAA_HiRes(x0, y0, r);
000056  4622              MOV      r2,r4
000058  4629              MOV      r1,r5
00005a  4630              MOV      r0,r6
00005c  f7fffffe          BL       GL_FillCircleAA_HiRes
;;;122      #if (GUI_WINSUPPORT)
;;;123        } WM_ITERATE_END();
000060  f7fffffe          BL       WM__GetNextIVR
                  |L3.100|
000064  2800              CMP      r0,#0
000066  d1f6              BNE      |L3.86|
;;;124      #endif
;;;125      GUI_UNLOCK();
;;;126    }
000068  bd7c              POP      {r2-r6,pc}
;;;127    
                          ENDP

00006a  0000              DCW      0x0000
                  |L3.108|
                          DCD      GUI_Context
