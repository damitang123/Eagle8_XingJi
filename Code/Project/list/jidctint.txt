; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\jidctint.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jidctint.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\JPEG\jidctint.c]
                          THUMB

                          AREA ||i.jpeg_idct_islow||, CODE, READONLY, ALIGN=2

                  jpeg_idct_islow PROC
;;;147    GLOBAL(void)
;;;148    jpeg_idct_islow (j_decompress_ptr cinfo, jpeg_component_info * compptr,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;149    		 JCOEFPTR coef_block,
;;;150    		 JSAMPARRAY output_buf, JDIMENSION output_col)
;;;151    {
;;;152      INT32 tmp0, tmp1, tmp2, tmp3;
;;;153      INT32 tmp10, tmp11, tmp12, tmp13;
;;;154      INT32 z1, z2, z3, z4, z5;
;;;155      JCOEFPTR inptr;
;;;156      ISLOW_MULT_TYPE * quantptr;
;;;157      int * wsptr;
;;;158      JSAMPROW outptr;
;;;159      JSAMPLE *range_limit = IDCT_range_limit(cinfo);
;;;160      int ctr;
;;;161      int workspace[DCTSIZE2];	/* buffers data between passes */
;;;162      SHIFT_TEMPS
;;;163    
;;;164      /* Pass 1: process columns from input, store into work array. */
;;;165      /* Note results are scaled up by sqrt(8) compared to a true IDCT; */
;;;166      /* furthermore, we scale the results by 2**PASS1_BITS. */
;;;167    
;;;168      inptr = coef_block;
;;;169      quantptr = (ISLOW_MULT_TYPE *) compptr->dct_table;
000004  f8d03144          LDR      r3,[r0,#0x144]
000008  b0d2              SUB      sp,sp,#0x148          ;151
00000a  6d09              LDR      r1,[r1,#0x50]
;;;170      wsptr = workspace;
00000c  a80a              ADD      r0,sp,#0x28
;;;171      for (ctr = DCTSIZE; ctr > 0; ctr--) {
00000e  f04f0e08          MOV      lr,#8
000012  3380              ADDS     r3,r3,#0x80
                  |L1.20|
;;;172        /* Due to quantization, we will usually find that many of the input
;;;173         * coefficients are zero, especially the AC terms.  We can exploit this
;;;174         * by short-circuiting the IDCT calculation for any column in which all
;;;175         * the AC terms are zero.  In that case each output is equal to the
;;;176         * DC coefficient (with scale factor as needed).
;;;177         * With typical images and quantization tables, half or more of the
;;;178         * column DCT calculations can be simplified this way.
;;;179         */
;;;180        
;;;181        if (inptr[DCTSIZE*1] == 0 && inptr[DCTSIZE*2] == 0 &&
000014  f9b24010          LDRSH    r4,[r2,#0x10]
000018  b984              CBNZ     r4,|L1.60|
00001a  8c15              LDRH     r5,[r2,#0x20]
00001c  b975              CBNZ     r5,|L1.60|
;;;182    	inptr[DCTSIZE*3] == 0 && inptr[DCTSIZE*4] == 0 &&
00001e  8e15              LDRH     r5,[r2,#0x30]
000020  b965              CBNZ     r5,|L1.60|
000022  f8b25040          LDRH     r5,[r2,#0x40]
000026  b94d              CBNZ     r5,|L1.60|
;;;183    	inptr[DCTSIZE*5] == 0 && inptr[DCTSIZE*6] == 0 &&
000028  f8b25050          LDRH     r5,[r2,#0x50]
00002c  b935              CBNZ     r5,|L1.60|
00002e  f8b25060          LDRH     r5,[r2,#0x60]
000032  b91d              CBNZ     r5,|L1.60|
;;;184    	inptr[DCTSIZE*7] == 0) {
000034  f8b25070          LDRH     r5,[r2,#0x70]
000038  2d00              CMP      r5,#0
00003a  d07d              BEQ      |L1.312|
                  |L1.60|
;;;185          /* AC terms all zero */
;;;186          int dcval = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]) << PASS1_BITS;
;;;187          
;;;188          wsptr[DCTSIZE*0] = dcval;
;;;189          wsptr[DCTSIZE*1] = dcval;
;;;190          wsptr[DCTSIZE*2] = dcval;
;;;191          wsptr[DCTSIZE*3] = dcval;
;;;192          wsptr[DCTSIZE*4] = dcval;
;;;193          wsptr[DCTSIZE*5] = dcval;
;;;194          wsptr[DCTSIZE*6] = dcval;
;;;195          wsptr[DCTSIZE*7] = dcval;
;;;196          
;;;197          inptr++;			/* advance pointers to next column */
;;;198          quantptr++;
;;;199          wsptr++;
;;;200          continue;
;;;201        }
;;;202        
;;;203        /* Even part: reverse the even part of the forward DCT. */
;;;204        /* The rotator is sqrt(2)*c(-6). */
;;;205        
;;;206        z2 = DEQUANTIZE(inptr[DCTSIZE*2], quantptr[DCTSIZE*2]);
00003c  f9b25020          LDRSH    r5,[r2,#0x20]
000040  6c0e              LDR      r6,[r1,#0x40]
;;;207        z3 = DEQUANTIZE(inptr[DCTSIZE*6], quantptr[DCTSIZE*6]);
000042  f8d170c0          LDR      r7,[r1,#0xc0]
000046  4375              MULS     r5,r6,r5              ;206
000048  f9b26060          LDRSH    r6,[r2,#0x60]
00004c  437e              MULS     r6,r7,r6
;;;208        
;;;209        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
00004e  eb050c06          ADD      r12,r5,r6
000052  f2411751          MOV      r7,#0x1151
000056  fb0cfc07          MUL      r12,r12,r7
;;;210        tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
00005a  4fd8              LDR      r7,|L1.956|
00005c  fb07c706          MLA      r7,r7,r6,r12
;;;211        tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
000060  f640463f          MOV      r6,#0xc3f
000064  4375              MULS     r5,r6,r5
000066  eb0c0c45          ADD      r12,r12,r5,LSL #1
;;;212        
;;;213        z2 = DEQUANTIZE(inptr[DCTSIZE*0], quantptr[DCTSIZE*0]);
00006a  f8516b80          LDR      r6,[r1],#0x80
00006e  f9325b40          LDRSH    r5,[r2],#0x40
;;;214        z3 = DEQUANTIZE(inptr[DCTSIZE*4], quantptr[DCTSIZE*4]);
000072  f8518b60          LDR      r8,[r1],#0x60
000076  4375              MULS     r5,r6,r5              ;213
000078  f9326b30          LDRSH    r6,[r2],#0x30
00007c  fb06f608          MUL      r6,r6,r8
;;;215    
;;;216        tmp0 = (z2 + z3) << CONST_BITS;
000080  eb050806          ADD      r8,r5,r6
000084  ea4f3848          LSL      r8,r8,#13
;;;217        tmp1 = (z2 - z3) << CONST_BITS;
000088  1bad              SUBS     r5,r5,r6
;;;218        
;;;219        tmp10 = tmp0 + tmp3;
00008a  eb08090c          ADD      r9,r8,r12
00008e  036d              LSLS     r5,r5,#13             ;217
;;;220        tmp13 = tmp0 - tmp3;
000090  eba8060c          SUB      r6,r8,r12
;;;221        tmp11 = tmp1 + tmp2;
000094  eb050c07          ADD      r12,r5,r7
000098  f8cd9128          STR      r9,[sp,#0x128]
00009c  e9cdc64d          STRD     r12,r6,[sp,#0x134]
;;;222        tmp12 = tmp1 - tmp2;
0000a0  1bee              SUBS     r6,r5,r7
;;;223        
;;;224        /* Odd part per figure 8; the matrix is unitary and hence its
;;;225         * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
;;;226         */
;;;227        
;;;228        tmp0 = DEQUANTIZE(inptr[DCTSIZE*7], quantptr[DCTSIZE*7]);
0000a2  964c              STR      r6,[sp,#0x130]
0000a4  f9325920          LDRSH    r5,[r2],#-0x20
0000a8  f8516940          LDR      r6,[r1],#-0x40
;;;229        tmp1 = DEQUANTIZE(inptr[DCTSIZE*5], quantptr[DCTSIZE*5]);
0000ac  f9327920          LDRSH    r7,[r2],#-0x20
0000b0  4375              MULS     r5,r6,r5              ;228
0000b2  f8516940          LDR      r6,[r1],#-0x40
0000b6  4377              MULS     r7,r6,r7
;;;230        tmp2 = DEQUANTIZE(inptr[DCTSIZE*3], quantptr[DCTSIZE*3]);
0000b8  f932692e          LDRSH    r6,[r2],#-0x2e
0000bc  f851c940          LDR      r12,[r1],#-0x40
0000c0  fb06f60c          MUL      r6,r6,r12
;;;231        tmp3 = DEQUANTIZE(inptr[DCTSIZE*1], quantptr[DCTSIZE*1]);
0000c4  f851c91c          LDR      r12,[r1],#-0x1c
;;;232        
;;;233        z1 = tmp0 + tmp3;
;;;234        z2 = tmp1 + tmp2;
;;;235        z3 = tmp0 + tmp2;
0000c8  eb050b06          ADD      r11,r5,r6
0000cc  fb04f40c          MUL      r4,r4,r12             ;231
0000d0  eb050c04          ADD      r12,r5,r4             ;233
;;;236        z4 = tmp1 + tmp3;
0000d4  eb070a04          ADD      r10,r7,r4
;;;237        z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
0000d8  f8cdc01c          STR      r12,[sp,#0x1c]
0000dc  eb0b080a          ADD      r8,r11,r10
0000e0  f2425ca1          MOV      r12,#0x25a1
0000e4  fb08f80c          MUL      r8,r8,r12
;;;238        
;;;239        tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
0000e8  f6401c8e          MOV      r12,#0x98e
0000ec  fb05f50c          MUL      r5,r5,r12
;;;240        tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
0000f0  9503              STR      r5,[sp,#0xc]
0000f2  eb070906          ADD      r9,r7,r6              ;234
0000f6  f24415b3          MOV      r5,#0x41b3
0000fa  436f              MULS     r7,r5,r7
;;;241        tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
0000fc  f2462554          MOV      r5,#0x6254
000100  436e              MULS     r6,r5,r6
;;;242        tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
000102  f243050b          MOV      r5,#0x300b
000106  436c              MULS     r4,r5,r4
000108  e9cd6404          STRD     r6,r4,[sp,#0x10]
00010c  9702              STR      r7,[sp,#8]
;;;243        z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
00010e  4cac              LDR      r4,|L1.960|
000110  f8ddc01c          LDR      r12,[sp,#0x1c]
;;;244        z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
;;;245        z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
;;;246        z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
000114  4dac              LDR      r5,|L1.968|
000116  fb0cfc04          MUL      r12,r12,r4            ;243
00011a  4caa              LDR      r4,|L1.964|
00011c  fb09f904          MUL      r9,r9,r4              ;244
000120  ebab240b          SUB      r4,r11,r11,LSL #8     ;245
000124  ebc41484          RSB      r4,r4,r4,LSL #6       ;245
000128  eba4048b          SUB      r4,r4,r11,LSL #2      ;245
;;;247        
;;;248        z3 += z5;
00012c  4444              ADD      r4,r4,r8
;;;249        z4 += z5;
00012e  fb0a8805          MLA      r8,r10,r5,r8
;;;250        
;;;251        tmp0 += z1 + z3;
000132  eb0c0604          ADD      r6,r12,r4
000136  e000              B        |L1.314|
                  |L1.312|
000138  e05f              B        |L1.506|
                  |L1.314|
00013a  9d03              LDR      r5,[sp,#0xc]
;;;252        tmp1 += z2 + z4;
00013c  9f02              LDR      r7,[sp,#8]
00013e  eb060a05          ADD      r10,r6,r5             ;251
;;;253        tmp2 += z2 + z3;
000142  9e04              LDR      r6,[sp,#0x10]
000144  eb090508          ADD      r5,r9,r8              ;252
000148  444c              ADD      r4,r4,r9
00014a  4426              ADD      r6,r6,r4
00014c  443d              ADD      r5,r5,r7              ;252
;;;254        tmp3 += z1 + z4;
00014e  9c05              LDR      r4,[sp,#0x14]
000150  eb0c0708          ADD      r7,r12,r8
;;;255        
;;;256        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
;;;257        
;;;258        wsptr[DCTSIZE*0] = (int) DESCALE(tmp10 + tmp3, CONST_BITS-PASS1_BITS);
000154  f8dd9128          LDR      r9,[sp,#0x128]
000158  443c              ADD      r4,r4,r7              ;254
00015a  eb090704          ADD      r7,r9,r4
00015e  f5076780          ADD      r7,r7,#0x400
000162  12ff              ASRS     r7,r7,#11
000164  f8407be0          STR      r7,[r0],#0xe0
;;;259        wsptr[DCTSIZE*7] = (int) DESCALE(tmp10 - tmp3, CONST_BITS-PASS1_BITS);
000168  f8dd9128          LDR      r9,[sp,#0x128]
00016c  eba90404          SUB      r4,r9,r4
000170  f5046480          ADD      r4,r4,#0x400
000174  12e4              ASRS     r4,r4,#11
000176  f84049c0          STR      r4,[r0],#-0xc0
;;;260        wsptr[DCTSIZE*1] = (int) DESCALE(tmp11 + tmp2, CONST_BITS-PASS1_BITS);
00017a  f8ddc134          LDR      r12,[sp,#0x134]
00017e  eb0c0406          ADD      r4,r12,r6
000182  f5046480          ADD      r4,r4,#0x400
000186  12e4              ASRS     r4,r4,#11
000188  f8404b20          STR      r4,[r0],#0x20
;;;261        wsptr[DCTSIZE*6] = (int) DESCALE(tmp11 - tmp2, CONST_BITS-PASS1_BITS);
00018c  f8ddc134          LDR      r12,[sp,#0x134]
000190  ebac0406          SUB      r4,r12,r6
000194  f5046480          ADD      r4,r4,#0x400
000198  12e4              ASRS     r4,r4,#11
;;;262        wsptr[DCTSIZE*2] = (int) DESCALE(tmp12 + tmp1, CONST_BITS-PASS1_BITS);
00019a  f8c04080          STR      r4,[r0,#0x80]
00019e  9e4c              LDR      r6,[sp,#0x130]
0001a0  1974              ADDS     r4,r6,r5
0001a2  f5046480          ADD      r4,r4,#0x400
0001a6  12e4              ASRS     r4,r4,#11
0001a8  f8404b40          STR      r4,[r0],#0x40
;;;263        wsptr[DCTSIZE*5] = (int) DESCALE(tmp12 - tmp1, CONST_BITS-PASS1_BITS);
0001ac  9e4c              LDR      r6,[sp,#0x130]
0001ae  1b74              SUBS     r4,r6,r5
0001b0  f5046480          ADD      r4,r4,#0x400
0001b4  12e4              ASRS     r4,r4,#11
;;;264        wsptr[DCTSIZE*3] = (int) DESCALE(tmp13 + tmp0, CONST_BITS-PASS1_BITS);
0001b6  6204              STR      r4,[r0,#0x20]
0001b8  9e4e              LDR      r6,[sp,#0x138]
0001ba  eb06040a          ADD      r4,r6,r10
0001be  f5046480          ADD      r4,r4,#0x400
0001c2  12e4              ASRS     r4,r4,#11
0001c4  f8404c20          STR      r4,[r0,#-0x20]
;;;265        wsptr[DCTSIZE*4] = (int) DESCALE(tmp13 - tmp0, CONST_BITS-PASS1_BITS);
0001c8  9e4e              LDR      r6,[sp,#0x138]
0001ca  eba6040a          SUB      r4,r6,r10
0001ce  f5046480          ADD      r4,r4,#0x400
0001d2  12e4              ASRS     r4,r4,#11
0001d4  f840497c          STR      r4,[r0],#-0x7c
                  |L1.472|
0001d8  f1ae0e01          SUB      lr,lr,#1              ;171
0001dc  f1be0f00          CMP      lr,#0                 ;171
0001e0  f73faf18          BGT      |L1.20|
;;;266        
;;;267        inptr++;			/* advance pointers to next column */
;;;268        quantptr++;
;;;269        wsptr++;
;;;270      }
;;;271      
;;;272      /* Pass 2: process rows from work array, store into output array. */
;;;273      /* Note that we must descale the results by a factor of 8 == 2**3, */
;;;274      /* and also undo the PASS1_BITS scaling. */
;;;275    
;;;276      wsptr = workspace;
0001e4  a80a              ADD      r0,sp,#0x28
;;;277      for (ctr = 0; ctr < DCTSIZE; ctr++) {
0001e6  f04f0c00          MOV      r12,#0
                  |L1.490|
;;;278        outptr = output_buf[ctr] + output_col;
0001ea  9955              LDR      r1,[sp,#0x154]
0001ec  f851202c          LDR      r2,[r1,r12,LSL #2]
0001f0  995f              LDR      r1,[sp,#0x17c]
0001f2  4411              ADD      r1,r1,r2
;;;279        /* Rows of zeroes can be exploited in the same way as we did with columns.
;;;280         * However, the column calculation has created many nonzero AC terms, so
;;;281         * the simplification applies less often (typically 5% to 10% of the time).
;;;282         * On machines with very fast multiplication, it's possible that the
;;;283         * test takes more time than it's worth.  In that case this section
;;;284         * may be commented out.
;;;285         */
;;;286        
;;;287    #ifndef NO_ZERO_ROW_TEST
;;;288        if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&
0001f4  6842              LDR      r2,[r0,#4]
0001f6  b1b2              CBZ      r2,|L1.550|
0001f8  e022              B        |L1.576|
                  |L1.506|
0001fa  c920              LDM      r1!,{r5}              ;186
0001fc  f9324b02          LDRSH    r4,[r2],#2            ;186
000200  436c              MULS     r4,r5,r4              ;186
000202  00a4              LSLS     r4,r4,#2              ;186
000204  f8404b20          STR      r4,[r0],#0x20         ;188
000208  f8404b20          STR      r4,[r0],#0x20         ;189
00020c  f8404b20          STR      r4,[r0],#0x20         ;190
000210  f8404b60          STR      r4,[r0],#0x60         ;191
000214  f8404c40          STR      r4,[r0,#-0x40]        ;192
000218  f8404c20          STR      r4,[r0,#-0x20]        ;193
00021c  f8404b20          STR      r4,[r0],#0x20         ;194
000220  f84049dc          STR      r4,[r0],#-0xdc        ;195
000224  e7d8              B        |L1.472|
                  |L1.550|
000226  6884              LDR      r4,[r0,#8]
000228  b954              CBNZ     r4,|L1.576|
00022a  68c4              LDR      r4,[r0,#0xc]
00022c  b944              CBNZ     r4,|L1.576|
00022e  6904              LDR      r4,[r0,#0x10]
000230  b934              CBNZ     r4,|L1.576|
;;;289    	wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {
000232  6944              LDR      r4,[r0,#0x14]
000234  b924              CBNZ     r4,|L1.576|
000236  6984              LDR      r4,[r0,#0x18]
000238  b914              CBNZ     r4,|L1.576|
00023a  69c4              LDR      r4,[r0,#0x1c]
00023c  2c00              CMP      r4,#0
00023e  d07d              BEQ      |L1.828|
                  |L1.576|
;;;290          /* AC terms all zero */
;;;291          JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
;;;292    				  & RANGE_MASK];
;;;293          
;;;294          outptr[0] = dcval;
;;;295          outptr[1] = dcval;
;;;296          outptr[2] = dcval;
;;;297          outptr[3] = dcval;
;;;298          outptr[4] = dcval;
;;;299          outptr[5] = dcval;
;;;300          outptr[6] = dcval;
;;;301          outptr[7] = dcval;
;;;302    
;;;303          wsptr += DCTSIZE;		/* advance pointer to next row */
;;;304          continue;
;;;305        }
;;;306    #endif
;;;307        
;;;308        /* Even part: reverse the even part of the forward DCT. */
;;;309        /* The rotator is sqrt(2)*c(-6). */
;;;310        
;;;311        z2 = (INT32) wsptr[2];
;;;312        z3 = (INT32) wsptr[6];
;;;313        
;;;314        z1 = MULTIPLY(z2 + z3, FIX_0_541196100);
000240  6886              LDR      r6,[r0,#8]
000242  6984              LDR      r4,[r0,#0x18]
000244  f2411751          MOV      r7,#0x1151
000248  1935              ADDS     r5,r6,r4
00024a  437d              MULS     r5,r7,r5
;;;315        tmp2 = z1 + MULTIPLY(z3, - FIX_1_847759065);
00024c  4f5b              LDR      r7,|L1.956|
;;;316        tmp3 = z1 + MULTIPLY(z2, FIX_0_765366865);
;;;317        
;;;318        tmp0 = ((INT32) wsptr[0] + (INT32) wsptr[4]) << CONST_BITS;
00024e  f8308b10          LDRH     r8,[r0],#0x10
000252  fb045407          MLA      r4,r4,r7,r5           ;315
000256  f640473f          MOV      r7,#0xc3f             ;316
00025a  437e              MULS     r6,r7,r6              ;316
00025c  f8307b10          LDRH     r7,[r0],#0x10
000260  eb050546          ADD      r5,r5,r6,LSL #1       ;316
000264  eb080607          ADD      r6,r8,r7
000268  0376              LSLS     r6,r6,#13
;;;319        tmp1 = ((INT32) wsptr[0] - (INT32) wsptr[4]) << CONST_BITS;
00026a  eba80707          SUB      r7,r8,r7
;;;320        
;;;321        tmp10 = tmp0 + tmp3;
00026e  eb060e05          ADD      lr,r6,r5
000272  037f              LSLS     r7,r7,#13             ;319
;;;322        tmp13 = tmp0 - tmp3;
000274  1b75              SUBS     r5,r6,r5
;;;323        tmp11 = tmp1 + tmp2;
000276  193e              ADDS     r6,r7,r4
000278  e9cd654d          STRD     r6,r5,[sp,#0x134]
;;;324        tmp12 = tmp1 - tmp2;
00027c  1b3d              SUBS     r5,r7,r4
;;;325        
;;;326        /* Odd part per figure 8; the matrix is unitary and hence its
;;;327         * transpose is its inverse.  i0..i3 are y7,y5,y3,y1 respectively.
;;;328         */
;;;329        
;;;330        tmp0 = (INT32) wsptr[7];
00027e  954c              STR      r5,[sp,#0x130]
000280  f8504c04          LDR      r4,[r0,#-4]
;;;331        tmp1 = (INT32) wsptr[5];
000284  f8505c0c          LDR      r5,[r0,#-0xc]
;;;332        tmp2 = (INT32) wsptr[3];
000288  f8506c14          LDR      r6,[r0,#-0x14]
;;;333        tmp3 = (INT32) wsptr[1];
;;;334        
;;;335        z1 = tmp0 + tmp3;
00028c  18a7              ADDS     r7,r4,r2
;;;336        z2 = tmp1 + tmp2;
;;;337        z3 = tmp0 + tmp2;
00028e  eb040b06          ADD      r11,r4,r6
;;;338        z4 = tmp1 + tmp3;
000292  eb050a02          ADD      r10,r5,r2
;;;339        z5 = MULTIPLY(z3 + z4, FIX_1_175875602); /* sqrt(2) * c3 */
000296  9707              STR      r7,[sp,#0x1c]
000298  eb0b080a          ADD      r8,r11,r10
00029c  f24257a1          MOV      r7,#0x25a1
0002a0  fb08f807          MUL      r8,r8,r7
;;;340        
;;;341        tmp0 = MULTIPLY(tmp0, FIX_0_298631336); /* sqrt(2) * (-c1+c3+c5-c7) */
0002a4  f640178e          MOV      r7,#0x98e
0002a8  437c              MULS     r4,r7,r4
;;;342        tmp1 = MULTIPLY(tmp1, FIX_2_053119869); /* sqrt(2) * ( c1+c3-c5+c7) */
0002aa  9403              STR      r4,[sp,#0xc]
0002ac  eb050906          ADD      r9,r5,r6              ;336
0002b0  f24414b3          MOV      r4,#0x41b3
0002b4  4365              MULS     r5,r4,r5
;;;343        tmp2 = MULTIPLY(tmp2, FIX_3_072711026); /* sqrt(2) * ( c1+c3+c5-c7) */
0002b6  f2462454          MOV      r4,#0x6254
0002ba  4366              MULS     r6,r4,r6
;;;344        tmp3 = MULTIPLY(tmp3, FIX_1_501321110); /* sqrt(2) * ( c1+c3-c5-c7) */
0002bc  f243040b          MOV      r4,#0x300b
0002c0  4362              MULS     r2,r4,r2
;;;345        z1 = MULTIPLY(z1, - FIX_0_899976223); /* sqrt(2) * (c7-c3) */
0002c2  9502              STR      r5,[sp,#8]
0002c4  9205              STR      r2,[sp,#0x14]
0002c6  4a3e              LDR      r2,|L1.960|
0002c8  9f07              LDR      r7,[sp,#0x1c]
;;;346        z2 = MULTIPLY(z2, - FIX_2_562915447); /* sqrt(2) * (-c1-c3) */
;;;347        z3 = MULTIPLY(z3, - FIX_1_961570560); /* sqrt(2) * (-c3-c5) */
;;;348        z4 = MULTIPLY(z4, - FIX_0_390180644); /* sqrt(2) * (c5-c3) */
0002ca  4c3f              LDR      r4,|L1.968|
0002cc  4357              MULS     r7,r2,r7              ;345
0002ce  4a3d              LDR      r2,|L1.964|
0002d0  fb09f902          MUL      r9,r9,r2              ;346
0002d4  ebab220b          SUB      r2,r11,r11,LSL #8     ;347
0002d8  ebc21282          RSB      r2,r2,r2,LSL #6       ;347
0002dc  eba2028b          SUB      r2,r2,r11,LSL #2      ;347
;;;349        
;;;350        z3 += z5;
0002e0  4442              ADD      r2,r2,r8
;;;351        z4 += z5;
0002e2  fb0a8804          MLA      r8,r10,r4,r8
;;;352        
;;;353        tmp0 += z1 + z3;
0002e6  18bd              ADDS     r5,r7,r2
0002e8  9c03              LDR      r4,[sp,#0xc]
;;;354        tmp1 += z2 + z4;
;;;355        tmp2 += z2 + z3;
0002ea  444a              ADD      r2,r2,r9
0002ec  eb050a04          ADD      r10,r5,r4             ;353
0002f0  9d02              LDR      r5,[sp,#8]            ;354
0002f2  eb090408          ADD      r4,r9,r8              ;354
0002f6  442c              ADD      r4,r4,r5              ;354
0002f8  1995              ADDS     r5,r2,r6
;;;356        tmp3 += z1 + z4;
0002fa  9a05              LDR      r2,[sp,#0x14]
0002fc  eb070608          ADD      r6,r7,r8
000300  4432              ADD      r2,r2,r6
;;;357        
;;;358        /* Final output stage: inputs are tmp10..tmp13, tmp0..tmp3 */
;;;359        
;;;360        outptr[0] = range_limit[(int) DESCALE(tmp10 + tmp3,
000302  eb0e0602          ADD      r6,lr,r2
000306  f5063600          ADD      r6,r6,#0x20000
00030a  f3c64689          UBFX     r6,r6,#18,#10
;;;361    					  CONST_BITS+PASS1_BITS+3)
;;;362    			    & RANGE_MASK];
;;;363        outptr[7] = range_limit[(int) DESCALE(tmp10 - tmp3,
00030e  ebae0202          SUB      r2,lr,r2
000312  f5023200          ADD      r2,r2,#0x20000
000316  5d9e              LDRB     r6,[r3,r6]            ;360
000318  f3c24289          UBFX     r2,r2,#18,#10
00031c  700e              STRB     r6,[r1,#0]            ;360
00031e  5c9a              LDRB     r2,[r3,r2]
000320  71ca              STRB     r2,[r1,#7]
;;;364    					  CONST_BITS+PASS1_BITS+3)
;;;365    			    & RANGE_MASK];
;;;366        outptr[1] = range_limit[(int) DESCALE(tmp11 + tmp2,
000322  9e4d              LDR      r6,[sp,#0x134]
000324  1972              ADDS     r2,r6,r5
000326  f5023200          ADD      r2,r2,#0x20000
00032a  f3c24289          UBFX     r2,r2,#18,#10
00032e  5c9a              LDRB     r2,[r3,r2]
000330  704a              STRB     r2,[r1,#1]
;;;367    					  CONST_BITS+PASS1_BITS+3)
;;;368    			    & RANGE_MASK];
;;;369        outptr[6] = range_limit[(int) DESCALE(tmp11 - tmp2,
000332  9e4d              LDR      r6,[sp,#0x134]
000334  1b72              SUBS     r2,r6,r5
000336  f5023200          ADD      r2,r2,#0x20000
00033a  e000              B        |L1.830|
                  |L1.828|
00033c  e02f              B        |L1.926|
                  |L1.830|
00033e  f3c24289          UBFX     r2,r2,#18,#10
000342  5c9a              LDRB     r2,[r3,r2]
000344  718a              STRB     r2,[r1,#6]
;;;370    					  CONST_BITS+PASS1_BITS+3)
;;;371    			    & RANGE_MASK];
;;;372        outptr[2] = range_limit[(int) DESCALE(tmp12 + tmp1,
000346  9d4c              LDR      r5,[sp,#0x130]
000348  192a              ADDS     r2,r5,r4
00034a  f5023200          ADD      r2,r2,#0x20000
00034e  f3c24289          UBFX     r2,r2,#18,#10
000352  5c9a              LDRB     r2,[r3,r2]
000354  708a              STRB     r2,[r1,#2]
;;;373    					  CONST_BITS+PASS1_BITS+3)
;;;374    			    & RANGE_MASK];
;;;375        outptr[5] = range_limit[(int) DESCALE(tmp12 - tmp1,
000356  9d4c              LDR      r5,[sp,#0x130]
000358  1b2a              SUBS     r2,r5,r4
00035a  f5023200          ADD      r2,r2,#0x20000
00035e  f3c24289          UBFX     r2,r2,#18,#10
000362  5c9a              LDRB     r2,[r3,r2]
000364  714a              STRB     r2,[r1,#5]
;;;376    					  CONST_BITS+PASS1_BITS+3)
;;;377    			    & RANGE_MASK];
;;;378        outptr[3] = range_limit[(int) DESCALE(tmp13 + tmp0,
000366  9d4e              LDR      r5,[sp,#0x138]
000368  eb05020a          ADD      r2,r5,r10
00036c  f5023200          ADD      r2,r2,#0x20000
000370  f3c24289          UBFX     r2,r2,#18,#10
000374  5c9a              LDRB     r2,[r3,r2]
000376  70ca              STRB     r2,[r1,#3]
;;;379    					  CONST_BITS+PASS1_BITS+3)
;;;380    			    & RANGE_MASK];
;;;381        outptr[4] = range_limit[(int) DESCALE(tmp13 - tmp0,
000378  9d4e              LDR      r5,[sp,#0x138]
00037a  eba5020a          SUB      r2,r5,r10
00037e  f5023200          ADD      r2,r2,#0x20000
000382  f3c24289          UBFX     r2,r2,#18,#10
000386  5c9a              LDRB     r2,[r3,r2]
000388  f8812004          STRB.W   r2,[r1,#4]
                  |L1.908|
00038c  f10c0c01          ADD      r12,r12,#1
000390  f1bc0f08          CMP      r12,#8                ;277
000394  f6ffaf29          BLT      |L1.490|
;;;382    					  CONST_BITS+PASS1_BITS+3)
;;;383    			    & RANGE_MASK];
;;;384        
;;;385        wsptr += DCTSIZE;		/* advance pointer to next row */
;;;386      }
;;;387    }
000398  b056              ADD      sp,sp,#0x158
00039a  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.926|
00039e  f8302b20          LDRH     r2,[r0],#0x20         ;291
0003a2  3210              ADDS     r2,r2,#0x10           ;291
0003a4  f3c21249          UBFX     r2,r2,#5,#10          ;291
0003a8  5c9a              LDRB     r2,[r3,r2]            ;291
0003aa  700a              STRB     r2,[r1,#0]            ;294
0003ac  704a              STRB     r2,[r1,#1]            ;295
0003ae  708a              STRB     r2,[r1,#2]            ;296
0003b0  70ca              STRB     r2,[r1,#3]            ;297
0003b2  710a              STRB     r2,[r1,#4]            ;298
0003b4  714a              STRB     r2,[r1,#5]            ;299
0003b6  718a              STRB     r2,[r1,#6]            ;300
0003b8  71ca              STRB     r2,[r1,#7]            ;301
0003ba  e7e7              B        |L1.908|
;;;388    
                          ENDP

                  |L1.956|
                          DCD      0xffffc4df
                  |L1.960|
                          DCD      0xffffe333
                  |L1.964|
                          DCD      0xffffadfd
                  |L1.968|
                          DCD      0xfffff384
