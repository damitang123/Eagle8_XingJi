; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\guidev_usagebm.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\guidev_usagebm.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\MemDev\GUIDEV_UsageBM.c]
                          THUMB

                          AREA ||i.GUI_USAGE_BM_AddHLine||, CODE, READONLY, ALIGN=1

                  GUI_USAGE_BM_AddHLine PROC
;;;75     */
;;;76     static void GUI_USAGE_BM_AddHLine(GUI_USAGE* p, int x, int y, int len) {
000000  b570              PUSH     {r4-r6,lr}
;;;77     #if 0   /* Enable for the slower, but smaller version ... xxx*/
;;;78       while (len-- >0)
;;;79         GUI_USAGE_BM_AddPixel(h, x++,y);
;;;80     #else
;;;81       U8* pData;
;;;82       GUI_USAGE_BM * pThis = (GUI_USAGE_BM*)p;
;;;83       /* Asserts */
;;;84       GUI_DEBUG_ERROROUT3_IF( x<pThis->Public.x0, "GUIDEV.c: MarkPixels: negative x offset, Act= %d, Border= %d, Clip= %d"
;;;85                         ,x, pThis->Public.x0, GUI_Context.ClipRect.x0);
;;;86       /* Calculate pointers */
;;;87       x -= pThis->Public.x0;
000002  f9b04000          LDRSH    r4,[r0,#0]
;;;88       pData =  (U8*)(pThis+1); 
;;;89       pData += (y-pThis->Public.y0) * pThis->Private.BytesPerLine;
000006  f9b05002          LDRSH    r5,[r0,#2]
00000a  1b09              SUBS     r1,r1,r4              ;87
00000c  f1000414          ADD      r4,r0,#0x14           ;88
000010  6900              LDR      r0,[r0,#0x10]
000012  1b52              SUBS     r2,r2,r5
000014  fb024000          MLA      r0,r2,r0,r4
;;;90       pData += x>>3;
;;;91       /* Set bits */
;;;92       {  
;;;93         int x1 = x+len-1;   /* last pixel */
000018  18ca              ADDS     r2,r1,r3
00001a  eb0004e1          ADD      r4,r0,r1,ASR #3       ;90
00001e  1e52              SUBS     r2,r2,#1
;;;94         int NumBytes = (x1>>3) - (x>>3);
000020  10d0              ASRS     r0,r2,#3
000022  ebb005e1          SUBS     r5,r0,r1,ASR #3
;;;95         U8 Mask0 = 0xff >> (x&7);
000026  f0010307          AND      r3,r1,#7
00002a  f04f01ff          MOV      r1,#0xff
;;;96         U8 Mask1 = 0xff << (7-(x1&7));
00002e  f0020207          AND      r2,r2,#7
000032  fa21f003          LSR      r0,r1,r3              ;95
000036  f1c20207          RSB      r2,r2,#7
00003a  fa01f102          LSL      r1,r1,r2
00003e  b2ce              UXTB     r6,r1
;;;97         if (NumBytes ==0) {
;;;98           *pData |= (Mask0&Mask1);
;;;99         } else {
;;;100          *pData++ |= Mask0;               /* Mark first byte */
000040  7821              LDRB     r1,[r4,#0]
000042  d00f              BEQ      |L1.100|
000044  4301              ORRS     r1,r1,r0
000046  1e6d              SUBS     r5,r5,#1
000048  f8041b01          STRB     r1,[r4],#1
;;;101          /* Mark middle bytes */
;;;102          if (--NumBytes > 0) {
00004c  2d00              CMP      r5,#0
00004e  dd05              BLE      |L1.92|
;;;103            memset (pData, 0xff, NumBytes);
000050  22ff              MOVS     r2,#0xff
000052  4629              MOV      r1,r5
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       __aeabi_memset
;;;104            pData += NumBytes;
00005a  442c              ADD      r4,r4,r5
                  |L1.92|
;;;105          }
;;;106          *pData |= Mask1;                 /* Mark last bytes */
00005c  7820              LDRB     r0,[r4,#0]
00005e  4330              ORRS     r0,r0,r6
000060  7020              STRB     r0,[r4,#0]
;;;107        }
;;;108      }
;;;109    #endif
;;;110    }
000062  bd70              POP      {r4-r6,pc}
                  |L1.100|
000064  4030              ANDS     r0,r0,r6              ;98
000066  4301              ORRS     r1,r1,r0              ;98
000068  7021              STRB     r1,[r4,#0]            ;98
00006a  bd70              POP      {r4-r6,pc}
;;;111    
                          ENDP


                          AREA ||i.GUI_USAGE_BM_AddPixel||, CODE, READONLY, ALIGN=1

                  GUI_USAGE_BM_AddPixel PROC
;;;54     */
;;;55     static void GUI_USAGE_BM_AddPixel(GUI_USAGE* p, int x, int y) {
000000  b510              PUSH     {r4,lr}
;;;56       U8* pData;
;;;57       GUI_USAGE_BM * pThis = (GUI_USAGE_BM*)p;
;;;58       #if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_CHECK_ALL
;;;59         if ((x >= pThis->Public.x0 + pThis->Public.XSize) | (x < pThis->Public.x0)
;;;60           | (y >= pThis->Public.y0 + pThis->Public.YSize) | (y < pThis->Public.y0))
;;;61         {
;;;62           GUI_DEBUG_ERROROUT2("GUI_USAGE_BM_AddPixel: parameters out of bounds",x,y);
;;;63         }
;;;64       #endif
;;;65       x -= pThis->Public.x0;
000002  f9b03000          LDRSH    r3,[r0,#0]
;;;66       pData =  (U8*)(pThis+1); 
;;;67       pData += (y-pThis->Public.y0) * pThis->Private.BytesPerLine;
000006  f9b04002          LDRSH    r4,[r0,#2]
00000a  1ac9              SUBS     r1,r1,r3              ;65
00000c  f1000314          ADD      r3,r0,#0x14           ;66
000010  6900              LDR      r0,[r0,#0x10]
000012  1b12              SUBS     r2,r2,r4
000014  fb023000          MLA      r0,r2,r0,r3
;;;68       pData += x>>3;
000018  eb0000e1          ADD      r0,r0,r1,ASR #3
;;;69       *pData|= 0x80>>(x&7);
00001c  f0010307          AND      r3,r1,#7
000020  7802              LDRB     r2,[r0,#0]
000022  2180              MOVS     r1,#0x80
000024  40d9              LSRS     r1,r1,r3
000026  430a              ORRS     r2,r2,r1
000028  7002              STRB     r2,[r0,#0]
;;;70     }
00002a  bd10              POP      {r4,pc}
;;;71     
                          ENDP


                          AREA ||i.GUI_USAGE_BM_Clear||, CODE, READONLY, ALIGN=1

                  GUI_USAGE_BM_Clear PROC
;;;115    */
;;;116    static void GUI_USAGE_BM_Clear(GUI_USAGE* p) {
000000  f9b01006          LDRSH    r1,[r0,#6]
;;;117      GUI_USAGE_BM * pThis = (GUI_USAGE_BM*) p;
;;;118      memset (pThis+1, 0, pThis->Public.YSize * pThis->Private.BytesPerLine);
000004  6902              LDR      r2,[r0,#0x10]
000006  4351              MULS     r1,r2,r1
000008  3014              ADDS     r0,r0,#0x14
00000a  f7ffbffe          B.W      __aeabi_memclr4
;;;119    }
;;;120    
                          ENDP


                          AREA ||i.GUI_USAGE_BM_Create||, CODE, READONLY, ALIGN=2

                  GUI_USAGE_BM_Create PROC
;;;214    */
;;;215    GUI_USAGE_Handle GUI_USAGE_BM_Create(int x0, int y0, int xsize, int ysize, int Flags) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4680              MOV      r8,r0
;;;216      int MemSize;
;;;217      int BytesPerLine;
;;;218      GUI_USAGE_Handle hMem;
;;;219      GUI_USE_PARA(Flags);
;;;220      BytesPerLine = ((xsize+15) >>4)<<1;  /* 2 byte alignment */
000006  f102000f          ADD      r0,r2,#0xf
00000a  1100              ASRS     r0,r0,#4
00000c  0047              LSLS     r7,r0,#1
;;;221      MemSize = ysize*BytesPerLine +sizeof(GUI_USAGE_BM);
00000e  fb03f007          MUL      r0,r3,r7
000012  3014              ADDS     r0,r0,#0x14
000014  461c              MOV      r4,r3                 ;215
000016  4615              MOV      r5,r2                 ;215
000018  4689              MOV      r9,r1                 ;215
;;;222      hMem = GUI_ALLOC_AllocZero(MemSize);
00001a  b200              SXTH     r0,r0
00001c  f7fffffe          BL       GUI_ALLOC_AllocZero
000020  0006              MOVS     r6,r0
;;;223      /* Check if we can alloc sufficient memory */
;;;224      if (!hMem) {
000022  d00d              BEQ      |L4.64|
;;;225        GUI_DEBUG_ERROROUT("GUI_USAGE_BM_Create: Too little memory");
;;;226        return 0;    
;;;227      }
;;;228      {
;;;229        GUI_USAGE_BM * pUsage;
;;;230        GUI_LOCK();
;;;231        pUsage = (GUI_USAGE_BM*)GUI_ALLOC_h2p(hMem);
000024  f7fffffe          BL       GUI_ALLOC_h2p
;;;232        pUsage->Public.x0    = x0;
000028  f8a08000          STRH     r8,[r0,#0]
;;;233        pUsage->Public.y0    = y0;
00002c  f8a09002          STRH     r9,[r0,#2]
;;;234        pUsage->Public.XSize = xsize;
000030  8085              STRH     r5,[r0,#4]
;;;235        pUsage->Public.YSize = ysize;
000032  80c4              STRH     r4,[r0,#6]
;;;236        pUsage->Public.pAPI  = &API;
000034  4903              LDR      r1,|L4.68|
;;;237        pUsage->Public.UseCnt= 1;
000036  6081              STR      r1,[r0,#8]
000038  2101              MOVS     r1,#1
00003a  8181              STRH     r1,[r0,#0xc]
;;;238        pUsage->Private.BytesPerLine= BytesPerLine;
;;;239        GUI_UNLOCK();
;;;240      }
;;;241      return hMem;
00003c  6107              STR      r7,[r0,#0x10]
00003e  4630              MOV      r0,r6
                  |L4.64|
;;;242    }
000040  e8bd87f0          POP      {r4-r10,pc}
;;;243    
                          ENDP

                  |L4.68|
                          DCD      ||.constdata||

                          AREA ||i.GUI_USAGE_BM_GetNextDirty||, CODE, READONLY, ALIGN=1

                  GUI_USAGE_BM_GetNextDirty PROC
;;;124    */
;;;125    static int GUI_USAGE_BM_GetNextDirty(GUI_USAGE* p, int *pxOff, int yOff) {
000000  b570              PUSH     {r4-r6,lr}
;;;126      int x = *pxOff;
;;;127      int xEnd;
;;;128      GUI_USAGE_BM * pThis = (GUI_USAGE_BM*)p;
;;;129      int xSize = pThis->Public.XSize;
;;;130      U8* pData = (U8*)(pThis+1);
;;;131      if (yOff >= pThis->Public.YSize) {
000002  f9b06006          LDRSH    r6,[r0,#6]
000006  f9b04004          LDRSH    r4,[r0,#4]            ;129
00000a  680b              LDR      r3,[r1,#0]
00000c  f1000514          ADD      r5,r0,#0x14           ;130
000010  4296              CMP      r6,r2
000012  dd1b              BLE      |L5.76|
;;;132        return 0;
;;;133      }
;;;134      pData += yOff * pThis->Private.BytesPerLine;
000014  6900              LDR      r0,[r0,#0x10]
;;;135      pData += (x>>3);
;;;136      if (x>=xSize)
000016  42a3              CMP      r3,r4
000018  fb025000          MLA      r0,r2,r0,r5           ;134
00001c  eb0002e3          ADD      r2,r0,r3,ASR #3       ;135
000020  da14              BGE      |L5.76|
000022  1e64              SUBS     r4,r4,#1
;;;137        return 0;
;;;138      {
;;;139    /* Find first bit */
;;;140        int BytesLeft = ((xSize-1) >>3) - (x>>3);
000024  10e0              ASRS     r0,r4,#3
000026  eba005e3          SUB      r5,r0,r3,ASR #3
;;;141        /* Check first byte */
;;;142        U8 Data = (*pData++) << (x&7);
00002a  f8120b01          LDRB     r0,[r2],#1
00002e  f0030407          AND      r4,r3,#7
000032  40a0              LSLS     r0,r0,r4
000034  b2c4              UXTB     r4,r0
;;;143        while (Data == 0) {
000036  e006              B        |L5.70|
                  |L5.56|
;;;144          if (BytesLeft ==0)
000038  b145              CBZ      r5,|L5.76|
;;;145            return 0;
;;;146          Data = *pData++;
00003a  3308              ADDS     r3,r3,#8
00003c  f8124b01          LDRB     r4,[r2],#1
;;;147          BytesLeft--;
;;;148          x= (x+8) & ~7;
000040  f0230307          BIC      r3,r3,#7
000044  1e6d              SUBS     r5,r5,#1
                  |L5.70|
000046  2c00              CMP      r4,#0                 ;143
000048  d0f6              BEQ      |L5.56|
00004a  e004              B        |L5.86|
                  |L5.76|
00004c  2000              MOVS     r0,#0                 ;145
;;;149        }
;;;150        while ((Data&0x80) ==0) {
;;;151          Data<<=1;
;;;152          x++;
;;;153        }
;;;154    /* Find last cleared byte */
;;;155        if (Data != 0xff) {   /* This line is simply a speed-opt and may be eliminated */
;;;156          xEnd =x;
;;;157          while (Data&0x40) {
;;;158            Data<<=1;
;;;159            xEnd++;
;;;160          }
;;;161        } else {
;;;162          xEnd =x+7;
;;;163        }
;;;164        if ((xEnd&7) ==7) {
;;;165          while (--BytesLeft >= 0) {
;;;166            if ((Data = *pData++) == 0xff) {
;;;167              xEnd+=8;
;;;168            } else {
;;;169              while (Data&0x80) {
;;;170                Data<<=1;
;;;171                xEnd++;
;;;172              }
;;;173              break;
;;;174            }
;;;175          }
;;;176        }
;;;177    
;;;178      }
;;;179      *pxOff =x;
;;;180      return xEnd-x+1;
;;;181    }
00004e  bd70              POP      {r4-r6,pc}
                  |L5.80|
000050  0660              LSLS     r0,r4,#25             ;151
000052  0e04              LSRS     r4,r0,#24             ;151
000054  1c5b              ADDS     r3,r3,#1              ;151
                  |L5.86|
000056  0620              LSLS     r0,r4,#24             ;150
000058  d5fa              BPL      |L5.80|
00005a  2cff              CMP      r4,#0xff              ;155
00005c  d007              BEQ      |L5.110|
00005e  4618              MOV      r0,r3                 ;156
000060  e002              B        |L5.104|
                  |L5.98|
000062  0664              LSLS     r4,r4,#25             ;158
000064  0e24              LSRS     r4,r4,#24             ;158
000066  1c40              ADDS     r0,r0,#1              ;158
                  |L5.104|
000068  0666              LSLS     r6,r4,#25             ;157
00006a  d4fa              BMI      |L5.98|
00006c  e000              B        |L5.112|
                  |L5.110|
00006e  1dd8              ADDS     r0,r3,#7              ;162
                  |L5.112|
000070  43c4              MVNS     r4,r0                 ;164
000072  0764              LSLS     r4,r4,#29             ;164
000074  d005              BEQ      |L5.130|
000076  e006              B        |L5.134|
                  |L5.120|
000078  f8124b01          LDRB     r4,[r2],#1            ;166
00007c  2cff              CMP      r4,#0xff              ;166
00007e  d109              BNE      |L5.148|
000080  3008              ADDS     r0,r0,#8              ;166
                  |L5.130|
000082  1e6d              SUBS     r5,r5,#1              ;166
000084  d5f8              BPL      |L5.120|
                  |L5.134|
000086  1ac0              SUBS     r0,r0,r3              ;180
000088  1c40              ADDS     r0,r0,#1              ;180
00008a  600b              STR      r3,[r1,#0]            ;180
00008c  bd70              POP      {r4-r6,pc}
                  |L5.142|
00008e  0662              LSLS     r2,r4,#25             ;170
000090  0e14              LSRS     r4,r2,#24             ;170
000092  1c40              ADDS     r0,r0,#1              ;170
                  |L5.148|
000094  0622              LSLS     r2,r4,#24             ;169
000096  d4fa              BMI      |L5.142|
000098  e7f5              B        |L5.134|
;;;182    
                          ENDP


                          AREA ||i._GUI_USAGE_BM_Delete||, CODE, READONLY, ALIGN=1

                  _GUI_USAGE_BM_Delete PROC
;;;186    */
;;;187    static void _GUI_USAGE_BM_Delete(GUI_MEMDEV_Handle hDevUsage) {
000000  f7ffbffe          B.W      GUI_ALLOC_Free
;;;188      GUI_ALLOC_Free(hDevUsage);
;;;189    }
;;;190    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  API
                          DCD      GUI_USAGE_BM_AddPixel
                          DCD      GUI_USAGE_BM_AddHLine
                          DCD      GUI_USAGE_BM_Clear
                          DCD      0x00000000
                          DCD      _GUI_USAGE_BM_Delete
                          DCD      GUI_USAGE_BM_GetNextDirty
