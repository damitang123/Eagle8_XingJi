; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\guidev.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\guidev.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\MemDev\GUIDEV.c]
                          THUMB

                          AREA ||i.GUI_MEMDEV_CopyToLCD||, CODE, READONLY, ALIGN=2

                  GUI_MEMDEV_CopyToLCD PROC
;;;344    */
;;;345    void GUI_MEMDEV_CopyToLCD(GUI_MEMDEV_Handle hMem) {
000000  4901              LDR      r1,|L1.8|
;;;346      GUI_MEMDEV_CopyToLCDAt(hMem, GUI_POS_AUTO, GUI_POS_AUTO);
000002  460a              MOV      r2,r1
000004  f7ffbffe          B.W      GUI_MEMDEV_CopyToLCDAt
;;;347    }
;;;348    
                          ENDP

                  |L1.8|
                          DCD      0xfffff001

                          AREA ||i.GUI_MEMDEV_CopyToLCDAt||, CODE, READONLY, ALIGN=2

                  GUI_MEMDEV_CopyToLCDAt PROC
;;;296    */
;;;297    void GUI_MEMDEV_CopyToLCDAt(GUI_MEMDEV_Handle hMem, int x, int y) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4616              MOV      r6,r2
000006  460d              MOV      r5,r1
000008  ea5f0800          MOVS     r8,r0
00000c  d030              BEQ      |L2.112|
;;;298      if (hMem) {
;;;299        GUI_MEMDEV_Handle hMemPrev;
;;;300        GUI_MEMDEV* pDevData;
;;;301      #if (GUI_WINSUPPORT)
;;;302        GUI_RECT r;
;;;303      #endif
;;;304      #if GUI_NUM_LAYERS > 1
;;;305        int PrevLayer;
;;;306      #endif
;;;307        GUI_LOCK();
;;;308        hMemPrev = GUI_Context.hDevData;
00000e  4819              LDR      r0,|L2.116|
000010  f9b07050          LDRSH    r7,[r0,#0x50]  ; GUI_Context
;;;309        pDevData = (GUI_MEMDEV*) GUI_ALLOC_h2p(hMem);  /* Convert to pointer */
000014  4640              MOV      r0,r8
000016  f7fffffe          BL       GUI_ALLOC_h2p
00001a  4604              MOV      r4,r0
;;;310        /* Make sure LCD is selected as device */
;;;311      #if GUI_NUM_LAYERS > 1
;;;312        PrevLayer = GUI_SelectLayer(pDevData->LayerIndex);
;;;313      #else
;;;314        GUI_SelectLCD();  /* Activate LCD */
00001c  f7fffffe          BL       GUI_SelectLCD
;;;315      #endif
;;;316        if (x == GUI_POS_AUTO) {
000020  f64070ff          MOV      r0,#0xfff
000024  1940              ADDS     r0,r0,r5
000026  d103              BNE      |L2.48|
;;;317          x = pDevData->x0;
000028  f9b45000          LDRSH    r5,[r4,#0]
;;;318          y = pDevData->y0;
00002c  f9b46002          LDRSH    r6,[r4,#2]
                  |L2.48|
;;;319        }
;;;320      #if (GUI_WINSUPPORT)
;;;321        /* Calculate rectangle */
;;;322        r.x1 = (r.x0 = x) + pDevData->XSize-1;
000030  88a1              LDRH     r1,[r4,#4]
000032  1e68              SUBS     r0,r5,#1
000034  4408              ADD      r0,r0,r1
000036  f8ad0004          STRH     r0,[sp,#4]
00003a  f8ad5000          STRH     r5,[sp,#0]
;;;323        r.y1 = (r.y0 = y) + pDevData->YSize-1;;
00003e  88e1              LDRH     r1,[r4,#6]
000040  1e70              SUBS     r0,r6,#1
000042  4408              ADD      r0,r0,r1
000044  f8ad6002          STRH     r6,[sp,#2]
000048  f8ad0006          STRH     r0,[sp,#6]
;;;324        /* Do the drawing. Window manager has to be on */
;;;325        WM_Activate();
00004c  f7fffffe          BL       WM_Activate
;;;326        WM_ITERATE_START(&r) {
000050  4668              MOV      r0,sp
000052  f7fffffe          BL       WM__InitIVRSearch
000056  e006              B        |L2.102|
                  |L2.88|
;;;327      #endif
;;;328        GUI_MEMDEV__WriteToActiveAt(hMem, x, y);
000058  4632              MOV      r2,r6
00005a  4629              MOV      r1,r5
00005c  4640              MOV      r0,r8
00005e  f7fffffe          BL       GUI_MEMDEV__WriteToActiveAt
;;;329      #if (GUI_WINSUPPORT)
;;;330        } WM_ITERATE_END();
000062  f7fffffe          BL       WM__GetNextIVR
                  |L2.102|
000066  2800              CMP      r0,#0
000068  d1f6              BNE      |L2.88|
;;;331      #endif
;;;332      #if GUI_NUM_LAYERS > 1
;;;333        GUI_SelectLayer(PrevLayer);
;;;334      #endif
;;;335        /* Reactivate previously used device */
;;;336        GUI_MEMDEV_Select(hMemPrev);
00006a  4638              MOV      r0,r7
00006c  f7fffffe          BL       GUI_MEMDEV_Select
                  |L2.112|
;;;337        GUI_UNLOCK();
;;;338      }
;;;339    }
000070  e8bd81fc          POP      {r2-r8,pc}
;;;340    
                          ENDP

                  |L2.116|
                          DCD      GUI_Context

                          AREA ||i.GUI_MEMDEV_Create||, CODE, READONLY, ALIGN=1

                  GUI_MEMDEV_Create PROC
;;;218    */
;;;219    GUI_MEMDEV_Handle GUI_MEMDEV_Create(int x0, int y0, int xsize, int ysize) {
000000  b538              PUSH     {r3-r5,lr}
;;;220      return GUI_MEMDEV_CreateEx(x0, y0, xsize, ysize, GUI_MEMDEV_HASTRANS);
000002  2400              MOVS     r4,#0
000004  9400              STR      r4,[sp,#0]
000006  f7fffffe          BL       GUI_MEMDEV_CreateEx
;;;221    }
00000a  bd38              POP      {r3-r5,pc}
;;;222    
                          ENDP


                          AREA ||i.GUI_MEMDEV_CreateEx||, CODE, READONLY, ALIGN=2

                  GUI_MEMDEV_CreateEx PROC
;;;185    */
;;;186    GUI_MEMDEV_Handle GUI_MEMDEV_CreateEx(int x0, int y0, int xSize, int ySize, int Flags) {
000000  e92d43f0          PUSH     {r4-r9,lr}
000004  4681              MOV      r9,r0
000006  4688              MOV      r8,r1
;;;187      GUI_MEMDEV_Handle hMemDev;
;;;188      const tLCDDEV_APIList * pDeviceAPI;
;;;189      tLCDDEV_Color2Index   * pfColor2Index;
;;;190      tLCDDEV_Index2Color   * pfIndex2Color;
;;;191      tLCDDEV_GetIndexMask  * pfGetIndexMask;
;;;192      GUI_LOCK();
;;;193      #if (GUI_NUM_LAYERS > 1)   /* Size opt., preprocessor not required */
;;;194        pDeviceAPI = LCD_aAPI[GUI_Context.SelLayer];
;;;195      #else
;;;196        pDeviceAPI = LCD_aAPI[0];
000008  4811              LDR      r0,|L4.80|
;;;197      #endif
;;;198      if (GUI_Context.hDevData == 0) {
00000a  4912              LDR      r1,|L4.84|
00000c  b085              SUB      sp,sp,#0x14           ;186
00000e  6804              LDR      r4,[r0,#0]  ; LCD_aAPI
000010  9d0c              LDR      r5,[sp,#0x30]         ;196
000012  f9b10050          LDRSH    r0,[r1,#0x50]  ; GUI_Context
000016  461e              MOV      r6,r3                 ;186
000018  4617              MOV      r7,r2                 ;186
00001a  b198              CBZ      r0,|L4.68|
;;;199        pfColor2Index = GUI_Context.pDeviceAPI->pfColor2Index;    /* LCD_L0_Color2Index; */
;;;200        pfIndex2Color = GUI_Context.pDeviceAPI->pfIndex2Color;    /* LCD_L0_Index2Color; */
;;;201        pfGetIndexMask= GUI_Context.pDeviceAPI->pfGetIndexMask;   /* LCD_L0_GetIndexMask */
;;;202      } else {
;;;203        /* If a memory device is already selected, we create a compatible one by copying its data */
;;;204        GUI_MEMDEV* pDevSel;
;;;205        pDevSel = GUI_MEMDEV_H2P(GUI_Context.hDevData);
00001c  f7fffffe          BL       GUI_ALLOC_h2p
;;;206        pfColor2Index = pDevSel->pfColor2Index;
;;;207        pfIndex2Color = pDevSel->pfIndex2Color;
;;;208        pfGetIndexMask= pDevSel->pfGetIndexMask;
000020  e9d02107          LDRD     r2,r1,[r0,#0x1c]
000024  6a40              LDR      r0,[r0,#0x24]
                  |L4.38|
;;;209      }
;;;210      hMemDev = GUI_MEMDEV__CreateFixed(x0, y0, xSize, ySize, Flags, pDeviceAPI->pMemDevAPI, 
000026  6be3              LDR      r3,[r4,#0x3c]
000028  9500              STR      r5,[sp,#0]
00002a  e9cd3201          STRD     r3,r2,[sp,#4]
00002e  e9cd1003          STRD     r1,r0,[sp,#0xc]
000032  4633              MOV      r3,r6
000034  463a              MOV      r2,r7
000036  4641              MOV      r1,r8
000038  4648              MOV      r0,r9
00003a  f7fffffe          BL       GUI_MEMDEV__CreateFixed
;;;211                                        pfColor2Index, pfIndex2Color ,pfGetIndexMask);
;;;212      GUI_UNLOCK();
;;;213      return hMemDev;
;;;214    }
00003e  b005              ADD      sp,sp,#0x14
000040  e8bd83f0          POP      {r4-r9,pc}
                  |L4.68|
000044  6cc8              LDR      r0,[r1,#0x4c]         ;199  ; GUI_Context
000046  e9d02100          LDRD     r2,r1,[r0,#0]         ;201
00004a  6880              LDR      r0,[r0,#8]            ;201
00004c  e7eb              B        |L4.38|
;;;215    /*********************************************************************
                          ENDP

00004e  0000              DCW      0x0000
                  |L4.80|
                          DCD      LCD_aAPI
                  |L4.84|
                          DCD      GUI_Context

                          AREA ||i.GUI_MEMDEV_Delete||, CODE, READONLY, ALIGN=2

                  GUI_MEMDEV_Delete PROC
;;;88     */
;;;89     void GUI_MEMDEV_Delete(GUI_MEMDEV_Handle hMemDev) {
000000  b510              PUSH     {r4,lr}
000002  0004              MOVS     r4,r0
000004  d013              BEQ      |L5.46|
;;;90     /* Make sure memory device is not used */
;;;91       GUI_LOCK();
;;;92       if (hMemDev) {
;;;93         GUI_MEMDEV* pDev;
;;;94         if (GUI_Context.hDevData == hMemDev) {
000006  480a              LDR      r0,|L5.48|
000008  f9b00050          LDRSH    r0,[r0,#0x50]  ; GUI_Context
00000c  42a0              CMP      r0,r4
00000e  d101              BNE      |L5.20|
;;;95     	    GUI_SelectLCD();
000010  f7fffffe          BL       GUI_SelectLCD
                  |L5.20|
;;;96         }
;;;97         pDev = GUI_MEMDEV_H2P(hMemDev);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       GUI_ALLOC_h2p
;;;98         /* Delete the associated usage device */
;;;99         if (pDev->hUsage)
00001a  f9b00018          LDRSH    r0,[r0,#0x18]
00001e  b108              CBZ      r0,|L5.36|
;;;100          GUI_USAGE_DecUseCnt(pDev->hUsage);
000020  f7fffffe          BL       GUI_USAGE_DecUseCnt
                  |L5.36|
;;;101        GUI_ALLOC_Free(hMemDev);
000024  4620              MOV      r0,r4
000026  e8bd4010          POP      {r4,lr}
00002a  f7ffbffe          B.W      GUI_ALLOC_Free
                  |L5.46|
;;;102      }
;;;103      GUI_UNLOCK();
;;;104    }
00002e  bd10              POP      {r4,pc}
;;;105    
                          ENDP

                  |L5.48|
                          DCD      GUI_Context

                          AREA ||i.GUI_MEMDEV_Select||, CODE, READONLY, ALIGN=2

                  GUI_MEMDEV_Select PROC
;;;226    */
;;;227    GUI_MEMDEV_Handle GUI_MEMDEV_Select(GUI_MEMDEV_Handle hMem) {
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;228      GUI_MEMDEV_Handle r;
;;;229      GUI_LOCK();
;;;230      r = GUI_Context.hDevData;
000004  4c0f              LDR      r4,|L6.68|
000006  0005              MOVS     r5,r0                 ;227
000008  f9b47050          LDRSH    r7,[r4,#0x50]  ; GUI_Context
00000c  d008              BEQ      |L6.32|
;;;231      if (hMem == 0) {
;;;232        GUI_SelectLCD();
;;;233      } else {
;;;234        GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(hMem);
00000e  f7fffffe          BL       GUI_ALLOC_h2p
000012  4606              MOV      r6,r0
;;;235        #if GUI_WINSUPPORT
;;;236          WM_Deactivate();
000014  f7fffffe          BL       WM_Deactivate
;;;237        #endif
;;;238        /* If LCD was selected Save cliprect */
;;;239        if (GUI_Context.hDevData == 0) {
000018  f8b40050          LDRH     r0,[r4,#0x50]  ; GUI_Context
00001c  b118              CBZ      r0,|L6.38|
00001e  e008              B        |L6.50|
                  |L6.32|
000020  f7fffffe          BL       GUI_SelectLCD
000024  e00b              B        |L6.62|
                  |L6.38|
;;;240          GUI_Context.ClipRectPrev = GUI_Context.ClipRect;
000026  68a0              LDR      r0,[r4,#8]  ; GUI_Context
000028  f8c40052          STR      r0,[r4,#0x52]  ; GUI_Context
00002c  68e0              LDR      r0,[r4,#0xc]  ; GUI_Context
00002e  f8c40056          STR      r0,[r4,#0x56]  ; GUI_Context
                  |L6.50|
;;;241        }
;;;242        GUI_Context.hDevData = hMem;
000032  f8a45050          STRH     r5,[r4,#0x50]
;;;243        GUI_Context.pDeviceAPI = pDev->pAPIList;
000036  6ab0              LDR      r0,[r6,#0x28]
;;;244        LCD_SetClipRectMax();
000038  64e0              STR      r0,[r4,#0x4c]  ; GUI_Context
00003a  f7fffffe          BL       LCD_SetClipRectMax
                  |L6.62|
;;;245      }
;;;246      GUI_UNLOCK();
;;;247      return r;
00003e  4638              MOV      r0,r7
;;;248    }
000040  e8bd81f0          POP      {r4-r8,pc}
;;;249    
                          ENDP

                  |L6.68|
                          DCD      GUI_Context

                          AREA ||i.GUI_MEMDEV__Color2Index||, CODE, READONLY, ALIGN=2

                  GUI_MEMDEV__Color2Index PROC
;;;55     */
;;;56     unsigned int GUI_MEMDEV__Color2Index(LCD_COLOR Color) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;57       GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
000004  4804              LDR      r0,|L7.24|
000006  f9b00050          LDRSH    r0,[r0,#0x50]  ; GUI_Context
00000a  f7fffffe          BL       GUI_ALLOC_h2p
;;;58       return pDev->pfColor2Index(Color);
00000e  69c1              LDR      r1,[r0,#0x1c]
000010  4620              MOV      r0,r4
000012  e8bd4010          POP      {r4,lr}
000016  4708              BX       r1
;;;59     }
;;;60     
                          ENDP

                  |L7.24|
                          DCD      GUI_Context

                          AREA ||i.GUI_MEMDEV__CreateFixed||, CODE, READONLY, ALIGN=1

                  GUI_MEMDEV__CreateFixed PROC
;;;109    */
;;;110    GUI_MEMDEV_Handle GUI_MEMDEV__CreateFixed(int x0, int y0, int xsize, int ysize, int Flags
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;111                                            ,const tLCDDEV_APIList * pMemDevAPI
;;;112                                            ,tLCDDEV_Color2Index*        pfColor2Index
;;;113                                            ,tLCDDEV_Index2Color*        pfIndex2Color
;;;114                                            ,tLCDDEV_GetIndexMask*       pfGetIndexMask) {
000004  b081              SUB      sp,sp,#4
000006  461c              MOV      r4,r3
000008  e9dd5b0e          LDRD     r5,r11,[sp,#0x38]
00000c  4692              MOV      r10,r2
;;;115      I32 MemSize;
;;;116      GUI_USAGE_Handle hUsage = 0;
;;;117      unsigned int BitsPerPixel, BytesPerLine;
;;;118      GUI_MEMDEV_Handle hMemDev;
;;;119      BitsPerPixel = pMemDevAPI->BitsPerPixel;
;;;120      BytesPerLine = (xsize * BitsPerPixel + 7) >> 3;     /* Note: This code works with 8 and 16 bit memory devices. If other BPPs are introduced for MemDevs, it needs to be changed */
00000e  f8db9040          LDR      r9,[r11,#0x40]
000012  2600              MOVS     r6,#0                 ;116
000014  fb02f009          MUL      r0,r2,r9
000018  1dc0              ADDS     r0,r0,#7
00001a  08c7              LSRS     r7,r0,#3
;;;121      /* Calc available MemSize */
;;;122      MemSize = GUI_ALLOC_GetMaxSize();
00001c  f7fffffe          BL       GUI_ALLOC_GetMaxSize
;;;123      if (!(Flags & GUI_MEMDEV_NOTRANS)) {
000020  07e9              LSLS     r1,r5,#31
000022  d105              BNE      |L8.48|
;;;124        MemSize = (MemSize / 4) * 3;   /* We need to reserve some memory for usage object ... TBD: This can be optimized as we do not use memory perfectly. */
000024  17c1              ASRS     r1,r0,#31
000026  eb007091          ADD      r0,r0,r1,LSR #30
00002a  1080              ASRS     r0,r0,#2
00002c  eb000040          ADD      r0,r0,r0,LSL #1
                  |L8.48|
;;;125      }
;;;126      if (ysize<=0) {
000030  2c00              CMP      r4,#0
000032  dc06              BGT      |L8.66|
000034  382c              SUBS     r0,r0,#0x2c
;;;127        int MaxLines = (MemSize - sizeof(GUI_MEMDEV)) / BytesPerLine;
000036  fbb0f0f7          UDIV     r0,r0,r7
;;;128        ysize = (MaxLines > -ysize) ? -ysize : MaxLines;
00003a  4264              RSBS     r4,r4,#0
00003c  42a0              CMP      r0,r4
00003e  dc00              BGT      |L8.66|
000040  4604              MOV      r4,r0
                  |L8.66|
;;;129      }
;;;130      if (!(Flags & GUI_MEMDEV_NOTRANS)) {
000042  07e8              LSLS     r0,r5,#31
000044  d107              BNE      |L8.86|
;;;131        /* Create the usage map */
;;;132        hUsage = GUI_USAGE_BM_Create(x0, y0, xsize, ysize, 0);
000046  9000              STR      r0,[sp,#0]
000048  e9dd0101          LDRD     r0,r1,[sp,#4]
00004c  4623              MOV      r3,r4
00004e  4652              MOV      r2,r10
000050  f7fffffe          BL       GUI_USAGE_BM_Create
000054  4606              MOV      r6,r0
                  |L8.86|
;;;133      }
;;;134      /* Check if we can alloc sufficient memory */
;;;135      if (ysize <= 0) {
000056  2c00              CMP      r4,#0
000058  dc03              BGT      |L8.98|
;;;136        GUI_DEBUG_WARN("GUI_MEMDEV_Create: Too little memory");
;;;137        GUI_UNLOCK();
;;;138        return 0;    
00005a  2000              MOVS     r0,#0
                  |L8.92|
;;;139      }
;;;140      MemSize = ysize * BytesPerLine + sizeof(GUI_MEMDEV);
;;;141      if (Flags & GUI_MEMDEV_NOTRANS) {
;;;142        hMemDev = GUI_ALLOC_AllocNoInit(MemSize);
;;;143      } else {
;;;144        hMemDev = GUI_ALLOC_AllocZero(MemSize);
;;;145      }
;;;146      if (hMemDev) {
;;;147        GUI_MEMDEV* pDevData;
;;;148        pDevData = GUI_MEMDEV_H2P(hMemDev);
;;;149        pDevData->x0            = x0;
;;;150        pDevData->y0            = y0;
;;;151        pDevData->XSize         = xsize;
;;;152        pDevData->YSize         = ysize;
;;;153        pDevData->NumColors     = 
;;;154        #if GUI_NUM_LAYERS == 1
;;;155          LCD_GET_NUMCOLORS();
;;;156        #else
;;;157          LCD_GetNumColorsEx(GUI_Context.SelLayer);
;;;158        #endif
;;;159        pDevData->BytesPerLine  = BytesPerLine;
;;;160        pDevData->hUsage        = hUsage;
;;;161        /* Set color conversion routine pointers */
;;;162        pDevData->pfColor2Index = pfColor2Index;    /* LCD_L0_Color2Index; */
;;;163        pDevData->pfIndex2Color = pfIndex2Color;    /* LCD_L0_Index2Color; */
;;;164        pDevData->pfGetIndexMask= pfGetIndexMask;   /* LCD_L0_GetIndexMask */
;;;165    
;;;166        pDevData->pAPIList      = pMemDevAPI;
;;;167        pDevData->BitsPerPixel  = BitsPerPixel;
;;;168        #if (GUI_NUM_LAYERS > 1)   /* Size opt., preprocessor not required */
;;;169          pDevData->LayerIndex  = GUI_Context.SelLayer;
;;;170        #else
;;;171          pDevData->LayerIndex  = 0;
;;;172        #endif
;;;173      } else {
;;;174        if (hUsage) {
;;;175          GUI_ALLOC_Free(hUsage);
;;;176        }
;;;177        GUI_DEBUG_WARN("GUI_MEMDEV_Create: Alloc failed");
;;;178      }
;;;179      return hMemDev;
;;;180    }
00005c  b005              ADD      sp,sp,#0x14
00005e  e8bd8ff0          POP      {r4-r11,pc}
                  |L8.98|
000062  fb04f007          MUL      r0,r4,r7              ;140
000066  302c              ADDS     r0,r0,#0x2c           ;140
000068  07e9              LSLS     r1,r5,#31             ;141
00006a  b200              SXTH     r0,r0                 ;144
00006c  d002              BEQ      |L8.116|
00006e  f7fffffe          BL       GUI_ALLOC_AllocNoInit
000072  e001              B        |L8.120|
                  |L8.116|
000074  f7fffffe          BL       GUI_ALLOC_AllocZero
                  |L8.120|
000078  ea5f0800          MOVS     r8,r0                 ;144
00007c  d019              BEQ      |L8.178|
00007e  f7fffffe          BL       GUI_ALLOC_h2p
000082  9901              LDR      r1,[sp,#4]            ;149
000084  8001              STRH     r1,[r0,#0]            ;149
000086  9902              LDR      r1,[sp,#8]            ;150
000088  8041              STRH     r1,[r0,#2]            ;150
00008a  f8a0a004          STRH     r10,[r0,#4]           ;151
00008e  4605              MOV      r5,r0                 ;148
000090  80c4              STRH     r4,[r0,#6]            ;152
000092  f7fffffe          BL       LCD_GetNumColors
000096  e9c50702          STRD     r0,r7,[r5,#8]         ;153
00009a  832e              STRH     r6,[r5,#0x18]         ;160
00009c  9810              LDR      r0,[sp,#0x40]         ;162
00009e  61e8              STR      r0,[r5,#0x1c]         ;163
0000a0  9811              LDR      r0,[sp,#0x44]         ;163
0000a2  6228              STR      r0,[r5,#0x20]         ;164
0000a4  9812              LDR      r0,[sp,#0x48]         ;164
0000a6  e9c50b09          STRD     r0,r11,[r5,#0x24]     ;164
0000aa  2000              MOVS     r0,#0                 ;171
0000ac  e9c59004          STRD     r9,r0,[r5,#0x10]      ;171
0000b0  e003              B        |L8.186|
                  |L8.178|
0000b2  b116              CBZ      r6,|L8.186|
0000b4  4630              MOV      r0,r6                 ;175
0000b6  f7fffffe          BL       GUI_ALLOC_Free
                  |L8.186|
0000ba  4640              MOV      r0,r8                 ;179
0000bc  e7ce              B        |L8.92|
;;;181    
                          ENDP


                          AREA ||i.GUI_MEMDEV__GetIndexMask||, CODE, READONLY, ALIGN=2

                  GUI_MEMDEV__GetIndexMask PROC
;;;73     */
;;;74     unsigned int GUI_MEMDEV__GetIndexMask(void) {
000000  4804              LDR      r0,|L9.20|
000002  b510              PUSH     {r4,lr}
;;;75       GUI_MEMDEV * pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
000004  f9b00050          LDRSH    r0,[r0,#0x50]  ; GUI_Context
000008  f7fffffe          BL       GUI_ALLOC_h2p
;;;76       return pDev->pfGetIndexMask();
00000c  6a40              LDR      r0,[r0,#0x24]
00000e  e8bd4010          POP      {r4,lr}
000012  4700              BX       r0
;;;77     }
;;;78     
                          ENDP

                  |L9.20|
                          DCD      GUI_Context

                          AREA ||i.GUI_MEMDEV__GetRect||, CODE, READONLY, ALIGN=2

                  GUI_MEMDEV__GetRect PROC
;;;43     */
;;;44     void GUI_MEMDEV__GetRect(GUI_RECT* pRect) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;45       GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
000004  4809              LDR      r0,|L10.44|
000006  f9b00050          LDRSH    r0,[r0,#0x50]  ; GUI_Context
00000a  f7fffffe          BL       GUI_ALLOC_h2p
;;;46       pRect->x0 = pDev->x0;
00000e  8801              LDRH     r1,[r0,#0]
000010  8021              STRH     r1,[r4,#0]
;;;47       pRect->y0 = pDev->y0;
000012  8841              LDRH     r1,[r0,#2]
000014  8061              STRH     r1,[r4,#2]
;;;48       pRect->x1 = pDev->x0 + pDev->XSize-1;
000016  8801              LDRH     r1,[r0,#0]
000018  8882              LDRH     r2,[r0,#4]
00001a  4411              ADD      r1,r1,r2
00001c  1e49              SUBS     r1,r1,#1
00001e  80a1              STRH     r1,[r4,#4]
;;;49       pRect->y1 = pDev->y0 + pDev->YSize-1;
000020  8841              LDRH     r1,[r0,#2]
000022  88c0              LDRH     r0,[r0,#6]
000024  4408              ADD      r0,r0,r1
000026  1e40              SUBS     r0,r0,#1
000028  80e0              STRH     r0,[r4,#6]
;;;50     }
00002a  bd10              POP      {r4,pc}
;;;51     
                          ENDP

                  |L10.44|
                          DCD      GUI_Context

                          AREA ||i.GUI_MEMDEV__Index2Color||, CODE, READONLY, ALIGN=2

                  GUI_MEMDEV__Index2Color PROC
;;;64     */
;;;65     LCD_COLOR GUI_MEMDEV__Index2Color(int Index) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;66       GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(GUI_Context.hDevData);
000004  4804              LDR      r0,|L11.24|
000006  f9b00050          LDRSH    r0,[r0,#0x50]  ; GUI_Context
00000a  f7fffffe          BL       GUI_ALLOC_h2p
;;;67       return pDev->pfIndex2Color(Index);
00000e  6a01              LDR      r1,[r0,#0x20]
000010  4620              MOV      r0,r4
000012  e8bd4010          POP      {r4,lr}
000016  4708              BX       r1
;;;68     }
;;;69     
                          ENDP

                  |L11.24|
                          DCD      GUI_Context

                          AREA ||i.GUI_MEMDEV__WriteToActiveAt||, CODE, READONLY, ALIGN=1

                  GUI_MEMDEV__WriteToActiveAt PROC
;;;253    */
;;;254    void GUI_MEMDEV__WriteToActiveAt(GUI_MEMDEV_Handle hMem,int x, int y) {
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
000004  b08a              SUB      sp,sp,#0x28
;;;255      GUI_MEMDEV* pDev = GUI_MEMDEV_H2P(hMem);
000006  f7fffffe          BL       GUI_ALLOC_h2p
;;;256      GUI_USAGE_h hUsage = pDev->hUsage; 
;;;257      GUI_USAGE*  pUsage;
;;;258      int YSize = pDev->YSize;
;;;259      int yi;
;;;260      unsigned int BytesPerLine = pDev->BytesPerLine;
;;;261      unsigned int BitsPerPixel = pDev->BitsPerPixel;
;;;262      int BytesPerPixel = BitsPerPixel >> 3;
00000a  e9d0a903          LDRD     r10,r9,[r0,#0xc]
00000e  4605              MOV      r5,r0                 ;255
000010  f9b01018          LDRSH    r1,[r0,#0x18]         ;256
000014  f9b0b006          LDRSH    r11,[r0,#6]           ;258
000018  ea4f00d9          LSR      r0,r9,#3
;;;263      U8* pData = (U8*)(pDev+1);
00001c  f105082c          ADD      r8,r5,#0x2c
;;;264      if (hUsage) {
000020  9007              STR      r0,[sp,#0x1c]
000022  2900              CMP      r1,#0
000024  d05e              BEQ      |L12.228|
;;;265        pUsage = GUI_USAGE_H2P(hUsage);
000026  4608              MOV      r0,r1
000028  f7fffffe          BL       GUI_ALLOC_h2p
00002c  4607              MOV      r7,r0
;;;266        for (yi = 0; yi < YSize; yi++) {
00002e  2400              MOVS     r4,#0
000030  e053              B        |L12.218|
                  |L12.50|
;;;267          int xOff = 0;
000032  2000              MOVS     r0,#0
;;;268          int XSize;
;;;269          XSize = GUI_USAGE_GetNextDirty(pUsage, &xOff, yi);
000034  9006              STR      r0,[sp,#0x18]
000036  68b8              LDR      r0,[r7,#8]
000038  4622              MOV      r2,r4
00003a  a906              ADD      r1,sp,#0x18
00003c  6943              LDR      r3,[r0,#0x14]
00003e  4638              MOV      r0,r7
000040  4798              BLX      r3
;;;270          if (XSize == pDev->XSize) {
000042  f9b51004          LDRSH    r1,[r5,#4]
000046  4606              MOV      r6,r0                 ;269
000048  42b1              CMP      r1,r6
00004a  d140              BNE      |L12.206|
;;;271            /* If the entire line is affected, calculate the number of entire lines */
;;;272            int y0 = yi;
;;;273            while ((GUI_USAGE_GetNextDirty(pUsage, &xOff, yi + 1)) == XSize) {
00004c  9408              STR      r4,[sp,#0x20]
00004e  e000              B        |L12.82|
                  |L12.80|
000050  1c64              ADDS     r4,r4,#1
                  |L12.82|
000052  68b8              LDR      r0,[r7,#8]
000054  1c62              ADDS     r2,r4,#1
000056  a906              ADD      r1,sp,#0x18
000058  6943              LDR      r3,[r0,#0x14]
00005a  4638              MOV      r0,r7
00005c  4798              BLX      r3
00005e  42b0              CMP      r0,r6
000060  d0f6              BEQ      |L12.80|
;;;274              yi++;
;;;275            }
;;;276    		    LCD_DrawBitmap(x, y + y0, pDev->XSize, yi - y0 + 1, 1, 1, BitsPerPixel, BytesPerLine, pData, NULL);
000062  2000              MOVS     r0,#0
000064  e9cd8004          STRD     r8,r0,[sp,#0x10]
000068  2001              MOVS     r0,#1
00006a  a901              ADD      r1,sp,#4
00006c  9000              STR      r0,[sp,#0]
00006e  e8810601          STM      r1,{r0,r9,r10}
000072  9808              LDR      r0,[sp,#0x20]
000074  9908              LDR      r1,[sp,#0x20]
000076  1a26              SUBS     r6,r4,r0
000078  980c              LDR      r0,[sp,#0x30]
00007a  1c73              ADDS     r3,r6,#1
00007c  4401              ADD      r1,r1,r0
00007e  f9b52004          LDRSH    r2,[r5,#4]
000082  980b              LDR      r0,[sp,#0x2c]
000084  f7fffffe          BL       LCD_DrawBitmap
000088  1c76              ADDS     r6,r6,#1
;;;277            pData += (yi - y0 + 1) * BytesPerLine;
00008a  fb06800a          MLA      r0,r6,r10,r8
;;;278          } else {
00008e  e022              B        |L12.214|
                  |L12.144|
;;;279            /* Draw the partial line which needs to be drawn */
;;;280            for (; XSize; ) {
;;;281              LCD_DrawBitmap(x + xOff, y + yi, XSize, 1, 1, 1, BitsPerPixel, BytesPerLine, pData + xOff * BytesPerPixel, NULL);
000090  e9dd2306          LDRD     r2,r3,[sp,#0x18]
000094  2001              MOVS     r0,#1
000096  f10d0c04          ADD      r12,sp,#4
00009a  9000              STR      r0,[sp,#0]
00009c  e88c0601          STM      r12,{r0,r9,r10}
0000a0  fb028303          MLA      r3,r2,r3,r8
0000a4  2100              MOVS     r1,#0
0000a6  e9cd3104          STRD     r3,r1,[sp,#0x10]
0000aa  980c              LDR      r0,[sp,#0x30]
0000ac  2301              MOVS     r3,#1
0000ae  1901              ADDS     r1,r0,r4
0000b0  980b              LDR      r0,[sp,#0x2c]
0000b2  4410              ADD      r0,r0,r2
0000b4  4632              MOV      r2,r6
0000b6  f7fffffe          BL       LCD_DrawBitmap
;;;282              xOff += XSize;
0000ba  9806              LDR      r0,[sp,#0x18]
;;;283              XSize = GUI_USAGE_GetNextDirty(pUsage, &xOff, yi);
0000bc  4622              MOV      r2,r4
0000be  4430              ADD      r0,r0,r6              ;282
0000c0  9006              STR      r0,[sp,#0x18]
0000c2  68b8              LDR      r0,[r7,#8]
0000c4  a906              ADD      r1,sp,#0x18
0000c6  6943              LDR      r3,[r0,#0x14]
0000c8  4638              MOV      r0,r7
0000ca  4798              BLX      r3
0000cc  4606              MOV      r6,r0
                  |L12.206|
0000ce  2e00              CMP      r6,#0                 ;280
0000d0  d1de              BNE      |L12.144|
;;;284            }
;;;285            pData += BytesPerLine;
0000d2  eb08000a          ADD      r0,r8,r10
                  |L12.214|
0000d6  4680              MOV      r8,r0
0000d8  1c64              ADDS     r4,r4,#1
                  |L12.218|
0000da  455c              CMP      r4,r11                ;266
0000dc  dba9              BLT      |L12.50|
                  |L12.222|
;;;286          }
;;;287        }
;;;288      } else {
;;;289    		LCD_DrawBitmap(x, y, pDev->XSize, YSize, 1, 1, BitsPerPixel, BytesPerLine, pData, NULL);
;;;290      }
;;;291    }
0000de  b00d              ADD      sp,sp,#0x34
0000e0  e8bd8ff0          POP      {r4-r11,pc}
                  |L12.228|
0000e4  2001              MOVS     r0,#1                 ;289
0000e6  aa01              ADD      r2,sp,#4              ;289
0000e8  9000              STR      r0,[sp,#0]            ;289
0000ea  e8820601          STM      r2,{r0,r9,r10}        ;289
0000ee  2100              MOVS     r1,#0                 ;289
0000f0  e9cd8104          STRD     r8,r1,[sp,#0x10]      ;289
0000f4  f9b52004          LDRSH    r2,[r5,#4]            ;289
0000f8  e9dd010b          LDRD     r0,r1,[sp,#0x2c]      ;289
0000fc  465b              MOV      r3,r11                ;289
0000fe  f7fffffe          BL       LCD_DrawBitmap
000102  e7ec              B        |L12.222|
;;;292    
                          ENDP

