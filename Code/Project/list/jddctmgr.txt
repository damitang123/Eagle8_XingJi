; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\jddctmgr.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jddctmgr.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\JPEG\jddctmgr.c]
                          THUMB

                          AREA ||i.jinit_inverse_dct||, CODE, READONLY, ALIGN=2

                  jinit_inverse_dct PROC
;;;243    GLOBAL(void)
;;;244    jinit_inverse_dct (j_decompress_ptr cinfo)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;245    {
000004  4604              MOV      r4,r0
;;;246      my_idct_ptr idct;
;;;247      int ci;
;;;248      jpeg_component_info *compptr;
;;;249    
;;;250      idct = (my_idct_ptr)
000006  6840              LDR      r0,[r0,#4]
000008  2224              MOVS     r2,#0x24
00000a  2101              MOVS     r1,#1
00000c  6803              LDR      r3,[r0,#0]
00000e  4620              MOV      r0,r4
000010  4798              BLX      r3
000012  4606              MOV      r6,r0
;;;251        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;252    				SIZEOF(my_idct_controller));
;;;253      cinfo->idct = (struct jpeg_inverse_dct *) idct;
;;;254      idct->pub.start_pass = start_pass;
000014  f8c401c0          STR      r0,[r4,#0x1c0]
000018  480f              LDR      r0,|L1.88|
;;;255    
;;;256      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
00001a  6030              STR      r0,[r6,#0]
00001c  2500              MOVS     r5,#0
;;;257           ci++, compptr++) {
;;;258        /* Allocate and pre-zero a multiplier table for each component */
;;;259        compptr->dct_table =
00001e  f44f7880          MOV      r8,#0x100
;;;260          (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;261    				  SIZEOF(multiplier_table));
;;;262        MEMZERO(compptr->dct_table, SIZEOF(multiplier_table));
;;;263        /* Mark multiplier table not yet set up for any method */
;;;264        idct->cur_method[ci] = -1;
000022  f04f39ff          MOV      r9,#0xffffffff
000026  f8d470d8          LDR      r7,[r4,#0xd8]         ;256
00002a  e00f              B        |L1.76|
                  |L1.44|
00002c  6860              LDR      r0,[r4,#4]            ;259
00002e  4642              MOV      r2,r8                 ;259
000030  2101              MOVS     r1,#1                 ;259
000032  6803              LDR      r3,[r0,#0]            ;259
000034  4620              MOV      r0,r4                 ;259
000036  4798              BLX      r3                    ;259
000038  4641              MOV      r1,r8                 ;262
00003a  6538              STR      r0,[r7,#0x50]         ;262
00003c  f7fffffe          BL       __aeabi_memclr
000040  eb060185          ADD      r1,r6,r5,LSL #2
000044  1c6d              ADDS     r5,r5,#1
000046  3754              ADDS     r7,r7,#0x54
000048  f8c19014          STR      r9,[r1,#0x14]
                  |L1.76|
00004c  6a60              LDR      r0,[r4,#0x24]         ;256
00004e  42a8              CMP      r0,r5                 ;256
000050  dcec              BGT      |L1.44|
;;;265      }
;;;266    }
000052  e8bd87f0          POP      {r4-r10,pc}
                          ENDP

000056  0000              DCW      0x0000
                  |L1.88|
                          DCD      start_pass

                          AREA ||i.start_pass||, CODE, READONLY, ALIGN=2

                  start_pass PROC
;;;87     
;;;88     METHODDEF(void) start_pass (j_decompress_ptr cinfo) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;89       my_idct_ptr idct = (my_idct_ptr) cinfo->idct;
;;;90       int ci, i;
;;;91       jpeg_component_info *compptr;
;;;92       int method = 0;
000004  f04f0900          MOV      r9,#0
000008  4604              MOV      r4,r0                 ;88
;;;93       inverse_DCT_method_ptr method_ptr = NULL;
00000a  464f              MOV      r7,r9
;;;94       JQUANT_TBL * qtbl;
;;;95     
;;;96       for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components; ci++, compptr++) {
00000c  464e              MOV      r6,r9
;;;97         /* Select the proper IDCT routine for this component's scaling */
;;;98         switch (compptr->DCT_scaled_size) {
;;;99     #ifdef IDCT_SCALING_SUPPORTED
;;;100        case 1:
;;;101          method_ptr = jpeg_idct_1x1;
;;;102          method = JDCT_ISLOW;	/* jidctred uses islow-style table */
;;;103          break;
;;;104        case 2:
;;;105          method_ptr = jpeg_idct_2x2;
;;;106          method = JDCT_ISLOW;	/* jidctred uses islow-style table */
;;;107          break;
;;;108        case 4:
;;;109          method_ptr = jpeg_idct_4x4;
;;;110          method = JDCT_ISLOW;	/* jidctred uses islow-style table */
;;;111          break;
;;;112    #endif
;;;113        case DCTSIZE:
;;;114          switch (cinfo->dct_method) {
;;;115    #ifdef DCT_ISLOW_SUPPORTED
;;;116          case JDCT_ISLOW:
;;;117    	method_ptr = jpeg_idct_islow;
;;;118    	method = JDCT_ISLOW;
;;;119    	break;
;;;120    #endif
;;;121    #ifdef DCT_IFAST_SUPPORTED
;;;122          case JDCT_IFAST:
;;;123    	method_ptr = jpeg_idct_ifast;
;;;124    	method = JDCT_IFAST;
;;;125    	break;
;;;126    #endif
;;;127    #ifdef DCT_FLOAT_SUPPORTED
;;;128          case JDCT_FLOAT:
;;;129    	method_ptr = jpeg_idct_float;
;;;130    	method = JDCT_FLOAT;
;;;131    	break;
;;;132    #endif
;;;133          default:
;;;134    	ERREXIT(cinfo, JERR_NOT_COMPILED);
00000e  f04f0b30          MOV      r11,#0x30
000012  f8d0a1c0          LDR      r10,[r0,#0x1c0]       ;88
000016  f8d050d8          LDR      r5,[r0,#0xd8]         ;88
00001a  e056              B        |L2.202|
                  |L2.28|
00001c  6a68              LDR      r0,[r5,#0x24]         ;98
00001e  2808              CMP      r0,#8                 ;98
000020  d006              BEQ      |L2.48|
;;;135    	break;
;;;136          }
;;;137          break;
;;;138        default:
;;;139          ERREXIT1(cinfo, JERR_BAD_DCTSIZE, compptr->DCT_scaled_size);
000022  6821              LDR      r1,[r4,#0]
000024  2007              MOVS     r0,#7
000026  6148              STR      r0,[r1,#0x14]
000028  6821              LDR      r1,[r4,#0]
00002a  6a68              LDR      r0,[r5,#0x24]
;;;140          break;
00002c  6188              STR      r0,[r1,#0x18]
00002e  e007              B        |L2.64|
                  |L2.48|
000030  f8940048          LDRB     r0,[r4,#0x48]         ;114
000034  b148              CBZ      r0,|L2.74|
000036  2801              CMP      r0,#1                 ;114
000038  d00a              BEQ      |L2.80|
00003a  6821              LDR      r1,[r4,#0]            ;134
00003c  f8c1b014          STR      r11,[r1,#0x14]        ;134
                  |L2.64|
000040  6820              LDR      r0,[r4,#0]            ;134
000042  6801              LDR      r1,[r0,#0]            ;134
000044  4620              MOV      r0,r4                 ;134
000046  4788              BLX      r1                    ;134
000048  e005              B        |L2.86|
                  |L2.74|
00004a  4f22              LDR      r7,|L2.212|
00004c  2000              MOVS     r0,#0                 ;118
00004e  e001              B        |L2.84|
                  |L2.80|
000050  4f21              LDR      r7,|L2.216|
000052  2001              MOVS     r0,#1                 ;124
                  |L2.84|
000054  4681              MOV      r9,r0                 ;124
                  |L2.86|
;;;141        }
;;;142        idct->pub.inverse_DCT[ci] = method_ptr;
000056  eb0a0086          ADD      r0,r10,r6,LSL #2
;;;143        /* Create multiplier table from quant table.
;;;144         * However, we can skip this if the component is uninteresting
;;;145         * or if we already built the table.  Also, if no quant table
;;;146         * has yet been saved for the component, we leave the
;;;147         * multiplier table all-zero; we'll be reading zeroes from the
;;;148         * coefficient controller's buffer anyway.
;;;149         */
;;;150        if (! compptr->component_needed || idct->cur_method[ci] == method)
00005a  6047              STR      r7,[r0,#4]
00005c  6b29              LDR      r1,[r5,#0x30]
00005e  b1f9              CBZ      r1,|L2.160|
000060  6942              LDR      r2,[r0,#0x14]
000062  454a              CMP      r2,r9
000064  d02f              BEQ      |L2.198|
;;;151          continue;
;;;152        qtbl = compptr->quant_table;
;;;153        if (qtbl == NULL)		/* happens if no data yet for component */
000066  6ce9              LDR      r1,[r5,#0x4c]
000068  b1d1              CBZ      r1,|L2.160|
;;;154          continue;
;;;155        idct->cur_method[ci] = method;
;;;156        switch (method) {
00006a  f8c09014          STR      r9,[r0,#0x14]
00006e  ea5f0009          MOVS     r0,r9
000072  d016              BEQ      |L2.162|
000074  f1b90f00          CMP      r9,#0
000078  d01e              BEQ      |L2.184|
;;;157    #ifdef PROVIDE_ISLOW_TABLES
;;;158        case JDCT_ISLOW:
;;;159          {
;;;160    	/* For LL&M IDCT method, multipliers are equal to raw quantization
;;;161    	 * coefficients, but are stored as ints to ensure access efficiency.
;;;162    	 */
;;;163    	ISLOW_MULT_TYPE * ismtbl = (ISLOW_MULT_TYPE *) compptr->dct_table;
;;;164    	for (i = 0; i < DCTSIZE2; i++) {
;;;165    	  ismtbl[i] = (ISLOW_MULT_TYPE) qtbl->quantval[i];
;;;166    	}
;;;167          }
;;;168          break;
;;;169    #endif
;;;170    #ifdef DCT_IFAST_SUPPORTED
;;;171        case JDCT_IFAST:
;;;172          {
;;;173    	/* For AA&N IDCT method, multipliers are equal to quantization
;;;174    	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
;;;175    	 *   scalefactor[0] = 1
;;;176    	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
;;;177    	 * For integer operation, the multiplier table is to be scaled by
;;;178    	 * IFAST_SCALE_BITS.
;;;179    	 */
;;;180    	IFAST_MULT_TYPE * ifmtbl = (IFAST_MULT_TYPE *) compptr->dct_table;
;;;181    #define CONST_BITS 14
;;;182    	static const INT16 aanscales[DCTSIZE2] = {
;;;183    	  /* precomputed values scaled up by 14 bits */
;;;184    	  16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
;;;185    	  22725, 31521, 29692, 26722, 22725, 17855, 12299,  6270,
;;;186    	  21407, 29692, 27969, 25172, 21407, 16819, 11585,  5906,
;;;187    	  19266, 26722, 25172, 22654, 19266, 15137, 10426,  5315,
;;;188    	  16384, 22725, 21407, 19266, 16384, 12873,  8867,  4520,
;;;189    	  12873, 17855, 16819, 15137, 12873, 10114,  6967,  3552,
;;;190    	   8867, 12299, 11585, 10426,  8867,  6967,  4799,  2446,
;;;191    	   4520,  6270,  5906,  5315,  4520,  3552,  2446,  1247
;;;192    	};
;;;193    	SHIFT_TEMPS
;;;194    
;;;195    	for (i = 0; i < DCTSIZE2; i++) {
;;;196    	  ifmtbl[i] = (IFAST_MULT_TYPE)
00007a  f8dfc060          LDR      r12,|L2.220|
00007e  f8d52050          LDR.W    r2,[r5,#0x50]
000082  2000              MOVS     r0,#0                 ;195
                  |L2.132|
000084  f8313010          LDRH     r3,[r1,r0,LSL #1]
000088  f93c8010          LDRSH    r8,[r12,r0,LSL #1]
00008c  fb03f308          MUL      r3,r3,r8
000090  f5036300          ADD      r3,r3,#0x800
000094  131b              ASRS     r3,r3,#12
000096  f8423020          STR      r3,[r2,r0,LSL #2]
00009a  1c40              ADDS     r0,r0,#1
00009c  2840              CMP      r0,#0x40              ;195
00009e  dbf1              BLT      |L2.132|
                  |L2.160|
0000a0  e011              B        |L2.198|
                  |L2.162|
0000a2  f8d52050          LDR.W    r2,[r5,#0x50]         ;164
0000a6  2000              MOVS     r0,#0                 ;164
                  |L2.168|
0000a8  f8313010          LDRH     r3,[r1,r0,LSL #1]     ;165
0000ac  f8423020          STR      r3,[r2,r0,LSL #2]     ;165
0000b0  1c40              ADDS     r0,r0,#1              ;165
0000b2  2840              CMP      r0,#0x40              ;164
0000b4  dbf8              BLT      |L2.168|
0000b6  e006              B        |L2.198|
                  |L2.184|
;;;197    	    DESCALE(MULTIPLY16V16((INT32) qtbl->quantval[i],
;;;198    				  (INT32) aanscales[i]),
;;;199    		    CONST_BITS-IFAST_SCALE_BITS);
;;;200    	}
;;;201          }
;;;202          break;
;;;203    #endif
;;;204    #ifdef DCT_FLOAT_SUPPORTED
;;;205        case JDCT_FLOAT:
;;;206          {
;;;207    	/* For float AA&N IDCT method, multipliers are equal to quantization
;;;208    	 * coefficients scaled by scalefactor[row]*scalefactor[col], where
;;;209    	 *   scalefactor[0] = 1
;;;210    	 *   scalefactor[k] = cos(k*PI/16) * sqrt(2)    for k=1..7
;;;211    	 */
;;;212    	FLOAT_MULT_TYPE * fmtbl = (FLOAT_MULT_TYPE *) compptr->dct_table;
;;;213    	int row, col;
;;;214    	static const double aanscalefactor[DCTSIZE] = {
;;;215    	  1.0, 1.387039845, 1.306562965, 1.175875602,
;;;216    	  1.0, 0.785694958, 0.541196100, 0.275899379
;;;217    	};
;;;218    
;;;219    	i = 0;
;;;220    	for (row = 0; row < DCTSIZE; row++) {
;;;221    	  for (col = 0; col < DCTSIZE; col++) {
;;;222    	    fmtbl[i] = (FLOAT_MULT_TYPE)
;;;223    	      ((double) qtbl->quantval[i] *
;;;224    	       aanscalefactor[row] * aanscalefactor[col]);
;;;225    	    i++;
;;;226    	  }
;;;227    	}
;;;228          }
;;;229          break;
;;;230    #endif
;;;231        default:
;;;232          ERREXIT(cinfo, JERR_NOT_COMPILED);
0000b8  6821              LDR      r1,[r4,#0]
0000ba  f8c1b014          STR      r11,[r1,#0x14]
0000be  6820              LDR      r0,[r4,#0]
0000c0  6801              LDR      r1,[r0,#0]
0000c2  4620              MOV      r0,r4
0000c4  4788              BLX      r1
                  |L2.198|
0000c6  3554              ADDS     r5,r5,#0x54
0000c8  1c76              ADDS     r6,r6,#1
                  |L2.202|
0000ca  6a60              LDR      r0,[r4,#0x24]         ;96
0000cc  42b0              CMP      r0,r6                 ;96
0000ce  dca5              BGT      |L2.28|
;;;233          break;
;;;234        }
;;;235      }
;;;236    }
0000d0  e8bd9ff0          POP      {r4-r12,pc}
;;;237    
                          ENDP

                  |L2.212|
                          DCD      jpeg_idct_islow
                  |L2.216|
                          DCD      jpeg_idct_ifast
                  |L2.220|
                          DCD      ||.constdata||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  aanscales
000000  400058c5          DCW      0x4000,0x58c5
000004  539f4b42          DCW      0x539f,0x4b42
000008  40003249          DCW      0x4000,0x3249
00000c  22a311a8          DCW      0x22a3,0x11a8
000010  58c57b21          DCW      0x58c5,0x7b21
000014  73fc6862          DCW      0x73fc,0x6862
000018  58c545bf          DCW      0x58c5,0x45bf
00001c  300b187e          DCW      0x300b,0x187e
000020  539f73fc          DCW      0x539f,0x73fc
000024  6d416254          DCW      0x6d41,0x6254
000028  539f41b3          DCW      0x539f,0x41b3
00002c  2d411712          DCW      0x2d41,0x1712
000030  4b426862          DCW      0x4b42,0x6862
000034  6254587e          DCW      0x6254,0x587e
000038  4b423b21          DCW      0x4b42,0x3b21
00003c  28ba14c3          DCW      0x28ba,0x14c3
000040  400058c5          DCW      0x4000,0x58c5
000044  539f4b42          DCW      0x539f,0x4b42
000048  40003249          DCW      0x4000,0x3249
00004c  22a311a8          DCW      0x22a3,0x11a8
000050  324945bf          DCW      0x3249,0x45bf
000054  41b33b21          DCW      0x41b3,0x3b21
000058  32492782          DCW      0x3249,0x2782
00005c  1b370de0          DCW      0x1b37,0x0de0
000060  22a3300b          DCW      0x22a3,0x300b
000064  2d4128ba          DCW      0x2d41,0x28ba
000068  22a31b37          DCW      0x22a3,0x1b37
00006c  12bf098e          DCW      0x12bf,0x098e
000070  11a8187e          DCW      0x11a8,0x187e
000074  171214c3          DCW      0x1712,0x14c3
000078  11a80de0          DCW      0x11a8,0x0de0
00007c  098e04df          DCW      0x098e,0x04df
