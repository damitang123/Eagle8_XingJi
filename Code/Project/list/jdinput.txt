; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\jdinput.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jdinput.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\JPEG\jdinput.c]
                          THUMB

                          AREA ||i.consume_markers||, CODE, READONLY, ALIGN=1

                  consume_markers PROC
;;;287    METHODDEF(int)
;;;288    consume_markers (j_decompress_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;289    {
;;;290      my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
;;;291      int val;
;;;292    
;;;293      if (inputctl->pub.eoi_reached) /* After hitting EOI, read no further */
000002  f8d051b4          LDR      r5,[r0,#0x1b4]
000006  4604              MOV      r4,r0                 ;289
000008  6968              LDR      r0,[r5,#0x14]         ;289
00000a  b108              CBZ      r0,|L1.16|
;;;294        return JPEG_REACHED_EOI;
00000c  2002              MOVS     r0,#2
;;;295    
;;;296      val = (*cinfo->marker->read_markers) (cinfo);
;;;297    
;;;298      switch (val) {
;;;299      case JPEG_REACHED_SOS:	/* Found SOS */
;;;300        if (inputctl->inheaders) {	/* 1st SOS */
;;;301          initial_setup(cinfo);
;;;302          inputctl->inheaders = FALSE;
;;;303          /* Note: start_input_pass must be called by jdmaster.c
;;;304           * before any more input can be consumed.  jdapimin.c is
;;;305           * responsible for enforcing this sequencing.
;;;306           */
;;;307        } else {			/* 2nd or later SOS marker */
;;;308          if (! inputctl->pub.has_multiple_scans)
;;;309    	ERREXIT(cinfo, JERR_EOI_EXPECTED); /* Oops, I wasn't expecting this! */
;;;310          start_input_pass(cinfo);
;;;311        }
;;;312        break;
;;;313      case JPEG_REACHED_EOI:	/* Found EOI */
;;;314        inputctl->pub.eoi_reached = TRUE;
;;;315        if (inputctl->inheaders) {	/* Tables-only datastream, apparently */
;;;316          if (cinfo->marker->saw_SOF)
;;;317    	ERREXIT(cinfo, JERR_SOF_NO_SOS);
;;;318        } else {
;;;319          /* Prevent infinite loop in coef ctlr's decompress_data routine
;;;320           * if user set output_scan_number larger than number of scans.
;;;321           */
;;;322          if (cinfo->output_scan_number > cinfo->input_scan_number)
;;;323    	cinfo->output_scan_number = cinfo->input_scan_number;
;;;324        }
;;;325        break;
;;;326      case JPEG_SUSPENDED:
;;;327        break;
;;;328      }
;;;329    
;;;330      return val;
;;;331    }
00000e  bd70              POP      {r4-r6,pc}
                  |L1.16|
000010  f8d401b8          LDR      r0,[r4,#0x1b8]        ;296
000014  6841              LDR      r1,[r0,#4]            ;296
000016  4620              MOV      r0,r4                 ;296
000018  4788              BLX      r1                    ;296
00001a  0006              MOVS     r6,r0                 ;296
00001c  d031              BEQ      |L1.130|
00001e  2e01              CMP      r6,#1                 ;298
000020  d002              BEQ      |L1.40|
000022  2e02              CMP      r6,#2                 ;298
000024  d12d              BNE      |L1.130|
000026  e014              B        |L1.82|
                  |L1.40|
000028  69a8              LDR      r0,[r5,#0x18]         ;300
00002a  b128              CBZ      r0,|L1.56|
00002c  4620              MOV      r0,r4                 ;301
00002e  f7fffffe          BL       initial_setup
000032  2000              MOVS     r0,#0                 ;302
000034  61a8              STR      r0,[r5,#0x18]         ;302
000036  e024              B        |L1.130|
                  |L1.56|
000038  6928              LDR      r0,[r5,#0x10]         ;308
00003a  b930              CBNZ     r0,|L1.74|
00003c  6821              LDR      r1,[r4,#0]            ;309
00003e  2023              MOVS     r0,#0x23              ;309
000040  6148              STR      r0,[r1,#0x14]         ;309
000042  6820              LDR      r0,[r4,#0]            ;309
000044  6801              LDR      r1,[r0,#0]            ;309
000046  4620              MOV      r0,r4                 ;309
000048  4788              BLX      r1                    ;309
                  |L1.74|
00004a  4620              MOV      r0,r4                 ;310
00004c  f7fffffe          BL       start_input_pass
000050  e017              B        |L1.130|
                  |L1.82|
000052  2001              MOVS     r0,#1                 ;314
000054  6168              STR      r0,[r5,#0x14]         ;315
000056  69a8              LDR      r0,[r5,#0x18]         ;315
000058  b158              CBZ      r0,|L1.114|
00005a  f8d401b8          LDR      r0,[r4,#0x1b8]        ;316
00005e  6900              LDR      r0,[r0,#0x10]         ;316
000060  b178              CBZ      r0,|L1.130|
000062  6821              LDR      r1,[r4,#0]            ;317
000064  203b              MOVS     r0,#0x3b              ;317
000066  6148              STR      r0,[r1,#0x14]         ;317
000068  6820              LDR      r0,[r4,#0]            ;317
00006a  6801              LDR      r1,[r0,#0]            ;317
00006c  4620              MOV      r0,r4                 ;317
00006e  4788              BLX      r1                    ;317
000070  e007              B        |L1.130|
                  |L1.114|
000072  f8d41098          LDR      r1,[r4,#0x98]         ;322
000076  f8d40090          LDR      r0,[r4,#0x90]         ;322
00007a  4281              CMP      r1,r0                 ;322
00007c  dd01              BLE      |L1.130|
00007e  f8c40098          STR      r0,[r4,#0x98]         ;323
                  |L1.130|
000082  4630              MOV      r0,r6                 ;330
000084  bd70              POP      {r4-r6,pc}
;;;332    
                          ENDP


                          AREA ||i.finish_input_pass||, CODE, READONLY, ALIGN=2

                  finish_input_pass PROC
;;;270    METHODDEF(void)
;;;271    finish_input_pass (j_decompress_ptr cinfo)
000000  f8d001b4          LDR      r0,[r0,#0x1b4]
;;;272    {
;;;273      cinfo->inputctl->consume_input = consume_markers;
000004  4901              LDR      r1,|L2.12|
000006  6001              STR      r1,[r0,#0]
;;;274    }
000008  4770              BX       lr
;;;275    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      consume_markers

                          AREA ||i.initial_setup||, CODE, READONLY, ALIGN=2

                  initial_setup PROC
;;;38     LOCAL(void)
;;;39     initial_setup (j_decompress_ptr cinfo)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;40     /* Called once, when first SOS marker is reached */
;;;41     {
000004  4604              MOV      r4,r0
;;;42       int ci;
;;;43       jpeg_component_info *compptr;
;;;44     
;;;45       /* Make sure image isn't bigger than I can handle */
;;;46       if ((long) cinfo->image_height > (long) JPEG_MAX_DIMENSION ||
000006  6a01              LDR      r1,[r0,#0x20]
000008  f64f70dc          MOV      r0,#0xffdc
00000c  4281              CMP      r1,r0
00000e  dc02              BGT      |L3.22|
;;;47           (long) cinfo->image_width > (long) JPEG_MAX_DIMENSION)
000010  69e1              LDR      r1,[r4,#0x1c]
000012  4281              CMP      r1,r0
000014  dd08              BLE      |L3.40|
                  |L3.22|
;;;48         ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (unsigned int) JPEG_MAX_DIMENSION);
000016  6822              LDR      r2,[r4,#0]
000018  2129              MOVS     r1,#0x29
00001a  6151              STR      r1,[r2,#0x14]
00001c  6821              LDR      r1,[r4,#0]
00001e  6188              STR      r0,[r1,#0x18]
000020  6820              LDR      r0,[r4,#0]
000022  6801              LDR      r1,[r0,#0]
000024  4620              MOV      r0,r4
000026  4788              BLX      r1
                  |L3.40|
;;;49     
;;;50       /* For now, precision must match compiled-in value... */
;;;51       if (cinfo->data_precision != BITS_IN_JSAMPLE)
000028  f8d400d4          LDR      r0,[r4,#0xd4]
00002c  2808              CMP      r0,#8
00002e  d00a              BEQ      |L3.70|
;;;52         ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
000030  6821              LDR      r1,[r4,#0]
000032  200f              MOVS     r0,#0xf
000034  6148              STR      r0,[r1,#0x14]
000036  6821              LDR      r1,[r4,#0]
000038  f8d400d4          LDR      r0,[r4,#0xd4]
00003c  6188              STR      r0,[r1,#0x18]
00003e  6820              LDR      r0,[r4,#0]
000040  6801              LDR      r1,[r0,#0]
000042  4620              MOV      r0,r4
000044  4788              BLX      r1
                  |L3.70|
;;;53     
;;;54       /* Check that number of components won't exceed internal array sizes */
;;;55       if (cinfo->num_components > MAX_COMPONENTS)
000046  6a60              LDR      r0,[r4,#0x24]
000048  2804              CMP      r0,#4
00004a  dd0c              BLE      |L3.102|
;;;56         ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->num_components,
00004c  6821              LDR      r1,[r4,#0]
00004e  201a              MOVS     r0,#0x1a
000050  6148              STR      r0,[r1,#0x14]
000052  6821              LDR      r1,[r4,#0]
000054  6a60              LDR      r0,[r4,#0x24]
000056  6188              STR      r0,[r1,#0x18]
000058  6821              LDR      r1,[r4,#0]
00005a  2004              MOVS     r0,#4
00005c  61c8              STR      r0,[r1,#0x1c]
00005e  6820              LDR      r0,[r4,#0]
000060  6801              LDR      r1,[r0,#0]
000062  4620              MOV      r0,r4
000064  4788              BLX      r1
                  |L3.102|
;;;57     	     MAX_COMPONENTS);
;;;58     
;;;59       /* Compute maximum sampling factors; check factor validity */
;;;60       cinfo->max_h_samp_factor = 1;
000066  2601              MOVS     r6,#1
;;;61       cinfo->max_v_samp_factor = 1;
000068  f8c46134          STR      r6,[r4,#0x134]
;;;62       for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
00006c  f8c46138          STR      r6,[r4,#0x138]
000070  2700              MOVS     r7,#0
000072  f8d450d8          LDR      r5,[r4,#0xd8]
000076  e022              B        |L3.190|
                  |L3.120|
;;;63            ci++, compptr++) {
;;;64         if (compptr->h_samp_factor<=0 || compptr->h_samp_factor>MAX_SAMP_FACTOR ||
000078  68a8              LDR      r0,[r5,#8]
00007a  2800              CMP      r0,#0
00007c  dd06              BLE      |L3.140|
00007e  2804              CMP      r0,#4
000080  dc04              BGT      |L3.140|
;;;65     	compptr->v_samp_factor<=0 || compptr->v_samp_factor>MAX_SAMP_FACTOR)
000082  68e8              LDR      r0,[r5,#0xc]
000084  2800              CMP      r0,#0
000086  dd01              BLE      |L3.140|
000088  2804              CMP      r0,#4
00008a  dd06              BLE      |L3.154|
                  |L3.140|
;;;66           ERREXIT(cinfo, JERR_BAD_SAMPLING);
00008c  6821              LDR      r1,[r4,#0]
00008e  2012              MOVS     r0,#0x12
000090  6148              STR      r0,[r1,#0x14]
000092  6820              LDR      r0,[r4,#0]
000094  6801              LDR      r1,[r0,#0]
000096  4620              MOV      r0,r4
000098  4788              BLX      r1
                  |L3.154|
;;;67         cinfo->max_h_samp_factor = MAX(cinfo->max_h_samp_factor,
00009a  f8d40134          LDR      r0,[r4,#0x134]
00009e  68a9              LDR      r1,[r5,#8]
0000a0  4288              CMP      r0,r1
0000a2  dc00              BGT      |L3.166|
0000a4  4608              MOV      r0,r1
                  |L3.166|
;;;68     				   compptr->h_samp_factor);
;;;69         cinfo->max_v_samp_factor = MAX(cinfo->max_v_samp_factor,
0000a6  f8c40134          STR      r0,[r4,#0x134]
0000aa  f8d41138          LDR      r1,[r4,#0x138]
0000ae  68e8              LDR      r0,[r5,#0xc]
0000b0  4281              CMP      r1,r0
0000b2  dd00              BLE      |L3.182|
0000b4  4608              MOV      r0,r1
                  |L3.182|
0000b6  3554              ADDS     r5,r5,#0x54
0000b8  1c7f              ADDS     r7,r7,#1
0000ba  f8c40138          STR      r0,[r4,#0x138]
                  |L3.190|
0000be  6a60              LDR      r0,[r4,#0x24]         ;62
0000c0  42b8              CMP      r0,r7                 ;62
0000c2  dcd9              BGT      |L3.120|
;;;70     				   compptr->v_samp_factor);
;;;71       }
;;;72     
;;;73       /* We initialize DCT_scaled_size and min_DCT_scaled_size to DCTSIZE.
;;;74        * In the full decompressor, this will be overridden by jdmaster.c;
;;;75        * but in the transcoder, jdmaster.c is not used, so we must do it here.
;;;76        */
;;;77       cinfo->min_DCT_scaled_size = DCTSIZE;
0000c4  f04f0808          MOV      r8,#8
;;;78     
;;;79       /* Compute dimensions of components */
;;;80       for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
0000c8  2700              MOVS     r7,#0
0000ca  f8c4813c          STR      r8,[r4,#0x13c]
0000ce  46b9              MOV      r9,r7
0000d0  f8d450d8          LDR      r5,[r4,#0xd8]
0000d4  e029              B        |L3.298|
;;;81            ci++, compptr++) {
;;;82         compptr->DCT_scaled_size = DCTSIZE;
;;;83         /* Size in DCT blocks */
;;;84         compptr->width_in_blocks = (JDIMENSION)
0000d6  bf00              NOP      
                  |L3.216|
0000d8  f8c58024          STR      r8,[r5,#0x24]
0000dc  69e0              LDR      r0,[r4,#0x1c]
0000de  68a9              LDR      r1,[r5,#8]
0000e0  4348              MULS     r0,r1,r0
0000e2  f8d41134          LDR      r1,[r4,#0x134]
0000e6  00c9              LSLS     r1,r1,#3
0000e8  f7fffffe          BL       jdiv_round_up
;;;85           jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
;;;86     		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
;;;87         compptr->height_in_blocks = (JDIMENSION)
0000ec  61e8              STR      r0,[r5,#0x1c]
0000ee  6a20              LDR      r0,[r4,#0x20]
0000f0  68e9              LDR      r1,[r5,#0xc]
0000f2  4348              MULS     r0,r1,r0
0000f4  f8d41138          LDR      r1,[r4,#0x138]
0000f8  00c9              LSLS     r1,r1,#3
0000fa  f7fffffe          BL       jdiv_round_up
;;;88           jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
;;;89     		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
;;;90         /* downsampled_width and downsampled_height will also be overridden by
;;;91          * jdmaster.c if we are doing full decompression.  The transcoder library
;;;92          * doesn't use these values, but the calling application might.
;;;93          */
;;;94         /* Size in samples */
;;;95         compptr->downsampled_width = (JDIMENSION)
0000fe  6228              STR      r0,[r5,#0x20]
000100  69e0              LDR      r0,[r4,#0x1c]
000102  68a9              LDR      r1,[r5,#8]
000104  4348              MULS     r0,r1,r0
000106  f8d41134          LDR      r1,[r4,#0x134]
00010a  f7fffffe          BL       jdiv_round_up
;;;96           jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
;;;97     		    (long) cinfo->max_h_samp_factor);
;;;98         compptr->downsampled_height = (JDIMENSION)
00010e  62a8              STR      r0,[r5,#0x28]
000110  6a20              LDR      r0,[r4,#0x20]
000112  68e9              LDR      r1,[r5,#0xc]
000114  4348              MULS     r0,r1,r0
000116  f8d41138          LDR      r1,[r4,#0x138]
00011a  f7fffffe          BL       jdiv_round_up
;;;99           jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
;;;100    		    (long) cinfo->max_v_samp_factor);
;;;101        /* Mark component needed, until color conversion says otherwise */
;;;102        compptr->component_needed = TRUE;
;;;103        /* Mark no quantization table yet saved for component */
;;;104        compptr->quant_table = NULL;
00011e  f8c5904c          STR      r9,[r5,#0x4c]
000122  e9c5060b          STRD     r0,r6,[r5,#0x2c]
000126  3554              ADDS     r5,r5,#0x54
000128  1c7f              ADDS     r7,r7,#1
                  |L3.298|
00012a  6a60              LDR      r0,[r4,#0x24]         ;80
00012c  42b8              CMP      r0,r7                 ;80
00012e  dcd3              BGT      |L3.216|
;;;105      }
;;;106    
;;;107      /* Compute number of fully interleaved MCU rows. */
;;;108      cinfo->total_iMCU_rows = (JDIMENSION)
000130  f8d40138          LDR      r0,[r4,#0x138]
000134  00c1              LSLS     r1,r0,#3
000136  6a20              LDR      r0,[r4,#0x20]
000138  f7fffffe          BL       jdiv_round_up
;;;109        jdiv_round_up((long) cinfo->image_height,
;;;110    		  (long) (cinfo->max_v_samp_factor*DCTSIZE));
;;;111    
;;;112      /* Decide whether file contains multiple scans */
;;;113      if (cinfo->comps_in_scan < cinfo->num_components || cinfo->progressive_mode)
00013c  f8c40140          STR      r0,[r4,#0x140]
000140  6a61              LDR      r1,[r4,#0x24]
000142  f8d40148          LDR      r0,[r4,#0x148]
000146  4288              CMP      r0,r1
000148  db02              BLT      |L3.336|
00014a  f8d400dc          LDR      r0,[r4,#0xdc]
00014e  b120              CBZ      r0,|L3.346|
                  |L3.336|
;;;114        cinfo->inputctl->has_multiple_scans = TRUE;
000150  f8d401b4          LDR      r0,[r4,#0x1b4]
000154  6106              STR      r6,[r0,#0x10]
                  |L3.342|
;;;115      else
;;;116        cinfo->inputctl->has_multiple_scans = FALSE;
;;;117    }
000156  e8bd87f0          POP      {r4-r10,pc}
                  |L3.346|
00015a  f8d411b4          LDR      r1,[r4,#0x1b4]        ;116
00015e  f8c19010          STR      r9,[r1,#0x10]         ;116
000162  e7f8              B        |L3.342|
;;;118    
                          ENDP


                          AREA ||i.jinit_input_controller||, CODE, READONLY, ALIGN=2

                  jinit_input_controller PROC
;;;360    GLOBAL(void)
;;;361    jinit_input_controller (j_decompress_ptr cinfo)
000000  b510              PUSH     {r4,lr}
;;;362    {
000002  4604              MOV      r4,r0
;;;363      my_inputctl_ptr inputctl;
;;;364    
;;;365      /* Create subobject in permanent pool */
;;;366      inputctl = (my_inputctl_ptr)
000004  6840              LDR      r0,[r0,#4]
000006  221c              MOVS     r2,#0x1c
000008  2100              MOVS     r1,#0
00000a  6803              LDR      r3,[r0,#0]
00000c  4620              MOV      r0,r4
00000e  4798              BLX      r3
;;;367        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
;;;368    				SIZEOF(my_input_controller));
;;;369      cinfo->inputctl = (struct jpeg_input_controller *) inputctl;
;;;370      /* Initialize method pointers */
;;;371      inputctl->pub.consume_input = consume_markers;
000010  4907              LDR      r1,|L4.48|
000012  f8c401b4          STR      r0,[r4,#0x1b4]
;;;372      inputctl->pub.reset_input_controller = reset_input_controller;
000016  6001              STR      r1,[r0,#0]
000018  4906              LDR      r1,|L4.52|
;;;373      inputctl->pub.start_input_pass = start_input_pass;
00001a  6041              STR      r1,[r0,#4]
00001c  4906              LDR      r1,|L4.56|
;;;374      inputctl->pub.finish_input_pass = finish_input_pass;
00001e  6081              STR      r1,[r0,#8]
000020  4906              LDR      r1,|L4.60|
;;;375      /* Initialize state: can't use reset_input_controller since we don't
;;;376       * want to try to reset other modules yet.
;;;377       */
;;;378      inputctl->pub.has_multiple_scans = FALSE; /* "unknown" would be better */
000022  60c1              STR      r1,[r0,#0xc]
000024  2100              MOVS     r1,#0
;;;379      inputctl->pub.eoi_reached = FALSE;
000026  6101              STR      r1,[r0,#0x10]
;;;380      inputctl->inheaders = TRUE;
000028  6141              STR      r1,[r0,#0x14]
00002a  2101              MOVS     r1,#1
00002c  6181              STR      r1,[r0,#0x18]
;;;381    }
00002e  bd10              POP      {r4,pc}
                          ENDP

                  |L4.48|
                          DCD      consume_markers
                  |L4.52|
                          DCD      reset_input_controller
                  |L4.56|
                          DCD      start_input_pass
                  |L4.60|
                          DCD      finish_input_pass

                          AREA ||i.per_scan_setup||, CODE, READONLY, ALIGN=2

                  per_scan_setup PROC
;;;120    LOCAL(void)
;;;121    per_scan_setup (j_decompress_ptr cinfo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;122    /* Do computations that are needed before processing a JPEG scan */
;;;123    /* cinfo->comps_in_scan and cinfo->cur_comp_info[] were set from SOS marker */
;;;124    {
000004  4604              MOV      r4,r0
;;;125      int ci, mcublks, tmp;
;;;126      jpeg_component_info *compptr;
;;;127      
;;;128      if (cinfo->comps_in_scan == 1) {
000006  f8d00148          LDR      r0,[r0,#0x148]
00000a  2500              MOVS     r5,#0
00000c  2801              CMP      r0,#1
00000e  d024              BEQ      |L5.90|
;;;129        
;;;130        /* Noninterleaved (single-component) scan */
;;;131        compptr = cinfo->cur_comp_info[0];
;;;132        
;;;133        /* Overall image size in MCUs */
;;;134        cinfo->MCUs_per_row = compptr->width_in_blocks;
;;;135        cinfo->MCU_rows_in_scan = compptr->height_in_blocks;
;;;136        
;;;137        /* For noninterleaved scan, always one block per MCU */
;;;138        compptr->MCU_width = 1;
;;;139        compptr->MCU_height = 1;
;;;140        compptr->MCU_blocks = 1;
;;;141        compptr->MCU_sample_width = compptr->DCT_scaled_size;
;;;142        compptr->last_col_width = 1;
;;;143        /* For noninterleaved scans, it is convenient to define last_row_height
;;;144         * as the number of block rows present in the last iMCU row.
;;;145         */
;;;146        tmp = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
;;;147        if (tmp == 0) tmp = compptr->v_samp_factor;
;;;148        compptr->last_row_height = tmp;
;;;149        
;;;150        /* Prepare array describing MCU composition */
;;;151        cinfo->blocks_in_MCU = 1;
;;;152        cinfo->MCU_membership[0] = 0;
;;;153        
;;;154      } else {
;;;155        
;;;156        /* Interleaved (multi-component) scan */
;;;157        if (cinfo->comps_in_scan <= 0 || cinfo->comps_in_scan > MAX_COMPS_IN_SCAN)
000010  2800              CMP      r0,#0
000012  dd01              BLE      |L5.24|
000014  2804              CMP      r0,#4
000016  dd0d              BLE      |L5.52|
                  |L5.24|
;;;158          ERREXIT2(cinfo, JERR_COMPONENT_COUNT, cinfo->comps_in_scan,
000018  6821              LDR      r1,[r4,#0]
00001a  201a              MOVS     r0,#0x1a
00001c  6148              STR      r0,[r1,#0x14]
00001e  6821              LDR      r1,[r4,#0]
000020  f8d40148          LDR      r0,[r4,#0x148]
000024  6188              STR      r0,[r1,#0x18]
000026  6821              LDR      r1,[r4,#0]
000028  2004              MOVS     r0,#4
00002a  61c8              STR      r0,[r1,#0x1c]
00002c  6820              LDR      r0,[r4,#0]
00002e  6801              LDR      r1,[r0,#0]
000030  4620              MOV      r0,r4
000032  4788              BLX      r1
                  |L5.52|
;;;159    	       MAX_COMPS_IN_SCAN);
;;;160        
;;;161        /* Overall image size in MCUs */
;;;162        cinfo->MCUs_per_row = (JDIMENSION)
000034  f8d40134          LDR      r0,[r4,#0x134]
000038  00c1              LSLS     r1,r0,#3
00003a  69e0              LDR      r0,[r4,#0x1c]
00003c  34e8              ADDS     r4,r4,#0xe8
00003e  f7fffffe          BL       jdiv_round_up
;;;163          jdiv_round_up((long) cinfo->image_width,
;;;164    		    (long) (cinfo->max_h_samp_factor*DCTSIZE));
;;;165        cinfo->MCU_rows_in_scan = (JDIMENSION)
000042  6760              STR      r0,[r4,#0x74]
000044  6d20              LDR      r0,[r4,#0x50]
000046  00c1              LSLS     r1,r0,#3
000048  f8540cc8          LDR      r0,[r4,#-0xc8]
00004c  f7fffffe          BL       jdiv_round_up
000050  e9c4051e          STRD     r0,r5,[r4,#0x78]
;;;166          jdiv_round_up((long) cinfo->image_height,
;;;167    		    (long) (cinfo->max_v_samp_factor*DCTSIZE));
;;;168        
;;;169        cinfo->blocks_in_MCU = 0;
;;;170        
;;;171        for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
000054  2600              MOVS     r6,#0
000056  3ce8              SUBS     r4,r4,#0xe8
000058  e056              B        |L5.264|
                  |L5.90|
00005a  f8d4014c          LDR      r0,[r4,#0x14c]        ;134
00005e  69c1              LDR      r1,[r0,#0x1c]         ;134
000060  f8c4115c          STR      r1,[r4,#0x15c]        ;135
000064  6a01              LDR      r1,[r0,#0x20]         ;135
000066  f8c41160          STR      r1,[r4,#0x160]        ;138
00006a  2101              MOVS     r1,#1                 ;138
00006c  6341              STR      r1,[r0,#0x34]         ;139
00006e  6381              STR      r1,[r0,#0x38]         ;140
000070  63c1              STR      r1,[r0,#0x3c]         ;141
000072  6a42              LDR      r2,[r0,#0x24]         ;141
000074  e9c02110          STRD     r2,r1,[r0,#0x40]      ;141
000078  68c3              LDR      r3,[r0,#0xc]          ;146
00007a  6a02              LDR      r2,[r0,#0x20]         ;146
00007c  fbb2f6f3          UDIV     r6,r2,r3              ;146
000080  fb032216          MLS      r2,r3,r6,r2           ;146
000084  b902              CBNZ     r2,|L5.136|
000086  461a              MOV      r2,r3                 ;147
                  |L5.136|
000088  6482              STR      r2,[r0,#0x48]         ;148
00008a  e9c41559          STRD     r1,r5,[r4,#0x164]     ;148
                  |L5.142|
;;;172          compptr = cinfo->cur_comp_info[ci];
;;;173          /* Sampling factors give # of blocks of component in each MCU */
;;;174          compptr->MCU_width = compptr->h_samp_factor;
;;;175          compptr->MCU_height = compptr->v_samp_factor;
;;;176          compptr->MCU_blocks = compptr->MCU_width * compptr->MCU_height;
;;;177          compptr->MCU_sample_width = compptr->MCU_width * compptr->DCT_scaled_size;
;;;178          /* Figure number of non-dummy blocks in last MCU column & row */
;;;179          tmp = (int) (compptr->width_in_blocks % compptr->MCU_width);
;;;180          if (tmp == 0) tmp = compptr->MCU_width;
;;;181          compptr->last_col_width = tmp;
;;;182          tmp = (int) (compptr->height_in_blocks % compptr->MCU_height);
;;;183          if (tmp == 0) tmp = compptr->MCU_height;
;;;184          compptr->last_row_height = tmp;
;;;185          /* Prepare array describing MCU composition */
;;;186          mcublks = compptr->MCU_blocks;
;;;187          if (cinfo->blocks_in_MCU + mcublks > D_MAX_BLOCKS_IN_MCU)
;;;188    	ERREXIT(cinfo, JERR_BAD_MCU_SIZE);
;;;189          while (mcublks-- > 0) {
;;;190    	cinfo->MCU_membership[cinfo->blocks_in_MCU++] = ci;
;;;191          }
;;;192        }
;;;193        
;;;194      }
;;;195    }
00008e  e8bd81f0          POP      {r4-r8,pc}
000092  bf00              NOP                            ;172
                  |L5.148|
000094  eb040086          ADD      r0,r4,r6,LSL #2       ;172
000098  f8d0014c          LDR      r0,[r0,#0x14c]        ;172
00009c  6881              LDR      r1,[r0,#8]            ;174
00009e  6341              STR      r1,[r0,#0x34]         ;175
0000a0  68c3              LDR      r3,[r0,#0xc]          ;176
0000a2  fb01f503          MUL      r5,r1,r3              ;176
0000a6  e9c0350e          STRD     r3,r5,[r0,#0x38]      ;176
0000aa  6a42              LDR      r2,[r0,#0x24]         ;177
0000ac  434a              MULS     r2,r1,r2              ;177
0000ae  6402              STR      r2,[r0,#0x40]         ;179
0000b0  69c2              LDR      r2,[r0,#0x1c]         ;179
0000b2  fbb2f7f1          UDIV     r7,r2,r1              ;179
0000b6  fb012217          MLS      r2,r1,r7,r2           ;179
0000ba  b902              CBNZ     r2,|L5.190|
0000bc  460a              MOV      r2,r1                 ;180
                  |L5.190|
0000be  6442              STR      r2,[r0,#0x44]         ;182
0000c0  6a01              LDR      r1,[r0,#0x20]         ;182
0000c2  fbb1f2f3          UDIV     r2,r1,r3              ;182
0000c6  fb031112          MLS      r1,r3,r2,r1           ;182
0000ca  b901              CBNZ     r1,|L5.206|
0000cc  4619              MOV      r1,r3                 ;183
                  |L5.206|
0000ce  6481              STR      r1,[r0,#0x48]         ;187
0000d0  f8d40164          LDR      r0,[r4,#0x164]        ;187
0000d4  4428              ADD      r0,r0,r5              ;187
0000d6  280a              CMP      r0,#0xa               ;187
0000d8  dd11              BLE      |L5.254|
0000da  6821              LDR      r1,[r4,#0]            ;188
0000dc  200d              MOVS     r0,#0xd               ;188
0000de  6148              STR      r0,[r1,#0x14]         ;188
0000e0  6820              LDR      r0,[r4,#0]            ;188
0000e2  6801              LDR      r1,[r0,#0]            ;188
0000e4  4620              MOV      r0,r4                 ;188
0000e6  4788              BLX      r1                    ;188
0000e8  e009              B        |L5.254|
0000ea  bf00              NOP                            ;190
                  |L5.236|
0000ec  f8d40164          LDR      r0,[r4,#0x164]        ;190
0000f0  eb040180          ADD      r1,r4,r0,LSL #2       ;190
0000f4  1c40              ADDS     r0,r0,#1              ;190
0000f6  f8c40164          STR      r0,[r4,#0x164]        ;190
0000fa  f8c16168          STR      r6,[r1,#0x168]        ;190
                  |L5.254|
0000fe  1e28              SUBS     r0,r5,#0              ;189
000100  f1a50501          SUB      r5,r5,#1              ;189
000104  dcf2              BGT      |L5.236|
000106  1c76              ADDS     r6,r6,#1              ;189
                  |L5.264|
000108  f8d40148          LDR      r0,[r4,#0x148]        ;171
00010c  42b0              CMP      r0,r6                 ;171
00010e  dcc1              BGT      |L5.148|
000110  e7bd              B        |L5.142|
;;;196    
                          ENDP


                          AREA ||i.reset_input_controller||, CODE, READONLY, ALIGN=2

                  reset_input_controller PROC
;;;338    METHODDEF(void)
;;;339    reset_input_controller (j_decompress_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;340    {
000002  4604              MOV      r4,r0
;;;341      my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
000004  f8d001b4          LDR      r0,[r0,#0x1b4]
;;;342    
;;;343      inputctl->pub.consume_input = consume_markers;
;;;344      inputctl->pub.has_multiple_scans = FALSE; /* "unknown" would be better */
000008  2500              MOVS     r5,#0
00000a  4909              LDR      r1,|L6.48|
;;;345      inputctl->pub.eoi_reached = FALSE;
;;;346      inputctl->inheaders = TRUE;
00000c  6105              STR      r5,[r0,#0x10]
00000e  6001              STR      r1,[r0,#0]
000010  2101              MOVS     r1,#1
000012  e9c05105          STRD     r5,r1,[r0,#0x14]
;;;347      /* Reset other modules */
;;;348      (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
000016  6820              LDR      r0,[r4,#0]
000018  6901              LDR      r1,[r0,#0x10]
00001a  4620              MOV      r0,r4
00001c  4788              BLX      r1
;;;349      (*cinfo->marker->reset_marker_reader) (cinfo);
00001e  f8d401b8          LDR      r0,[r4,#0x1b8]
000022  6801              LDR      r1,[r0,#0]
000024  4620              MOV      r0,r4
000026  4788              BLX      r1
;;;350      /* Reset progression state -- would be cleaner if entropy decoder did this */
;;;351      cinfo->coef_bits = NULL;
000028  f8c450a0          STR      r5,[r4,#0xa0]
;;;352    }
00002c  bd70              POP      {r4-r6,pc}
;;;353    
                          ENDP

00002e  0000              DCW      0x0000
                  |L6.48|
                          DCD      consume_markers

                          AREA ||i.start_input_pass||, CODE, READONLY, ALIGN=2

                  start_input_pass PROC
;;;253    METHODDEF(void)
;;;254    start_input_pass (j_decompress_ptr cinfo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;255    {
000004  4604              MOV      r4,r0
;;;256      per_scan_setup(cinfo);
000006  f7fffffe          BL       per_scan_setup
00000a  2500              MOVS     r5,#0
;;;257      latch_quant_tables(cinfo);
00000c  e029              B        |L7.98|
00000e  bf00              NOP      
                  |L7.16|
000010  eb040085          ADD      r0,r4,r5,LSL #2
000014  f8d0714c          LDR      r7,[r0,#0x14c]
000018  6cf8              LDR      r0,[r7,#0x4c]
00001a  bb08              CBNZ     r0,|L7.96|
00001c  693e              LDR      r6,[r7,#0x10]
00001e  2e04              CMP      r6,#4
000020  d204              BCS      |L7.44|
000022  eb040086          ADD      r0,r4,r6,LSL #2
000026  f8d000a4          LDR      r0,[r0,#0xa4]
00002a  b940              CBNZ     r0,|L7.62|
                  |L7.44|
00002c  6820              LDR      r0,[r4,#0]
00002e  2134              MOVS     r1,#0x34
000030  6141              STR      r1,[r0,#0x14]
000032  6820              LDR      r0,[r4,#0]
000034  6186              STR      r6,[r0,#0x18]
000036  6820              LDR      r0,[r4,#0]
000038  6801              LDR      r1,[r0,#0]
00003a  4620              MOV      r0,r4
00003c  4788              BLX      r1
                  |L7.62|
00003e  6860              LDR      r0,[r4,#4]
000040  2284              MOVS     r2,#0x84
000042  2101              MOVS     r1,#1
000044  6803              LDR      r3,[r0,#0]
000046  4620              MOV      r0,r4
000048  4798              BLX      r3
00004a  4680              MOV      r8,r0
00004c  eb040086          ADD      r0,r4,r6,LSL #2
000050  2284              MOVS     r2,#0x84
000052  f8d010a4          LDR      r1,[r0,#0xa4]
000056  4640              MOV      r0,r8
000058  f7fffffe          BL       __aeabi_memcpy4
00005c  f8c7804c          STR      r8,[r7,#0x4c]
                  |L7.96|
000060  1c6d              ADDS     r5,r5,#1
                  |L7.98|
000062  f8d40148          LDR      r0,[r4,#0x148]
000066  42a8              CMP      r0,r5
000068  dcd2              BGT      |L7.16|
;;;258      (*cinfo->entropy->start_pass) (cinfo);
00006a  f8d401bc          LDR      r0,[r4,#0x1bc]
00006e  6801              LDR      r1,[r0,#0]
000070  4620              MOV      r0,r4
000072  4788              BLX      r1
;;;259      (*cinfo->coef->start_input_pass) (cinfo);
000074  f8d401ac          LDR      r0,[r4,#0x1ac]
000078  6801              LDR      r1,[r0,#0]
00007a  4620              MOV      r0,r4
00007c  4788              BLX      r1
;;;260      cinfo->inputctl->consume_input = cinfo->coef->consume_data;
00007e  f8d401ac          LDR      r0,[r4,#0x1ac]
000082  f8d411b4          LDR      r1,[r4,#0x1b4]
000086  6840              LDR      r0,[r0,#4]
000088  6008              STR      r0,[r1,#0]
;;;261    }
00008a  e8bd81f0          POP      {r4-r8,pc}
;;;262    
                          ENDP

