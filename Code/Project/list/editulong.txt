; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\editulong.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\editulong.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\Widget\EDITUlong.c]
                          THUMB

                          AREA ||i.EDIT_SetUlongMode||, CODE, READONLY, ALIGN=2

                  EDIT_SetUlongMode PROC
;;;223    */
;;;224    void EDIT_SetUlongMode(EDIT_Handle hEdit, U32 Value, U32 Min, U32 Max) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  461d              MOV      r5,r3
000006  4616              MOV      r6,r2
000008  460c              MOV      r4,r1
00000a  0007              MOVS     r7,r0
00000c  d01c              BEQ      |L1.72|
;;;225      EDIT_Obj* pObj;
;;;226      WM_LOCK();
;;;227      if (hEdit) {
;;;228        pObj = EDIT_H2P(hEdit);
00000e  f7fffffe          BL       GUI_ALLOC_h2p
;;;229        if (Value > Max) {
000012  42ac              CMP      r4,r5
000014  d901              BLS      |L1.26|
;;;230          Value = Max;
000016  462c              MOV      r4,r5
000018  e002              B        |L1.32|
                  |L1.26|
;;;231        } else if (Value < Min) {
00001a  42b4              CMP      r4,r6
00001c  d200              BCS      |L1.32|
;;;232          Value = Min;
00001e  4634              MOV      r4,r6
                  |L1.32|
;;;233        }
;;;234        pObj->pfAddKeyEx    = _AddKey;
000020  490a              LDR      r1,|L1.76|
;;;235        pObj->pfUpdateBuffer= _UpdateBuffer;
000022  64c1              STR      r1,[r0,#0x4c]
000024  490a              LDR      r1,|L1.80|
;;;236        pObj->CurrentValue  = Value;
;;;237        pObj->CursorPos     = 0;
000026  6501              STR      r1,[r0,#0x50]
000028  2100              MOVS     r1,#0
00002a  e9c0410f          STRD     r4,r1,[r0,#0x3c]
;;;238        pObj->Min           = Min;
;;;239        pObj->Max           = Max;
;;;240        pObj->EditMode      = GUI_EDIT_MODE_OVERWRITE;
00002e  e9c0650c          STRD     r6,r5,[r0,#0x30]
000032  2101              MOVS     r1,#1
000034  f8801048          STRB     r1,[r0,#0x48]
;;;241        _UpdateBuffer(hEdit);
000038  4638              MOV      r0,r7
00003a  f7fffffe          BL       _UpdateBuffer
;;;242        WM_Invalidate(hEdit);
00003e  4638              MOV      r0,r7
000040  e8bd41f0          POP      {r4-r8,lr}
000044  f7ffbffe          B.W      WM_InvalidateWindow
                  |L1.72|
;;;243      }
;;;244      WM_UNLOCK();
;;;245    }
000048  e8bd81f0          POP      {r4-r8,pc}
;;;246    
                          ENDP

                  |L1.76|
                          DCD      _AddKey
                  |L1.80|
                          DCD      _UpdateBuffer

                          AREA ||i._AddKey||, CODE, READONLY, ALIGN=1

                  _AddKey PROC
;;;182    */
;;;183    static void _AddKey(EDIT_Handle hObj, int Key) {
000000  b570              PUSH     {r4-r6,lr}
000002  460d              MOV      r5,r1
000004  4606              MOV      r6,r0
;;;184      EDIT_Obj * pObj;
;;;185      pObj = EDIT_H2P(hObj); /* The GUI needs not to be locked here. This function is called only from EDIT_AddKey which has already locked the GUI */
000006  f7fffffe          BL       GUI_ALLOC_h2p
00000a  0004              MOVS     r4,r0
;;;186      if (pObj) {
00000c  d020              BEQ      |L2.80|
;;;187        switch (Key) {
00000e  2d10              CMP      r5,#0x10
000010  d01a              BEQ      |L2.72|
000012  2d11              CMP      r5,#0x11
000014  d010              BEQ      |L2.56|
000016  2d12              CMP      r5,#0x12
000018  d00b              BEQ      |L2.50|
00001a  2d13              CMP      r5,#0x13
00001c  d00e              BEQ      |L2.60|
;;;188        case GUI_KEY_UP:
;;;189          _AddPosition(pObj, hObj, 1);
;;;190          break;
;;;191        case GUI_KEY_DOWN:
;;;192          _AddPosition(pObj, hObj, -1);
;;;193          break;
;;;194        case GUI_KEY_RIGHT:
;;;195          _IncrementCursor(pObj);
;;;196          break;
;;;197        case GUI_KEY_LEFT:
;;;198          EDIT__SetCursorPos(pObj, pObj->CursorPos - 1);
;;;199          break;
;;;200        default:
;;;201          {
;;;202            int Digit = _DecChar2Int(Key);
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       _DecChar2Int
;;;203            if (Digit >= 0) {
000024  2800              CMP      r0,#0
000026  db13              BLT      |L2.80|
;;;204              _EditULong(Digit, pObj, hObj);
000028  4632              MOV      r2,r6
00002a  4621              MOV      r1,r4
00002c  f7fffffe          BL       _EditULong
;;;205              _IncrementCursor(pObj);
000030  4620              MOV      r0,r4
                  |L2.50|
000032  f7fffffe          BL       _IncrementCursor
000036  e00b              B        |L2.80|
                  |L2.56|
000038  2201              MOVS     r2,#1                 ;189
00003a  e001              B        |L2.64|
                  |L2.60|
00003c  f04f32ff          MOV      r2,#0xffffffff        ;192
                  |L2.64|
000040  4631              MOV      r1,r6                 ;192
000042  f7fffffe          BL       _AddPosition
000046  e003              B        |L2.80|
                  |L2.72|
000048  6c21              LDR      r1,[r4,#0x40]         ;198
00004a  1e49              SUBS     r1,r1,#1              ;198
00004c  f7fffffe          BL       EDIT__SetCursorPos
                  |L2.80|
;;;206            }
;;;207          }
;;;208          break;
;;;209        }
;;;210      }
;;;211      _UpdateBuffer(hObj);
000050  4630              MOV      r0,r6
000052  e8bd4070          POP      {r4-r6,lr}
000056  f7ffbffe          B.W      _UpdateBuffer
;;;212    }
;;;213    
                          ENDP


                          AREA ||i._AddPosition||, CODE, READONLY, ALIGN=2

                  _AddPosition PROC
;;;149    */
;;;150    static void _AddPosition(EDIT_Obj* pObj, EDIT_Handle hObj, int Sign) {
000000  b430              PUSH     {r4,r5}
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;151      int Pos;
;;;152      I32 v, NewValue;
;;;153      v = Sign;
;;;154      Pos = pObj->MaxLen - pObj->CursorPos-1;
000006  f9b0002a          LDRSH    r0,[r0,#0x2a]
00000a  6c19              LDR      r1,[r3,#0x40]
00000c  1a40              SUBS     r0,r0,r1
;;;155      if (pObj->NumDecs && (Pos > pObj->NumDecs)) {
00000e  f8931038          LDRB     r1,[r3,#0x38]
000012  1e40              SUBS     r0,r0,#1
000014  b139              CBZ      r1,|L3.38|
000016  4281              CMP      r1,r0
000018  da05              BGE      |L3.38|
00001a  1e40              SUBS     r0,r0,#1
;;;156        Pos--;
00001c  e003              B        |L3.38|
;;;157      }
;;;158      while (Pos--) {
;;;159        v *= 10;
00001e  bf00              NOP      
                  |L3.32|
000020  eb020182          ADD      r1,r2,r2,LSL #2
000024  004a              LSLS     r2,r1,#1
                  |L3.38|
000026  1e40              SUBS     r0,r0,#1
000028  d2fa              BCS      |L3.32|
;;;160      }
;;;161      NewValue = pObj->CurrentValue + v;
00002a  6bd8              LDR      r0,[r3,#0x3c]
00002c  1881              ADDS     r1,r0,r2
;;;162      /*
;;;163       * Check if overflow occurs
;;;164       */
;;;165      if (v > 0) {
00002e  2a00              CMP      r2,#0
000030  dd03              BLE      |L3.58|
;;;166        /* If result of addition is less than previous value he have an overflow */
;;;167        if (((U32)pObj->CurrentValue + v) < (U32)pObj->CurrentValue) {
000032  4281              CMP      r1,r0
000034  d205              BCS      |L3.66|
;;;168          NewValue = pObj->Max; /* Set maximum value */
000036  6b59              LDR      r1,[r3,#0x34]
000038  e003              B        |L3.66|
                  |L3.58|
;;;169        }
;;;170      } else if (v < 0) {
00003a  da02              BGE      |L3.66|
;;;171        /* If result of addition is more than previous value he have an overflow */
;;;172        if (((U32)pObj->CurrentValue + v) > (U32)pObj->CurrentValue) {
00003c  4281              CMP      r1,r0
00003e  d900              BLS      |L3.66|
;;;173          NewValue = pObj->Min; /* Set minimum value */
000040  6b19              LDR      r1,[r3,#0x30]
                  |L3.66|
;;;174        }
;;;175      }
;;;176      EDIT__SetValueUnsigned(hObj, NewValue);
000042  4620              MOV      r0,r4
000044  bc30              POP      {r4,r5}
000046  f7ffbffe          B.W      EDIT__SetValueUnsigned
;;;177    }
;;;178    
                          ENDP


                          AREA ||i._DecChar2Int||, CODE, READONLY, ALIGN=1

                  _DecChar2Int PROC
;;;44     */
;;;45     static int _DecChar2Int(int Char) {
000000  3830              SUBS     r0,r0,#0x30
;;;46       if ((Char >= '0') && (Char <= '9')) {
000002  2809              CMP      r0,#9
000004  d901              BLS      |L4.10|
;;;47         return Char - '0';
;;;48       }
;;;49       return -1;
000006  f04f30ff          MOV      r0,#0xffffffff
                  |L4.10|
;;;50     }
00000a  4770              BX       lr
;;;51     
                          ENDP


                          AREA ||i._EditULong||, CODE, READONLY, ALIGN=2

                  _EditULong PROC
;;;85     */
;;;86     static void _EditULong(int Digit, EDIT_Obj* pObj, EDIT_Handle hObj) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
000004  4680              MOV      r8,r0
;;;87       U32 Result = 0;
000006  2400              MOVS     r4,#0
000008  4693              MOV      r11,r2                ;86
00000a  460e              MOV      r6,r1                 ;86
;;;88       int i, j, Pos = 0;
00000c  4625              MOV      r5,r4
;;;89       char * s = (char*) GUI_ALLOC_h2p(pObj->hpText);
00000e  f9b10028          LDRSH    r0,[r1,#0x28]
000012  f7fffffe          BL       GUI_ALLOC_h2p
000016  4681              MOV      r9,r0
;;;90       for (i = 0; i < pObj->MaxLen; i++) {
000018  2700              MOVS     r7,#0
;;;91         int Index = pObj->MaxLen - i - 1;
;;;92         if (Index == pObj->CursorPos) {
;;;93           /* In this case we need to check if an overflow occures */
;;;94           char c;
;;;95           int Value;
;;;96           U32 OldResult;
;;;97           /* Calculate old value (until cursor position) */
;;;98           c         = *(s + Index);
;;;99           Value     = _DecChar2Int(c);
;;;100          OldResult = Result;
;;;101          if (Value >= 0) {
;;;102            OldResult += GUI_Pow10[Pos] * Value;
00001a  f8dfa080          LDR      r10,|L5.156|
00001e  e032              B        |L5.134|
                  |L5.32|
000020  1bc0              SUBS     r0,r0,r7              ;91
000022  6c31              LDR      r1,[r6,#0x40]         ;92
000024  1e40              SUBS     r0,r0,#1              ;92
000026  4281              CMP      r1,r0                 ;92
;;;103          }
;;;104          /* Calculate new value (until cursor position).
;;;105           * A multiplication like Result += GUI_Pow10[Pos++] * Digit
;;;106           * does not work, because in this case we have no chance to
;;;107           * notice an overflow.
;;;108           */
;;;109          for (j = 0; j < Digit; j++) {
;;;110            U32 NewResult;
;;;111            NewResult = Result + GUI_Pow10[Pos];
;;;112            /* Check if we have an overflow */
;;;113            if (NewResult < Result) {
;;;114              Result = pObj->Max;
;;;115              break;
;;;116            }
;;;117            Result = NewResult;
;;;118          }
;;;119          /* Check if we have an overflow */
;;;120          if (Digit > Value) {
;;;121            if (Result < OldResult) {
;;;122              Result = pObj->Max;
;;;123              break;
;;;124            }
;;;125          }
;;;126          Pos++;
;;;127        } else {
;;;128          /* If current index is not the cursor position */
;;;129          char c = *(s + Index);
000028  f8190000          LDRB     r0,[r9,r0]
00002c  d11c              BNE      |L5.104|
00002e  f7fffffe          BL       _DecChar2Int
000032  4621              MOV      r1,r4                 ;100
000034  2800              CMP      r0,#0                 ;101
000036  db03              BLT      |L5.64|
000038  f85a2025          LDR      r2,[r10,r5,LSL #2]    ;102
00003c  fb024100          MLA      r1,r2,r0,r4           ;102
                  |L5.64|
000040  2200              MOVS     r2,#0                 ;109
000042  46d4              MOV      r12,r10               ;102
000044  e008              B        |L5.88|
000046  bf00              NOP                            ;111
                  |L5.72|
000048  f85c3025          LDR      r3,[r12,r5,LSL #2]    ;111
00004c  191b              ADDS     r3,r3,r4              ;111
00004e  d301              BCC      |L5.84|
000050  6b74              LDR      r4,[r6,#0x34]         ;115
000052  e003              B        |L5.92|
                  |L5.84|
000054  461c              MOV      r4,r3                 ;117
000056  1c52              ADDS     r2,r2,#1              ;117
                  |L5.88|
000058  4542              CMP      r2,r8                 ;109
00005a  dbf5              BLT      |L5.72|
                  |L5.92|
00005c  4580              CMP      r8,r0                 ;120
00005e  dd01              BLE      |L5.100|
000060  428c              CMP      r4,r1                 ;121
000062  d30d              BCC      |L5.128|
                  |L5.100|
000064  1c6d              ADDS     r5,r5,#1              ;121
000066  e00d              B        |L5.132|
                  |L5.104|
;;;130          int Value = _DecChar2Int(c);
000068  f7fffffe          BL       _DecChar2Int
;;;131          if (Value >= 0) {
00006c  2800              CMP      r0,#0
00006e  db09              BLT      |L5.132|
;;;132            U32 OldResult;
;;;133            OldResult = Result;
;;;134            Result += GUI_Pow10[Pos++] * Value;
000070  f85a2025          LDR      r2,[r10,r5,LSL #2]
000074  4621              MOV      r1,r4                 ;133
000076  fb021400          MLA      r4,r2,r0,r1
00007a  1c6d              ADDS     r5,r5,#1
;;;135            /* Check if we have an overflow */
;;;136            if (Result < OldResult) {
00007c  428c              CMP      r4,r1
00007e  d201              BCS      |L5.132|
                  |L5.128|
;;;137              Result = pObj->Max;
;;;138              break;
000080  6b74              LDR      r4,[r6,#0x34]
000082  e004              B        |L5.142|
                  |L5.132|
000084  1c7f              ADDS     r7,r7,#1
                  |L5.134|
000086  f9b6002a          LDRSH    r0,[r6,#0x2a]         ;90
00008a  42b8              CMP      r0,r7                 ;90
00008c  dcc8              BGT      |L5.32|
                  |L5.142|
;;;139            }
;;;140          }
;;;141        }
;;;142      }
;;;143      EDIT__SetValueUnsigned(hObj, Result);
00008e  4621              MOV      r1,r4
000090  4658              MOV      r0,r11
000092  e8bd5ff0          POP      {r4-r12,lr}
000096  f7ffbffe          B.W      EDIT__SetValueUnsigned
;;;144    }
;;;145    
                          ENDP

00009a  0000              DCW      0x0000
                  |L5.156|
                          DCD      GUI_Pow10

                          AREA ||i._IncrementCursor||, CODE, READONLY, ALIGN=1

                  _IncrementCursor PROC
;;;36     */
;;;37     static void _IncrementCursor(EDIT_Obj* pObj) {
000000  6c01              LDR      r1,[r0,#0x40]
;;;38       EDIT__SetCursorPos(pObj, pObj->CursorPos + 1);
000002  1c49              ADDS     r1,r1,#1
000004  f7ffbffe          B.W      EDIT__SetCursorPos
;;;39     }
;;;40     
                          ENDP


                          AREA ||i._UpdateBuffer||, CODE, READONLY, ALIGN=2

                  _UpdateBuffer PROC
;;;55     */
;;;56     static void _UpdateBuffer(EDIT_Handle hObj) {
000000  b5fe              PUSH     {r1-r7,lr}
;;;57       char acValue[10] = {0};
000002  2100              MOVS     r1,#0
000004  9100              STR      r1,[sp,#0]
000006  9101              STR      r1,[sp,#4]
;;;58       int NumDigits = 0;
000008  460c              MOV      r4,r1
;;;59       U32 Value;
;;;60       char * s;
;;;61       EDIT_Obj * pObj;
;;;62       pObj = EDIT_H2P(hObj); /* The GUI needs not to be locked here. This function is called only from EDIT_AddKey which has already locked the GUI */
00000a  9102              STR      r1,[sp,#8]
00000c  f7fffffe          BL       GUI_ALLOC_h2p
000010  4605              MOV      r5,r0
;;;63       s = (char*) GUI_ALLOC_h2p(pObj->hpText);
000012  f9b00028          LDRSH    r0,[r0,#0x28]
000016  f7fffffe          BL       GUI_ALLOC_h2p
00001a  4669              MOV      r1,sp                 ;57
;;;64       /* Convert an unsigned long value into text */
;;;65       Value = pObj->CurrentValue;
;;;66       /* Fill the buffer with the digits (reverse order) */
;;;67       while (Value) {
;;;68         U8 c = Value % 10;
00001c  260a              MOVS     r6,#0xa
00001e  6bea              LDR      r2,[r5,#0x3c]         ;67
000020  e009              B        |L7.54|
000022  bf00              NOP      
                  |L7.36|
000024  fbb2f3f6          UDIV     r3,r2,r6
000028  fb062313          MLS      r3,r6,r3,r2
;;;69         acValue[NumDigits++] = '0' + c;
;;;70         Value /= 10;
00002c  fbb2f2f6          UDIV     r2,r2,r6
000030  3330              ADDS     r3,r3,#0x30           ;68
000032  550b              STRB     r3,[r1,r4]            ;69
000034  1c64              ADDS     r4,r4,#1
                  |L7.54|
000036  2a00              CMP      r2,#0                 ;67
000038  d1f4              BNE      |L7.36|
;;;71       }
;;;72       /* Fill with leading spaces */
;;;73       while (NumDigits < pObj->MaxLen) {
00003a  f9b5202a          LDRSH    r2,[r5,#0x2a]
;;;74         acValue[NumDigits++] = '0';
00003e  2330              MOVS     r3,#0x30
                  |L7.64|
000040  42a2              CMP      r2,r4                 ;73
000042  dd06              BLE      |L7.82|
000044  550b              STRB     r3,[r1,r4]
000046  1c64              ADDS     r4,r4,#1
000048  e7fa              B        |L7.64|
                  |L7.74|
00004a  1e64              SUBS     r4,r4,#1
;;;75       }
;;;76       /* Reverse order */
;;;77       while (NumDigits) {
;;;78         *(s++) = acValue[--NumDigits];
00004c  5d0a              LDRB     r2,[r1,r4]
00004e  f8002b01          STRB     r2,[r0],#1
                  |L7.82|
000052  2c00              CMP      r4,#0                 ;77
000054  d1f9              BNE      |L7.74|
;;;79       }
;;;80     }
000056  bdfe              POP      {r1-r7,pc}
;;;81     
                          ENDP

