; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\jdcoefct.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jdcoefct.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\JPEG\jdcoefct.c]
                          THUMB

                          AREA ||i.consume_data||, CODE, READONLY, ALIGN=1

                  consume_data PROC
;;;244    METHODDEF(int)
;;;245    consume_data (j_decompress_ptr cinfo)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;246    {
000004  b085              SUB      sp,sp,#0x14
000006  4604              MOV      r4,r0
;;;247      my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
;;;248      JDIMENSION MCU_col_num;	/* index of current MCU within row */
;;;249      int blkn, ci, xindex, yindex, yoffset;
;;;250      JDIMENSION start_col;
;;;251      JBLOCKARRAY buffer[MAX_COMPS_IN_SCAN];
;;;252      JBLOCKROW buffer_ptr;
;;;253      jpeg_component_info *compptr;
;;;254    
;;;255      /* Align the virtual buffers for the components used in this scan. */
;;;256      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
000008  2600              MOVS     r6,#0
00000a  f10d0b04          ADD      r11,sp,#4             ;251
00000e  f8d051ac          LDR      r5,[r0,#0x1ac]        ;246
000012  e014              B        |L1.62|
                  |L1.20|
;;;257        compptr = cinfo->cur_comp_info[ci];
000014  eb040086          ADD      r0,r4,r6,LSL #2
;;;258        buffer[ci] = (*cinfo->mem->access_virt_barray)
000018  2101              MOVS     r1,#1
00001a  f8d0014c          LDR      r0,[r0,#0x14c]        ;257
00001e  9100              STR      r1,[sp,#0]
000020  f8d42094          LDR      r2,[r4,#0x94]
000024  68c3              LDR      r3,[r0,#0xc]
000026  6840              LDR      r0,[r0,#4]
000028  435a              MULS     r2,r3,r2
00002a  eb050080          ADD      r0,r5,r0,LSL #2
00002e  6c81              LDR      r1,[r0,#0x48]
000030  6860              LDR      r0,[r4,#4]
000032  6a07              LDR      r7,[r0,#0x20]
000034  4620              MOV      r0,r4
000036  47b8              BLX      r7
000038  f84b0026          STR      r0,[r11,r6,LSL #2]
00003c  1c76              ADDS     r6,r6,#1
                  |L1.62|
00003e  f8d40148          LDR      r0,[r4,#0x148]        ;256
000042  42b0              CMP      r0,r6                 ;256
000044  dce6              BGT      |L1.20|
;;;259          ((j_common_ptr) cinfo, coef->whole_image[compptr->component_index],
;;;260           cinfo->input_iMCU_row * compptr->v_samp_factor,
;;;261           (JDIMENSION) compptr->v_samp_factor, TRUE);
;;;262        /* Note: entropy decoder expects buffer to be zeroed,
;;;263         * but this is handled automatically by the memory manager
;;;264         * because we requested a pre-zeroed array.
;;;265         */
;;;266      }
;;;267    
;;;268      /* Loop to process one whole iMCU row */
;;;269      for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
000046  69a8              LDR      r0,[r5,#0x18]
000048  e03f              B        |L1.202|
                  |L1.74|
;;;270           yoffset++) {
;;;271        for (MCU_col_num = coef->MCU_ctr; MCU_col_num < cinfo->MCUs_per_row;
00004a  6968              LDR      r0,[r5,#0x14]
00004c  e034              B        |L1.184|
                  |L1.78|
;;;272    	 MCU_col_num++) {
;;;273          /* Construct list of pointers to DCT blocks belonging to this MCU */
;;;274          blkn = 0;			/* index of current DCT block within MCU */
00004e  2600              MOVS     r6,#0
;;;275          for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
000050  4630              MOV      r0,r6
000052  e023              B        |L1.156|
                  |L1.84|
;;;276    	compptr = cinfo->cur_comp_info[ci];
000054  eb040180          ADD      r1,r4,r0,LSL #2
;;;277    	start_col = MCU_col_num * compptr->MCU_width;
000058  f8d1214c          LDR      r2,[r1,#0x14c]
;;;278    	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
00005c  2100              MOVS     r1,#0
00005e  f8d28034          LDR      r8,[r2,#0x34]         ;277
000062  fb08f809          MUL      r8,r8,r9              ;277
000066  e015              B        |L1.148|
                  |L1.104|
;;;279    	  buffer_ptr = buffer[ci][yindex+yoffset] + start_col;
000068  f85b7020          LDR      r7,[r11,r0,LSL #2]
00006c  eb01030a          ADD      r3,r1,r10
000070  f8573023          LDR      r3,[r7,r3,LSL #2]
000074  eb0317c8          ADD      r7,r3,r8,LSL #7
;;;280    	  for (xindex = 0; xindex < compptr->MCU_width; xindex++) {
000078  2300              MOVS     r3,#0
00007a  e006              B        |L1.138|
                  |L1.124|
;;;281    	    coef->MCU_buffer[blkn++] = buffer_ptr++;
00007c  eb050c86          ADD      r12,r5,r6,LSL #2
000080  1c5b              ADDS     r3,r3,#1
000082  1c76              ADDS     r6,r6,#1
000084  f8cc7020          STR      r7,[r12,#0x20]
000088  3780              ADDS     r7,r7,#0x80
                  |L1.138|
00008a  f8d2c034          LDR      r12,[r2,#0x34]        ;280
00008e  459c              CMP      r12,r3                ;280
000090  dcf4              BGT      |L1.124|
000092  1c49              ADDS     r1,r1,#1              ;280
                  |L1.148|
000094  6b93              LDR      r3,[r2,#0x38]         ;278
000096  428b              CMP      r3,r1                 ;278
000098  dce6              BGT      |L1.104|
00009a  1c40              ADDS     r0,r0,#1              ;278
                  |L1.156|
00009c  f8d41148          LDR      r1,[r4,#0x148]        ;275
0000a0  4281              CMP      r1,r0                 ;275
0000a2  dcd7              BGT      |L1.84|
;;;282    	  }
;;;283    	}
;;;284          }
;;;285          /* Try to fetch the MCU. */
;;;286          if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
0000a4  f8d401bc          LDR      r0,[r4,#0x1bc]
0000a8  f1050120          ADD      r1,r5,#0x20
0000ac  6842              LDR      r2,[r0,#4]
0000ae  4620              MOV      r0,r4
0000b0  4790              BLX      r2
0000b2  b1f0              CBZ      r0,|L1.242|
0000b4  f1090001          ADD      r0,r9,#1              ;272
                  |L1.184|
0000b8  f8d4115c          LDR      r1,[r4,#0x15c]        ;271
0000bc  4681              MOV      r9,r0                 ;271
0000be  4549              CMP      r1,r9                 ;271
0000c0  d8c5              BHI      |L1.78|
;;;287    	/* Suspension forced; update state counters and exit */
;;;288    	coef->MCU_vert_offset = yoffset;
;;;289    	coef->MCU_ctr = MCU_col_num;
;;;290    	return JPEG_SUSPENDED;
;;;291          }
;;;292        }
;;;293        /* Completed an MCU row, but perhaps not an iMCU row */
;;;294        coef->MCU_ctr = 0;
0000c2  2000              MOVS     r0,#0
0000c4  6168              STR      r0,[r5,#0x14]         ;270
0000c6  f10a0001          ADD      r0,r10,#1             ;270
                  |L1.202|
0000ca  69e9              LDR      r1,[r5,#0x1c]         ;269
0000cc  4682              MOV      r10,r0                ;269
0000ce  4551              CMP      r1,r10                ;269
0000d0  dcbb              BGT      |L1.74|
;;;295      }
;;;296      /* Completed the iMCU row, advance counters for next one */
;;;297      if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
0000d2  f8d40094          LDR      r0,[r4,#0x94]
0000d6  1c40              ADDS     r0,r0,#1
0000d8  f8c40094          STR      r0,[r4,#0x94]
0000dc  f8d41140          LDR      r1,[r4,#0x140]
0000e0  4288              CMP      r0,r1
0000e2  d20a              BCS      |L1.250|
;;;298        start_iMCU_row(cinfo);
0000e4  4620              MOV      r0,r4
0000e6  f7fffffe          BL       start_iMCU_row
;;;299        return JPEG_ROW_COMPLETED;
0000ea  2003              MOVS     r0,#3
                  |L1.236|
;;;300      }
;;;301      /* Completed the scan */
;;;302      (*cinfo->inputctl->finish_input_pass) (cinfo);
;;;303      return JPEG_SCAN_COMPLETED;
;;;304    }
0000ec  b005              ADD      sp,sp,#0x14
0000ee  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.242|
0000f2  e9c59a05          STRD     r9,r10,[r5,#0x14]
0000f6  2000              MOVS     r0,#0                 ;290
0000f8  e7f8              B        |L1.236|
                  |L1.250|
0000fa  f8d401b4          LDR      r0,[r4,#0x1b4]        ;302
0000fe  68c1              LDR      r1,[r0,#0xc]          ;302
000100  4620              MOV      r0,r4                 ;302
000102  4788              BLX      r1                    ;302
000104  2004              MOVS     r0,#4                 ;303
000106  e7f1              B        |L1.236|
;;;305    
                          ENDP


                          AREA ||i.decompress_data||, CODE, READONLY, ALIGN=1

                  decompress_data PROC
;;;315    METHODDEF(int)
;;;316    decompress_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;317    {
000004  b087              SUB      sp,sp,#0x1c
000006  4604              MOV      r4,r0
;;;318      my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
000008  f8d001ac          LDR      r0,[r0,#0x1ac]
;;;319      JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
00000c  9002              STR      r0,[sp,#8]
00000e  f8d40140          LDR      r0,[r4,#0x140]
000012  1e40              SUBS     r0,r0,#1
000014  9001              STR      r0,[sp,#4]            ;317
000016  e006              B        |L2.38|
                  |L2.24|
;;;320      JDIMENSION block_num;
;;;321      int ci, block_row, block_rows;
;;;322      JBLOCKARRAY buffer;
;;;323      JBLOCKROW buffer_ptr;
;;;324      JSAMPARRAY output_ptr;
;;;325      JDIMENSION output_col;
;;;326      jpeg_component_info *compptr;
;;;327      inverse_DCT_method_ptr inverse_DCT;
;;;328    
;;;329      /* Force some input to be done if we are getting ahead of the input. */
;;;330      while (cinfo->input_scan_number < cinfo->output_scan_number ||
;;;331    	 (cinfo->input_scan_number == cinfo->output_scan_number &&
;;;332    	  cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {
;;;333        if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
000018  f8d401b4          LDR      r0,[r4,#0x1b4]
00001c  6801              LDR      r1,[r0,#0]
00001e  4620              MOV      r0,r4
000020  4788              BLX      r1
000022  2800              CMP      r0,#0
000024  d06f              BEQ      |L2.262|
                  |L2.38|
000026  f8d41098          LDR      r1,[r4,#0x98]         ;330
00002a  f8d40090          LDR      r0,[r4,#0x90]         ;330
00002e  4288              CMP      r0,r1                 ;330
000030  dbf2              BLT      |L2.24|
000032  d105              BNE      |L2.64|
000034  f8d4109c          LDR      r1,[r4,#0x9c]         ;332
000038  f8d40094          LDR      r0,[r4,#0x94]         ;332
00003c  4288              CMP      r0,r1                 ;332
00003e  d9eb              BLS      |L2.24|
                  |L2.64|
;;;334          return JPEG_SUSPENDED;
;;;335      }
;;;336    
;;;337      /* OK, output from the virtual arrays. */
;;;338      for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
000040  f04f0900          MOV      r9,#0
000044  f8d450d8          LDR      r5,[r4,#0xd8]
000048  e051              B        |L2.238|
                  |L2.74|
;;;339           ci++, compptr++) {
;;;340        /* Don't bother to IDCT an uninteresting component. */
;;;341        if (! compptr->component_needed)
00004a  6b28              LDR      r0,[r5,#0x30]
00004c  b390              CBZ      r0,|L2.180|
;;;342          continue;
;;;343        /* Align the virtual buffer for this component. */
;;;344        buffer = (*cinfo->mem->access_virt_barray)
00004e  2000              MOVS     r0,#0
000050  9000              STR      r0,[sp,#0]
000052  9802              LDR      r0,[sp,#8]
000054  f8d4209c          LDR      r2,[r4,#0x9c]
000058  eb000089          ADD      r0,r0,r9,LSL #2
00005c  68eb              LDR      r3,[r5,#0xc]
00005e  6c81              LDR      r1,[r0,#0x48]
000060  6860              LDR      r0,[r4,#4]
000062  435a              MULS     r2,r3,r2
000064  6a06              LDR      r6,[r0,#0x20]
000066  4620              MOV      r0,r4
000068  47b0              BLX      r6
;;;345          ((j_common_ptr) cinfo, coef->whole_image[ci],
;;;346           cinfo->output_iMCU_row * compptr->v_samp_factor,
;;;347           (JDIMENSION) compptr->v_samp_factor, FALSE);
;;;348        /* Count non-dummy DCT block rows in this iMCU row. */
;;;349        if (cinfo->output_iMCU_row < last_iMCU_row)
00006a  9005              STR      r0,[sp,#0x14]
00006c  f8d4109c          LDR      r1,[r4,#0x9c]
000070  9801              LDR      r0,[sp,#4]
000072  4281              CMP      r1,r0
000074  d201              BCS      |L2.122|
;;;350          block_rows = compptr->v_samp_factor;
000076  68e8              LDR      r0,[r5,#0xc]
000078  e008              B        |L2.140|
                  |L2.122|
;;;351        else {
;;;352          /* NB: can't use last_row_height here; it is input-side-dependent! */
;;;353          block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
00007a  6a29              LDR      r1,[r5,#0x20]
00007c  68e8              LDR      r0,[r5,#0xc]
00007e  fbb1f2f0          UDIV     r2,r1,r0
000082  fb001112          MLS      r1,r0,r2,r1
000086  ea5f0b01          MOVS     r11,r1
;;;354          if (block_rows == 0) block_rows = compptr->v_samp_factor;
00008a  d100              BNE      |L2.142|
                  |L2.140|
00008c  4683              MOV      r11,r0
                  |L2.142|
;;;355        }
;;;356        inverse_DCT = cinfo->idct->inverse_DCT[ci];
00008e  2204              MOVS     r2,#4
000090  f8d411c0          LDR      r1,[r4,#0x1c0]
000094  eb020089          ADD      r0,r2,r9,LSL #2
000098  5808              LDR      r0,[r1,r0]
;;;357        output_ptr = output_buf[ci];
00009a  9004              STR      r0,[sp,#0x10]
00009c  9808              LDR      r0,[sp,#0x20]
00009e  f8500029          LDR      r0,[r0,r9,LSL #2]
;;;358        /* Loop over all DCT blocks to be processed. */
;;;359        for (block_row = 0; block_row < block_rows; block_row++) {
0000a2  9003              STR      r0,[sp,#0xc]
0000a4  2000              MOVS     r0,#0
0000a6  e01c              B        |L2.226|
                  |L2.168|
;;;360          buffer_ptr = buffer[block_row];
0000a8  9805              LDR      r0,[sp,#0x14]
;;;361          output_col = 0;
0000aa  2700              MOVS     r7,#0
;;;362          for (block_num = 0; block_num < compptr->width_in_blocks; block_num++) {
0000ac  463e              MOV      r6,r7
0000ae  f850a028          LDR      r10,[r0,r8,LSL #2]    ;360
0000b2  e00c              B        |L2.206|
                  |L2.180|
0000b4  e018              B        |L2.232|
                  |L2.182|
;;;363    	(*inverse_DCT) (cinfo, compptr, (JCOEFPTR) buffer_ptr,
0000b6  9700              STR      r7,[sp,#0]
0000b8  e9dd3c03          LDRD     r3,r12,[sp,#0xc]
0000bc  4652              MOV      r2,r10
0000be  4629              MOV      r1,r5
0000c0  4620              MOV      r0,r4
0000c2  47e0              BLX      r12
;;;364    			output_ptr, output_col);
;;;365    	buffer_ptr++;
;;;366    	output_col += compptr->DCT_scaled_size;
0000c4  6a68              LDR      r0,[r5,#0x24]
0000c6  f10a0a80          ADD      r10,r10,#0x80         ;365
0000ca  4407              ADD      r7,r7,r0
0000cc  1c76              ADDS     r6,r6,#1
                  |L2.206|
0000ce  69e8              LDR      r0,[r5,#0x1c]         ;362
0000d0  42b0              CMP      r0,r6                 ;362
0000d2  d8f0              BHI      |L2.182|
;;;367          }
;;;368          output_ptr += compptr->DCT_scaled_size;
0000d4  6a69              LDR      r1,[r5,#0x24]
0000d6  9803              LDR      r0,[sp,#0xc]
0000d8  eb000081          ADD      r0,r0,r1,LSL #2
0000dc  9003              STR      r0,[sp,#0xc]          ;359
0000de  f1080001          ADD      r0,r8,#1              ;359
                  |L2.226|
0000e2  4680              MOV      r8,r0                 ;359
0000e4  4558              CMP      r0,r11                ;359
0000e6  dbdf              BLT      |L2.168|
                  |L2.232|
0000e8  f1090901          ADD      r9,r9,#1              ;339
0000ec  3554              ADDS     r5,r5,#0x54           ;339
                  |L2.238|
0000ee  6a61              LDR      r1,[r4,#0x24]         ;338
0000f0  4549              CMP      r1,r9                 ;338
0000f2  dcaa              BGT      |L2.74|
;;;369        }
;;;370      }
;;;371    
;;;372      if (++(cinfo->output_iMCU_row) < cinfo->total_iMCU_rows)
0000f4  f8540f9c          LDR      r0,[r4,#0x9c]!
0000f8  1c40              ADDS     r0,r0,#1
0000fa  6020              STR      r0,[r4,#0]
0000fc  f8d410a4          LDR      r1,[r4,#0xa4]
000100  4288              CMP      r0,r1
000102  d203              BCS      |L2.268|
;;;373        return JPEG_ROW_COMPLETED;
000104  2003              MOVS     r0,#3
                  |L2.262|
;;;374      return JPEG_SCAN_COMPLETED;
;;;375    }
000106  b009              ADD      sp,sp,#0x24
000108  e8bd8ff0          POP      {r4-r11,pc}
                  |L2.268|
00010c  2004              MOVS     r0,#4                 ;374
00010e  e7fa              B        |L2.262|
;;;376    
                          ENDP


                          AREA ||i.decompress_onepass||, CODE, READONLY, ALIGN=2

                  decompress_onepass PROC
;;;146    METHODDEF(int)
;;;147    decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;148    {
000004  4604              MOV      r4,r0
;;;149      my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
;;;150      JDIMENSION MCU_col_num;	/* index of current MCU within row */
;;;151      JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
000006  f8d061ac          LDR      r6,[r0,#0x1ac]
00000a  f8d0015c          LDR      r0,[r0,#0x15c]
00000e  b089              SUB      sp,sp,#0x24           ;148
000010  1e40              SUBS     r0,r0,#1
;;;152      JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
000012  9002              STR      r0,[sp,#8]
000014  f8d40140          LDR      r0,[r4,#0x140]
000018  1e40              SUBS     r0,r0,#1
;;;153      int blkn, ci, xindex, yindex, yoffset, useful_width;
;;;154      JSAMPARRAY output_ptr;
;;;155      JDIMENSION start_col, output_col;
;;;156      jpeg_component_info *compptr;
;;;157      inverse_DCT_method_ptr inverse_DCT;
;;;158    
;;;159      /* Loop to process as much as one whole iMCU row */
;;;160      for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
00001a  9008              STR      r0,[sp,#0x20]
00001c  69b0              LDR      r0,[r6,#0x18]
                  |L3.30|
00001e  9003              STR      r0,[sp,#0xc]
000020  69f1              LDR      r1,[r6,#0x1c]
000022  4281              CMP      r1,r0
000024  dd7e              BLE      |L3.292|
;;;161           yoffset++) {
;;;162        for (MCU_col_num = coef->MCU_ctr; MCU_col_num <= last_MCU_col;
000026  6970              LDR      r0,[r6,#0x14]
000028  e079              B        |L3.286|
;;;163    	 MCU_col_num++) {
;;;164          /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */
;;;165          jzero_far((void FAR *) coef->MCU_buffer[0],
00002a  bf00              NOP      
                  |L3.44|
00002c  f8d40164          LDR      r0,[r4,#0x164]
000030  01c1              LSLS     r1,r0,#7
000032  6a30              LDR      r0,[r6,#0x20]
000034  f7fffffe          BL       jzero_far
;;;166    		(size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));
;;;167          if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
000038  f8d401bc          LDR      r0,[r4,#0x1bc]
00003c  f1060120          ADD      r1,r6,#0x20
000040  6842              LDR      r2,[r0,#4]
000042  4620              MOV      r0,r4
000044  4790              BLX      r2
000046  b118              CBZ      r0,|L3.80|
;;;168    	/* Suspension forced; update state counters and exit */
;;;169    	coef->MCU_vert_offset = yoffset;
;;;170    	coef->MCU_ctr = MCU_col_num;
;;;171    	return JPEG_SUSPENDED;
;;;172          }
;;;173          /* Determine where data should go in output_buf and do the IDCT thing.
;;;174           * We skip dummy blocks at the right and bottom edges (but blkn gets
;;;175           * incremented past them!).  Note the inner loop relies on having
;;;176           * allocated the MCU_buffer[] blocks sequentially.
;;;177           */
;;;178          blkn = 0;			/* index of current DCT block within MCU */
000048  f04f0b00          MOV      r11,#0
;;;179          for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
00004c  4658              MOV      r0,r11
00004e  e05f              B        |L3.272|
                  |L3.80|
000050  9803              LDR      r0,[sp,#0xc]          ;169
000052  61b0              STR      r0,[r6,#0x18]         ;170
000054  9801              LDR      r0,[sp,#4]            ;170
000056  6170              STR      r0,[r6,#0x14]         ;171
000058  2000              MOVS     r0,#0                 ;171
                  |L3.90|
;;;180    	compptr = cinfo->cur_comp_info[ci];
;;;181    	/* Don't bother to IDCT an uninteresting component. */
;;;182    	if (! compptr->component_needed) {
;;;183    	  blkn += compptr->MCU_blocks;
;;;184    	  continue;
;;;185    	}
;;;186    	inverse_DCT = cinfo->idct->inverse_DCT[compptr->component_index];
;;;187    	useful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
;;;188    						    : compptr->last_col_width;
;;;189    	output_ptr = output_buf[compptr->component_index] +
;;;190    	  yoffset * compptr->DCT_scaled_size;
;;;191    	start_col = MCU_col_num * compptr->MCU_sample_width;
;;;192    	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
;;;193    	  if (cinfo->input_iMCU_row < last_iMCU_row ||
;;;194    	      yoffset+yindex < compptr->last_row_height) {
;;;195    	    output_col = start_col;
;;;196    	    for (xindex = 0; xindex < useful_width; xindex++) {
;;;197    	      (*inverse_DCT) (cinfo, compptr,
;;;198    			      (JCOEFPTR) coef->MCU_buffer[blkn+xindex],
;;;199    			      output_ptr, output_col);
;;;200    	      output_col += compptr->DCT_scaled_size;
;;;201    	    }
;;;202    	  }
;;;203    	  blkn += compptr->MCU_width;
;;;204    	  output_ptr += compptr->DCT_scaled_size;
;;;205    	}
;;;206          }
;;;207        }
;;;208        /* Completed an MCU row, but perhaps not an iMCU row */
;;;209        coef->MCU_ctr = 0;
;;;210      }
;;;211      /* Completed the iMCU row, advance counters for next one */
;;;212      cinfo->output_iMCU_row++;
;;;213      if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
;;;214        start_iMCU_row(cinfo);
;;;215        return JPEG_ROW_COMPLETED;
;;;216      }
;;;217      /* Completed the scan */
;;;218      (*cinfo->inputctl->finish_input_pass) (cinfo);
;;;219      return JPEG_SCAN_COMPLETED;
;;;220    }
00005a  b00b              ADD      sp,sp,#0x2c
00005c  e8bd8ff0          POP      {r4-r11,pc}
                  |L3.96|
000060  eb04008a          ADD      r0,r4,r10,LSL #2      ;180
000064  f8d0514c          LDR      r5,[r0,#0x14c]        ;182
000068  6b28              LDR      r0,[r5,#0x30]         ;182
00006a  b168              CBZ      r0,|L3.136|
00006c  6868              LDR      r0,[r5,#4]            ;186
00006e  f8d411c0          LDR      r1,[r4,#0x1c0]        ;186
000072  2204              MOVS     r2,#4                 ;186
000074  eb020280          ADD      r2,r2,r0,LSL #2       ;186
000078  5889              LDR      r1,[r1,r2]            ;186
00007a  9107              STR      r1,[sp,#0x1c]         ;186
00007c  e9dd1201          LDRD     r1,r2,[sp,#4]         ;186
000080  4291              CMP      r1,r2                 ;187
000082  d204              BCS      |L3.142|
000084  6b69              LDR      r1,[r5,#0x34]         ;187
000086  e003              B        |L3.144|
                  |L3.136|
000088  6be9              LDR      r1,[r5,#0x3c]         ;183
00008a  448b              ADD      r11,r11,r1            ;183
00008c  e03e              B        |L3.268|
                  |L3.142|
00008e  6c69              LDR      r1,[r5,#0x44]         ;188
                  |L3.144|
000090  9106              STR      r1,[sp,#0x18]         ;189
000092  990a              LDR      r1,[sp,#0x28]         ;189
000094  f8512020          LDR      r2,[r1,r0,LSL #2]     ;189
000098  6a68              LDR      r0,[r5,#0x24]         ;189
00009a  9903              LDR      r1,[sp,#0xc]          ;189
00009c  4348              MULS     r0,r1,r0              ;189
00009e  eb020080          ADD      r0,r2,r0,LSL #2       ;189
0000a2  9004              STR      r0,[sp,#0x10]         ;191
0000a4  6c28              LDR      r0,[r5,#0x40]         ;191
0000a6  9901              LDR      r1,[sp,#4]            ;191
0000a8  4348              MULS     r0,r1,r0              ;191
0000aa  9005              STR      r0,[sp,#0x14]         ;192
0000ac  2000              MOVS     r0,#0                 ;192
0000ae  e029              B        |L3.260|
                  |L3.176|
0000b0  f8d41094          LDR      r1,[r4,#0x94]         ;193
0000b4  9808              LDR      r0,[sp,#0x20]         ;193
0000b6  4281              CMP      r1,r0                 ;193
0000b8  d304              BCC      |L3.196|
0000ba  9803              LDR      r0,[sp,#0xc]          ;194
0000bc  6ca9              LDR      r1,[r5,#0x48]         ;194
0000be  4448              ADD      r0,r0,r9              ;194
0000c0  4288              CMP      r0,r1                 ;194
0000c2  da16              BGE      |L3.242|
                  |L3.196|
0000c4  2700              MOVS     r7,#0                 ;196
0000c6  f8dd8014          LDR      r8,[sp,#0x14]         ;196
0000ca  e00f              B        |L3.236|
                  |L3.204|
0000cc  eb0b0007          ADD      r0,r11,r7             ;197
0000d0  eb060080          ADD      r0,r6,r0,LSL #2       ;197
0000d4  f8cd8000          STR      r8,[sp,#0]            ;197
0000d8  6a02              LDR      r2,[r0,#0x20]         ;197
0000da  f8ddc01c          LDR      r12,[sp,#0x1c]        ;197
0000de  4629              MOV      r1,r5                 ;197
0000e0  4620              MOV      r0,r4                 ;197
0000e2  9b04              LDR      r3,[sp,#0x10]         ;197
0000e4  47e0              BLX      r12                   ;197
0000e6  6a69              LDR      r1,[r5,#0x24]         ;200
0000e8  1c7f              ADDS     r7,r7,#1              ;200
0000ea  4488              ADD      r8,r8,r1              ;200
                  |L3.236|
0000ec  9806              LDR      r0,[sp,#0x18]         ;196
0000ee  4287              CMP      r7,r0                 ;196
0000f0  dbec              BLT      |L3.204|
                  |L3.242|
0000f2  6b69              LDR      r1,[r5,#0x34]         ;203
0000f4  9804              LDR      r0,[sp,#0x10]         ;204
0000f6  448b              ADD      r11,r11,r1            ;203
0000f8  6a69              LDR      r1,[r5,#0x24]         ;204
0000fa  eb000081          ADD      r0,r0,r1,LSL #2       ;204
0000fe  9004              STR      r0,[sp,#0x10]         ;192
000100  f1090001          ADD      r0,r9,#1              ;192
                  |L3.260|
000104  6ba9              LDR      r1,[r5,#0x38]         ;192
000106  4681              MOV      r9,r0                 ;192
000108  4549              CMP      r1,r9                 ;192
00010a  dcd1              BGT      |L3.176|
                  |L3.268|
00010c  f10a0001          ADD      r0,r10,#1             ;179
                  |L3.272|
000110  f8d41148          LDR      r1,[r4,#0x148]        ;179
000114  4682              MOV      r10,r0                ;179
000116  4551              CMP      r1,r10                ;179
000118  dca2              BGT      |L3.96|
00011a  9801              LDR      r0,[sp,#4]            ;163
00011c  1c40              ADDS     r0,r0,#1              ;163
                  |L3.286|
00011e  9001              STR      r0,[sp,#4]            ;162
000120  9902              LDR      r1,[sp,#8]            ;162
000122  e000              B        |L3.294|
                  |L3.292|
000124  e006              B        |L3.308|
                  |L3.294|
000126  4288              CMP      r0,r1                 ;162
000128  d980              BLS      |L3.44|
00012a  2000              MOVS     r0,#0                 ;209
00012c  6170              STR      r0,[r6,#0x14]         ;161
00012e  9803              LDR      r0,[sp,#0xc]          ;161
000130  1c40              ADDS     r0,r0,#1              ;161
000132  e774              B        |L3.30|
                  |L3.308|
000134  f8d4009c          LDR      r0,[r4,#0x9c]         ;212
000138  1c40              ADDS     r0,r0,#1              ;212
00013a  f8c4009c          STR      r0,[r4,#0x9c]         ;213
00013e  f8d40094          LDR      r0,[r4,#0x94]         ;213
000142  1c40              ADDS     r0,r0,#1              ;213
000144  f8c40094          STR      r0,[r4,#0x94]         ;213
000148  f8d41140          LDR      r1,[r4,#0x140]        ;213
00014c  4288              CMP      r0,r1                 ;213
00014e  d204              BCS      |L3.346|
000150  4620              MOV      r0,r4                 ;214
000152  f7fffffe          BL       start_iMCU_row
000156  2003              MOVS     r0,#3                 ;215
000158  e77f              B        |L3.90|
                  |L3.346|
00015a  f8d401b4          LDR      r0,[r4,#0x1b4]        ;218
00015e  68c1              LDR      r1,[r0,#0xc]          ;218
000160  4620              MOV      r0,r4                 ;218
000162  4788              BLX      r1                    ;218
000164  2004              MOVS     r0,#4                 ;219
000166  e778              B        |L3.90|
;;;221    
                          ENDP


                          AREA ||i.dummy_consume_data||, CODE, READONLY, ALIGN=1

                  dummy_consume_data PROC
;;;227    METHODDEF(int)
;;;228    dummy_consume_data (j_decompress_ptr cinfo)
000000  2000              MOVS     r0,#0
;;;229    {
;;;230      GUI_USE_PARA(cinfo);
;;;231      return JPEG_SUSPENDED;	/* Always indicate nothing was done */
;;;232    }
000002  4770              BX       lr
;;;233    
                          ENDP


                          AREA ||i.jinit_d_coef_controller||, CODE, READONLY, ALIGN=2

                  jinit_d_coef_controller PROC
;;;676    GLOBAL(void)
;;;677    jinit_d_coef_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
000000  e92d47fc          PUSH     {r2-r10,lr}
;;;678    {
000004  4606              MOV      r6,r0
;;;679      my_coef_ptr coef;
;;;680    
;;;681      coef = (my_coef_ptr)
000006  6840              LDR      r0,[r0,#4]
000008  460d              MOV      r5,r1                 ;678
00000a  2258              MOVS     r2,#0x58
00000c  6803              LDR      r3,[r0,#0]
00000e  2101              MOVS     r1,#1
000010  4630              MOV      r0,r6
000012  4798              BLX      r3
;;;682        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;683    				SIZEOF(my_coef_controller));
;;;684      cinfo->coef = (struct jpeg_d_coef_controller *) coef;
;;;685      coef->pub.start_input_pass = start_input_pass;
000014  4923              LDR      r1,|L5.164|
000016  f8c601ac          STR      r0,[r6,#0x1ac]
;;;686      coef->pub.start_output_pass = start_output_pass;
00001a  6001              STR      r1,[r0,#0]
00001c  4922              LDR      r1,|L5.168|
00001e  4604              MOV      r4,r0                 ;681
;;;687    #ifdef BLOCK_SMOOTHING_SUPPORTED
;;;688      coef->coef_bits_latch = NULL;
;;;689    #endif
;;;690    
;;;691      /* Create the coefficient buffer. */
;;;692      if (need_full_buffer) {
000020  6081              STR      r1,[r0,#8]
000022  b335              CBZ      r5,|L5.114|
;;;693    #ifdef D_MULTISCAN_FILES_SUPPORTED
;;;694        /* Allocate a full-image virtual array for each component, */
;;;695        /* padded to a multiple of samp_factor DCT blocks in each direction. */
;;;696        /* Note we ask for a pre-zeroed array. */
;;;697        int ci, access_rows;
;;;698        jpeg_component_info *compptr;
;;;699    
;;;700        for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
000024  2700              MOVS     r7,#0
000026  f8d650d8          LDR      r5,[r6,#0xd8]
00002a  e018              B        |L5.94|
                  |L5.44|
;;;701    	 ci++, compptr++) {
;;;702          access_rows = compptr->v_samp_factor;
00002c  68e9              LDR      r1,[r5,#0xc]
;;;703    #ifdef BLOCK_SMOOTHING_SUPPORTED
;;;704          /* If block smoothing could be used, need a bigger window */
;;;705          if (cinfo->progressive_mode)
;;;706    	access_rows *= 3;
;;;707    #endif
;;;708          coef->whole_image[ci] = (*cinfo->mem->request_virt_barray)
00002e  6a28              LDR      r0,[r5,#0x20]
000030  4689              MOV      r9,r1                 ;702
000032  f7fffffe          BL       jround_up
000036  4680              MOV      r8,r0
000038  68a9              LDR      r1,[r5,#8]
00003a  69e8              LDR      r0,[r5,#0x1c]
00003c  f7fffffe          BL       jround_up
000040  4603              MOV      r3,r0
000042  e9cd8900          STRD     r8,r9,[sp,#0]
000046  6870              LDR      r0,[r6,#4]
000048  2201              MOVS     r2,#1
00004a  4611              MOV      r1,r2
00004c  f8d0c014          LDR      r12,[r0,#0x14]
000050  4630              MOV      r0,r6
000052  47e0              BLX      r12
000054  eb040187          ADD      r1,r4,r7,LSL #2
000058  3554              ADDS     r5,r5,#0x54
00005a  1c7f              ADDS     r7,r7,#1
00005c  6488              STR      r0,[r1,#0x48]
                  |L5.94|
00005e  6a70              LDR      r0,[r6,#0x24]         ;700
000060  42b8              CMP      r0,r7                 ;700
000062  dce3              BGT      |L5.44|
;;;709    	((j_common_ptr) cinfo, JPOOL_IMAGE, TRUE,
;;;710    	 (JDIMENSION) jround_up((long) compptr->width_in_blocks,
;;;711    				(long) compptr->h_samp_factor),
;;;712    	 (JDIMENSION) jround_up((long) compptr->height_in_blocks,
;;;713    				(long) compptr->v_samp_factor),
;;;714    	 (JDIMENSION) access_rows);
;;;715        }
;;;716        coef->pub.consume_data = consume_data;
000064  4811              LDR      r0,|L5.172|
;;;717        coef->pub.decompress_data = decompress_data;
000066  6060              STR      r0,[r4,#4]
000068  4811              LDR      r0,|L5.176|
;;;718        coef->pub.coef_arrays = coef->whole_image; /* link to virtual arrays */
00006a  60e0              STR      r0,[r4,#0xc]
00006c  f1040048          ADD      r0,r4,#0x48
;;;719    #else
;;;720        ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;721    #endif
;;;722      } else {
000070  e015              B        |L5.158|
                  |L5.114|
;;;723        /* We only need a single-MCU buffer. */
;;;724        JBLOCKROW buffer;
;;;725        int i;
;;;726    
;;;727        buffer = (JBLOCKROW)
000072  6870              LDR      r0,[r6,#4]
000074  f44f62a0          MOV      r2,#0x500
000078  2101              MOVS     r1,#1
00007a  6843              LDR      r3,[r0,#4]
00007c  4630              MOV      r0,r6
00007e  4798              BLX      r3
000080  4601              MOV      r1,r0
;;;728          (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;729    				  D_MAX_BLOCKS_IN_MCU * SIZEOF(JBLOCK));
;;;730        for (i = 0; i < D_MAX_BLOCKS_IN_MCU; i++) {
000082  2000              MOVS     r0,#0
                  |L5.132|
;;;731          coef->MCU_buffer[i] = buffer + i;
000084  eb0112c0          ADD      r2,r1,r0,LSL #7
000088  eb040380          ADD      r3,r4,r0,LSL #2
00008c  1c40              ADDS     r0,r0,#1
00008e  621a              STR      r2,[r3,#0x20]         ;730
000090  280a              CMP      r0,#0xa               ;730
000092  dbf7              BLT      |L5.132|
;;;732        }
;;;733        coef->pub.consume_data = dummy_consume_data;
000094  4807              LDR      r0,|L5.180|
;;;734        coef->pub.decompress_data = decompress_onepass;
000096  6060              STR      r0,[r4,#4]
000098  4807              LDR      r0,|L5.184|
;;;735        coef->pub.coef_arrays = NULL; /* flag for no virtual arrays */
00009a  60e0              STR      r0,[r4,#0xc]
00009c  2000              MOVS     r0,#0
                  |L5.158|
00009e  6120              STR      r0,[r4,#0x10]         ;718
;;;736      }
;;;737    }
0000a0  e8bd87fc          POP      {r2-r10,pc}
                          ENDP

                  |L5.164|
                          DCD      start_input_pass
                  |L5.168|
                          DCD      start_output_pass
                  |L5.172|
                          DCD      consume_data
                  |L5.176|
                          DCD      decompress_data
                  |L5.180|
                          DCD      dummy_consume_data
                  |L5.184|
                          DCD      decompress_onepass

                          AREA ||i.start_iMCU_row||, CODE, READONLY, ALIGN=1

                  start_iMCU_row PROC
;;;78     LOCAL(void)
;;;79     start_iMCU_row (j_decompress_ptr cinfo)
000000  f8d02148          LDR      r2,[r0,#0x148]
;;;80     /* Reset within-iMCU-row counters for a new row (input side) */
;;;81     {
;;;82       my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
;;;83     
;;;84       /* In an interleaved scan, an MCU row is the same as an iMCU row.
;;;85        * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
;;;86        * But at the bottom of the image, process only what's left.
;;;87        */
;;;88       if (cinfo->comps_in_scan > 1) {
000004  f8d011ac          LDR      r1,[r0,#0x1ac]
000008  2a01              CMP      r2,#1
00000a  dd01              BLE      |L6.16|
;;;89         coef->MCU_rows_per_iMCU_row = 1;
00000c  2001              MOVS     r0,#1
00000e  e00b              B        |L6.40|
                  |L6.16|
;;;90       } else {
;;;91         if (cinfo->input_iMCU_row < (cinfo->total_iMCU_rows-1))
000010  f8d02140          LDR      r2,[r0,#0x140]
000014  f8d03094          LDR      r3,[r0,#0x94]
000018  1e52              SUBS     r2,r2,#1
;;;92           coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->v_samp_factor;
;;;93         else
;;;94           coef->MCU_rows_per_iMCU_row = cinfo->cur_comp_info[0]->last_row_height;
00001a  f8d0014c          LDR      r0,[r0,#0x14c]
00001e  4293              CMP      r3,r2                 ;91
000020  d201              BCS      |L6.38|
000022  68c0              LDR      r0,[r0,#0xc]          ;92
000024  e000              B        |L6.40|
                  |L6.38|
000026  6c80              LDR      r0,[r0,#0x48]
                  |L6.40|
;;;95       }
;;;96     
;;;97       coef->MCU_ctr = 0;
000028  61c8              STR      r0,[r1,#0x1c]
00002a  2000              MOVS     r0,#0
;;;98       coef->MCU_vert_offset = 0;
00002c  6148              STR      r0,[r1,#0x14]
00002e  6188              STR      r0,[r1,#0x18]
;;;99     }
000030  4770              BX       lr
;;;100    
                          ENDP


                          AREA ||i.start_input_pass||, CODE, READONLY, ALIGN=1

                  start_input_pass PROC
;;;106    METHODDEF(void)
;;;107    start_input_pass (j_decompress_ptr cinfo)
000000  2100              MOVS     r1,#0
;;;108    {
;;;109      cinfo->input_iMCU_row = 0;
;;;110      start_iMCU_row(cinfo);
000002  f8c01094          STR      r1,[r0,#0x94]
000006  f7ffbffe          B.W      start_iMCU_row
;;;111    }
;;;112    
                          ENDP


                          AREA ||i.start_output_pass||, CODE, READONLY, ALIGN=1

                  start_output_pass PROC
;;;118    METHODDEF(void)
;;;119    start_output_pass (j_decompress_ptr cinfo)
000000  2100              MOVS     r1,#0
;;;120    {
;;;121    #ifdef BLOCK_SMOOTHING_SUPPORTED
;;;122      my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
;;;123    
;;;124      /* If multipass, check to see whether to use block smoothing on this pass */
;;;125      if (coef->pub.coef_arrays != NULL) {
;;;126        if (cinfo->do_block_smoothing && smoothing_ok(cinfo))
;;;127          coef->pub.decompress_data = decompress_smooth_data;
;;;128        else
;;;129          coef->pub.decompress_data = decompress_data;
;;;130      }
;;;131    #endif
;;;132      cinfo->output_iMCU_row = 0;
000002  f8c0109c          STR      r1,[r0,#0x9c]
;;;133    }
000006  4770              BX       lr
;;;134    
                          ENDP

