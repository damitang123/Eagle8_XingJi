; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\gui_uc_encodeutf8.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\gui_uc_encodeutf8.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\Core\GUI_UC_EncodeUTF8.c]
                          THUMB

                          AREA ||i.GUI_UC_SetEncodeUTF8||, CODE, READONLY, ALIGN=2

                  GUI_UC_SetEncodeUTF8 PROC
;;;146    */
;;;147    void GUI_UC_SetEncodeUTF8(void) {
000000  4902              LDR      r1,|L1.12|
;;;148      #if GUI_SUPPORT_UNICODE
;;;149        GUI_LOCK();
;;;150        GUI_Context.pUC_API = &_API_Table;
000002  4801              LDR      r0,|L1.8|
000004  6208              STR      r0,[r1,#0x20]  ; GUI_Context
;;;151        GUI_UNLOCK();
;;;152      #endif
;;;153    }
000006  4770              BX       lr
;;;154    
                          ENDP

                  |L1.8|
                          DCD      ||.constdata||
                  |L1.12|
                          DCD      GUI_Context

                          AREA ||i._CalcSizeOfChar||, CODE, READONLY, ALIGN=1

                  _CalcSizeOfChar PROC
;;;86     */
;;;87     static int _CalcSizeOfChar(U16 Char) {
000000  0ac1              LSRS     r1,r0,#11
000002  d001              BEQ      |L2.8|
;;;88       int r;
;;;89       if (Char & 0xF800) {                /* Single byte (ASCII)  */
;;;90         r = 3;
000004  2003              MOVS     r0,#3
;;;91       } else if (Char & 0xFF80) {         /* Double byte sequence */
;;;92         r = 2;
;;;93       } else {                            /* 3 byte sequence      */
;;;94         r = 1;
;;;95       }
;;;96       return r;
;;;97     }
000006  4770              BX       lr
                  |L2.8|
000008  09c0              LSRS     r0,r0,#7              ;91
00000a  d001              BEQ      |L2.16|
00000c  2002              MOVS     r0,#2                 ;92
00000e  4770              BX       lr
                  |L2.16|
000010  2001              MOVS     r0,#1                 ;94
000012  4770              BX       lr
;;;98     
                          ENDP


                          AREA ||i._Encode||, CODE, READONLY, ALIGN=1

                  _Encode PROC
;;;105    */
;;;106    static int _Encode(char *s, U16 Char) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;107      int r;
;;;108      r = _CalcSizeOfChar(Char);
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       _CalcSizeOfChar
;;;109      switch (r) {
00000c  2801              CMP      r0,#1
00000e  d012              BEQ      |L3.54|
;;;110      case 1:
;;;111        *s = (char)Char;
;;;112        break;
;;;113      case 2:
;;;114        *s++ = 0xC0 | (Char >> 6);
;;;115        *s   = 0x80 | (Char & 0x3F);
000010  f005013f          AND      r1,r5,#0x3f
000014  f0410180          ORR      r1,r1,#0x80
000018  2802              CMP      r0,#2                 ;109
00001a  d00e              BEQ      |L3.58|
00001c  2803              CMP      r0,#3                 ;109
00001e  d109              BNE      |L3.52|
;;;116        break;
;;;117      case 3:
;;;118        *s++ = 0xE0 | (Char >> 12);
000020  22e0              MOVS     r2,#0xe0
000022  ea423215          ORR      r2,r2,r5,LSR #12
000026  7022              STRB     r2,[r4,#0]
;;;119        *s++ = 0x80 | ((Char >> 6) & 0x3F);
000028  f3c51285          UBFX     r2,r5,#6,#6
00002c  f0420280          ORR      r2,r2,#0x80
000030  7062              STRB     r2,[r4,#1]
;;;120        *s   = 0x80 | (Char & 0x3F);
000032  70a1              STRB     r1,[r4,#2]
                  |L3.52|
;;;121        break;
;;;122      }
;;;123      return r;
;;;124    }
000034  bd70              POP      {r4-r6,pc}
                  |L3.54|
000036  7025              STRB     r5,[r4,#0]            ;111
000038  bd70              POP      {r4-r6,pc}
                  |L3.58|
00003a  22c0              MOVS     r2,#0xc0              ;114
00003c  ea421295          ORR      r2,r2,r5,LSR #6       ;114
000040  7022              STRB     r2,[r4,#0]            ;114
000042  7061              STRB     r1,[r4,#1]            ;115
000044  bd70              POP      {r4-r6,pc}
;;;125    
                          ENDP


                          AREA ||i._GetCharCode||, CODE, READONLY, ALIGN=1

                  _GetCharCode PROC
;;;34     */
;;;35     static U16 _GetCharCode(const char GUI_UNI_PTR * s) {
000000  4601              MOV      r1,r0
;;;36       U16 r;
;;;37       U8 Char = *(const U8*)s;
000002  7800              LDRB     r0,[r0,#0]
;;;38       if ((Char & 0x80) == 0) {                /* Single byte (ASCII)  */
000004  0602              LSLS     r2,r0,#24
000006  d516              BPL      |L4.54|
;;;39         r = Char;
;;;40       } else if ((Char & 0xe0) == 0xc0) {      /* Double byte sequence */
000008  2206              MOVS     r2,#6
00000a  ebb21f50          CMP      r2,r0,LSR #5
00000e  d103              BNE      |L4.24|
;;;41         r = (Char & 0x1f) << 6;
000010  06c0              LSLS     r0,r0,#27
000012  0d40              LSRS     r0,r0,#21
;;;42         Char = *(++s);
000014  7849              LDRB     r1,[r1,#1]
;;;43         Char &= 0x3f;
;;;44         r |= Char;
000016  e00b              B        |L4.48|
                  |L4.24|
;;;45       } else if ((Char & 0xf0) == 0xe0) {      /* 3 byte sequence      */
000018  220e              MOVS     r2,#0xe
00001a  ebb21f10          CMP      r2,r0,LSR #4
00001e  d10b              BNE      |L4.56|
;;;46         r = (Char & 0x0f) << 12;
;;;47         Char = *(++s);
000020  784a              LDRB     r2,[r1,#1]
000022  0700              LSLS     r0,r0,#28             ;46
000024  0c00              LSRS     r0,r0,#16             ;46
;;;48         Char &= 0x3f;
000026  f002023f          AND      r2,r2,#0x3f
;;;49         r |= (Char << 6);
;;;50         Char = *(++s);
00002a  7889              LDRB     r1,[r1,#2]
00002c  ea401082          ORR      r0,r0,r2,LSL #6       ;49
                  |L4.48|
000030  f001013f          AND      r1,r1,#0x3f           ;43
000034  4308              ORRS     r0,r0,r1              ;44
                  |L4.54|
;;;51         Char &= 0x3f;
;;;52         r |= Char;
;;;53       } else {
;;;54         GUI_DEBUG_ERROROUT("Illegal character during UTF-8 decoding!");
;;;55         r = 1;       /* Illegal character. To avoid endless loops in upper layers, we return 1 rather than 0. */
;;;56       }
;;;57       return r;
;;;58     }
000036  4770              BX       lr
                  |L4.56|
000038  2001              MOVS     r0,#1                 ;55
00003a  4770              BX       lr
;;;59     
                          ENDP


                          AREA ||i._GetCharSize||, CODE, READONLY, ALIGN=1

                  _GetCharSize PROC
;;;66     */
;;;67     static int _GetCharSize(const char GUI_UNI_PTR * s) {
000000  7800              LDRB     r0,[r0,#0]
;;;68       U8 Char = *s;
;;;69       if ((Char & 0x80) == 0) {
000002  0601              LSLS     r1,r0,#24
000004  d50b              BPL      |L5.30|
;;;70         return 1;
;;;71       } else if ((Char & 0xe0) == 0xc0) {
000006  2106              MOVS     r1,#6
000008  ebb11f50          CMP      r1,r0,LSR #5
00000c  d101              BNE      |L5.18|
;;;72         return 2;
00000e  2002              MOVS     r0,#2
;;;73       } else if ((Char & 0xf0) == 0xe0) {
;;;74         return 3;
;;;75       }
;;;76       GUI_DEBUG_ERROROUT("Illegal character during UTF-8 decoding!");
;;;77       return 1;       /* Illegal character. To avoid endless loops in upper layers, we return 1 rather than 0. */
;;;78     }
000010  4770              BX       lr
                  |L5.18|
000012  210e              MOVS     r1,#0xe               ;73
000014  ebb11f10          CMP      r1,r0,LSR #4          ;73
000018  d101              BNE      |L5.30|
00001a  2003              MOVS     r0,#3                 ;74
00001c  4770              BX       lr
                  |L5.30|
00001e  2001              MOVS     r0,#1                 ;77
000020  4770              BX       lr
;;;79     
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  _API_Table
                          DCD      _GetCharCode
                          DCD      _GetCharSize
                          DCD      _CalcSizeOfChar
                          DCD      _Encode
