; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\multiedit.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\multiedit.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\Widget\MULTIEDIT.c]
                          THUMB

                          AREA ||i.MULTIEDIT_AddKey||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_AddKey PROC
;;;1657   */
;;;1658   int MULTIEDIT_AddKey(MULTIEDIT_HANDLE hObj, U16 Key) {
000000  0002              MOVS     r2,r0
;;;1659     int r = 0;
000002  f04f0000          MOV      r0,#0
000006  d002              BEQ      |L1.14|
;;;1660     if (hObj) {
;;;1661       WM_LOCK();
;;;1662       r = _AddKey(hObj, Key);
000008  4610              MOV      r0,r2
00000a  f7ffbffe          B.W      _AddKey
                  |L1.14|
;;;1663       WM_UNLOCK();
;;;1664     }
;;;1665     return r;
;;;1666   }
00000e  4770              BX       lr
;;;1667   
                          ENDP


                          AREA ||i.MULTIEDIT_AddText||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_AddText PROC
;;;1671   */
;;;1672   int MULTIEDIT_AddText(MULTIEDIT_HANDLE hObj, const char * s) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4689              MOV      r9,r1
000006  ea5f0a00          MOVS     r10,r0
;;;1673     int Result;
;;;1674     Result = 1;
00000a  f04f0701          MOV      r7,#1
00000e  d063              BEQ      |L2.216|
;;;1675     if (hObj && s) {
000010  f1b90f00          CMP      r9,#0
000014  d060              BEQ      |L2.216|
;;;1676       MULTIEDIT_OBJ * pObj;
;;;1677       WM_LOCK();
;;;1678       pObj = MULTIEDIT_H2P(hObj);
000016  4650              MOV      r0,r10
000018  f7fffffe          BL       GUI_ALLOC_h2p
00001c  4604              MOV      r4,r0
;;;1679       if (!pObj->hText) {
00001e  f9b00038          LDRSH    r0,[r0,#0x38]
000022  2800              CMP      r0,#0
000024  d05b              BEQ      |L2.222|
;;;1680         _SetText(hObj, pObj, s);
;;;1681       } else {
;;;1682         char * pText;
;;;1683         int NumCharsNew, NumCharsOld, NumBytesNew, NumBytesOld;
;;;1684         pText = (char *)GUI_ALLOC_h2p(pObj->hText);
000026  f7fffffe          BL       GUI_ALLOC_h2p
00002a  4605              MOV      r5,r0
;;;1685         NumCharsOld = GUI__GetNumChars(pText);
00002c  f7fffffe          BL       GUI__GetNumChars
000030  4606              MOV      r6,r0
;;;1686         NumBytesOld = GUI_UC__NumChars2NumBytes(pText, NumCharsOld);
000032  4601              MOV      r1,r0
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       GUI_UC__NumChars2NumBytes
00003a  4680              MOV      r8,r0
;;;1687         NumCharsNew = GUI__GetNumChars(s);
00003c  4648              MOV      r0,r9
00003e  f7fffffe          BL       GUI__GetNumChars
000042  4605              MOV      r5,r0
;;;1688         if (pObj->MaxNumChars > 0) {
000044  8f60              LDRH     r0,[r4,#0x3a]
000046  b118              CBZ      r0,|L2.80|
;;;1689           if ((NumCharsOld + NumCharsNew) > pObj->MaxNumChars) {
000048  1971              ADDS     r1,r6,r5
00004a  4281              CMP      r1,r0
00004c  dd00              BLE      |L2.80|
;;;1690             NumCharsNew = pObj->MaxNumChars - NumCharsOld;
00004e  1b85              SUBS     r5,r0,r6
                  |L2.80|
;;;1691           }
;;;1692         }
;;;1693         if (NumCharsNew > 0) {
000050  2d00              CMP      r5,#0
000052  dd41              BLE      |L2.216|
;;;1694           NumBytesNew = GUI_UC__NumChars2NumBytes(s, NumCharsNew);
000054  4629              MOV      r1,r5
000056  4648              MOV      r0,r9
000058  f7fffffe          BL       GUI_UC__NumChars2NumBytes
00005c  4606              MOV      r6,r0
;;;1695           if (_IsSpaceInBuffer(pObj, NumBytesNew)) {
00005e  4601              MOV      r1,r0
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       _IsSpaceInBuffer
000066  b3b8              CBZ      r0,|L2.216|
;;;1696             pText = (char *)GUI_ALLOC_h2p(pObj->hText);
000068  f9340f38          LDRSH    r0,[r4,#0x38]!
00006c  f7fffffe          BL       GUI_ALLOC_h2p
;;;1697             memmove(pText + pObj->CursorPosByte + NumBytesNew, 
000070  8a61              LDRH     r1,[r4,#0x12]
000072  4607              MOV      r7,r0                 ;1696
000074  4430              ADD      r0,r0,r6
000076  4408              ADD      r0,r0,r1
000078  eba80201          SUB      r2,r8,r1
00007c  4439              ADD      r1,r1,r7
00007e  f7fffffe          BL       __aeabi_memmove
;;;1698                     pText + pObj->CursorPosByte, 
;;;1699                     NumBytesOld - pObj->CursorPosByte);
;;;1700             memcpy(pText + pObj->CursorPosByte, s, NumBytesNew);
000082  8a60              LDRH     r0,[r4,#0x12]
000084  4632              MOV      r2,r6
000086  4438              ADD      r0,r0,r7
000088  4649              MOV      r1,r9
00008a  f7fffffe          BL       __aeabi_memcpy
;;;1701             *(pText + NumBytesOld + NumBytesNew) = 0;
00008e  eb070008          ADD      r0,r7,r8
000092  2100              MOVS     r1,#0
000094  5581              STRB     r1,[r0,r6]
;;;1702             pObj->NumChars += NumCharsNew;
000096  f8340f04          LDRH     r0,[r4,#4]!
00009a  4428              ADD      r0,r0,r5
00009c  f8240b0c          STRH     r0,[r4],#0xc
;;;1703             _SetCursorPos(hObj, pObj, pObj->CursorPosChar + NumCharsNew);
0000a0  f8340948          LDRH     r0,[r4],#-0x48
0000a4  4621              MOV      r1,r4
0000a6  1942              ADDS     r2,r0,r5
0000a8  4650              MOV      r0,r10
0000aa  f7fffffe          BL       _SetCursorPos
0000ae  f8140f79          LDRB     r0,[r4,#0x79]!
0000b2  f0400006          ORR      r0,r0,#6
0000b6  7020              STRB     r0,[r4,#0]
;;;1704             _InvalidateNumLines(pObj);
;;;1705             _InvalidateTextSizeX(pObj);
;;;1706             _InvalidateTextArea(hObj);
0000b8  4650              MOV      r0,r10
0000ba  f7fffffe          BL       _InvalidateTextArea
0000be  7820              LDRB     r0,[r4,#0]
0000c0  f0400008          ORR      r0,r0,#8
0000c4  f8040979          STRB     r0,[r4],#-0x79
;;;1707             _InvalidateCursorXY(pObj);
;;;1708             _ClearCache(pObj);
0000c8  4620              MOV      r0,r4
0000ca  f7fffffe          BL       _ClearCache
;;;1709             WM_NotifyParent(hObj, WM_NOTIFICATION_VALUE_CHANGED);
0000ce  2105              MOVS     r1,#5
0000d0  4650              MOV      r0,r10
0000d2  f7fffffe          BL       WM_NotifyParent
;;;1710             Result = 0;
0000d6  2700              MOVS     r7,#0
                  |L2.216|
;;;1711           }
;;;1712         }
;;;1713       }
;;;1714       WM_UNLOCK();
;;;1715     }
;;;1716     return Result;
0000d8  4638              MOV      r0,r7
;;;1717   }
0000da  e8bd87f0          POP      {r4-r10,pc}
                  |L2.222|
0000de  464a              MOV      r2,r9                 ;1680
0000e0  4621              MOV      r1,r4                 ;1680
0000e2  4650              MOV      r0,r10                ;1680
0000e4  f7fffffe          BL       _SetText
0000e8  e7f6              B        |L2.216|
;;;1718   
                          ENDP


                          AREA ||i.MULTIEDIT_Callback||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_Callback PROC
;;;1498   */
;;;1499   void MULTIEDIT_Callback (WM_MESSAGE *pMsg) {
000000  b5fe              PUSH     {r1-r7,lr}
;;;1500     MULTIEDIT_HANDLE hObj;
;;;1501     MULTIEDIT_OBJ* pObj;
;;;1502     WM_SCROLL_STATE ScrollState;
;;;1503     hObj = pMsg->hWin;
000002  f9b06004          LDRSH    r6,[r0,#4]
000006  4605              MOV      r5,r0                 ;1499
;;;1504     /* Let widget handle the standard messages */
;;;1505     if (WIDGET_HandleActive(hObj, pMsg) == 0) {
000008  4601              MOV      r1,r0
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       WIDGET_HandleActive
000010  2800              CMP      r0,#0
000012  d060              BEQ      |L3.214|
;;;1506       return;
;;;1507     }
;;;1508     pObj = (MULTIEDIT_OBJ *)GUI_ALLOC_h2p(hObj); /* Don't use use WIDGET_H2P because WIDGET_INIT_ID() has not be called at this point */
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       GUI_ALLOC_h2p
00001a  4604              MOV      r4,r0
;;;1509     switch (pMsg->MsgId) {
00001c  6828              LDR      r0,[r5,#0]
00001e  280e              CMP      r0,#0xe
000020  d065              BEQ      |L3.238|
000022  dc06              BGT      |L3.50|
000024  2805              CMP      r0,#5
000026  d018              BEQ      |L3.90|
000028  280b              CMP      r0,#0xb
00002a  d05b              BEQ      |L3.228|
00002c  280c              CMP      r0,#0xc
00002e  d16e              BNE      |L3.270|
000030  e052              B        |L3.216|
                  |L3.50|
000032  280f              CMP      r0,#0xf
000034  d04b              BEQ      |L3.206|
000036  2825              CMP      r0,#0x25
000038  d002              BEQ      |L3.64|
00003a  2826              CMP      r0,#0x26
00003c  d167              BNE      |L3.270|
00003e  e019              B        |L3.116|
                  |L3.64|
000040  f8940079          LDRB     r0,[r4,#0x79]
000044  f040000e          ORR      r0,r0,#0xe
000048  f8840079          STRB     r0,[r4,#0x79]
;;;1510     case WM_NOTIFY_CLIENTCHANGE:
;;;1511       _InvalidateCursorXY(pObj);
;;;1512       _InvalidateNumLines(pObj);
;;;1513       _InvalidateTextSizeX(pObj);
;;;1514       _ClearCache(pObj);
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       _ClearCache
;;;1515       _CalcScrollParas(hObj);
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       _CalcScrollParas
;;;1516       break;
000058  e059              B        |L3.270|
                  |L3.90|
00005a  f8940079          LDRB     r0,[r4,#0x79]
00005e  f040000e          ORR      r0,r0,#0xe
000062  f8840079          STRB     r0,[r4,#0x79]
;;;1517     case WM_SIZE:
;;;1518       _InvalidateCursorXY(pObj);
;;;1519       _InvalidateNumLines(pObj);
;;;1520       _InvalidateTextSizeX(pObj);
;;;1521       _ClearCache(pObj);
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       _ClearCache
;;;1522       _Invalidate(hObj);
00006c  4630              MOV      r0,r6
00006e  f7fffffe          BL       _Invalidate
;;;1523       break;
000072  e04c              B        |L3.270|
                  |L3.116|
;;;1524     case WM_NOTIFY_PARENT:
;;;1525       switch (pMsg->Data.v) {
000074  68a8              LDR      r0,[r5,#8]
000076  2805              CMP      r0,#5
000078  d002              BEQ      |L3.128|
00007a  2806              CMP      r0,#6
00007c  d147              BNE      |L3.270|
00007e  e022              B        |L3.198|
                  |L3.128|
;;;1526       case WM_NOTIFICATION_VALUE_CHANGED:
;;;1527         if (pMsg->hWinSrc  == WM_GetScrollbarV(hObj)) {
000080  4630              MOV      r0,r6
000082  f7fffffe          BL       WM_GetScrollbarV
000086  4601              MOV      r1,r0
000088  f9b50006          LDRSH    r0,[r5,#6]
00008c  4281              CMP      r1,r0
00008e  d105              BNE      |L3.156|
;;;1528           WM_GetScrollState(pMsg->hWinSrc, &ScrollState);
000090  4669              MOV      r1,sp
000092  f7fffffe          BL       WM_GetScrollState
;;;1529           pObj->ScrollStateV.v = ScrollState.v;
000096  9801              LDR      r0,[sp,#4]
;;;1530           WM_InvalidateWindow(hObj);
;;;1531           WM_NotifyParent(hObj, WM_NOTIFICATION_SCROLL_CHANGED);
000098  6620              STR      r0,[r4,#0x60]
00009a  e00c              B        |L3.182|
                  |L3.156|
;;;1532         } else if (pMsg->hWinSrc == WM_GetScrollbarH(hObj)) {
00009c  4630              MOV      r0,r6
00009e  f7fffffe          BL       WM_GetScrollbarH
0000a2  4601              MOV      r1,r0
0000a4  f9b50006          LDRSH    r0,[r5,#6]
0000a8  4281              CMP      r1,r0
0000aa  d130              BNE      |L3.270|
;;;1533           WM_GetScrollState(pMsg->hWinSrc, &ScrollState);
0000ac  4669              MOV      r1,sp
0000ae  f7fffffe          BL       WM_GetScrollState
;;;1534           pObj->ScrollStateH.v = ScrollState.v;
0000b2  9801              LDR      r0,[sp,#4]
0000b4  66e0              STR      r0,[r4,#0x6c]
                  |L3.182|
0000b6  4630              MOV      r0,r6                 ;1530
0000b8  f7fffffe          BL       WM_InvalidateWindow
0000bc  210a              MOVS     r1,#0xa               ;1531
0000be  4630              MOV      r0,r6                 ;1531
0000c0  f7fffffe          BL       WM_NotifyParent
0000c4  e023              B        |L3.270|
                  |L3.198|
;;;1535           WM_InvalidateWindow(hObj);
;;;1536           WM_NotifyParent(hObj, WM_NOTIFICATION_SCROLL_CHANGED);
;;;1537         }
;;;1538         break;
;;;1539       case WM_NOTIFICATION_SCROLLBAR_ADDED:
;;;1540         #if WIDGET_USE_PARENT_EFFECT
;;;1541           WIDGET_SetEffect(pMsg->hWinSrc, pObj->Widget.pEffect);
;;;1542         #endif
;;;1543         _SetScrollState(hObj);
0000c6  4630              MOV      r0,r6
0000c8  f7fffffe          BL       _SetScrollState
;;;1544         break;
0000cc  e01f              B        |L3.270|
                  |L3.206|
;;;1545       }
;;;1546       break;
;;;1547     case WM_PAINT:
;;;1548       _MULTIEDIT_Paint(hObj, pObj);
0000ce  4621              MOV      r1,r4
0000d0  4630              MOV      r0,r6
0000d2  f7fffffe          BL       _MULTIEDIT_Paint
                  |L3.214|
;;;1549       return;
;;;1550     case WM_TOUCH:
;;;1551       _OnTouch(hObj, pObj, pMsg);
;;;1552       break;
;;;1553     case WM_DELETE:
;;;1554       GUI_ALLOC_FreePtr(&pObj->hText);
;;;1555       break;
;;;1556     case WM_KEY:
;;;1557       if (((const WM_KEY_INFO*)(pMsg->Data.p))->PressedCnt >0) {
;;;1558         int Key = ((const WM_KEY_INFO*)(pMsg->Data.p))->Key;
;;;1559         /* Leave code for test purpose
;;;1560         switch (Key) {
;;;1561         case '1': Key = GUI_KEY_LEFT;  break;
;;;1562         case '2': Key = GUI_KEY_UP;    break;
;;;1563         case '3': Key = GUI_KEY_RIGHT; break;
;;;1564         case '4': Key = GUI_KEY_DOWN;  break;
;;;1565         }
;;;1566         */
;;;1567         if (_AddKey(hObj, Key)) {
;;;1568           return;
;;;1569         }
;;;1570       } else {
;;;1571         if (!(pObj->Flags & MULTIEDIT_SF_READONLY)) {
;;;1572           return;                /* Key release is consumed (not sent to parent) */
;;;1573         }
;;;1574       }
;;;1575     }
;;;1576     WM_DefaultProc(pMsg);
;;;1577   }
0000d6  bdfe              POP      {r1-r7,pc}
                  |L3.216|
0000d8  462a              MOV      r2,r5                 ;1551
0000da  4621              MOV      r1,r4                 ;1551
0000dc  4630              MOV      r0,r6                 ;1551
0000de  f7fffffe          BL       _OnTouch
0000e2  e014              B        |L3.270|
                  |L3.228|
0000e4  f1040038          ADD      r0,r4,#0x38           ;1554
0000e8  f7fffffe          BL       GUI_ALLOC_FreePtr
0000ec  e00f              B        |L3.270|
                  |L3.238|
0000ee  68a8              LDR      r0,[r5,#8]            ;1557
0000f0  6841              LDR      r1,[r0,#4]            ;1557
0000f2  2900              CMP      r1,#0                 ;1557
0000f4  dd07              BLE      |L3.262|
0000f6  8800              LDRH     r0,[r0,#0]            ;1558
0000f8  b281              UXTH     r1,r0                 ;1567
0000fa  4630              MOV      r0,r6                 ;1567
0000fc  f7fffffe          BL       _AddKey
000100  2800              CMP      r0,#0                 ;1567
000102  d1e8              BNE      |L3.214|
000104  e003              B        |L3.270|
                  |L3.262|
000106  f8940078          LDRB     r0,[r4,#0x78]         ;1571
00010a  07c0              LSLS     r0,r0,#31             ;1571
00010c  d0e3              BEQ      |L3.214|
                  |L3.270|
00010e  4628              MOV      r0,r5                 ;1576
000110  f7fffffe          BL       WM_DefaultProc
000114  bdfe              POP      {r1-r7,pc}
;;;1578   
                          ENDP


                          AREA ||i.MULTIEDIT_CreateEx||, CODE, READONLY, ALIGN=2

                  MULTIEDIT_CreateEx PROC
;;;1592   */
;;;1593   MULTIEDIT_HANDLE MULTIEDIT_CreateEx(int x0, int y0, int xsize, int ysize, WM_HWIN hParent, int WinFlags, int ExFlags,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;1594                                       int Id, int BufferSize, const char* pText)
;;;1595   {
000004  4605              MOV      r5,r0
000006  e9dd490e          LDRD     r4,r9,[sp,#0x38]
00000a  e9dda611          LDRD     r10,r6,[sp,#0x44]
;;;1596     MULTIEDIT_HANDLE hObj;
;;;1597     /* Create the window */
;;;1598     WM_LOCK();
;;;1599     if ((xsize == 0) && (ysize == 0) && (x0 == 0) && (y0 == 0)) {
00000e  ea420003          ORR      r0,r2,r3
000012  4688              MOV      r8,r1                 ;1595
000014  4328              ORRS     r0,r0,r5
000016  f8ddb04c          LDR      r11,[sp,#0x4c]
00001a  9f10              LDR      r7,[sp,#0x40]
00001c  ea500008          ORRS     r0,r0,r8
000020  d10f              BNE      |L4.66|
;;;1600       GUI_RECT Rect;
;;;1601       WM_GetClientRectEx(hParent, &Rect);
000022  4669              MOV      r1,sp
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       WM_GetClientRectEx
;;;1602       xsize = Rect.x1 - Rect.x0 + 1;
00002a  f9bd0004          LDRSH    r0,[sp,#4]
00002e  f9bd1000          LDRSH    r1,[sp,#0]
000032  1a42              SUBS     r2,r0,r1
;;;1603       ysize = Rect.y1 - Rect.y0 + 1;
000034  f9bd0006          LDRSH    r0,[sp,#6]
000038  f9bd1002          LDRSH    r1,[sp,#2]
00003c  1c52              ADDS     r2,r2,#1
00003e  1a43              SUBS     r3,r0,r1
000040  1c5b              ADDS     r3,r3,#1
                  |L4.66|
;;;1604     }
;;;1605     hObj = WM_CreateWindowAsChild(x0, y0, xsize, ysize, hParent, WinFlags, &MULTIEDIT_Callback,
000042  2160              MOVS     r1,#0x60
000044  f8dfc0a4          LDR      r12,|L4.236|
000048  fa1ff089          UXTH     r0,r9
00004c  e9cdc102          STRD     r12,r1,[sp,#8]
000050  e9cd4000          STRD     r4,r0,[sp,#0]
000054  4641              MOV      r1,r8
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       WM_CreateWindowAsChild
00005c  0005              MOVS     r5,r0
;;;1606                                   sizeof(MULTIEDIT_OBJ) - sizeof(WM_Obj));
;;;1607     if (hObj) {
00005e  d040              BEQ      |L4.226|
;;;1608       int i;
;;;1609       MULTIEDIT_OBJ * pObj;
;;;1610       pObj = (MULTIEDIT_OBJ *)GUI_ALLOC_h2p(hObj); /* Don't use use WIDGET_H2P because WIDGET_INIT_ID() has not be called at this point */
000060  f7fffffe          BL       GUI_ALLOC_h2p
000064  4604              MOV      r4,r0
;;;1611       /* init widget specific variables */
;;;1612       WIDGET__Init(&pObj->Widget, Id, WIDGET_STATE_FOCUSSABLE);
000066  2210              MOVS     r2,#0x10
000068  4651              MOV      r1,r10
00006a  f7fffffe          BL       WIDGET__Init
;;;1613       /* init member variables */
;;;1614       MULTIEDIT_INIT_ID(pObj);
;;;1615       for (i = 0; i < NUM_DISP_MODES; i++) {
;;;1616         pObj->aBkColor[i]  = _aDefaultBkColor[i];
00006e  4a20              LDR      r2,|L4.240|
000070  2000              MOVS     r0,#0                 ;1615
;;;1617         pObj->aColor[i]    = _aDefaultColor[i];
000072  f1020308          ADD      r3,r2,#8
000076  bf00              NOP                            ;1616
                  |L4.120|
000078  eb040180          ADD      r1,r4,r0,LSL #2       ;1616
00007c  f852c020          LDR      r12,[r2,r0,LSL #2]    ;1616
000080  f8c1c028          STR      r12,[r1,#0x28]
000084  f853c020          LDR      r12,[r3,r0,LSL #2]
000088  1c40              ADDS     r0,r0,#1
00008a  f8c1c030          STR      r12,[r1,#0x30]        ;1615
00008e  2802              CMP      r0,#2                 ;1615
000090  dbf2              BLT      |L4.120|
;;;1618       }
;;;1619       pObj->pFont          = _pDefaultFont;
000092  4817              LDR      r0,|L4.240|
;;;1620       pObj->Flags          = ExFlags;
;;;1621       pObj->CursorPosChar  = 0;
;;;1622       pObj->CursorPosByte  = 0;
;;;1623       pObj->HBorder        = 1;
000094  2101              MOVS     r1,#1
000096  380c              SUBS     r0,r0,#0xc            ;1619
000098  6840              LDR      r0,[r0,#4]            ;1619  ; _pDefaultFont
00009a  6760              STR      r0,[r4,#0x74]         ;1620
00009c  2000              MOVS     r0,#0                 ;1621
00009e  f8847078          STRB     r7,[r4,#0x78]         ;1620
0000a2  f8a40048          STRH     r0,[r4,#0x48]         ;1621
0000a6  f8a4004a          STRH     r0,[r4,#0x4a]         ;1622
0000aa  f884107b          STRB     r1,[r4,#0x7b]
;;;1624       pObj->MaxNumChars    = 0;
0000ae  8760              STRH     r0,[r4,#0x3a]
;;;1625       pObj->NumCharsPrompt = 0;
0000b0  87e0              STRH     r0,[r4,#0x3e]
;;;1626       pObj->BufferSize     = 0;
0000b2  f8a40044          STRH     r0,[r4,#0x44]
;;;1627       pObj->hText          = 0;
0000b6  8720              STRH     r0,[r4,#0x38]
;;;1628       if (BufferSize > 0) {
0000b8  2e00              CMP      r6,#0
0000ba  dd0b              BLE      |L4.212|
;;;1629         WM_HWIN hText;
;;;1630         if ((hText = GUI_ALLOC_AllocZero(BufferSize)) != 0) {
0000bc  b230              SXTH     r0,r6
0000be  f7fffffe          BL       GUI_ALLOC_AllocZero
0000c2  b118              CBZ      r0,|L4.204|
;;;1631           pObj->BufferSize = BufferSize;
0000c4  f8a46044          STRH     r6,[r4,#0x44]
;;;1632           pObj->hText      = hText;
0000c8  8720              STRH     r0,[r4,#0x38]
0000ca  e003              B        |L4.212|
                  |L4.204|
;;;1633         } else {
;;;1634           GUI_DEBUG_ERROROUT("MULTIEDIT_CreateEx failed to alloc buffer");
;;;1635           WM_DeleteWindow(hObj);
0000cc  4628              MOV      r0,r5
0000ce  f7fffffe          BL       WM_DeleteWindow
;;;1636           hObj = 0;
0000d2  2500              MOVS     r5,#0
                  |L4.212|
;;;1637         }
;;;1638       }
;;;1639       MULTIEDIT_SetText(hObj, pText);
0000d4  4659              MOV      r1,r11
0000d6  4628              MOV      r0,r5
0000d8  f7fffffe          BL       MULTIEDIT_SetText
;;;1640       _ManageScrollers(hObj);
0000dc  4628              MOV      r0,r5
0000de  f7fffffe          BL       _ManageScrollers
                  |L4.226|
;;;1641     } else {
;;;1642       GUI_DEBUG_ERROROUT_IF(hObj==0, "MULTIEDIT_CreateEx failed")
;;;1643     }
;;;1644     WM_UNLOCK();
;;;1645     return hObj;
;;;1646   }
0000e2  b004              ADD      sp,sp,#0x10
0000e4  4628              MOV      r0,r5                 ;1645
0000e6  e8bd9ff0          POP      {r4-r12,pc}
;;;1647   
                          ENDP

0000ea  0000              DCW      0x0000
                  |L4.236|
                          DCD      MULTIEDIT_Callback
                  |L4.240|
                          DCD      ||.data||+0xc

                          AREA ||i.MULTIEDIT_GetCursorCharPos||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_GetCursorCharPos PROC
;;;2085   */
;;;2086   int MULTIEDIT_GetCursorCharPos(MULTIEDIT_HANDLE hObj) {
000000  b510              PUSH     {r4,lr}
000002  0001              MOVS     r1,r0
;;;2087     int r = 0;
000004  f04f0000          MOV      r0,#0
000008  d004              BEQ      |L5.20|
;;;2088     if (hObj) {
;;;2089       MULTIEDIT_OBJ* pObj;
;;;2090       WM_LOCK();
;;;2091       pObj = MULTIEDIT_H2P(hObj);
00000a  4608              MOV      r0,r1
00000c  f7fffffe          BL       GUI_ALLOC_h2p
;;;2092       r = pObj->CursorPosChar;
000010  f8b00048          LDRH     r0,[r0,#0x48]
                  |L5.20|
;;;2093       WM_UNLOCK();
;;;2094     }
;;;2095     return r;
;;;2096   }
000014  bd10              POP      {r4,pc}
;;;2097   
                          ENDP


                          AREA ||i.MULTIEDIT_GetCursorPixelPos||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_GetCursorPixelPos PROC
;;;2101   */
;;;2102   void MULTIEDIT_GetCursorPixelPos(MULTIEDIT_HANDLE hObj, int * pxPos, int * pyPos) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4615              MOV      r5,r2
000006  460e              MOV      r6,r1
000008  ea5f0800          MOVS     r8,r0
00000c  d01c              BEQ      |L6.72|
;;;2103     if (hObj) {
;;;2104       MULTIEDIT_OBJ* pObj;
;;;2105       int FontSizeY, EffectSize;
;;;2106       WM_LOCK();
;;;2107       pObj = MULTIEDIT_H2P(hObj);
00000e  f7fffffe          BL       GUI_ALLOC_h2p
000012  4604              MOV      r4,r0
;;;2108       FontSizeY  = GUI_GetYSizeOfFont(pObj->pFont);
000014  6f40              LDR      r0,[r0,#0x74]
000016  f7fffffe          BL       GUI_GetYSizeOfFont
00001a  4681              MOV      r9,r0
;;;2109       EffectSize = pObj->Widget.pEffect->EffectSize;
00001c  6a20              LDR      r0,[r4,#0x20]
;;;2110       _GetCursorXY(hObj, pObj, pxPos, pyPos);
00001e  462b              MOV      r3,r5
000020  4632              MOV      r2,r6
000022  6947              LDR      r7,[r0,#0x14]
000024  4621              MOV      r1,r4
000026  4640              MOV      r0,r8
000028  f7fffffe          BL       _GetCursorXY
;;;2111       *pxPos += EffectSize - pObj->ScrollStateH.v + pObj->HBorder;
00002c  f894107b          LDRB     r1,[r4,#0x7b]
000030  6830              LDR      r0,[r6,#0]
000032  4408              ADD      r0,r0,r1
000034  6ee1              LDR      r1,[r4,#0x6c]
000036  1a79              SUBS     r1,r7,r1
000038  4408              ADD      r0,r0,r1
;;;2112       *pyPos += EffectSize - pObj->ScrollStateV.v * FontSizeY;
00003a  6030              STR      r0,[r6,#0]
00003c  6e22              LDR      r2,[r4,#0x60]
00003e  6829              LDR      r1,[r5,#0]
000040  fb027019          MLS      r0,r2,r9,r7
000044  4408              ADD      r0,r0,r1
000046  6028              STR      r0,[r5,#0]
                  |L6.72|
;;;2113       WM_UNLOCK();
;;;2114     }
;;;2115   }
000048  e8bd87f0          POP      {r4-r10,pc}
;;;2116   
                          ENDP


                          AREA ||i.MULTIEDIT_GetPrompt||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_GetPrompt PROC
;;;1763   */
;;;1764   void MULTIEDIT_GetPrompt(MULTIEDIT_HANDLE hObj, char * sDest, int MaxLen) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4615              MOV      r5,r2
000006  460e              MOV      r6,r1
000008  2800              CMP      r0,#0
00000a  d017              BEQ      |L7.60|
;;;1765     if (hObj) {
;;;1766       MULTIEDIT_OBJ * pObj;
;;;1767       WM_LOCK();
;;;1768       pObj = MULTIEDIT_H2P(hObj);
00000c  f7fffffe          BL       GUI_ALLOC_h2p
000010  0004              MOVS     r4,r0
;;;1769       if (pObj) {
000012  d013              BEQ      |L7.60|
;;;1770         char* sSource = (char*)GUI_ALLOC_h2p(pObj->hText);
000014  f9b40038          LDRSH    r0,[r4,#0x38]
000018  f7fffffe          BL       GUI_ALLOC_h2p
00001c  4607              MOV      r7,r0
;;;1771         int Len = GUI_UC__NumChars2NumBytes(sSource, pObj->NumCharsPrompt);
00001e  8fe1              LDRH     r1,[r4,#0x3e]
000020  f7fffffe          BL       GUI_UC__NumChars2NumBytes
000024  4604              MOV      r4,r0
;;;1772         if (Len > (MaxLen - 1)) {
000026  1e68              SUBS     r0,r5,#1
000028  4284              CMP      r4,r0
00002a  dd00              BLE      |L7.46|
;;;1773           Len = MaxLen - 1;
00002c  4604              MOV      r4,r0
                  |L7.46|
;;;1774         }
;;;1775         memcpy(sDest, sSource, Len);
00002e  4622              MOV      r2,r4
000030  4639              MOV      r1,r7
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       __aeabi_memcpy
;;;1776         *(sDest + Len) = 0;
000038  2000              MOVS     r0,#0
00003a  5530              STRB     r0,[r6,r4]
                  |L7.60|
;;;1777       }
;;;1778       WM_UNLOCK();
;;;1779     }
;;;1780   }
00003c  e8bd81f0          POP      {r4-r8,pc}
;;;1781   
                          ENDP


                          AREA ||i.MULTIEDIT_GetText||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_GetText PROC
;;;1738   */
;;;1739   void MULTIEDIT_GetText(MULTIEDIT_HANDLE hObj, char* sDest, int MaxLen) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4615              MOV      r5,r2
000006  460e              MOV      r6,r1
000008  2800              CMP      r0,#0
00000a  d01b              BEQ      |L8.68|
;;;1740     if (hObj) {
;;;1741       MULTIEDIT_OBJ* pObj;
;;;1742       WM_LOCK();
;;;1743       pObj = MULTIEDIT_H2P(hObj);
00000c  f7fffffe          BL       GUI_ALLOC_h2p
000010  0004              MOVS     r4,r0
;;;1744       if (pObj) {
000012  d017              BEQ      |L8.68|
;;;1745         char* pText;
;;;1746         int Len;
;;;1747         pText  = (char*) GUI_ALLOC_h2p(pObj->hText);
000014  f9b40038          LDRSH    r0,[r4,#0x38]
000018  f7fffffe          BL       GUI_ALLOC_h2p
00001c  4607              MOV      r7,r0
;;;1748         pText += GUI_UC__NumChars2NumBytes(pText, pObj->NumCharsPrompt);
00001e  8fe1              LDRH     r1,[r4,#0x3e]
000020  f7fffffe          BL       GUI_UC__NumChars2NumBytes
000024  4407              ADD      r7,r7,r0
;;;1749         Len    = strlen(pText);
000026  4638              MOV      r0,r7
000028  f7fffffe          BL       strlen
00002c  4604              MOV      r4,r0
;;;1750         if (Len > (MaxLen - 1)) {
00002e  1e68              SUBS     r0,r5,#1
000030  4284              CMP      r4,r0
000032  dd00              BLE      |L8.54|
;;;1751           Len = MaxLen - 1;
000034  4604              MOV      r4,r0
                  |L8.54|
;;;1752         }
;;;1753         memcpy(sDest, pText, Len);
000036  4622              MOV      r2,r4
000038  4639              MOV      r1,r7
00003a  4630              MOV      r0,r6
00003c  f7fffffe          BL       __aeabi_memcpy
;;;1754         *(sDest + Len) = 0;
000040  2000              MOVS     r0,#0
000042  5530              STRB     r0,[r6,r4]
                  |L8.68|
;;;1755       }
;;;1756       WM_UNLOCK();
;;;1757     }
;;;1758   }
000044  e8bd81f0          POP      {r4-r8,pc}
;;;1759   
                          ENDP


                          AREA ||i.MULTIEDIT_GetTextSize||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_GetTextSize PROC
;;;2043   */
;;;2044   int MULTIEDIT_GetTextSize(MULTIEDIT_HANDLE hObj) {
000000  b570              PUSH     {r4-r6,lr}
;;;2045     int r = 0;
000002  2500              MOVS     r5,#0
000004  b178              CBZ      r0,|L9.38|
;;;2046     if (hObj) {
;;;2047       MULTIEDIT_OBJ* pObj;
;;;2048       WM_LOCK();
;;;2049       pObj = MULTIEDIT_H2P(hObj);
000006  f7fffffe          BL       GUI_ALLOC_h2p
00000a  4604              MOV      r4,r0
;;;2050       if (pObj->hText) {
00000c  f9b00038          LDRSH    r0,[r0,#0x38]
000010  b148              CBZ      r0,|L9.38|
;;;2051         const char* s;
;;;2052         s = (const char*)GUI_ALLOC_h2p(pObj->hText);
000012  f7fffffe          BL       GUI_ALLOC_h2p
000016  4605              MOV      r5,r0
;;;2053         s += GUI_UC__NumChars2NumBytes(s, pObj->NumCharsPrompt);
000018  8fe1              LDRH     r1,[r4,#0x3e]
00001a  f7fffffe          BL       GUI_UC__NumChars2NumBytes
00001e  4428              ADD      r0,r0,r5
;;;2054         r = 1 + strlen(s);
000020  f7fffffe          BL       strlen
000024  1c45              ADDS     r5,r0,#1
                  |L9.38|
;;;2055       }
;;;2056       WM_UNLOCK();
;;;2057     }
;;;2058     return r;
000026  4628              MOV      r0,r5
;;;2059   }
000028  bd70              POP      {r4-r6,pc}
;;;2060   
                          ENDP


                          AREA ||i.MULTIEDIT_SetAutoScrollH||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_SetAutoScrollH PROC
;;;1850   */
;;;1851   void MULTIEDIT_SetAutoScrollH(MULTIEDIT_HANDLE hObj, int OnOff) {
000000  2210              MOVS     r2,#0x10
;;;1852     _SetFlag(hObj, OnOff, MULTIEDIT_SF_AUTOSCROLLBAR_H);
000002  f7ffbffe          B.W      _SetFlag
;;;1853   }
;;;1854   
                          ENDP


                          AREA ||i.MULTIEDIT_SetAutoScrollV||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_SetAutoScrollV PROC
;;;1842   */
;;;1843   void MULTIEDIT_SetAutoScrollV(MULTIEDIT_HANDLE hObj, int OnOff) {
000000  2208              MOVS     r2,#8
;;;1844     _SetFlag(hObj, OnOff, MULTIEDIT_SF_AUTOSCROLLBAR_V);
000002  f7ffbffe          B.W      _SetFlag
;;;1845   }
;;;1846   
                          ENDP


                          AREA ||i.MULTIEDIT_SetBkColor||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_SetBkColor PROC
;;;1895   */
;;;1896   void MULTIEDIT_SetBkColor(MULTIEDIT_HANDLE hObj, unsigned Index, GUI_COLOR color) {
000000  b570              PUSH     {r4-r6,lr}
000002  4616              MOV      r6,r2
000004  460c              MOV      r4,r1
000006  0005              MOVS     r5,r0
000008  d00b              BEQ      |L12.34|
;;;1897     if (hObj && (Index < NUM_DISP_MODES)) {
00000a  2c02              CMP      r4,#2
00000c  d209              BCS      |L12.34|
;;;1898       MULTIEDIT_OBJ* pObj;
;;;1899       WM_LOCK();
;;;1900       pObj = MULTIEDIT_H2P(hObj);
00000e  f7fffffe          BL       GUI_ALLOC_h2p
;;;1901       pObj->aBkColor[Index] = color;
000012  eb000084          ADD      r0,r0,r4,LSL #2
;;;1902       _InvalidateTextArea(hObj);
000016  6286              STR      r6,[r0,#0x28]
000018  4628              MOV      r0,r5
00001a  e8bd4070          POP      {r4-r6,lr}
00001e  f7ffbffe          B.W      _InvalidateTextArea
                  |L12.34|
;;;1903       WM_UNLOCK();
;;;1904     }
;;;1905   }
000022  bd70              POP      {r4-r6,pc}
;;;1906   
                          ENDP


                          AREA ||i.MULTIEDIT_SetBufferSize||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_SetBufferSize PROC
;;;1980   */
;;;1981   void MULTIEDIT_SetBufferSize(MULTIEDIT_HANDLE hObj, int BufferSize) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  460d              MOV      r5,r1
000006  0007              MOVS     r7,r0
000008  d01f              BEQ      |L13.74|
;;;1982     if (hObj) {
;;;1983       MULTIEDIT_OBJ* pObj;
;;;1984       WM_HMEM hText;
;;;1985       WM_LOCK();
;;;1986       pObj = MULTIEDIT_H2P(hObj);
00000a  f7fffffe          BL       GUI_ALLOC_h2p
00000e  4604              MOV      r4,r0
;;;1987       if ((hText = GUI_ALLOC_AllocZero(BufferSize)) == 0) {
000010  b228              SXTH     r0,r5
000012  f7fffffe          BL       GUI_ALLOC_AllocZero
000016  0006              MOVS     r6,r0
000018  d012              BEQ      |L13.64|
;;;1988         GUI_DEBUG_ERROROUT("MULTIEDIT_SetBufferSize failed to alloc buffer");
;;;1989       } else {
;;;1990         GUI_ALLOC_FreePtr(&pObj->hText);
00001a  f1040038          ADD      r0,r4,#0x38
00001e  f7fffffe          BL       GUI_ALLOC_FreePtr
;;;1991         pObj->hText          = hText;
000022  8726              STRH     r6,[r4,#0x38]
;;;1992         pObj->BufferSize     = BufferSize;
;;;1993         pObj->NumCharsPrompt = 0;
000024  2000              MOVS     r0,#0
000026  f8a45044          STRH     r5,[r4,#0x44]         ;1992
00002a  87e0              STRH     r0,[r4,#0x3e]
;;;1994         _SetCursorPos(hObj, pObj, 0);
00002c  4602              MOV      r2,r0
00002e  4621              MOV      r1,r4
000030  4638              MOV      r0,r7
000032  f7fffffe          BL       _SetCursorPos
000036  f8140f79          LDRB     r0,[r4,#0x79]!
00003a  f040000f          ORR      r0,r0,#0xf
00003e  7020              STRB     r0,[r4,#0]
                  |L13.64|
;;;1995         _InvalidateNumChars(pObj);
;;;1996         _InvalidateCursorXY(pObj);
;;;1997         _InvalidateNumLines(pObj);
;;;1998         _InvalidateTextSizeX(pObj);
;;;1999       }
;;;2000       _InvalidateTextArea(hObj);
000040  4638              MOV      r0,r7
000042  e8bd41f0          POP      {r4-r8,lr}
000046  f7ffbffe          B.W      _InvalidateTextArea
                  |L13.74|
;;;2001       WM_UNLOCK();
;;;2002     }
;;;2003   }
00004a  e8bd81f0          POP      {r4-r8,pc}
;;;2004   
                          ENDP


                          AREA ||i.MULTIEDIT_SetCursorOffset||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_SetCursorOffset PROC
;;;1910   */
;;;1911   void MULTIEDIT_SetCursorOffset(MULTIEDIT_HANDLE hObj, int Offset) {
000000  b570              PUSH     {r4-r6,lr}
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d00b              BEQ      |L14.32|
;;;1912     if (hObj) {
;;;1913       MULTIEDIT_OBJ* pObj;
;;;1914       WM_LOCK();
;;;1915       pObj = MULTIEDIT_H2P(hObj);
000008  f7fffffe          BL       GUI_ALLOC_h2p
00000c  4601              MOV      r1,r0
;;;1916       _SetCursorPos(hObj, pObj, Offset);
00000e  462a              MOV      r2,r5
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       _SetCursorPos
;;;1917       WM_Invalidate(hObj);
000016  4620              MOV      r0,r4
000018  e8bd4070          POP      {r4-r6,lr}
00001c  f7ffbffe          B.W      WM_InvalidateWindow
                  |L14.32|
;;;1918       WM_UNLOCK();
;;;1919     }
;;;1920   }
000020  bd70              POP      {r4-r6,pc}
;;;1921   
                          ENDP


                          AREA ||i.MULTIEDIT_SetFont||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_SetFont PROC
;;;1875   */
;;;1876   void MULTIEDIT_SetFont(MULTIEDIT_HANDLE hObj, const GUI_FONT GUI_UNI_PTR * pFont) {
000000  b570              PUSH     {r4-r6,lr}
000002  460d              MOV      r5,r1
000004  0006              MOVS     r6,r0
000006  d00e              BEQ      |L15.38|
;;;1877     if (hObj) {
;;;1878       MULTIEDIT_OBJ* pObj;
;;;1879       WM_LOCK();
;;;1880       pObj = MULTIEDIT_H2P(hObj);
000008  f7fffffe          BL       GUI_ALLOC_h2p
00000c  4604              MOV      r4,r0
;;;1881       if (pObj->pFont != pFont) {
00000e  6f40              LDR      r0,[r0,#0x74]
000010  42a8              CMP      r0,r5
000012  d008              BEQ      |L15.38|
;;;1882         pObj->pFont = pFont;
000014  f8445f74          STR      r5,[r4,#0x74]!
;;;1883         _InvalidateTextArea(hObj);
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       _InvalidateTextArea
00001e  7960              LDRB     r0,[r4,#5]
000020  f040000e          ORR      r0,r0,#0xe
000024  7160              STRB     r0,[r4,#5]
                  |L15.38|
;;;1884         _InvalidateCursorXY(pObj);
;;;1885         _InvalidateNumLines(pObj);
;;;1886         _InvalidateTextSizeX(pObj);
;;;1887       }
;;;1888       WM_UNLOCK();
;;;1889     }
;;;1890   }
000026  bd70              POP      {r4-r6,pc}
;;;1891   
                          ENDP


                          AREA ||i.MULTIEDIT_SetHBorder||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_SetHBorder PROC
;;;1858   */
;;;1859   void MULTIEDIT_SetHBorder(MULTIEDIT_HANDLE hObj, unsigned HBorder) {
000000  b570              PUSH     {r4-r6,lr}
000002  460c              MOV      r4,r1
000004  0005              MOVS     r5,r0
000006  d00c              BEQ      |L16.34|
;;;1860     if (hObj) {
;;;1861       MULTIEDIT_OBJ* pObj;
;;;1862       WM_LOCK();
;;;1863       pObj = MULTIEDIT_H2P(hObj);
000008  f7fffffe          BL       GUI_ALLOC_h2p
;;;1864       if ((unsigned)pObj->HBorder != HBorder) {
00000c  f890107b          LDRB     r1,[r0,#0x7b]
000010  42a1              CMP      r1,r4
000012  d006              BEQ      |L16.34|
;;;1865         pObj->HBorder = HBorder;
000014  f880407b          STRB     r4,[r0,#0x7b]
;;;1866         _Invalidate(hObj);
000018  4628              MOV      r0,r5
00001a  e8bd4070          POP      {r4-r6,lr}
00001e  f7ffbffe          B.W      _Invalidate
                  |L16.34|
;;;1867       }
;;;1868       WM_UNLOCK();
;;;1869     }
;;;1870   }
000022  bd70              POP      {r4-r6,pc}
;;;1871   
                          ENDP


                          AREA ||i.MULTIEDIT_SetInsertMode||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_SetInsertMode PROC
;;;1809   */
;;;1810   void MULTIEDIT_SetInsertMode(MULTIEDIT_HANDLE hObj, int OnOff) {
000000  2204              MOVS     r2,#4
;;;1811     _SetFlag(hObj, OnOff, MULTIEDIT_SF_INSERT);
000002  f7ffbffe          B.W      _SetFlag
;;;1812   }
;;;1813   
                          ENDP


                          AREA ||i.MULTIEDIT_SetMaxNumChars||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_SetMaxNumChars PROC
;;;2008   */
;;;2009   void MULTIEDIT_SetMaxNumChars(MULTIEDIT_HANDLE hObj, unsigned MaxNumChars) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  460f              MOV      r7,r1
000006  0006              MOVS     r6,r0
000008  d027              BEQ      |L18.90|
;;;2010     if (hObj) {
;;;2011       MULTIEDIT_OBJ* pObj;
;;;2012       WM_LOCK();
;;;2013       pObj = MULTIEDIT_H2P(hObj);
00000a  f7fffffe          BL       GUI_ALLOC_h2p
;;;2014       pObj->MaxNumChars = MaxNumChars;
00000e  b2b9              UXTH     r1,r7
000010  4604              MOV      r4,r0                 ;2013
000012  8741              STRH     r1,[r0,#0x3a]
;;;2015       if (MaxNumChars < (unsigned)pObj->NumCharsPrompt) {
000014  8fc0              LDRH     r0,[r0,#0x3e]
000016  42b8              CMP      r0,r7
000018  d900              BLS      |L18.28|
;;;2016         pObj->NumCharsPrompt = MaxNumChars;
00001a  87e1              STRH     r1,[r4,#0x3e]
                  |L18.28|
;;;2017       }
;;;2018       if (pObj->hText && MaxNumChars) {
00001c  f9b40038          LDRSH    r0,[r4,#0x38]
000020  2800              CMP      r0,#0
000022  d01a              BEQ      |L18.90|
000024  2f00              CMP      r7,#0
000026  d018              BEQ      |L18.90|
;;;2019         char* pText;
;;;2020         int Offset;
;;;2021         pText = (char*) GUI_ALLOC_h2p(pObj->hText);
000028  f7fffffe          BL       GUI_ALLOC_h2p
00002c  4605              MOV      r5,r0
;;;2022         Offset = GUI_UC__NumChars2NumBytes(pText, MaxNumChars);
00002e  4639              MOV      r1,r7
000030  f7fffffe          BL       GUI_UC__NumChars2NumBytes
000034  4602              MOV      r2,r0
;;;2023         if (Offset < pObj->BufferSize) {
000036  f8b40044          LDRH     r0,[r4,#0x44]
00003a  4290              CMP      r0,r2
00003c  dd0d              BLE      |L18.90|
;;;2024           pText += Offset;
;;;2025           *pText = 0;
00003e  2100              MOVS     r1,#0
000040  54a9              STRB     r1,[r5,r2]
;;;2026           _SetCursorPos(hObj, pObj, Offset);
000042  4621              MOV      r1,r4
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       _SetCursorPos
;;;2027           _InvalidateTextArea(hObj);
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       _InvalidateTextArea
000050  f8140f79          LDRB     r0,[r4,#0x79]!
000054  f0400001          ORR      r0,r0,#1
000058  7020              STRB     r0,[r4,#0]
                  |L18.90|
;;;2028           _InvalidateNumChars(pObj);
;;;2029         }
;;;2030       }
;;;2031       WM_UNLOCK();
;;;2032     }
;;;2033   }
00005a  e8bd81f0          POP      {r4-r8,pc}
;;;2034   
                          ENDP


                          AREA ||i.MULTIEDIT_SetPasswordMode||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_SetPasswordMode PROC
;;;1825   */
;;;1826   void MULTIEDIT_SetPasswordMode(MULTIEDIT_HANDLE hObj, int OnOff) {
000000  b570              PUSH     {r4-r6,lr}
000002  460e              MOV      r6,r1
000004  0005              MOVS     r5,r0
000006  d00c              BEQ      |L19.34|
;;;1827     if (hObj) {
;;;1828       MULTIEDIT_OBJ* pObj;
;;;1829       WM_LOCK();
;;;1830       pObj = MULTIEDIT_H2P(hObj);
000008  f7fffffe          BL       GUI_ALLOC_h2p
00000c  4604              MOV      r4,r0
;;;1831       _SetFlag(hObj, OnOff, MULTIEDIT_SF_PASSWORD);
00000e  2220              MOVS     r2,#0x20
000010  4631              MOV      r1,r6
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       _SetFlag
000018  f8140f79          LDRB     r0,[r4,#0x79]!
00001c  f040010e          ORR      r1,r0,#0xe
000020  7021              STRB     r1,[r4,#0]
                  |L19.34|
;;;1832       _InvalidateCursorXY(pObj);
;;;1833       _InvalidateNumLines(pObj);
;;;1834       _InvalidateTextSizeX(pObj);
;;;1835       WM_UNLOCK();
;;;1836     }
;;;1837   }
000022  bd70              POP      {r4-r6,pc}
;;;1838   
                          ENDP


                          AREA ||i.MULTIEDIT_SetPrompt||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_SetPrompt PROC
;;;1940   */
;;;1941   void MULTIEDIT_SetPrompt(MULTIEDIT_HANDLE hObj, const char* pPrompt) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4689              MOV      r9,r1
000006  ea5f0a00          MOVS     r10,r0
00000a  d04f              BEQ      |L20.172|
;;;1942     if (hObj) {
;;;1943       MULTIEDIT_OBJ* pObj;
;;;1944       int NumCharsNew = 0, NumCharsOld = 0;
00000c  2500              MOVS     r5,#0
00000e  46a8              MOV      r8,r5
;;;1945       int NumBytesNew = 0, NumBytesOld = 0;
000010  462e              MOV      r6,r5
000012  462f              MOV      r7,r5
;;;1946       char* pText;
;;;1947       WM_LOCK();
;;;1948       pObj = MULTIEDIT_H2P(hObj);
000014  4650              MOV      r0,r10
000016  f7fffffe          BL       GUI_ALLOC_h2p
00001a  4604              MOV      r4,r0
;;;1949       if (pObj->hText) {
00001c  f9b00038          LDRSH    r0,[r0,#0x38]
000020  b138              CBZ      r0,|L20.50|
;;;1950         pText = (char*) GUI_ALLOC_h2p(pObj->hText);
000022  f7fffffe          BL       GUI_ALLOC_h2p
;;;1951         NumCharsOld = pObj->NumCharsPrompt;
000026  f8b4803e          LDRH     r8,[r4,#0x3e]
;;;1952         NumBytesOld = GUI_UC__NumChars2NumBytes(pText, NumCharsOld);
00002a  4641              MOV      r1,r8
00002c  f7fffffe          BL       GUI_UC__NumChars2NumBytes
000030  4607              MOV      r7,r0
                  |L20.50|
;;;1953       }
;;;1954       if (pPrompt) {
000032  ea5f0009          MOVS     r0,r9
000036  d007              BEQ      |L20.72|
;;;1955         NumCharsNew = GUI__GetNumChars(pPrompt);
000038  f7fffffe          BL       GUI__GetNumChars
00003c  4605              MOV      r5,r0
;;;1956         NumBytesNew = GUI_UC__NumChars2NumBytes(pPrompt, NumCharsNew);
00003e  4601              MOV      r1,r0
000040  4648              MOV      r0,r9
000042  f7fffffe          BL       GUI_UC__NumChars2NumBytes
000046  4606              MOV      r6,r0
                  |L20.72|
;;;1957       }
;;;1958       if (_IsCharsAvailable(pObj, NumCharsNew - NumCharsOld)) {
000048  eba50108          SUB      r1,r5,r8
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       _IsCharsAvailable
000052  2800              CMP      r0,#0
000054  d02a              BEQ      |L20.172|
;;;1959         if (_IsSpaceInBuffer(pObj, NumBytesNew - NumBytesOld)) {
000056  1bf1              SUBS     r1,r6,r7
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       _IsSpaceInBuffer
00005e  2800              CMP      r0,#0
000060  d024              BEQ      |L20.172|
;;;1960           pText = (char*) GUI_ALLOC_h2p(pObj->hText);
000062  f9b40038          LDRSH    r0,[r4,#0x38]
000066  f7fffffe          BL       GUI_ALLOC_h2p
00006a  4680              MOV      r8,r0
;;;1961           memmove(pText + NumBytesNew, pText + NumBytesOld, strlen(pText + NumBytesOld) + 1);
00006c  4407              ADD      r7,r7,r0
00006e  4638              MOV      r0,r7
000070  f7fffffe          BL       strlen
000074  1c42              ADDS     r2,r0,#1
000076  4639              MOV      r1,r7
000078  eb080006          ADD      r0,r8,r6
00007c  f7fffffe          BL       __aeabi_memmove
;;;1962           if (pPrompt) {
000080  ea5f0009          MOVS     r0,r9
000084  d004              BEQ      |L20.144|
;;;1963             memcpy(pText, pPrompt, NumBytesNew);
000086  4601              MOV      r1,r0
000088  4632              MOV      r2,r6
00008a  4640              MOV      r0,r8
00008c  f7fffffe          BL       __aeabi_memcpy
                  |L20.144|
;;;1964           }
;;;1965           pObj->NumCharsPrompt = NumCharsNew;
000090  87e5              STRH     r5,[r4,#0x3e]
;;;1966           _SetCursorPos(hObj, pObj, NumCharsNew);
000092  462a              MOV      r2,r5
000094  4621              MOV      r1,r4
000096  4650              MOV      r0,r10
000098  f7fffffe          BL       _SetCursorPos
;;;1967           _InvalidateTextArea(hObj);
00009c  4650              MOV      r0,r10
00009e  f7fffffe          BL       _InvalidateTextArea
0000a2  f8140f79          LDRB     r0,[r4,#0x79]!
0000a6  f0400007          ORR      r0,r0,#7
0000aa  7020              STRB     r0,[r4,#0]
                  |L20.172|
;;;1968           _InvalidateNumChars(pObj);
;;;1969           _InvalidateNumLines(pObj);
;;;1970           _InvalidateTextSizeX(pObj);
;;;1971         }
;;;1972       }
;;;1973       WM_UNLOCK();
;;;1974     }
;;;1975   }
0000ac  e8bd87f0          POP      {r4-r10,pc}
;;;1976   
                          ENDP


                          AREA ||i.MULTIEDIT_SetReadOnly||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_SetReadOnly PROC
;;;1817   */
;;;1818   void MULTIEDIT_SetReadOnly(MULTIEDIT_HANDLE hObj, int OnOff) {
000000  2201              MOVS     r2,#1
;;;1819     _SetFlag(hObj, OnOff, MULTIEDIT_SF_READONLY);
000002  f7ffbffe          B.W      _SetFlag
;;;1820   }
;;;1821   
                          ENDP


                          AREA ||i.MULTIEDIT_SetText||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_SetText PROC
;;;1724   */
;;;1725   void MULTIEDIT_SetText(MULTIEDIT_HANDLE hObj, const char* pNew) {
000000  b570              PUSH     {r4-r6,lr}
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d008              BEQ      |L22.26|
;;;1726     if (hObj) {
;;;1727       MULTIEDIT_OBJ * pObj;
;;;1728       WM_LOCK();
;;;1729       pObj = MULTIEDIT_H2P(hObj);
000008  f7fffffe          BL       GUI_ALLOC_h2p
00000c  4601              MOV      r1,r0
;;;1730       _SetText(hObj, pObj, pNew);
00000e  462a              MOV      r2,r5
000010  4620              MOV      r0,r4
000012  e8bd4070          POP      {r4-r6,lr}
000016  f7ffbffe          B.W      _SetText
                  |L22.26|
;;;1731       WM_UNLOCK();
;;;1732     }
;;;1733   }
00001a  bd70              POP      {r4-r6,pc}
;;;1734   
                          ENDP


                          AREA ||i.MULTIEDIT_SetTextAlign||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_SetTextAlign PROC
;;;2065   */
;;;2066   void MULTIEDIT_SetTextAlign(MULTIEDIT_HANDLE hObj, int Align) {
000000  b570              PUSH     {r4-r6,lr}
000002  460d              MOV      r5,r1
000004  0006              MOVS     r6,r0
000006  d010              BEQ      |L23.42|
;;;2067     if (hObj) {
;;;2068       MULTIEDIT_OBJ* pObj;
;;;2069       WM_LOCK();
;;;2070       pObj = MULTIEDIT_H2P(hObj);
000008  f7fffffe          BL       GUI_ALLOC_h2p
00000c  4604              MOV      r4,r0
;;;2071       if (pObj->Align != Align) {
00000e  f8b00058          LDRH     r0,[r0,#0x58]
000012  42a8              CMP      r0,r5
000014  d009              BEQ      |L23.42|
;;;2072         pObj->Align = Align;
000016  f8a45058          STRH     r5,[r4,#0x58]
;;;2073         _InvalidateTextArea(hObj);
00001a  4630              MOV      r0,r6
00001c  345a              ADDS     r4,r4,#0x5a
00001e  f7fffffe          BL       _InvalidateTextArea
000022  7fe0              LDRB     r0,[r4,#0x1f]
000024  f040000c          ORR      r0,r0,#0xc
000028  77e0              STRB     r0,[r4,#0x1f]
                  |L23.42|
;;;2074         _InvalidateCursorXY(pObj);
;;;2075         //_InvalidateNumLines(pObj);
;;;2076         _InvalidateTextSizeX(pObj);
;;;2077       }
;;;2078       WM_UNLOCK();
;;;2079     }
;;;2080   }
00002a  bd70              POP      {r4-r6,pc}
;;;2081   
                          ENDP


                          AREA ||i.MULTIEDIT_SetTextColor||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_SetTextColor PROC
;;;1925   */
;;;1926   void MULTIEDIT_SetTextColor(MULTIEDIT_HANDLE hObj, unsigned Index, GUI_COLOR color) {
000000  b570              PUSH     {r4-r6,lr}
000002  4616              MOV      r6,r2
000004  460c              MOV      r4,r1
000006  0005              MOVS     r5,r0
000008  d00b              BEQ      |L24.34|
;;;1927     if (hObj && (Index < NUM_DISP_MODES)) {
00000a  2c02              CMP      r4,#2
00000c  d209              BCS      |L24.34|
;;;1928       MULTIEDIT_OBJ* pObj;
;;;1929       WM_LOCK();
;;;1930       pObj = MULTIEDIT_H2P(hObj);
00000e  f7fffffe          BL       GUI_ALLOC_h2p
;;;1931       pObj->aColor[Index] = color;
000012  eb000084          ADD      r0,r0,r4,LSL #2
;;;1932       WM_Invalidate(hObj);
000016  6306              STR      r6,[r0,#0x30]
000018  4628              MOV      r0,r5
00001a  e8bd4070          POP      {r4-r6,lr}
00001e  f7ffbffe          B.W      WM_InvalidateWindow
                  |L24.34|
;;;1933       WM_UNLOCK();
;;;1934     }
;;;1935   }
000022  bd70              POP      {r4-r6,pc}
;;;1936   
                          ENDP


                          AREA ||i.MULTIEDIT_SetWrapChar||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_SetWrapChar PROC
;;;1793   */
;;;1794   void MULTIEDIT_SetWrapChar(MULTIEDIT_HANDLE hObj) {
000000  2102              MOVS     r1,#2
;;;1795     _SetWrapMode(hObj, GUI_WRAPMODE_CHAR);
000002  f7ffbffe          B.W      _SetWrapMode
;;;1796   }
;;;1797   
                          ENDP


                          AREA ||i.MULTIEDIT_SetWrapNone||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_SetWrapNone PROC
;;;1801   */
;;;1802   void MULTIEDIT_SetWrapNone(MULTIEDIT_HANDLE hObj) {
000000  2100              MOVS     r1,#0
;;;1803     _SetWrapMode(hObj, GUI_WRAPMODE_NONE);
000002  f7ffbffe          B.W      _SetWrapMode
;;;1804   }
;;;1805   
                          ENDP


                          AREA ||i.MULTIEDIT_SetWrapWord||, CODE, READONLY, ALIGN=1

                  MULTIEDIT_SetWrapWord PROC
;;;1785   */
;;;1786   void MULTIEDIT_SetWrapWord(MULTIEDIT_HANDLE hObj) {
000000  2101              MOVS     r1,#1
;;;1787     _SetWrapMode(hObj, GUI_WRAPMODE_WORD);
000002  f7ffbffe          B.W      _SetWrapMode
;;;1788   }
;;;1789   
                          ENDP


                          AREA ||i._AddKey||, CODE, READONLY, ALIGN=1

                  _AddKey PROC
;;;1345   */
;;;1346   static int _AddKey(MULTIEDIT_HANDLE hObj, U16 Key) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  460f              MOV      r7,r1
000006  4606              MOV      r6,r0
;;;1347     int r = 0;               /* Key has not been consumed */
000008  2500              MOVS     r5,#0
;;;1348     MULTIEDIT_OBJ* pObj;
;;;1349     pObj = MULTIEDIT_H2P(hObj);
00000a  f7fffffe          BL       GUI_ALLOC_h2p
00000e  4604              MOV      r4,r0
;;;1350     switch (Key) {
000010  4638              MOV      r0,r7
000012  2f13              CMP      r7,#0x13
000014  d023              BEQ      |L28.94|
000016  dc0c              BGT      |L28.50|
000018  2810              CMP      r0,#0x10
00001a  d02e              BEQ      |L28.122|
00001c  dc04              BGT      |L28.40|
00001e  2808              CMP      r0,#8
000020  d048              BEQ      |L28.180|
000022  2f0d              CMP      r7,#0xd
000024  d17d              BNE      |L28.290|
000026  e069              B        |L28.252|
                  |L28.40|
000028  2811              CMP      r0,#0x11
00002a  d00c              BEQ      |L28.70|
00002c  2f12              CMP      r7,#0x12
00002e  d17c              BNE      |L28.298|
000030  e090              B        |L28.340|
                  |L28.50|
000032  f1a70017          SUB      r0,r7,#0x17
000036  2808              CMP      r0,#8
000038  d277              BCS      |L28.298|
00003a  e8dff000          TBB      [pc,r0]
00003e  2e24              DCB      0x2e,0x24
000040  76769276          DCB      0x76,0x76,0x92,0x76
000044  534a              DCB      0x53,0x4a
                  |L28.70|
000046  466b              MOV      r3,sp
000048  aa01              ADD      r2,sp,#4
00004a  4621              MOV      r1,r4
00004c  4630              MOV      r0,r6
00004e  f7fffffe          BL       _GetCursorXY
000052  6f60              LDR      r0,[r4,#0x74]
000054  f7fffffe          BL       GUI_GetYDistOfFont
000058  9900              LDR      r1,[sp,#0]
00005a  1a0b              SUBS     r3,r1,r0
;;;1351     case GUI_KEY_UP:
;;;1352       _MoveCursorUp(hObj, pObj);
;;;1353       r = 1;               /* Key has been consumed */
;;;1354       break;
00005c  e00a              B        |L28.116|
                  |L28.94|
00005e  466b              MOV      r3,sp
000060  aa01              ADD      r2,sp,#4
000062  4621              MOV      r1,r4
000064  4630              MOV      r0,r6
000066  f7fffffe          BL       _GetCursorXY
00006a  6f60              LDR      r0,[r4,#0x74]
00006c  f7fffffe          BL       GUI_GetYDistOfFont
000070  9900              LDR      r1,[sp,#0]
000072  1843              ADDS     r3,r0,r1
                  |L28.116|
000074  9300              STR      r3,[sp,#0]
000076  9a01              LDR      r2,[sp,#4]
000078  e017              B        |L28.170|
                  |L28.122|
;;;1355     case GUI_KEY_DOWN:
;;;1356       _MoveCursorDown(hObj, pObj);
;;;1357       r = 1;               /* Key has been consumed */
;;;1358       break;
;;;1359     case GUI_KEY_RIGHT:
;;;1360       _SetCursorPos(hObj, pObj, pObj->CursorPosChar + 1);
;;;1361       r = 1;               /* Key has been consumed */
;;;1362       break;
;;;1363     case GUI_KEY_LEFT:
;;;1364       _SetCursorPos(hObj, pObj, pObj->CursorPosChar - 1);
00007a  f8b42048          LDRH     r2,[r4,#0x48]
00007e  4621              MOV      r1,r4
000080  4630              MOV      r0,r6
000082  1e52              SUBS     r2,r2,#1
;;;1365       r = 1;               /* Key has been consumed */
;;;1366       break;
000084  e04e              B        |L28.292|
000086  466b              MOV      r3,sp
000088  aa01              ADD      r2,sp,#4
00008a  4621              MOV      r1,r4
00008c  4630              MOV      r0,r6
00008e  f7fffffe          BL       _GetCursorXY
000092  f64772ff          MOV      r2,#0x7fff
;;;1367     case GUI_KEY_END:
;;;1368       _MoveCursor2LineEnd(hObj, pObj);
;;;1369       r = 1;               /* Key has been consumed */
;;;1370       break;
000096  9b00              LDR      r3,[sp,#0]
000098  e007              B        |L28.170|
00009a  466b              MOV      r3,sp
00009c  aa01              ADD      r2,sp,#4
00009e  4621              MOV      r1,r4
0000a0  4630              MOV      r0,r6
0000a2  f7fffffe          BL       _GetCursorXY
0000a6  9b00              LDR      r3,[sp,#0]
0000a8  2200              MOVS     r2,#0
                  |L28.170|
0000aa  4621              MOV      r1,r4
0000ac  4630              MOV      r0,r6
0000ae  f7fffffe          BL       _SetCursorXY
0000b2  e055              B        |L28.352|
                  |L28.180|
;;;1371     case GUI_KEY_HOME:
;;;1372       _MoveCursor2LinePos1(hObj, pObj);
;;;1373       r = 1;               /* Key has been consumed */
;;;1374       break;
;;;1375     case GUI_KEY_BACKSPACE:
;;;1376       if (!(pObj->Flags & MULTIEDIT_SF_READONLY)) {
0000b4  f8940078          LDRB     r0,[r4,#0x78]
0000b8  07c0              LSLS     r0,r0,#31
0000ba  d152              BNE      |L28.354|
;;;1377         if (pObj->CursorPosChar > pObj->NumCharsPrompt) {
0000bc  f8b42048          LDRH     r2,[r4,#0x48]
0000c0  8fe0              LDRH     r0,[r4,#0x3e]
0000c2  4282              CMP      r2,r0
0000c4  d94c              BLS      |L28.352|
;;;1378           _SetCursorPos(hObj, pObj, pObj->CursorPosChar - 1);
0000c6  4621              MOV      r1,r4
0000c8  4630              MOV      r0,r6
0000ca  1e52              SUBS     r2,r2,#1
0000cc  f7fffffe          BL       _SetCursorPos
;;;1379           _DeleteChar(hObj, pObj);
0000d0  e003              B        |L28.218|
;;;1380         }
;;;1381         r = 1;               /* Key has been consumed */
;;;1382       }
;;;1383       break;
;;;1384     case GUI_KEY_DELETE:
;;;1385       if (!(pObj->Flags & MULTIEDIT_SF_READONLY)) {
0000d2  f8940078          LDRB     r0,[r4,#0x78]
0000d6  07c0              LSLS     r0,r0,#31
0000d8  d143              BNE      |L28.354|
                  |L28.218|
;;;1386         _DeleteChar(hObj, pObj);
0000da  4621              MOV      r1,r4
0000dc  4630              MOV      r0,r6
0000de  f7fffffe          BL       _DeleteChar
;;;1387         r = 1;               /* Key has been consumed */
0000e2  e03d              B        |L28.352|
;;;1388       }
;;;1389       break;
;;;1390     case GUI_KEY_INSERT:
;;;1391       if (!(pObj->Flags & MULTIEDIT_CF_INSERT)) {
0000e4  f8940078          LDRB     r0,[r4,#0x78]
0000e8  0741              LSLS     r1,r0,#29
0000ea  d402              BMI      |L28.242|
;;;1392         pObj->Flags |= MULTIEDIT_CF_INSERT;
0000ec  f0400004          ORR      r0,r0,#4
0000f0  e001              B        |L28.246|
                  |L28.242|
;;;1393       } else {
;;;1394         pObj->Flags &= ~MULTIEDIT_CF_INSERT;
0000f2  f0200004          BIC      r0,r0,#4
                  |L28.246|
0000f6  f8840078          STRB     r0,[r4,#0x78]
0000fa  e031              B        |L28.352|
                  |L28.252|
;;;1395       }
;;;1396       r = 1;               /* Key has been consumed */
;;;1397       break;
;;;1398     case GUI_KEY_ENTER:
;;;1399       if (pObj->Flags & MULTIEDIT_SF_READONLY) {
0000fc  f8940078          LDRB     r0,[r4,#0x78]
000100  07c0              LSLS     r0,r0,#31
000102  d109              BNE      |L28.280|
;;;1400         _MoveCursor2NextLine(hObj, pObj);
;;;1401       } else {
;;;1402         if (_InsertChar(hObj, pObj, (U8)('\n'))) {
000104  220a              MOVS     r2,#0xa
000106  4621              MOV      r1,r4
000108  4630              MOV      r0,r6
00010a  f7fffffe          BL       _InsertChar
00010e  b338              CBZ      r0,|L28.352|
;;;1403           if (pObj->Flags & MULTIEDIT_SF_PASSWORD) {
000110  f8940078          LDRB     r0,[r4,#0x78]
000114  0680              LSLS     r0,r0,#26
000116  d41d              BMI      |L28.340|
                  |L28.280|
;;;1404             _SetCursorPos(hObj, pObj, pObj->CursorPosChar + 1);
;;;1405           } else {
;;;1406             _MoveCursor2NextLine(hObj, pObj);
000118  4621              MOV      r1,r4
00011a  4630              MOV      r0,r6
00011c  f7fffffe          BL       _MoveCursor2NextLine
000120  e01e              B        |L28.352|
                  |L28.290|
000122  e002              B        |L28.298|
                  |L28.292|
000124  f7fffffe          BL       _SetCursorPos
000128  e01a              B        |L28.352|
                  |L28.298|
;;;1407           }
;;;1408         }
;;;1409       }
;;;1410       r = 1;               /* Key has been consumed */
;;;1411       break;
;;;1412     case GUI_KEY_ESCAPE:
;;;1413       break;
;;;1414     default:
;;;1415       if (!(pObj->Flags & MULTIEDIT_SF_READONLY) && (Key >= 0x20)) {
00012a  f8940078          LDRB     r0,[r4,#0x78]
00012e  07c0              LSLS     r0,r0,#31
000130  d117              BNE      |L28.354|
000132  2f20              CMP      r7,#0x20
000134  d315              BCC      |L28.354|
;;;1416         if (_IsOverwriteAtThisChar(hObj, pObj)) {
000136  4621              MOV      r1,r4
000138  4630              MOV      r0,r6
00013a  f7fffffe          BL       _IsOverwriteAtThisChar
00013e  b118              CBZ      r0,|L28.328|
;;;1417           _DeleteChar(hObj, pObj);
000140  4621              MOV      r1,r4
000142  4630              MOV      r0,r6
000144  f7fffffe          BL       _DeleteChar
                  |L28.328|
;;;1418         }
;;;1419         if (_InsertChar(hObj, pObj, Key)) {
000148  463a              MOV      r2,r7
00014a  4621              MOV      r1,r4
00014c  4630              MOV      r0,r6
00014e  f7fffffe          BL       _InsertChar
000152  b128              CBZ      r0,|L28.352|
                  |L28.340|
;;;1420           _SetCursorPos(hObj, pObj, pObj->CursorPosChar + 1);
000154  f8b42048          LDRH     r2,[r4,#0x48]
000158  4621              MOV      r1,r4
00015a  4630              MOV      r0,r6
00015c  1c52              ADDS     r2,r2,#1
00015e  e7e1              B        |L28.292|
                  |L28.352|
;;;1421         }
;;;1422         r = 1;               /* Key has been consumed */
000160  2501              MOVS     r5,#1
                  |L28.354|
;;;1423       }
;;;1424     }
;;;1425     _InvalidateTextArea(hObj);
000162  4630              MOV      r0,r6
000164  f7fffffe          BL       _InvalidateTextArea
;;;1426     return r;
000168  4628              MOV      r0,r5
;;;1427   }
00016a  e8bd81fc          POP      {r2-r8,pc}
;;;1428   
                          ENDP


                          AREA ||i._CalcNextValidCursorPos||, CODE, READONLY, ALIGN=1

                  _CalcNextValidCursorPos PROC
;;;705    */
;;;706    static int _CalcNextValidCursorPos(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj, int CursorPosChar, int * pCursorPosByte, int * pCursorLine) {
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;707      if (pObj->hText) {
000004  f9b10038          LDRSH    r0,[r1,#0x38]
000008  f8ddb038          LDR      r11,[sp,#0x38]        ;706
00000c  4699              MOV      r9,r3                 ;706
00000e  4614              MOV      r4,r2                 ;706
000010  460e              MOV      r6,r1                 ;706
000012  2800              CMP      r0,#0                 ;706
000014  d052              BEQ      |L29.188|
;;;708        char *pNextLine, *pCursor, *pText;
;;;709        int CursorLine, NumChars, CursorPosByte;
;;;710        pText    = (char*) GUI_ALLOC_h2p(pObj->hText);
000016  f7fffffe          BL       GUI_ALLOC_h2p
00001a  4680              MOV      r8,r0
;;;711        NumChars = _GetNumChars(pObj);
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       _GetNumChars
;;;712        /* Set offset in valid range */
;;;713        if (CursorPosChar < pObj->NumCharsPrompt) {
000022  8ff1              LDRH     r1,[r6,#0x3e]
000024  42a1              CMP      r1,r4
000026  dd00              BLE      |L29.42|
;;;714          CursorPosChar = pObj->NumCharsPrompt;
000028  460c              MOV      r4,r1
                  |L29.42|
;;;715        }
;;;716        if (CursorPosChar > NumChars) {
00002a  4284              CMP      r4,r0
00002c  dd00              BLE      |L29.48|
;;;717          CursorPosChar = NumChars;
00002e  4604              MOV      r4,r0
                  |L29.48|
;;;718        }
;;;719        CursorPosByte = GUI_UC__NumChars2NumBytes(pText, CursorPosChar);
000030  4621              MOV      r1,r4
000032  4640              MOV      r0,r8
000034  f7fffffe          BL       GUI_UC__NumChars2NumBytes
000038  4607              MOV      r7,r0
;;;720        CursorLine    = _GetCursorLine(hObj, pObj, pText, CursorPosChar);
00003a  4623              MOV      r3,r4
00003c  4642              MOV      r2,r8
00003e  4631              MOV      r1,r6
000040  9800              LDR      r0,[sp,#0]
000042  f7fffffe          BL       _GetCursorLine
000046  4605              MOV      r5,r0
;;;721        pCursor       = pText + CursorPosByte;
000048  eb080a07          ADD      r10,r8,r7
;;;722        pNextLine     = _GetpLine(hObj, pObj, CursorLine);
00004c  462a              MOV      r2,r5
00004e  4631              MOV      r1,r6
000050  9800              LDR      r0,[sp,#0]
000052  f7fffffe          BL       _GetpLine
;;;723        if (pNextLine > pCursor) {
000056  4550              CMP      r0,r10
000058  d925              BLS      |L29.166|
;;;724          if (pObj->CursorPosChar < CursorPosChar) {
00005a  f8b61048          LDRH     r1,[r6,#0x48]
00005e  42a1              CMP      r1,r4
000060  db0f              BLT      |L29.130|
;;;725            pCursor = pNextLine;
;;;726          } else {
;;;727            char *pPrevLine;
;;;728            int NumChars;
;;;729            pPrevLine  = _GetpLine(hObj, pObj, CursorLine - 1);
000062  1e6a              SUBS     r2,r5,#1
000064  4631              MOV      r1,r6
000066  9800              LDR      r0,[sp,#0]
000068  f7fffffe          BL       _GetpLine
00006c  4604              MOV      r4,r0
;;;730            NumChars   = _WrapGetNumCharsDisp(hObj, pObj, pPrevLine);
00006e  4602              MOV      r2,r0
000070  4631              MOV      r1,r6
000072  9800              LDR      r0,[sp,#0]
000074  f7fffffe          BL       _WrapGetNumCharsDisp
000078  4601              MOV      r1,r0
;;;731            pPrevLine += GUI_UC__NumChars2NumBytes(pPrevLine, NumChars);
00007a  4620              MOV      r0,r4
00007c  f7fffffe          BL       GUI_UC__NumChars2NumBytes
000080  4420              ADD      r0,r0,r4
                  |L29.130|
;;;732            pCursor = pPrevLine;
;;;733          }
;;;734          CursorPosChar = GUI_UC__NumBytes2NumChars(pText, pCursor - pText);
000082  eba00108          SUB      r1,r0,r8
000086  4640              MOV      r0,r8
000088  f7fffffe          BL       GUI_UC__NumBytes2NumChars
00008c  4604              MOV      r4,r0
;;;735          CursorPosByte = GUI_UC__NumChars2NumBytes(pText, CursorPosChar);
00008e  4601              MOV      r1,r0
000090  4640              MOV      r0,r8
000092  f7fffffe          BL       GUI_UC__NumChars2NumBytes
000096  4607              MOV      r7,r0
;;;736          CursorLine    = _GetCursorLine(hObj, pObj, pText, CursorPosChar);
000098  4623              MOV      r3,r4
00009a  4642              MOV      r2,r8
00009c  4631              MOV      r1,r6
00009e  9800              LDR      r0,[sp,#0]
0000a0  f7fffffe          BL       _GetCursorLine
0000a4  4605              MOV      r5,r0
                  |L29.166|
;;;737        }
;;;738        if (pCursorPosByte) {
0000a6  f1b90f00          CMP      r9,#0
0000aa  d001              BEQ      |L29.176|
;;;739          *pCursorPosByte = CursorPosByte;
0000ac  f8c97000          STR      r7,[r9,#0]
                  |L29.176|
;;;740        }
;;;741        if (pCursorLine) {
0000b0  f1bb0f00          CMP      r11,#0
0000b4  d001              BEQ      |L29.186|
;;;742          *pCursorLine = CursorLine;
0000b6  f8cb5000          STR      r5,[r11,#0]
                  |L29.186|
;;;743        }
;;;744        return CursorPosChar;
0000ba  4620              MOV      r0,r4
                  |L29.188|
;;;745      }
;;;746      return 0;
;;;747    }
0000bc  b004              ADD      sp,sp,#0x10
0000be  e8bd9ff0          POP      {r4-r12,pc}
;;;748    
                          ENDP


                          AREA ||i._CalcScrollParas||, CODE, READONLY, ALIGN=1

                  _CalcScrollParas PROC
;;;584    */
;;;585    static void _CalcScrollParas(MULTIEDIT_HANDLE hObj) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;586      MULTIEDIT_OBJ* pObj = MULTIEDIT_H2P(hObj);
000004  f7fffffe          BL       GUI_ALLOC_h2p
000008  4604              MOV      r4,r0
;;;587      /* Calc vertical scroll parameters */
;;;588      pObj->ScrollStateV.NumItems = _GetNumLines(hObj, pObj);
00000a  4601              MOV      r1,r0
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       _GetNumLines
;;;589      pObj->ScrollStateV.PageSize = _GetNumVisLines(hObj, pObj);
000012  65e0              STR      r0,[r4,#0x5c]
000014  4621              MOV      r1,r4
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       _GetNumVisLines
;;;590      /* Calc horizontal scroll parameters */
;;;591      pObj->ScrollStateH.NumItems = _GetTextSizeX(hObj, pObj);
00001c  6660              STR      r0,[r4,#0x64]
00001e  4621              MOV      r1,r4
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       _GetTextSizeX
;;;592      pObj->ScrollStateH.PageSize = _GetXSize(hObj, pObj);
000026  66a0              STR      r0,[r4,#0x68]
000028  4621              MOV      r1,r4
00002a  4628              MOV      r0,r5
00002c  f7fffffe          BL       _GetXSize
;;;593      _CalcScrollPos(hObj, pObj);
000030  6720              STR      r0,[r4,#0x70]
000032  4621              MOV      r1,r4
000034  4628              MOV      r0,r5
000036  e8bd4070          POP      {r4-r6,lr}
00003a  f7ffbffe          B.W      _CalcScrollPos
;;;594    }
;;;595    
                          ENDP


                          AREA ||i._CalcScrollPos||, CODE, READONLY, ALIGN=1

                  _CalcScrollPos PROC
;;;467    */
;;;468    static void _CalcScrollPos(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj) {
000000  b57c              PUSH     {r2-r6,lr}
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;469      int xCursor, yCursor;
;;;470      _GetCursorXY(hObj, pObj, &xCursor, &yCursor);
000006  466b              MOV      r3,sp
000008  aa01              ADD      r2,sp,#4
00000a  f7fffffe          BL       _GetCursorXY
;;;471      yCursor /= GUI_GetYDistOfFont(pObj->pFont);
00000e  6f60              LDR      r0,[r4,#0x74]
000010  f7fffffe          BL       GUI_GetYDistOfFont
000014  9900              LDR      r1,[sp,#0]
;;;472      WM_CheckScrollPos(&pObj->ScrollStateV, yCursor, 0, 0);       /* Vertical */
000016  2300              MOVS     r3,#0
000018  fb91f1f0          SDIV     r1,r1,r0              ;471
00001c  461a              MOV      r2,r3
00001e  f104005c          ADD      r0,r4,#0x5c
000022  9100              STR      r1,[sp,#0]
000024  f7fffffe          BL       WM_CheckScrollPos
;;;473      if (pObj->Align == GUI_TA_RIGHT) {
000028  f8b40058          LDRH     r0,[r4,#0x58]
00002c  2801              CMP      r0,#1
00002e  d106              BNE      |L31.62|
;;;474        xCursor = _GetXSize(hObj, pObj) - xCursor;
000030  4621              MOV      r1,r4
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       _GetXSize
000038  9901              LDR      r1,[sp,#4]
00003a  1a40              SUBS     r0,r0,r1
00003c  9001              STR      r0,[sp,#4]
                  |L31.62|
;;;475      }
;;;476      WM_CheckScrollPos(&pObj->ScrollStateH, xCursor, 30, 30);     /* Horizontal */
00003e  231e              MOVS     r3,#0x1e
000040  461a              MOV      r2,r3
000042  f1040068          ADD      r0,r4,#0x68
000046  9901              LDR      r1,[sp,#4]
000048  f7fffffe          BL       WM_CheckScrollPos
;;;477      _SetScrollState(hObj);
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       _SetScrollState
;;;478    }
000052  bd7c              POP      {r2-r6,pc}
;;;479    
                          ENDP


                          AREA ||i._ClearCache||, CODE, READONLY, ALIGN=1

                  _ClearCache PROC
;;;356    */
;;;357    static void _ClearCache(MULTIEDIT_OBJ* pObj) {
000000  2100              MOVS     r1,#0
;;;358      pObj->CacheLineNumber = 0;
000002  f8a01052          STRH     r1,[r0,#0x52]
;;;359      pObj->CacheLinePosByte = 0;
000006  f8201f50          STRH     r1,[r0,#0x50]!
;;;360      pObj->CacheFirstVisibleByte = 0;
00000a  80c1              STRH     r1,[r0,#6]
;;;361      pObj->CacheFirstVisibleLine = 0;
00000c  8081              STRH     r1,[r0,#4]
;;;362    }
00000e  4770              BX       lr
;;;363    
                          ENDP


                          AREA ||i._DeleteChar||, CODE, READONLY, ALIGN=1

                  _DeleteChar PROC
;;;1100   */
;;;1101   static void _DeleteChar(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4681              MOV      r9,r0
;;;1102     if (pObj->hText) {
000006  f9b10038          LDRSH    r0,[r1,#0x38]
00000a  460c              MOV      r4,r1                 ;1101
00000c  2800              CMP      r0,#0                 ;1101
00000e  d04b              BEQ      |L33.168|
;;;1103       unsigned CursorOffset;
;;;1104       char* s;
;;;1105       s = (char*) GUI_ALLOC_h2p(pObj->hText);
000010  f7fffffe          BL       GUI_ALLOC_h2p
000014  4680              MOV      r8,r0
;;;1106       CursorOffset = pObj->CursorPosByte;
000016  f8b4504a          LDRH     r5,[r4,#0x4a]
;;;1107       if (CursorOffset < strlen(s)) {
00001a  f7fffffe          BL       strlen
00001e  42a8              CMP      r0,r5
000020  d942              BLS      |L33.168|
;;;1108         char *pCursor, *pLine, *pEndLine;
;;;1109         int CursorLine, NumChars, NumBytes;
;;;1110         pCursor    = s + CursorOffset;
000022  eb080605          ADD      r6,r8,r5
;;;1111         CursorLine = pObj->CursorLine;
000026  f8b42046          LDRH     r2,[r4,#0x46]
;;;1112         pLine      = _GetpLine(hObj, pObj, CursorLine);
00002a  4621              MOV      r1,r4
00002c  4648              MOV      r0,r9
00002e  f7fffffe          BL       _GetpLine
000032  4605              MOV      r5,r0
;;;1113         NumChars   = _WrapGetNumCharsDisp(hObj, pObj, pLine);
000034  4602              MOV      r2,r0
000036  4621              MOV      r1,r4
000038  4648              MOV      r0,r9
00003a  f7fffffe          BL       _WrapGetNumCharsDisp
00003e  4601              MOV      r1,r0
;;;1114         pEndLine   = pLine + GUI_UC__NumChars2NumBytes(pLine, NumChars);
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       GUI_UC__NumChars2NumBytes
000046  1947              ADDS     r7,r0,r5
;;;1115         pLine      = pLine + _WrapGetNumBytesToNextLine(hObj, pObj, pLine);
000048  462a              MOV      r2,r5
00004a  4621              MOV      r1,r4
00004c  4648              MOV      r0,r9
00004e  f7fffffe          BL       _WrapGetNumBytesToNextLine
000052  4428              ADD      r0,r0,r5
;;;1116         if (pCursor == pEndLine) {
000054  42be              CMP      r6,r7
000056  d101              BNE      |L33.92|
;;;1117           NumBytes = pLine - pEndLine;
000058  1bc5              SUBS     r5,r0,r7
00005a  e003              B        |L33.100|
                  |L33.92|
;;;1118         } else {
;;;1119           NumBytes = GUI_UC_GetCharSize(pCursor);
00005c  4630              MOV      r0,r6
00005e  f7fffffe          BL       GUI_UC_GetCharSize
000062  4605              MOV      r5,r0
                  |L33.100|
;;;1120         }
;;;1121         NumChars = GUI_UC__NumBytes2NumChars(pCursor, NumBytes);
000064  4629              MOV      r1,r5
000066  4630              MOV      r0,r6
000068  f7fffffe          BL       GUI_UC__NumBytes2NumChars
00006c  4607              MOV      r7,r0
;;;1122         strcpy(pCursor, pCursor + NumBytes);
00006e  1971              ADDS     r1,r6,r5
000070  4630              MOV      r0,r6
000072  f7fffffe          BL       strcpy
;;;1123         WM_NotifyParent(hObj, WM_NOTIFICATION_VALUE_CHANGED);
000076  2105              MOVS     r1,#5
000078  4648              MOV      r0,r9
00007a  f7fffffe          BL       WM_NotifyParent
;;;1124         pObj->NumChars -= NumChars;
00007e  8fa0              LDRH     r0,[r4,#0x3c]
000080  1bc0              SUBS     r0,r0,r7
000082  87a0              STRH     r0,[r4,#0x3c]
000084  f8940079          LDRB     r0,[r4,#0x79]
000088  f040000e          ORR      r0,r0,#0xe
00008c  f8840079          STRB     r0,[r4,#0x79]
;;;1125         _InvalidateNumLines(pObj);
;;;1126         _InvalidateTextSizeX(pObj);
;;;1127         _InvalidateCursorXY(pObj); /* Invalidate X/Y position */
;;;1128         _ClearCache(pObj);
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       _ClearCache
;;;1129         pObj->CursorLine = _GetCursorLine(hObj, pObj, s, pObj->CursorPosChar);
000096  f8b43048          LDRH     r3,[r4,#0x48]
00009a  4642              MOV      r2,r8
00009c  4621              MOV      r1,r4
00009e  4648              MOV      r0,r9
0000a0  f7fffffe          BL       _GetCursorLine
0000a4  f8a40046          STRH     r0,[r4,#0x46]
                  |L33.168|
;;;1130       }
;;;1131     }
;;;1132   }
0000a8  e8bd87f0          POP      {r4-r10,pc}
;;;1133   
                          ENDP


                          AREA ||i._DispString||, CODE, READONLY, ALIGN=1

                  _DispString PROC
;;;291    */
;;;292    static void _DispString(MULTIEDIT_HANDLE hObj, const MULTIEDIT_OBJ* pObj, const char* pText, GUI_RECT* pRect) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  461f              MOV      r7,r3
000006  4690              MOV      r8,r2
000008  460c              MOV      r4,r1
;;;293      int NumCharsDisp;
;;;294      NumCharsDisp = _WrapGetNumCharsDisp(hObj, pObj, pText);
00000a  f7fffffe          BL       _WrapGetNumCharsDisp
00000e  4605              MOV      r5,r0
;;;295      if (pObj->Flags & MULTIEDIT_SF_PASSWORD) {
000010  f8940078          LDRB     r0,[r4,#0x78]
000014  0680              LSLS     r0,r0,#26
000016  d525              BPL      |L34.100|
;;;296        int x, NumCharsPrompt, NumCharsLeft = 0;
000018  2600              MOVS     r6,#0
;;;297        NumCharsPrompt = _GetNumCharsInPrompt(pObj, pText);
00001a  4641              MOV      r1,r8
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       _GetNumCharsInPrompt
000022  4604              MOV      r4,r0
;;;298        if (NumCharsDisp < NumCharsPrompt) {
000024  42a5              CMP      r5,r4
000026  da01              BGE      |L34.44|
;;;299          NumCharsPrompt = NumCharsDisp;
000028  462c              MOV      r4,r5
00002a  e000              B        |L34.46|
                  |L34.44|
;;;300        } else {
;;;301          NumCharsLeft = NumCharsDisp - NumCharsPrompt;
00002c  1b2e              SUBS     r6,r5,r4
                  |L34.46|
;;;302        }
;;;303        GUI_DispStringInRectMax(pText, pRect, GUI_TA_LEFT, NumCharsPrompt);
00002e  4623              MOV      r3,r4
000030  2200              MOVS     r2,#0
000032  4639              MOV      r1,r7
000034  4640              MOV      r0,r8
000036  f7fffffe          BL       GUI_DispStringInRectMax
;;;304        x = pRect->x0 + GUI__GetLineDistX(pText, NumCharsPrompt);
00003a  4621              MOV      r1,r4
00003c  4640              MOV      r0,r8
00003e  f7fffffe          BL       GUI__GetLineDistX
000042  f9b71000          LDRSH    r1,[r7,#0]
;;;305        if (NumCharsLeft) {
000046  2e00              CMP      r6,#0
000048  4408              ADD      r0,r0,r1              ;304
00004a  d014              BEQ      |L34.118|
;;;306          GUI_DispCharAt(MULTIEDIT_PASSWORD_CHAR, x, pRect->y0);
00004c  b201              SXTH     r1,r0
00004e  f9b72002          LDRSH    r2,[r7,#2]
000052  202a              MOVS     r0,#0x2a
000054  f7fffffe          BL       GUI_DispCharAt
;;;307          GUI_DispChars(MULTIEDIT_PASSWORD_CHAR, NumCharsLeft - 1);
000058  1e71              SUBS     r1,r6,#1
00005a  e8bd41f0          POP      {r4-r8,lr}
00005e  202a              MOVS     r0,#0x2a
000060  f7ffbffe          B.W      GUI_DispChars
                  |L34.100|
;;;308        }
;;;309      } else {
;;;310        GUI_DispStringInRectMax(pText, pRect, pObj->Align, NumCharsDisp);
000064  f8b42058          LDRH     r2,[r4,#0x58]
000068  462b              MOV      r3,r5
00006a  4639              MOV      r1,r7
00006c  4640              MOV      r0,r8
00006e  e8bd41f0          POP      {r4-r8,lr}
000072  f7ffbffe          B.W      GUI_DispStringInRectMax
                  |L34.118|
;;;311      }
;;;312    }
000076  e8bd81f0          POP      {r4-r8,pc}
;;;313    
                          ENDP


                          AREA ||i._GetCharDistX||, CODE, READONLY, ALIGN=1

                  _GetCharDistX PROC
;;;275    */
;;;276    static int _GetCharDistX(const MULTIEDIT_OBJ* pObj, const char* pText) {
000000  b510              PUSH     {r4,lr}
000002  460c              MOV      r4,r1
;;;277      int r;
;;;278      if ((pObj->Flags & MULTIEDIT_SF_PASSWORD) && (_GetNumCharsInPrompt(pObj, pText) == 0)) {
000004  f8901078          LDRB     r1,[r0,#0x78]
000008  0689              LSLS     r1,r1,#26
00000a  d503              BPL      |L35.20|
00000c  4621              MOV      r1,r4
00000e  f7fffffe          BL       _GetNumCharsInPrompt
000012  b130              CBZ      r0,|L35.34|
                  |L35.20|
;;;279        r = GUI_GetCharDistX(MULTIEDIT_PASSWORD_CHAR);
;;;280      } else {
;;;281        U16 c;
;;;282        c = GUI_UC_GetCharCode(pText);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       GUI_UC_GetCharCode
                  |L35.26|
;;;283        r = GUI_GetCharDistX(c);
00001a  e8bd4010          POP      {r4,lr}
00001e  f7ffbffe          B.W      GUI_GetCharDistX
                  |L35.34|
000022  202a              MOVS     r0,#0x2a              ;279
000024  e7f9              B        |L35.26|
;;;284      }
;;;285      return r;
;;;286    }
;;;287    
                          ENDP


                          AREA ||i._GetCursorLine||, CODE, READONLY, ALIGN=1

                  _GetCursorLine PROC
;;;369    */
;;;370    static int _GetCursorLine(MULTIEDIT_HANDLE hObj, const MULTIEDIT_OBJ* pObj, const char* pText, int CursorPosChar) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4688              MOV      r8,r1
000006  4681              MOV      r9,r0
000008  4614              MOV      r4,r2
;;;371      const char *pCursor;
;;;372      const char *pEndLine;
;;;373      int NumChars, ByteOffsetNewCursor, LineNumber = 0;
00000a  2500              MOVS     r5,#0
;;;374      ByteOffsetNewCursor = GUI_UC__NumChars2NumBytes(pText, CursorPosChar);
00000c  4619              MOV      r1,r3
00000e  4610              MOV      r0,r2
000010  f7fffffe          BL       GUI_UC__NumChars2NumBytes
;;;375      pCursor = pText + ByteOffsetNewCursor;
;;;376      if (pObj->CacheLinePosByte < ByteOffsetNewCursor) {
000014  f8b81050          LDRH     r1,[r8,#0x50]
000018  1826              ADDS     r6,r4,r0              ;375
00001a  4281              CMP      r1,r0
00001c  da1e              BGE      |L36.92|
;;;377        /* If cache pos < new position we can use it as start position */
;;;378        pText      += pObj->CacheLinePosByte;
00001e  440c              ADD      r4,r4,r1
;;;379        LineNumber += pObj->CacheLineNumber;
000020  f8b85052          LDRH     r5,[r8,#0x52]
000024  e01a              B        |L36.92|
                  |L36.38|
;;;380      }
;;;381      while (*pText && (pCursor > pText)) {
;;;382        NumChars = _WrapGetNumCharsDisp(hObj, pObj, pText);
000026  4622              MOV      r2,r4
000028  4641              MOV      r1,r8
00002a  4648              MOV      r0,r9
00002c  f7fffffe          BL       _WrapGetNumCharsDisp
000030  4601              MOV      r1,r0
;;;383        pEndLine = pText + GUI_UC__NumChars2NumBytes(pText, NumChars);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       GUI_UC__NumChars2NumBytes
000038  1907              ADDS     r7,r0,r4
;;;384        pText   += _WrapGetNumBytesToNextLine(hObj, pObj, pText);
00003a  4622              MOV      r2,r4
00003c  4641              MOV      r1,r8
00003e  4648              MOV      r0,r9
000040  f7fffffe          BL       _WrapGetNumBytesToNextLine
000044  4404              ADD      r4,r4,r0
;;;385        if (pCursor <= pEndLine) {
000046  42be              CMP      r6,r7
000048  d807              BHI      |L36.90|
;;;386          if ((pCursor == pEndLine) && (pEndLine == pText) && *pText) {
00004a  42be              CMP      r6,r7
00004c  d10a              BNE      |L36.100|
00004e  42a7              CMP      r7,r4
000050  d108              BNE      |L36.100|
000052  7820              LDRB     r0,[r4,#0]
000054  b130              CBZ      r0,|L36.100|
000056  1c6d              ADDS     r5,r5,#1
;;;387            LineNumber++;
000058  e004              B        |L36.100|
                  |L36.90|
00005a  1c6d              ADDS     r5,r5,#1
                  |L36.92|
00005c  7820              LDRB     r0,[r4,#0]            ;381
00005e  b108              CBZ      r0,|L36.100|
000060  42a6              CMP      r6,r4                 ;381
000062  d8e0              BHI      |L36.38|
                  |L36.100|
;;;388          }
;;;389          break;
;;;390        }
;;;391        LineNumber++;
;;;392      }
;;;393      return LineNumber;
000064  4628              MOV      r0,r5
;;;394    }
000066  e8bd87f0          POP      {r4-r10,pc}
;;;395    
                          ENDP


                          AREA ||i._GetCursorXY||, CODE, READONLY, ALIGN=1

                  _GetCursorXY PROC
;;;399    */
;;;400    static void _GetCursorXY(MULTIEDIT_HANDLE hObj, /*const*/ MULTIEDIT_OBJ* pObj, int* px, int* py) {
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;401      if (pObj->InvalidFlags & INVALID_CURSORXY) {
000004  f8910079          LDRB     r0,[r1,#0x79]
000008  469b              MOV      r11,r3                ;400
00000a  460c              MOV      r4,r1                 ;400
00000c  0700              LSLS     r0,r0,#28
00000e  d55c              BPL      |L37.202|
;;;402        int CursorLine = 0, x = 0;
000010  f04f0800          MOV      r8,#0
000014  4646              MOV      r6,r8
;;;403        GUI_SetFont(pObj->pFont);
000016  6f60              LDR      r0,[r4,#0x74]
000018  f7fffffe          BL       GUI_SetFont
;;;404        if (pObj->hText) {
00001c  f9b40038          LDRSH    r0,[r4,#0x38]
000020  b3f0              CBZ      r0,|L37.160|
;;;405          const char *pLine;
;;;406          const char *pCursor;
;;;407          pLine      = (const char *)GUI_ALLOC_h2p(pObj->hText);
000022  f7fffffe          BL       GUI_ALLOC_h2p
;;;408          pCursor    = pLine + pObj->CursorPosByte;
000026  f8b4104a          LDRH     r1,[r4,#0x4a]
;;;409          CursorLine = pObj->CursorLine;
00002a  f8b48046          LDRH     r8,[r4,#0x46]
00002e  180f              ADDS     r7,r1,r0              ;408
;;;410          pLine      = _GetpLine(hObj, pObj, CursorLine);
000030  4642              MOV      r2,r8
000032  4621              MOV      r1,r4
000034  9800              LDR      r0,[sp,#0]
000036  f7fffffe          BL       _GetpLine
00003a  4605              MOV      r5,r0
;;;411          if ((pObj->Flags & MULTIEDIT_SF_PASSWORD)) {
00003c  f8940078          LDRB     r0,[r4,#0x78]
000040  0680              LSLS     r0,r0,#26
000042  d409              BMI      |L37.88|
000044  e00b              B        |L37.94|
                  |L37.70|
;;;412            while (pLine < pCursor) {
;;;413              x     += _GetCharDistX(pObj, pLine);
000046  4629              MOV      r1,r5
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       _GetCharDistX
00004e  4406              ADD      r6,r6,r0
;;;414              pLine += GUI_UC_GetCharSize(pLine);
000050  4628              MOV      r0,r5
000052  f7fffffe          BL       GUI_UC_GetCharSize
000056  4405              ADD      r5,r5,r0
                  |L37.88|
000058  42bd              CMP      r5,r7                 ;412
00005a  d3f4              BCC      |L37.70|
00005c  e027              B        |L37.174|
                  |L37.94|
;;;415            }
;;;416          } else {
;;;417            int xSize;
;;;418            const char *p;
;;;419            int NumChars = 0, NumCharsToNextLine;
00005e  2600              MOVS     r6,#0
;;;420            xSize = _GetXSize(hObj, pObj);
000060  4621              MOV      r1,r4
000062  9800              LDR      r0,[sp,#0]
000064  f7fffffe          BL       _GetXSize
000068  4681              MOV      r9,r0
;;;421            p = pLine;
00006a  46aa              MOV      r10,r5
;;;422            while (pLine < pCursor) {
00006c  e004              B        |L37.120|
                  |L37.110|
;;;423              NumChars++;
;;;424              pLine += GUI_UC_GetCharSize(pLine);
00006e  4628              MOV      r0,r5
000070  1c76              ADDS     r6,r6,#1
000072  f7fffffe          BL       GUI_UC_GetCharSize
000076  4405              ADD      r5,r5,r0
                  |L37.120|
000078  42bd              CMP      r5,r7                 ;422
00007a  d3f8              BCC      |L37.110|
;;;425            }
;;;426            NumCharsToNextLine = _WrapGetNumCharsDisp(hObj, pObj, p);
00007c  4652              MOV      r2,r10
00007e  4621              MOV      r1,r4
000080  9800              LDR      r0,[sp,#0]
000082  f7fffffe          BL       _WrapGetNumCharsDisp
000086  4605              MOV      r5,r0
;;;427            x = GUI__GetCursorPosX(p, NumChars, NumCharsToNextLine);
000088  4602              MOV      r2,r0
00008a  4631              MOV      r1,r6
00008c  4650              MOV      r0,r10
00008e  f7fffffe          BL       GUI__GetCursorPosX
000092  4606              MOV      r6,r0
;;;428            if (pObj->Align == GUI_TA_RIGHT) {
000094  f8b40058          LDRH     r0,[r4,#0x58]
000098  2801              CMP      r0,#1
00009a  d108              BNE      |L37.174|
;;;429              x += xSize - GUI__GetLineDistX(p, NumCharsToNextLine);
00009c  4629              MOV      r1,r5
00009e  e000              B        |L37.162|
                  |L37.160|
0000a0  e005              B        |L37.174|
                  |L37.162|
0000a2  4650              MOV      r0,r10
0000a4  f7fffffe          BL       GUI__GetLineDistX
0000a8  eba90000          SUB      r0,r9,r0
0000ac  4406              ADD      r6,r6,r0
                  |L37.174|
;;;430            }
;;;431          }
;;;432        }
;;;433        pObj->CursorPosX = x;
0000ae  f8a4604c          STRH     r6,[r4,#0x4c]
;;;434        pObj->CursorPosY = CursorLine * GUI_GetFontDistY();
0000b2  f7fffffe          BL       GUI_GetFontDistY
0000b6  fb00f008          MUL      r0,r0,r8
0000ba  f8a4004e          STRH     r0,[r4,#0x4e]
;;;435        pObj->InvalidFlags &= ~INVALID_CURSORXY;
0000be  f8940079          LDRB     r0,[r4,#0x79]
0000c2  f0200008          BIC      r0,r0,#8
0000c6  f8840079          STRB     r0,[r4,#0x79]
                  |L37.202|
;;;436      }
;;;437      *px = pObj->CursorPosX;
0000ca  9802              LDR      r0,[sp,#8]
0000cc  f9341f4c          LDRSH    r1,[r4,#0x4c]!
;;;438      *py = pObj->CursorPosY;
0000d0  6001              STR      r1,[r0,#0]
0000d2  8861              LDRH     r1,[r4,#2]
0000d4  f8cb1000          STR      r1,[r11,#0]
;;;439    }
0000d8  e8bd9fff          POP      {r0-r12,pc}
;;;440    
                          ENDP


                          AREA ||i._GetNumChars||, CODE, READONLY, ALIGN=1

                  _GetNumChars PROC
;;;174    */
;;;175    static int _GetNumChars(MULTIEDIT_OBJ * pObj) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;176      if (pObj->InvalidFlags & INVALID_NUMCHARS) {
000004  f8900079          LDRB     r0,[r0,#0x79]
000008  07c0              LSLS     r0,r0,#31
00000a  d00c              BEQ      |L38.38|
;;;177        char * pText;
;;;178        pText = (char*) GUI_ALLOC_h2p(pObj->hText);
00000c  f9b40038          LDRSH    r0,[r4,#0x38]
000010  f7fffffe          BL       GUI_ALLOC_h2p
;;;179        pObj->NumChars = GUI__GetNumChars(pText);
000014  f7fffffe          BL       GUI__GetNumChars
000018  87a0              STRH     r0,[r4,#0x3c]
;;;180        pObj->InvalidFlags &= ~INVALID_NUMCHARS;
00001a  f8940079          LDRB     r0,[r4,#0x79]
00001e  f0200001          BIC      r0,r0,#1
000022  f8840079          STRB     r0,[r4,#0x79]
                  |L38.38|
;;;181      }
;;;182      return pObj->NumChars;
000026  8fa0              LDRH     r0,[r4,#0x3c]
;;;183    }
000028  bd10              POP      {r4,pc}
;;;184    
                          ENDP


                          AREA ||i._GetNumCharsInPrompt||, CODE, READONLY, ALIGN=1

                  _GetNumCharsInPrompt PROC
;;;200    */
;;;201    static int _GetNumCharsInPrompt(const MULTIEDIT_OBJ* pObj, const char GUI_UNI_PTR * pText) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;202      char *pString, *pEndPrompt;
;;;203      int r = 0;
000008  2700              MOVS     r7,#0
;;;204      pString = (char*) GUI_ALLOC_h2p(pObj->hText);
00000a  f9b00038          LDRSH    r0,[r0,#0x38]
00000e  f7fffffe          BL       GUI_ALLOC_h2p
000012  4606              MOV      r6,r0
;;;205      pEndPrompt = pString + GUI_UC__NumChars2NumBytes(pString, pObj->NumCharsPrompt);
000014  8fe9              LDRH     r1,[r5,#0x3e]
000016  f7fffffe          BL       GUI_UC__NumChars2NumBytes
00001a  4430              ADD      r0,r0,r6
;;;206      if (pText < pEndPrompt) {
00001c  4284              CMP      r4,r0
00001e  d204              BCS      |L39.42|
;;;207        r = GUI_UC__NumBytes2NumChars(pText, pEndPrompt - pText);
000020  1b01              SUBS     r1,r0,r4
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       GUI_UC__NumBytes2NumChars
000028  4607              MOV      r7,r0
                  |L39.42|
;;;208      }
;;;209      return r;
00002a  4638              MOV      r0,r7
;;;210    }
00002c  e8bd81f0          POP      {r4-r8,pc}
;;;211    
                          ENDP


                          AREA ||i._GetNumLines||, CODE, READONLY, ALIGN=1

                  _GetNumLines PROC
;;;532    */
;;;533    static int _GetNumLines(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ * pObj) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4680              MOV      r8,r0
;;;534      if (pObj->InvalidFlags & INVALID_NUMLINES) {
000006  f8910079          LDRB     r0,[r1,#0x79]
00000a  460c              MOV      r4,r1                 ;533
00000c  0780              LSLS     r0,r0,#30
00000e  d529              BPL      |L40.100|
;;;535        int NumLines = 0;
;;;536        if (pObj->hText) {
000010  f9b40038          LDRSH    r0,[r4,#0x38]
000014  2600              MOVS     r6,#0                 ;535
000016  b1e0              CBZ      r0,|L40.82|
;;;537          int NumChars, NumBytes;
;;;538          char *pText;
;;;539          U16 Char;
;;;540          pText = (char*) GUI_ALLOC_h2p(pObj->hText);
000018  f7fffffe          BL       GUI_ALLOC_h2p
00001c  4605              MOV      r5,r0
;;;541          GUI_SetFont(pObj->pFont);
00001e  6f60              LDR      r0,[r4,#0x74]
000020  f7fffffe          BL       GUI_SetFont
                  |L40.36|
;;;542          do {
;;;543            NumChars = _WrapGetNumCharsDisp(hObj, pObj, pText);
000024  462a              MOV      r2,r5
000026  4621              MOV      r1,r4
000028  4640              MOV      r0,r8
00002a  f7fffffe          BL       _WrapGetNumCharsDisp
00002e  4601              MOV      r1,r0
;;;544            NumBytes = GUI_UC__NumChars2NumBytes(pText, NumChars);
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       GUI_UC__NumChars2NumBytes
;;;545            Char     = GUI_UC_GetCharCode(pText + NumBytes);
000036  4428              ADD      r0,r0,r5
000038  f7fffffe          BL       GUI_UC_GetCharCode
00003c  0007              MOVS     r7,r0
;;;546            if (Char) {
00003e  d000              BEQ      |L40.66|
000040  1c76              ADDS     r6,r6,#1
                  |L40.66|
;;;547              NumLines++;
;;;548            }
;;;549            pText += _WrapGetNumBytesToNextLine(hObj, pObj, pText);
000042  462a              MOV      r2,r5
000044  4621              MOV      r1,r4
000046  4640              MOV      r0,r8
000048  f7fffffe          BL       _WrapGetNumBytesToNextLine
00004c  4405              ADD      r5,r5,r0
;;;550          } while (Char);
00004e  2f00              CMP      r7,#0
000050  d1e8              BNE      |L40.36|
                  |L40.82|
000052  1c76              ADDS     r6,r6,#1
;;;551        }
;;;552        pObj->NumLines = NumLines + 1;
000054  f8a46040          STRH     r6,[r4,#0x40]
;;;553        pObj->InvalidFlags &= ~INVALID_NUMLINES;
000058  f8940079          LDRB     r0,[r4,#0x79]
00005c  f0200002          BIC      r0,r0,#2
000060  f8840079          STRB     r0,[r4,#0x79]
                  |L40.100|
;;;554      }
;;;555      return pObj->NumLines;
000064  f8b40040          LDRH     r0,[r4,#0x40]
;;;556    }
000068  e8bd81f0          POP      {r4-r8,pc}
;;;557    
                          ENDP


                          AREA ||i._GetNumVisLines||, CODE, READONLY, ALIGN=1

                  _GetNumVisLines PROC
;;;520    */
;;;521    static int _GetNumVisLines(MULTIEDIT_HANDLE hObj, const MULTIEDIT_OBJ* pObj) {
000000  b51c              PUSH     {r2-r4,lr}
000002  460c              MOV      r4,r1
;;;522      GUI_RECT Rect;
;;;523      WM_GetInsideRectExScrollbar(hObj, &Rect);
000004  4669              MOV      r1,sp
000006  f7fffffe          BL       WM_GetInsideRectExScrollbar
;;;524      return (Rect.y1 - Rect.y0 + 1) / GUI_GetYDistOfFont(pObj->pFont);
00000a  6f60              LDR      r0,[r4,#0x74]
00000c  f7fffffe          BL       GUI_GetYDistOfFont
000010  f9bd1006          LDRSH    r1,[sp,#6]
000014  f9bd2002          LDRSH    r2,[sp,#2]
000018  1a89              SUBS     r1,r1,r2
00001a  1c49              ADDS     r1,r1,#1
00001c  fb91f0f0          SDIV     r0,r1,r0
;;;525    }
000020  bd1c              POP      {r2-r4,pc}
;;;526    
                          ENDP


                          AREA ||i._GetTextSizeX||, CODE, READONLY, ALIGN=1

                  _GetTextSizeX PROC
;;;485    */
;;;486    static int _GetTextSizeX(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4681              MOV      r9,r0
;;;487      if (pObj->InvalidFlags & INVALID_TEXTSIZE) {
000006  f8910079          LDRB     r0,[r1,#0x79]
00000a  460c              MOV      r4,r1                 ;486
00000c  0740              LSLS     r0,r0,#29
00000e  d53f              BPL      |L42.144|
;;;488        pObj->TextSizeX = 0;
000010  2000              MOVS     r0,#0
000012  f8a40042          STRH     r0,[r4,#0x42]
;;;489        if (pObj->hText) {
000016  8f20              LDRH     r0,[r4,#0x38]
000018  b3a0              CBZ      r0,|L42.132|
;;;490          int NumChars, xSizeLine;
;;;491          char *pText, *pLine;
;;;492          GUI_SetFont(pObj->pFont);
00001a  6f60              LDR      r0,[r4,#0x74]
00001c  f7fffffe          BL       GUI_SetFont
;;;493          pText = (char*) GUI_ALLOC_h2p(pObj->hText);
000020  f9b40038          LDRSH    r0,[r4,#0x38]
000024  f7fffffe          BL       GUI_ALLOC_h2p
000028  4606              MOV      r6,r0
                  |L42.42|
;;;494          do {
;;;495            NumChars = _WrapGetNumCharsDisp(hObj, pObj, pText);
00002a  4632              MOV      r2,r6
00002c  4621              MOV      r1,r4
00002e  4648              MOV      r0,r9
000030  f7fffffe          BL       _WrapGetNumCharsDisp
000034  4607              MOV      r7,r0
;;;496            xSizeLine = 0;
;;;497            pLine = pText;
;;;498            if (pObj->Flags & MULTIEDIT_SF_PASSWORD) {
000036  f8940078          LDRB     r0,[r4,#0x78]
00003a  2500              MOVS     r5,#0                 ;496
00003c  46b0              MOV      r8,r6                 ;497
00003e  0680              LSLS     r0,r0,#26
000040  d409              BMI      |L42.86|
000042  e00b              B        |L42.92|
                  |L42.68|
;;;499              while (NumChars--) {
;;;500                xSizeLine += _GetCharDistX(pObj, pLine);
000044  4641              MOV      r1,r8
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       _GetCharDistX
00004c  4405              ADD      r5,r5,r0
;;;501                pLine     += GUI_UC_GetCharSize(pLine);
00004e  4640              MOV      r0,r8
000050  f7fffffe          BL       GUI_UC_GetCharSize
000054  4480              ADD      r8,r8,r0
                  |L42.86|
000056  1e7f              SUBS     r7,r7,#1
000058  d2f4              BCS      |L42.68|
00005a  e004              B        |L42.102|
                  |L42.92|
;;;502              }
;;;503            } else {
;;;504              xSizeLine += GUI__GetLineDistX(pLine, NumChars);
00005c  4639              MOV      r1,r7
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       GUI__GetLineDistX
000064  4605              MOV      r5,r0
                  |L42.102|
;;;505            }
;;;506            if (xSizeLine > pObj->TextSizeX) {
000066  f8b40042          LDRH     r0,[r4,#0x42]
00006a  42a8              CMP      r0,r5
00006c  da01              BGE      |L42.114|
;;;507              pObj->TextSizeX = xSizeLine;
00006e  f8a45042          STRH     r5,[r4,#0x42]
                  |L42.114|
;;;508            }
;;;509            pText += _WrapGetNumBytesToNextLine(hObj, pObj, pText);
000072  4632              MOV      r2,r6
000074  4621              MOV      r1,r4
000076  4648              MOV      r0,r9
000078  f7fffffe          BL       _WrapGetNumBytesToNextLine
00007c  4406              ADD      r6,r6,r0
;;;510          } while (*pText);
00007e  7830              LDRB     r0,[r6,#0]
000080  2800              CMP      r0,#0
000082  d1d2              BNE      |L42.42|
                  |L42.132|
;;;511        }
;;;512        pObj->InvalidFlags &= ~INVALID_TEXTSIZE;
000084  f8940079          LDRB     r0,[r4,#0x79]
000088  f0200004          BIC      r0,r0,#4
00008c  f8840079          STRB     r0,[r4,#0x79]
                  |L42.144|
;;;513      }
;;;514      return pObj->TextSizeX;
000090  f8b40042          LDRH     r0,[r4,#0x42]
;;;515    }
000094  e8bd87f0          POP      {r4-r10,pc}
;;;516    
                          ENDP


                          AREA ||i._GetXSize||, CODE, READONLY, ALIGN=1

                  _GetXSize PROC
;;;190    */
;;;191    static int _GetXSize(MULTIEDIT_HANDLE hObj, const MULTIEDIT_OBJ* pObj) {
000000  b51c              PUSH     {r2-r4,lr}
000002  460c              MOV      r4,r1
;;;192      GUI_RECT Rect;
;;;193      WM_GetInsideRectExScrollbar(hObj, &Rect);
000004  4669              MOV      r1,sp
000006  f7fffffe          BL       WM_GetInsideRectExScrollbar
;;;194      return Rect.x1 - Rect.x0 - (pObj->HBorder * 2) - 1;
00000a  f9bd0004          LDRSH    r0,[sp,#4]
00000e  f9bd1000          LDRSH    r1,[sp,#0]
000012  1a40              SUBS     r0,r0,r1
000014  f894107b          LDRB     r1,[r4,#0x7b]
000018  4249              RSBS     r1,r1,#0
00001a  eb000041          ADD      r0,r0,r1,LSL #1
00001e  1e40              SUBS     r0,r0,#1
;;;195    }
000020  bd1c              POP      {r2-r4,pc}
;;;196    
                          ENDP


                          AREA ||i._GetpLine||, CODE, READONLY, ALIGN=1

                  _GetpLine PROC
;;;326    */
;;;327    static char * _GetpLine(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj, unsigned LineNumber) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4680              MOV      r8,r0
000006  4614              MOV      r4,r2
000008  460d              MOV      r5,r1
;;;328      char * pText, * pLine;
;;;329      pText = (char*) GUI_ALLOC_h2p(pObj->hText);
00000a  f9b10038          LDRSH    r0,[r1,#0x38]
00000e  f7fffffe          BL       GUI_ALLOC_h2p
000012  4607              MOV      r7,r0
;;;330      if ((unsigned)pObj->CacheLineNumber != LineNumber) {
000014  f8b50052          LDRH     r0,[r5,#0x52]
;;;331        if (LineNumber > (unsigned)pObj->CacheLineNumber) {
;;;332          /* If new line number > cache we can start with old pointer */
;;;333          int OldNumber = pObj->CacheLineNumber;
;;;334          pLine = pText + pObj->CacheLinePosByte;
;;;335          pObj->CacheLineNumber  = LineNumber;
000018  b2a1              UXTH     r1,r4
00001a  42a0              CMP      r0,r4                 ;330
00001c  d018              BEQ      |L44.80|
00001e  d208              BCS      |L44.50|
000020  f8b52050          LDRH     r2,[r5,#0x50]         ;334
000024  f8a51052          STRH     r1,[r5,#0x52]
000028  eb020607          ADD      r6,r2,r7              ;334
;;;336          LineNumber -= OldNumber;
00002c  eba40400          SUB      r4,r4,r0
;;;337        } else {
000030  e009              B        |L44.70|
                  |L44.50|
;;;338          /* If new line number < cache we need to start with first byte */
;;;339          pLine = pText;
000032  463e              MOV      r6,r7
;;;340          pObj->CacheLineNumber  = LineNumber;
000034  f8a51052          STRH     r1,[r5,#0x52]
000038  e005              B        |L44.70|
                  |L44.58|
;;;341        }
;;;342        while (LineNumber--) {
;;;343          pLine += _WrapGetNumBytesToNextLine(hObj, pObj, pLine);
00003a  4632              MOV      r2,r6
00003c  4629              MOV      r1,r5
00003e  4640              MOV      r0,r8
000040  f7fffffe          BL       _WrapGetNumBytesToNextLine
000044  4406              ADD      r6,r6,r0
                  |L44.70|
000046  1e64              SUBS     r4,r4,#1
000048  d2f7              BCS      |L44.58|
;;;344        }
;;;345        pObj->CacheLinePosByte = pLine - pText;
00004a  1bf0              SUBS     r0,r6,r7
00004c  f8a50050          STRH     r0,[r5,#0x50]
                  |L44.80|
;;;346      }
;;;347      return pText + pObj->CacheLinePosByte;
000050  f8b50050          LDRH     r0,[r5,#0x50]
000054  4438              ADD      r0,r0,r7
;;;348    }
000056  e8bd81f0          POP      {r4-r8,pc}
;;;349    
                          ENDP


                          AREA ||i._InsertChar||, CODE, READONLY, ALIGN=1

                  _InsertChar PROC
;;;1139   */
;;;1140   static int _InsertChar(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj, U16 Char) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  460c              MOV      r4,r1
000006  4680              MOV      r8,r0
000008  4617              MOV      r7,r2
;;;1141     if (_IsCharsAvailable(pObj, 1)) {
00000a  2101              MOVS     r1,#1
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       _IsCharsAvailable
000012  b370              CBZ      r0,|L45.114|
;;;1142       int BytesNeeded;
;;;1143       BytesNeeded = GUI_UC__CalcSizeOfChar(Char);
000014  4638              MOV      r0,r7
000016  f7fffffe          BL       GUI_UC__CalcSizeOfChar
00001a  4606              MOV      r6,r0
;;;1144       if (_IsSpaceInBuffer(pObj, BytesNeeded)) {
00001c  4601              MOV      r1,r0
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       _IsSpaceInBuffer
000024  b328              CBZ      r0,|L45.114|
;;;1145         int CursorOffset;
;;;1146         char* pText;
;;;1147         pText = (char*) GUI_ALLOC_h2p(pObj->hText);
000026  f9b40038          LDRSH    r0,[r4,#0x38]
00002a  f7fffffe          BL       GUI_ALLOC_h2p
;;;1148         CursorOffset = pObj->CursorPosByte;
00002e  f8b4104a          LDRH     r1,[r4,#0x4a]
;;;1149         pText += CursorOffset;
000032  1845              ADDS     r5,r0,r1
;;;1150         memmove(pText + BytesNeeded, pText, strlen(pText) + 1);
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       strlen
00003a  1c42              ADDS     r2,r0,#1
00003c  19a8              ADDS     r0,r5,r6
00003e  4629              MOV      r1,r5
000040  f7fffffe          BL       __aeabi_memmove
;;;1151         GUI_UC_Encode(pText, Char);
000044  4639              MOV      r1,r7
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       GUI_UC_Encode
;;;1152         WM_NotifyParent(hObj, WM_NOTIFICATION_VALUE_CHANGED);
00004c  2105              MOVS     r1,#5
00004e  4640              MOV      r0,r8
000050  f7fffffe          BL       WM_NotifyParent
;;;1153         pObj->NumChars += 1;
000054  8fa0              LDRH     r0,[r4,#0x3c]
000056  1c40              ADDS     r0,r0,#1
000058  87a0              STRH     r0,[r4,#0x3c]
00005a  f8940079          LDRB     r0,[r4,#0x79]
00005e  f0400006          ORR      r0,r0,#6
000062  f8840079          STRB     r0,[r4,#0x79]
;;;1154         _InvalidateNumLines(pObj);
;;;1155         _InvalidateTextSizeX(pObj);
;;;1156         _ClearCache(pObj);
000066  4620              MOV      r0,r4
000068  f7fffffe          BL       _ClearCache
;;;1157         return 1;
00006c  2001              MOVS     r0,#1
                  |L45.110|
;;;1158       }
;;;1159     }
;;;1160     return 0;
;;;1161   }
00006e  e8bd81f0          POP      {r4-r8,pc}
                  |L45.114|
000072  e7ff              B        |L45.116|
                  |L45.116|
000074  2000              MOVS     r0,#0                 ;1160
000076  e7fa              B        |L45.110|
;;;1162   
                          ENDP


                          AREA ||i._Invalidate||, CODE, READONLY, ALIGN=1

                  _Invalidate PROC
;;;642    */
;;;643    static void _Invalidate(MULTIEDIT_HANDLE hObj) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;644      _ManageScrollers(hObj);
000004  f7fffffe          BL       _ManageScrollers
;;;645      WM_Invalidate(hObj);
000008  4620              MOV      r0,r4
00000a  e8bd4010          POP      {r4,lr}
00000e  f7ffbffe          B.W      WM_InvalidateWindow
;;;646    }
;;;647    
                          ENDP


                          AREA ||i._InvalidateTextArea||, CODE, READONLY, ALIGN=1

                  _InvalidateTextArea PROC
;;;653    */
;;;654    static void _InvalidateTextArea(MULTIEDIT_HANDLE hObj) {
000000  b51c              PUSH     {r2-r4,lr}
000002  4604              MOV      r4,r0
;;;655      GUI_RECT rInsideRect;
;;;656      _ManageScrollers(hObj);
000004  f7fffffe          BL       _ManageScrollers
;;;657      WM_GetInsideRectExScrollbar(hObj, &rInsideRect);
000008  4669              MOV      r1,sp
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       WM_GetInsideRectExScrollbar
;;;658      WM_InvalidateRect(hObj, &rInsideRect);
000010  4669              MOV      r1,sp
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       WM_InvalidateRect
;;;659    }
000018  bd1c              POP      {r2-r4,pc}
;;;660    
                          ENDP


                          AREA ||i._IsCharsAvailable||, CODE, READONLY, ALIGN=1

                  _IsCharsAvailable PROC
;;;1074   */
;;;1075   static int _IsCharsAvailable(MULTIEDIT_OBJ* pObj, int CharsNeeded) {
000000  b570              PUSH     {r4-r6,lr}
000002  1e0d              SUBS     r5,r1,#0
000004  4604              MOV      r4,r0
000006  dd0d              BLE      |L48.36|
;;;1076     if ((CharsNeeded > 0) && (pObj->MaxNumChars > 0)) {
000008  8f60              LDRH     r0,[r4,#0x3a]
00000a  b158              CBZ      r0,|L48.36|
;;;1077       int NumChars = 0;
;;;1078       if (pObj->hText) {
00000c  8f21              LDRH     r1,[r4,#0x38]
00000e  2000              MOVS     r0,#0                 ;1077
000010  b111              CBZ      r1,|L48.24|
;;;1079         NumChars = _GetNumChars(pObj);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       _GetNumChars
                  |L48.24|
;;;1080       }
;;;1081       if ((CharsNeeded + NumChars) > pObj->MaxNumChars) {
000018  8f61              LDRH     r1,[r4,#0x3a]
00001a  4428              ADD      r0,r0,r5
00001c  4288              CMP      r0,r1
00001e  dd01              BLE      |L48.36|
;;;1082         return 0;
000020  2000              MOVS     r0,#0
;;;1083       }
;;;1084     }
;;;1085     return 1;
;;;1086   }
000022  bd70              POP      {r4-r6,pc}
                  |L48.36|
000024  2001              MOVS     r0,#1                 ;1085
000026  bd70              POP      {r4-r6,pc}
;;;1087   
                          ENDP


                          AREA ||i._IsOverwriteAtThisChar||, CODE, READONLY, ALIGN=1

                  _IsOverwriteAtThisChar PROC
;;;908    */
;;;909    static int _IsOverwriteAtThisChar(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj) {
000000  e92d43f8          PUSH     {r3-r9,lr}
000004  4680              MOV      r8,r0
;;;910      int r = 0;
;;;911      if (pObj->hText && !(pObj->Flags & MULTIEDIT_CF_INSERT)) {
000006  f9b10038          LDRSH    r0,[r1,#0x38]
00000a  460c              MOV      r4,r1                 ;909
00000c  2500              MOVS     r5,#0                 ;910
00000e  b330              CBZ      r0,|L49.94|
000010  f8941078          LDRB     r1,[r4,#0x78]
000014  0749              LSLS     r1,r1,#29
000016  d42b              BMI      |L49.112|
;;;912        const char *pText;
;;;913        int CurPos, Line1, Line2;
;;;914        U16 Char;
;;;915        pText  = (const char *)GUI_ALLOC_h2p(pObj->hText);
000018  f7fffffe          BL       GUI_ALLOC_h2p
00001c  4607              MOV      r7,r0
;;;916        Line1  = pObj->CursorLine;
;;;917        CurPos = _CalcNextValidCursorPos(hObj, pObj, pObj->CursorPosChar + 1, 0, 0);
00001e  2000              MOVS     r0,#0
000020  f8b46046          LDRH     r6,[r4,#0x46]         ;916
000024  9000              STR      r0,[sp,#0]
000026  f8b42048          LDRH     r2,[r4,#0x48]
00002a  4603              MOV      r3,r0
00002c  4621              MOV      r1,r4
00002e  4640              MOV      r0,r8
000030  1c52              ADDS     r2,r2,#1
000032  f7fffffe          BL       _CalcNextValidCursorPos
000036  4603              MOV      r3,r0
;;;918        Line2  = _GetCursorLine(hObj, pObj, pText, CurPos);
000038  463a              MOV      r2,r7
00003a  4621              MOV      r1,r4
00003c  4640              MOV      r0,r8
00003e  f7fffffe          BL       _GetCursorLine
000042  4680              MOV      r8,r0
;;;919        pText += pObj->CursorPosByte;
000044  f8b4004a          LDRH     r0,[r4,#0x4a]
000048  4438              ADD      r0,r0,r7
;;;920        Char   = GUI_UC_GetCharCode(pText);
00004a  f7fffffe          BL       GUI_UC_GetCharCode
;;;921        if (Char) {
00004e  b130              CBZ      r0,|L49.94|
;;;922          if ((Line1 == Line2) || (pObj->Flags & MULTIEDIT_SF_PASSWORD)) {
000050  4546              CMP      r6,r8
000052  d003              BEQ      |L49.92|
000054  f8941078          LDRB     r1,[r4,#0x78]
000058  0689              LSLS     r1,r1,#26
00005a  d501              BPL      |L49.96|
                  |L49.92|
;;;923            r = 1;
00005c  2501              MOVS     r5,#1
                  |L49.94|
00005e  e007              B        |L49.112|
                  |L49.96|
;;;924          } else {
;;;925            if (Char != '\n') {
000060  280a              CMP      r0,#0xa
000062  d005              BEQ      |L49.112|
;;;926              if ((Char != ' ') || (pObj->WrapMode == GUI_WRAPMODE_CHAR)) {
000064  2820              CMP      r0,#0x20
000066  d1f9              BNE      |L49.92|
000068  f894007c          LDRB     r0,[r4,#0x7c]
00006c  2802              CMP      r0,#2
00006e  d0f5              BEQ      |L49.92|
                  |L49.112|
;;;927                r = 1;
;;;928              }
;;;929            }
;;;930          }
;;;931        }
;;;932      }
;;;933      return r;
000070  4628              MOV      r0,r5
;;;934    }
000072  e8bd83f8          POP      {r3-r9,pc}
;;;935    
                          ENDP


                          AREA ||i._IsSpaceInBuffer||, CODE, READONLY, ALIGN=1

                  _IsSpaceInBuffer PROC
;;;1050   */
;;;1051   static int _IsSpaceInBuffer(MULTIEDIT_OBJ* pObj, int BytesNeeded) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1052     int NumBytes = 0;
;;;1053     if (pObj->hText) {
000008  f9b42038          LDRSH    r2,[r4,#0x38]
00000c  2000              MOVS     r0,#0                 ;1052
00000e  b122              CBZ      r2,|L50.26|
000010  4610              MOV      r0,r2                 ;1051
;;;1054       NumBytes = strlen((char*)GUI_ALLOC_h2p(pObj->hText));
000012  f7fffffe          BL       GUI_ALLOC_h2p
000016  f7fffffe          BL       strlen
                  |L50.26|
;;;1055     }
;;;1056     BytesNeeded = (BytesNeeded + NumBytes + 1) - pObj->BufferSize;
00001a  1829              ADDS     r1,r5,r0
00001c  f8b40044          LDRH     r0,[r4,#0x44]
000020  1a09              SUBS     r1,r1,r0
000022  1c49              ADDS     r1,r1,#1
;;;1057     if (BytesNeeded > 0) {
000024  2900              CMP      r1,#0
000026  dd13              BLE      |L50.80|
000028  3110              ADDS     r1,r1,#0x10
00002a  1845              ADDS     r5,r0,r1
00002c  f9b40038          LDRSH    r0,[r4,#0x38]
000030  4629              MOV      r1,r5
000032  f7fffffe          BL       GUI_ALLOC_Realloc
000036  0006              MOVS     r6,r0
000038  f04f0700          MOV      r7,#0
00003c  d00b              BEQ      |L50.86|
00003e  8f20              LDRH     r0,[r4,#0x38]
000040  b918              CBNZ     r0,|L50.74|
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       GUI_ALLOC_h2p
000048  7007              STRB     r7,[r0,#0]
                  |L50.74|
00004a  f8a45044          STRH     r5,[r4,#0x44]
00004e  8726              STRH     r6,[r4,#0x38]
                  |L50.80|
;;;1058       if (!_IncrementBuffer(pObj, BytesNeeded + MULTIEDIT_REALLOC_SIZE)) {
;;;1059         return 0;
;;;1060       }
;;;1061     }
;;;1062     return 1;
000050  2001              MOVS     r0,#1
                  |L50.82|
;;;1063   }
000052  e8bd81f0          POP      {r4-r8,pc}
                  |L50.86|
000056  2000              MOVS     r0,#0                 ;1059
000058  e7fb              B        |L50.82|
;;;1064   
                          ENDP


                          AREA ||i._MULTIEDIT_Paint||, CODE, READONLY, ALIGN=1

                  _MULTIEDIT_Paint PROC
;;;1172   */
;;;1173   static void _MULTIEDIT_Paint(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ * pObj) {
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
000004  b08d              SUB      sp,sp,#0x34
000006  460c              MOV      r4,r1
;;;1174     int ScrollPosX, ScrollPosY, EffectSize, HBorder, IsRTL = 0;
;;;1175     int x, y, xOff, yOff, ColorIndex, FontSizeY;
;;;1176     GUI_RECT r, rClip;
;;;1177     const GUI_RECT *prOldClip;
;;;1178     /* Init some values */
;;;1179     GUI_SetFont(pObj->pFont);
000008  6f48              LDR      r0,[r1,#0x74]
00000a  f7fffffe          BL       GUI_SetFont
;;;1180     FontSizeY  = GUI_GetFontDistY();
00000e  f7fffffe          BL       GUI_GetFontDistY
;;;1181     ScrollPosX = pObj->ScrollStateH.v;
000012  9004              STR      r0,[sp,#0x10]
;;;1182     ScrollPosY = pObj->ScrollStateV.v;
;;;1183     EffectSize = pObj->Widget.pEffect->EffectSize;
000014  6a20              LDR      r0,[r4,#0x20]
000016  6e26              LDR      r6,[r4,#0x60]
;;;1184     HBorder    = pObj->HBorder;
;;;1185     xOff       = EffectSize + HBorder - ScrollPosX;
;;;1186     yOff       = EffectSize - ScrollPosY * FontSizeY;
000018  9904              LDR      r1,[sp,#0x10]
00001a  f8d08014          LDR      r8,[r0,#0x14]         ;1185
00001e  f8d4906c          LDR      r9,[r4,#0x6c]         ;1183
000022  fb068011          MLS      r0,r6,r1,r8
000026  f894a07b          LDRB     r10,[r4,#0x7b]        ;1184
;;;1187     ColorIndex = ((pObj->Flags & MULTIEDIT_SF_READONLY) ? 1 : 0);
00002a  9006              STR      r0,[sp,#0x18]
00002c  f8940078          LDRB     r0,[r4,#0x78]
000030  eb08050a          ADD      r5,r8,r10             ;1185
000034  f0000001          AND      r0,r0,#1
;;;1188     /* Set colors and draw the background */
;;;1189     LCD_SetBkColor(pObj->aBkColor[ColorIndex]);
000038  eb040780          ADD      r7,r4,r0,LSL #2
00003c  eba50b09          SUB      r11,r5,r9             ;1185
000040  6ab8              LDR      r0,[r7,#0x28]
000042  f7fffffe          BL       LCD_SetBkColor
;;;1190     LCD_SetColor(pObj->aColor[ColorIndex]);
000046  6b38              LDR      r0,[r7,#0x30]
000048  f7fffffe          BL       LCD_SetColor
;;;1191     GUI_Clear();
00004c  f7fffffe          BL       GUI_Clear
;;;1192     /* Draw the text if necessary */
;;;1193     rClip.x0 = EffectSize + HBorder;
000050  f8ad5008          STRH     r5,[sp,#8]
;;;1194     rClip.y0 = EffectSize;
000054  fa0ff088          SXTH     r0,r8
000058  9007              STR      r0,[sp,#0x1c]
00005a  f8ad000a          STRH     r0,[sp,#0xa]
;;;1195     rClip.x1 = WM_GetWindowSizeX(hObj) - EffectSize - HBorder - 1;
00005e  980d              LDR      r0,[sp,#0x34]
000060  f7fffffe          BL       WM_GetWindowSizeX
000064  eba00008          SUB      r0,r0,r8
000068  eba0000a          SUB      r0,r0,r10
00006c  1e40              SUBS     r0,r0,#1
00006e  f8ad000c          STRH     r0,[sp,#0xc]
;;;1196     rClip.y1 = WM_GetWindowSizeY(hObj) - EffectSize - 1;
000072  980d              LDR      r0,[sp,#0x34]
000074  f7fffffe          BL       WM_GetWindowSizeY
000078  eba00008          SUB      r0,r0,r8
00007c  1e40              SUBS     r0,r0,#1
00007e  f8ad000e          STRH     r0,[sp,#0xe]
;;;1197     prOldClip = WM_SetUserClipRect(&rClip);
000082  a802              ADD      r0,sp,#8
000084  f7fffffe          BL       WM_SetUserClipRect
;;;1198     if (pObj->hText) {
000088  900a              STR      r0,[sp,#0x28]
00008a  8f20              LDRH     r0,[r4,#0x38]
00008c  2800              CMP      r0,#0
00008e  d06a              BEQ      |L51.358|
;;;1199       const char* pText;
;;;1200       int Line = 0;
000090  2500              MOVS     r5,#0
;;;1201       int xSize       = _GetXSize(hObj, pObj);
000092  4621              MOV      r1,r4
000094  980d              LDR      r0,[sp,#0x34]
000096  f7fffffe          BL       _GetXSize
;;;1202       int NumVisLines = _GetNumVisLines(hObj, pObj);
00009a  900b              STR      r0,[sp,#0x2c]
00009c  4621              MOV      r1,r4
00009e  980d              LDR      r0,[sp,#0x34]
0000a0  f7fffffe          BL       _GetNumVisLines
;;;1203       /* Get the text */
;;;1204       pText = (const char *)GUI_ALLOC_h2p(pObj->hText);
0000a4  9009              STR      r0,[sp,#0x24]
0000a6  f9b40038          LDRSH    r0,[r4,#0x38]
0000aa  f7fffffe          BL       GUI_ALLOC_h2p
0000ae  4607              MOV      r7,r0
;;;1205       /* Set the rectangle for drawing */
;;;1206       r.x0 = xOff;
0000b0  fa0ff18b          SXTH     r1,r11
0000b4  f8ad1000          STRH     r1,[sp,#0]
;;;1207       r.y0 = EffectSize;
0000b8  9807              LDR      r0,[sp,#0x1c]
0000ba  f8ad0002          STRH     r0,[sp,#2]
;;;1208       r.x1 = xSize + EffectSize + HBorder - 1;
0000be  980b              LDR      r0,[sp,#0x2c]
0000c0  eb000208          ADD      r2,r0,r8
0000c4  eb02000a          ADD      r0,r2,r10
0000c8  1e40              SUBS     r0,r0,#1
0000ca  b202              SXTH     r2,r0
0000cc  f8ad2004          STRH     r2,[sp,#4]
;;;1209       r.y1 = pObj->Widget.Win.Rect.y1 - pObj->Widget.Win.Rect.y0 + 1;
0000d0  88e0              LDRH     r0,[r4,#6]
0000d2  8863              LDRH     r3,[r4,#2]
0000d4  1ac0              SUBS     r0,r0,r3
0000d6  1c40              ADDS     r0,r0,#1
0000d8  f8ad0006          STRH     r0,[sp,#6]
;;;1210       /* Use cached position of first visible byte if possible */
;;;1211       if (ScrollPosY >= pObj->CacheFirstVisibleLine) {
0000dc  f8b40054          LDRH     r0,[r4,#0x54]
0000e0  42b0              CMP      r0,r6
0000e2  dc04              BGT      |L51.238|
;;;1212         if (pObj->CacheFirstVisibleByte) {
0000e4  f8b43056          LDRH     r3,[r4,#0x56]
0000e8  b10b              CBZ      r3,|L51.238|
;;;1213           pText += pObj->CacheFirstVisibleByte;
0000ea  441f              ADD      r7,r7,r3
;;;1214           Line   = pObj->CacheFirstVisibleLine;
0000ec  4605              MOV      r5,r0
                  |L51.238|
;;;1215         }
;;;1216       }
;;;1217       if (pObj->Align == GUI_TA_RIGHT) {
0000ee  f8b40058          LDRH     r0,[r4,#0x58]
0000f2  2801              CMP      r0,#1
0000f4  d107              BNE      |L51.262|
;;;1218         r.x0 += ScrollPosX;
0000f6  eb010009          ADD      r0,r1,r9
0000fa  f8ad0000          STRH     r0,[sp,#0]
;;;1219         r.x1 += ScrollPosX;
0000fe  eb020009          ADD      r0,r2,r9
000102  f8ad0004          STRH     r0,[sp,#4]
                  |L51.262|
;;;1220       }
;;;1221       /* Do the drawing of the text */
;;;1222       do {
;;;1223         /* Cache the position of the first visible byte and the depending line number */
;;;1224         if (pObj->CacheFirstVisibleLine != ScrollPosY) {
000106  f8b40054          LDRH     r0,[r4,#0x54]
00010a  42b0              CMP      r0,r6
00010c  d00a              BEQ      |L51.292|
;;;1225           if (Line == ScrollPosY) {
00010e  42b5              CMP      r5,r6
000110  d108              BNE      |L51.292|
;;;1226             pObj->CacheFirstVisibleByte = pText - (const char *)GUI_ALLOC_h2p(pObj->hText);
000112  f9b40038          LDRSH    r0,[r4,#0x38]
000116  f7fffffe          BL       GUI_ALLOC_h2p
00011a  1a38              SUBS     r0,r7,r0
00011c  f8a40056          STRH     r0,[r4,#0x56]
;;;1227             pObj->CacheFirstVisibleLine = ScrollPosY;
000120  f8a46054          STRH     r6,[r4,#0x54]
                  |L51.292|
;;;1228           }
;;;1229         }
;;;1230         /* Draw it */
;;;1231         if ((Line >= ScrollPosY) && ((Line - ScrollPosY) <= NumVisLines)) {
000124  42b5              CMP      r5,r6
000126  db0f              BLT      |L51.328|
000128  9809              LDR      r0,[sp,#0x24]
00012a  1ba9              SUBS     r1,r5,r6
00012c  4281              CMP      r1,r0
00012e  dc0b              BGT      |L51.328|
;;;1232           _DispString(hObj, pObj, pText, &r);
000130  466b              MOV      r3,sp
000132  463a              MOV      r2,r7
000134  4621              MOV      r1,r4
000136  980d              LDR      r0,[sp,#0x34]
000138  f7fffffe          BL       _DispString
;;;1233           r.y0 += FontSizeY;  /* Next line */
00013c  f8bd1002          LDRH     r1,[sp,#2]
000140  9804              LDR      r0,[sp,#0x10]
000142  4408              ADD      r0,r0,r1
000144  f8ad0002          STRH     r0,[sp,#2]
                  |L51.328|
;;;1234         }
;;;1235         pText += _WrapGetNumBytesToNextLine(hObj, pObj, pText);
000148  463a              MOV      r2,r7
00014a  4621              MOV      r1,r4
00014c  980d              LDR      r0,[sp,#0x34]
00014e  f7fffffe          BL       _WrapGetNumBytesToNextLine
000152  4407              ADD      r7,r7,r0
;;;1236         Line++;
;;;1237       } while (GUI_UC_GetCharCode(pText) && ((Line - ScrollPosY) <= NumVisLines));
000154  4638              MOV      r0,r7
000156  1c6d              ADDS     r5,r5,#1
000158  f7fffffe          BL       GUI_UC_GetCharCode
00015c  b118              CBZ      r0,|L51.358|
00015e  9809              LDR      r0,[sp,#0x24]
000160  1ba9              SUBS     r1,r5,r6
000162  4281              CMP      r1,r0
000164  ddcf              BLE      |L51.262|
                  |L51.358|
;;;1238     }
;;;1239     /* Draw cursor if necessary */
;;;1240     if (WM_HasFocus(hObj)) {
000166  980d              LDR      r0,[sp,#0x34]
000168  f7fffffe          BL       WM_HasFocus
00016c  b3e8              CBZ      r0,|L51.490|
;;;1241       int CursorSize;
;;;1242       _GetCursorXY(hObj, pObj, &x, &y);
00016e  ab05              ADD      r3,sp,#0x14
000170  aa08              ADD      r2,sp,#0x20
000172  4621              MOV      r1,r4
000174  980d              LDR      r0,[sp,#0x34]
000176  f7fffffe          BL       _GetCursorXY
00017a  4621              MOV      r1,r4
00017c  980d              LDR      r0,[sp,#0x34]
00017e  f7fffffe          BL       _IsOverwriteAtThisChar
000182  b158              CBZ      r0,|L51.412|
000184  f9b40038          LDRSH    r0,[r4,#0x38]
000188  f7fffffe          BL       GUI_ALLOC_h2p
00018c  f8b4104a          LDRH     r1,[r4,#0x4a]
000190  4401              ADD      r1,r1,r0
000192  4620              MOV      r0,r4
000194  f7fffffe          BL       _GetCharDistX
000198  4601              MOV      r1,r0
00019a  e000              B        |L51.414|
                  |L51.412|
00019c  2102              MOVS     r1,#2
                  |L51.414|
;;;1243       CursorSize = _GetCursorSizeX(hObj, pObj, &IsRTL);
;;;1244       if (IsRTL) {
;;;1245         r.x0 = x + xOff - CursorSize;
;;;1246         r.x1 = r.x0 + CursorSize - 1;
;;;1247       } else {
;;;1248         r.x0 = x + xOff;
00019e  9a08              LDR      r2,[sp,#0x20]
0001a0  1e49              SUBS     r1,r1,#1
0001a2  eb02000b          ADD      r0,r2,r11
0001a6  b200              SXTH     r0,r0
;;;1249         r.x1 = r.x0 + CursorSize - 1;
0001a8  4401              ADD      r1,r1,r0
0001aa  b20a              SXTH     r2,r1
0001ac  f8ad0000          STRH     r0,[sp,#0]            ;1248
0001b0  f8ad2004          STRH     r2,[sp,#4]
0001b4  e9dd3105          LDRD     r3,r1,[sp,#0x14]
;;;1250       }
;;;1251       r.y0 = y + yOff;
0001b8  4419              ADD      r1,r1,r3
;;;1252       r.y1 = r.y0 + FontSizeY - 1;
0001ba  9b04              LDR      r3,[sp,#0x10]
0001bc  b209              SXTH     r1,r1                 ;1251
0001be  1e5b              SUBS     r3,r3,#1
0001c0  440b              ADD      r3,r3,r1
0001c2  b21b              SXTH     r3,r3
0001c4  f8ad1002          STRH     r1,[sp,#2]            ;1251
0001c8  f8ad3006          STRH     r3,[sp,#6]
;;;1253       if (pObj->Align == GUI_TA_RIGHT) {
0001cc  f8b45058          LDRH     r5,[r4,#0x58]
0001d0  2d01              CMP      r5,#1
0001d2  d107              BNE      |L51.484|
;;;1254         r.x0 += ScrollPosX << 1;
0001d4  eb000049          ADD      r0,r0,r9,LSL #1
0001d8  f8ad0000          STRH     r0,[sp,#0]
;;;1255         r.x1 += ScrollPosX << 1;
0001dc  eb020049          ADD      r0,r2,r9,LSL #1
0001e0  f8ad0004          STRH     r0,[sp,#4]
                  |L51.484|
;;;1256       }
;;;1257       GUI_InvertRect(r.x0, r.y0, r.x1, r.y1);
0001e4  f9bd2004          LDRSH    r2,[sp,#4]
0001e8  e000              B        |L51.492|
                  |L51.490|
0001ea  e003              B        |L51.500|
                  |L51.492|
0001ec  f9bd0000          LDRSH    r0,[sp,#0]
0001f0  f7fffffe          BL       GUI_InvertRect
                  |L51.500|
;;;1258     }
;;;1259     WM_SetUserClipRect(prOldClip);
0001f4  980a              LDR      r0,[sp,#0x28]
0001f6  f7fffffe          BL       WM_SetUserClipRect
;;;1260     /* Draw the 3D effect (if configured) */
;;;1261     WIDGET__EFFECT_DrawDown(&pObj->Widget);
0001fa  4620              MOV      r0,r4
0001fc  f7fffffe          BL       WIDGET__EFFECT_DrawDown
;;;1262   }
000200  b00f              ADD      sp,sp,#0x3c
000202  e8bd8ff0          POP      {r4-r11,pc}
;;;1263   
                          ENDP


                          AREA ||i._ManageAutoScrollV||, CODE, READONLY, ALIGN=1

                  _ManageAutoScrollV PROC
;;;599    */
;;;600    static void _ManageAutoScrollV(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
;;;601      if (pObj->Flags & MULTIEDIT_SF_AUTOSCROLLBAR_V) {
000004  f8910078          LDRB     r0,[r1,#0x78]
000008  460c              MOV      r4,r1                 ;600
00000a  0700              LSLS     r0,r0,#28
00000c  d51d              BPL      |L52.74|
;;;602        char IsRequired = _GetNumVisLines(hObj, pObj) < _GetNumLines(hObj, pObj);
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       _GetNumVisLines
000014  4605              MOV      r5,r0
000016  4621              MOV      r1,r4
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       _GetNumLines
00001e  4285              CMP      r5,r0
000020  da01              BGE      |L52.38|
000022  2501              MOVS     r5,#1
000024  e000              B        |L52.40|
                  |L52.38|
000026  2500              MOVS     r5,#0
                  |L52.40|
;;;603        if (WM_SetScrollbarV(hObj, IsRequired) != IsRequired) {
000028  4629              MOV      r1,r5
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       WM_SetScrollbarV
000030  42a8              CMP      r0,r5
000032  d00a              BEQ      |L52.74|
000034  f8940079          LDRB     r0,[r4,#0x79]
000038  f040000e          ORR      r0,r0,#0xe
00003c  f8840079          STRB     r0,[r4,#0x79]
;;;604          _InvalidateNumLines(pObj);
;;;605          _InvalidateTextSizeX(pObj);
;;;606          _InvalidateCursorXY(pObj);
;;;607          _ClearCache(pObj);
000040  4620              MOV      r0,r4
000042  e8bd4070          POP      {r4-r6,lr}
000046  f7ffbffe          B.W      _ClearCache
                  |L52.74|
;;;608        }
;;;609      }
;;;610    }
00004a  bd70              POP      {r4-r6,pc}
;;;611    
                          ENDP


                          AREA ||i._ManageScrollers||, CODE, READONLY, ALIGN=1

                  _ManageScrollers PROC
;;;621    */
;;;622    static void _ManageScrollers(MULTIEDIT_HANDLE hObj) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
;;;623      MULTIEDIT_OBJ* pObj;
;;;624      pObj = MULTIEDIT_H2P(hObj);
000004  f7fffffe          BL       GUI_ALLOC_h2p
000008  4605              MOV      r5,r0
;;;625      /* 1. Step: Check if vertical scrollbar is required */
;;;626      _ManageAutoScrollV(hObj, pObj);
00000a  4601              MOV      r1,r0
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       _ManageAutoScrollV
;;;627      /* 2. Step: Check if horizontal scrollbar is required */
;;;628      if (pObj->Flags & MULTIEDIT_SF_AUTOSCROLLBAR_H) {
000012  f8950078          LDRB     r0,[r5,#0x78]
000016  06c0              LSLS     r0,r0,#27
000018  d517              BPL      |L53.74|
;;;629        char IsRequired;
;;;630        IsRequired = (_GetXSize(hObj, pObj) < _GetTextSizeX(hObj, pObj));
00001a  4629              MOV      r1,r5
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       _GetXSize
000022  4604              MOV      r4,r0
000024  4629              MOV      r1,r5
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       _GetTextSizeX
00002c  4284              CMP      r4,r0
00002e  da01              BGE      |L53.52|
000030  2401              MOVS     r4,#1
000032  e000              B        |L53.54|
                  |L53.52|
000034  2400              MOVS     r4,#0
                  |L53.54|
;;;631        if (WM_SetScrollbarH(hObj, IsRequired) != IsRequired) {
000036  4621              MOV      r1,r4
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       WM_SetScrollbarH
00003e  42a0              CMP      r0,r4
000040  d003              BEQ      |L53.74|
;;;632          /* 3. Step: Check vertical scrollbar again if horizontal has changed */
;;;633          _ManageAutoScrollV(hObj, pObj);
000042  4629              MOV      r1,r5
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       _ManageAutoScrollV
                  |L53.74|
;;;634        }
;;;635      }
;;;636      _CalcScrollParas(hObj);
00004a  4630              MOV      r0,r6
00004c  e8bd4070          POP      {r4-r6,lr}
000050  f7ffbffe          B.W      _CalcScrollParas
;;;637    }
;;;638    
                          ENDP


                          AREA ||i._MoveCursor2NextLine||, CODE, READONLY, ALIGN=1

                  _MoveCursor2NextLine PROC
;;;877    */
;;;878    static void _MoveCursor2NextLine(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj) {
000000  b57c              PUSH     {r2-r6,lr}
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;879      int xPos, yPos;
;;;880      _GetCursorXY(hObj, pObj, &xPos, &yPos);
000006  466b              MOV      r3,sp
000008  aa01              ADD      r2,sp,#4
00000a  f7fffffe          BL       _GetCursorXY
;;;881      yPos += GUI_GetYDistOfFont(pObj->pFont);
00000e  6f60              LDR      r0,[r4,#0x74]
000010  f7fffffe          BL       GUI_GetYDistOfFont
000014  9900              LDR      r1,[sp,#0]
;;;882      _SetCursorXY(hObj, pObj, 0, yPos);
000016  2200              MOVS     r2,#0
000018  1843              ADDS     r3,r0,r1              ;881
00001a  4621              MOV      r1,r4
00001c  4628              MOV      r0,r5
00001e  9300              STR      r3,[sp,#0]
000020  f7fffffe          BL       _SetCursorXY
;;;883    }
000024  bd7c              POP      {r2-r6,pc}
;;;884    
                          ENDP


                          AREA ||i._OnTouch||, CODE, READONLY, ALIGN=2

                  _OnTouch PROC
;;;1268   #define MUTIEDIT_SUPPORT_SCROLL		1
;;;1269   static void _OnTouch(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj, WM_MESSAGE*pMsg) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  6890              LDR      r0,[r2,#8]
000006  b3a0              CBZ      r0,|L55.114|
;;;1270     int Notification;
;;;1271     const GUI_PID_STATE* pState = (const GUI_PID_STATE*)pMsg->Data.p;
;;;1272     #if MUTIEDIT_SUPPORT_SCROLL
;;;1273     static int yLast = -1;
;;;1274     static char bAreadyUp;
;;;1275     static char bAreadyDown;
;;;1276      if (pMsg->Data.p) {  /* Something happened in our area (pressed or released) */
;;;1277       if (pState->Pressed) {
000008  7a03              LDRB     r3,[r0,#8]
;;;1278         if(yLast == -1)
00000a  4a1d              LDR      r2,|L55.128|
00000c  2500              MOVS     r5,#0                 ;1277
00000e  b34b              CBZ      r3,|L55.100|
000010  6896              LDR      r6,[r2,#8]  ; yLast
000012  1c73              ADDS     r3,r6,#1
000014  d009              BEQ      |L55.42|
;;;1279   	{
;;;1280   		yLast = pState->y;
;;;1281   		return;
;;;1282   	}
;;;1283   	else
;;;1284   	{
;;;1285   		unsigned short nOffset = 30;
;;;1286   		if(pState->y>=yLast)
;;;1287   		{
;;;1288   			if((pState->y-yLast) > nOffset && bAreadyUp == 0)
;;;1289   			{
;;;1290   				bAreadyUp = 1;
000016  6843              LDR      r3,[r0,#4]
000018  2001              MOVS     r0,#1
00001a  42b3              CMP      r3,r6                 ;1286
00001c  db0e              BLT      |L55.60|
00001e  1b9e              SUBS     r6,r3,r6              ;1288
000020  2e1e              CMP      r6,#0x1e              ;1288
000022  dd1d              BLE      |L55.96|
000024  7816              LDRB     r6,[r2,#0]            ;1288  ; bAreadyUp
000026  b11e              CBZ      r6,|L55.48|
000028  e01a              B        |L55.96|
                  |L55.42|
00002a  6840              LDR      r0,[r0,#4]            ;1280
00002c  6090              STR      r0,[r2,#8]            ;1280  ; yLast
;;;1291   				bAreadyDown = 0;
;;;1292   				yLast = pState->y + nOffset;
;;;1293   				_SetCursorXY(hObj, pObj, 0, 0);
;;;1294   				_Invalidate(hObj);
;;;1295   			}
;;;1296   		}
;;;1297   		else
;;;1298   		{
;;;1299   			if((yLast-pState->y)>nOffset && bAreadyDown == 0)
;;;1300   			{
;;;1301   				bAreadyUp = 0;
;;;1302   				bAreadyDown = 1;
;;;1303   				yLast = pState->y - nOffset;
;;;1304   				_SetCursorXY(hObj, pObj, 0, 0x7FFF);
;;;1305   				_Invalidate(hObj);
;;;1306   			}
;;;1307   		}
;;;1308   	}
;;;1309         Notification = WM_NOTIFICATION_CLICKED;
;;;1310       } else {
;;;1311         yLast = -1;
;;;1312         bAreadyUp = 0;
;;;1313         bAreadyDown = 0;
;;;1314         Notification = WM_NOTIFICATION_RELEASED;
;;;1315       }
;;;1316     } else {
;;;1317       Notification = WM_NOTIFICATION_MOVED_OUT;
;;;1318     }
;;;1319     WM_NotifyParent(hObj, Notification);
;;;1320     #else
;;;1321     if (pMsg->Data.p) {  /* Something happened in our area (pressed or released) */
;;;1322       if (pState->Pressed) {
;;;1323         int Effect, xPos, yPos;
;;;1324         Effect = pObj->Widget.pEffect->EffectSize;
;;;1325         xPos   = pState->x + pObj->ScrollStateH.v - Effect - pObj->HBorder;
;;;1326         yPos   = pState->y + pObj->ScrollStateV.v * GUI_GetYDistOfFont(pObj->pFont) - Effect;
;;;1327         _SetCursorXY(hObj, pObj, xPos, yPos);
;;;1328         _Invalidate(hObj);
;;;1329         Notification = WM_NOTIFICATION_CLICKED;
;;;1330       } else {
;;;1331         Notification = WM_NOTIFICATION_RELEASED;
;;;1332       }
;;;1333     } else {
;;;1334       Notification = WM_NOTIFICATION_MOVED_OUT;
;;;1335     }
;;;1336     WM_NotifyParent(hObj, Notification);
;;;1337     #endif
;;;1338   }
00002e  bd70              POP      {r4-r6,pc}
                  |L55.48|
000030  7010              STRB     r0,[r2,#0]            ;1290
000032  7055              STRB     r5,[r2,#1]            ;1291
000034  331e              ADDS     r3,r3,#0x1e           ;1291
000036  6093              STR      r3,[r2,#8]            ;1293  ; yLast
000038  2300              MOVS     r3,#0                 ;1293
00003a  e00a              B        |L55.82|
                  |L55.60|
00003c  1af6              SUBS     r6,r6,r3              ;1299
00003e  2e1e              CMP      r6,#0x1e              ;1299
000040  dd0e              BLE      |L55.96|
000042  7856              LDRB     r6,[r2,#1]            ;1299  ; bAreadyDown
000044  b966              CBNZ     r6,|L55.96|
000046  7015              STRB     r5,[r2,#0]            ;1301
000048  7050              STRB     r0,[r2,#1]            ;1302
00004a  3b1e              SUBS     r3,r3,#0x1e           ;1302
00004c  6093              STR      r3,[r2,#8]            ;1304  ; yLast
00004e  f64773ff          MOV      r3,#0x7fff            ;1304
                  |L55.82|
000052  2200              MOVS     r2,#0                 ;1304
000054  4620              MOV      r0,r4                 ;1304
000056  f7fffffe          BL       _SetCursorXY
00005a  4620              MOV      r0,r4                 ;1305
00005c  f7fffffe          BL       _Invalidate
                  |L55.96|
000060  2101              MOVS     r1,#1                 ;1309
000062  e008              B        |L55.118|
                  |L55.100|
000064  f04f30ff          MOV      r0,#0xffffffff        ;1311
000068  6090              STR      r0,[r2,#8]            ;1312  ; yLast
00006a  7015              STRB     r5,[r2,#0]            ;1312
00006c  7055              STRB     r5,[r2,#1]            ;1313
00006e  2102              MOVS     r1,#2                 ;1314
000070  e001              B        |L55.118|
                  |L55.114|
000072  e7ff              B        |L55.116|
                  |L55.116|
000074  2103              MOVS     r1,#3                 ;1317
                  |L55.118|
000076  4620              MOV      r0,r4                 ;1319
000078  e8bd4070          POP      {r4-r6,lr}            ;1319
00007c  f7ffbffe          B.W      WM_NotifyParent
;;;1339   /*********************************************************************
                          ENDP

                  |L55.128|
                          DCD      ||.data||

                          AREA ||i._SetCursorPos||, CODE, READONLY, ALIGN=1

                  _SetCursorPos PROC
;;;754    */
;;;755    static void _SetCursorPos(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj, int CursorPosChar) {
000000  b53e              PUSH     {r1-r5,lr}
000002  4605              MOV      r5,r0
;;;756      int CursorPosByte, CursorLine;
;;;757      CursorPosChar = _CalcNextValidCursorPos(hObj, pObj, CursorPosChar, &CursorPosByte, &CursorLine);
000004  a802              ADD      r0,sp,#8
000006  9000              STR      r0,[sp,#0]
000008  460c              MOV      r4,r1                 ;755
00000a  ab01              ADD      r3,sp,#4
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       _CalcNextValidCursorPos
;;;758      /* Assign value and recalc whatever necessary */
;;;759      if (pObj->CursorPosChar != CursorPosChar) {
000012  f8b41048          LDRH     r1,[r4,#0x48]
000016  4281              CMP      r1,r0
000018  d011              BEQ      |L56.62|
;;;760        /* Save values */
;;;761        pObj->CursorPosByte = CursorPosByte;
00001a  9901              LDR      r1,[sp,#4]
00001c  f8a4104a          STRH     r1,[r4,#0x4a]
;;;762        pObj->CursorPosChar = CursorPosChar;
000020  f8a40048          STRH     r0,[r4,#0x48]
;;;763        pObj->CursorLine = CursorLine;
000024  9802              LDR      r0,[sp,#8]
000026  f8a40046          STRH     r0,[r4,#0x46]
00002a  f8940079          LDRB     r0,[r4,#0x79]
;;;764        _InvalidateCursorXY(pObj); /* Invalidate X/Y position */
;;;765        _CalcScrollPos(hObj, pObj);
00002e  4621              MOV      r1,r4
000030  f0400008          ORR      r0,r0,#8
000034  f8840079          STRB     r0,[r4,#0x79]
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       _CalcScrollPos
                  |L56.62|
;;;766      }
;;;767    }
00003e  bd3e              POP      {r1-r5,pc}
;;;768    
                          ENDP


                          AREA ||i._SetCursorXY||, CODE, READONLY, ALIGN=2

                  _SetCursorXY PROC
;;;801    */
;;;802    static void _SetCursorXY(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ* pObj, int x, int y) {
000000  e92d5ff0          PUSH     {r4-r12,lr}
000004  0016              MOVS     r6,r2
000006  461c              MOV      r4,r3
000008  460d              MOV      r5,r1
00000a  4683              MOV      r11,r0
;;;803      int CursorPosChar = 0;
00000c  f04f0200          MOV      r2,#0
000010  d47a              BMI      |L57.264|
;;;804      if ((x < 0) || (y < 0)) {
000012  2c00              CMP      r4,#0
000014  db78              BLT      |L57.264|
;;;805        return;
;;;806      }
;;;807      if (pObj->hText) {
000016  8f28              LDRH     r0,[r5,#0x38]
000018  2800              CMP      r0,#0
00001a  d06f              BEQ      |L57.252|
;;;808        char *pLine, *pText;
;;;809        int CursorLine, WrapChars;
;;;810        int SizeX = 0;
00001c  4691              MOV      r9,r2
;;;811        U16 Char;
;;;812        GUI_SetFont(pObj->pFont);
00001e  6f68              LDR      r0,[r5,#0x74]
000020  f7fffffe          BL       GUI_SetFont
;;;813        CursorLine = y / GUI_GetFontDistY();
000024  f7fffffe          BL       GUI_GetFontDistY
000028  fb94f2f0          SDIV     r2,r4,r0
;;;814        pLine      = _GetpLine(hObj, pObj, CursorLine);
00002c  4629              MOV      r1,r5
00002e  4658              MOV      r0,r11
000030  f7fffffe          BL       _GetpLine
000034  4680              MOV      r8,r0
;;;815        pText      = (char*) GUI_ALLOC_h2p(pObj->hText);
000036  f9b50038          LDRSH    r0,[r5,#0x38]
00003a  f7fffffe          BL       GUI_ALLOC_h2p
00003e  4682              MOV      r10,r0
;;;816        WrapChars  = _WrapGetNumCharsDisp(hObj, pObj, pLine);
000040  4642              MOV      r2,r8
000042  4629              MOV      r1,r5
000044  4658              MOV      r0,r11
000046  f7fffffe          BL       _WrapGetNumCharsDisp
00004a  4604              MOV      r4,r0
;;;817        Char       = GUI_UC__GetCharCode(pLine + GUI_UC__NumChars2NumBytes(pLine, WrapChars));
00004c  4601              MOV      r1,r0
00004e  4640              MOV      r0,r8
000050  f7fffffe          BL       GUI_UC__NumChars2NumBytes
000054  492d              LDR      r1,|L57.268|
000056  4440              ADD      r0,r0,r8
000058  6a09              LDR      r1,[r1,#0x20]  ; GUI_Context
00005a  6809              LDR      r1,[r1,#0]
00005c  4788              BLX      r1
;;;818        if (pObj->Flags & MULTIEDIT_SF_PASSWORD) {
00005e  f8951078          LDRB     r1,[r5,#0x78]
000062  0689              LSLS     r1,r1,#26
000064  d501              BPL      |L57.106|
;;;819          if (!Char) {
000066  b148              CBZ      r0,|L57.124|
000068  e009              B        |L57.126|
                  |L57.106|
;;;820            WrapChars++;
;;;821          }
;;;822        } else {
;;;823          if (!Char || (Char == '\n') || ((Char == ' ') && (pObj->WrapMode == GUI_WRAPMODE_WORD))) {
00006a  b138              CBZ      r0,|L57.124|
00006c  280a              CMP      r0,#0xa
00006e  d005              BEQ      |L57.124|
000070  2820              CMP      r0,#0x20
000072  d104              BNE      |L57.126|
000074  f895007c          LDRB     r0,[r5,#0x7c]
000078  2801              CMP      r0,#1
00007a  d100              BNE      |L57.126|
                  |L57.124|
00007c  1c64              ADDS     r4,r4,#1
                  |L57.126|
;;;824            WrapChars++;
;;;825          }
;;;826        }
;;;827        if (pObj->Align == GUI_TA_RIGHT) {
00007e  f8b50058          LDRH     r0,[r5,#0x58]
000082  2801              CMP      r0,#1
000084  d10f              BNE      |L57.166|
;;;828          x -= _GetXSize(hObj, pObj) - GUI__GetLineDistX(pLine, WrapChars);
000086  4629              MOV      r1,r5
000088  4658              MOV      r0,r11
00008a  f7fffffe          BL       _GetXSize
00008e  4607              MOV      r7,r0
000090  4621              MOV      r1,r4
000092  4640              MOV      r0,r8
000094  f7fffffe          BL       GUI__GetLineDistX
000098  1a38              SUBS     r0,r7,r0
;;;829          x -= pObj->ScrollStateH.v << 1;
00009a  6ee9              LDR      r1,[r5,#0x6c]
00009c  1a30              SUBS     r0,r6,r0              ;828
00009e  ebb00641          SUBS     r6,r0,r1,LSL #1
;;;830          if (x < 0) {
0000a2  d500              BPL      |L57.166|
;;;831            x = 0;
0000a4  2600              MOVS     r6,#0
                  |L57.166|
;;;832          }
;;;833        }
;;;834    
;;;835        if (pObj->Flags & MULTIEDIT_SF_PASSWORD) {
0000a6  f8950078          LDRB     r0,[r5,#0x78]
0000aa  0680              LSLS     r0,r0,#26
0000ac  d410              BMI      |L57.208|
0000ae  e019              B        |L57.228|
                  |L57.176|
;;;836          while (--WrapChars > 0) {
;;;837            Char   = GUI_UC_GetCharCode(pLine);
0000b0  4640              MOV      r0,r8
0000b2  f7fffffe          BL       GUI_UC_GetCharCode
0000b6  4607              MOV      r7,r0
;;;838            SizeX += _GetCharDistX(pObj, pLine);
0000b8  4641              MOV      r1,r8
0000ba  4628              MOV      r0,r5
0000bc  f7fffffe          BL       _GetCharDistX
0000c0  4481              ADD      r9,r9,r0
;;;839            if (!Char || (SizeX > x)) {
0000c2  b147              CBZ      r7,|L57.214|
0000c4  45b1              CMP      r9,r6
0000c6  dc06              BGT      |L57.214|
;;;840              break;
;;;841            }
;;;842            pLine += GUI_UC_GetCharSize(pLine);
0000c8  4640              MOV      r0,r8
0000ca  f7fffffe          BL       GUI_UC_GetCharSize
0000ce  4480              ADD      r8,r8,r0
                  |L57.208|
0000d0  1e64              SUBS     r4,r4,#1
0000d2  2c00              CMP      r4,#0                 ;836
0000d4  dcec              BGT      |L57.176|
                  |L57.214|
;;;843          }
;;;844          CursorPosChar = GUI_UC__NumBytes2NumChars(pText, pLine - pText);
0000d6  eba8010a          SUB      r1,r8,r10
0000da  4650              MOV      r0,r10
0000dc  f7fffffe          BL       GUI_UC__NumBytes2NumChars
0000e0  4602              MOV      r2,r0
0000e2  e00b              B        |L57.252|
                  |L57.228|
;;;845        } else {
;;;846          CursorPosChar = GUI_UC__NumBytes2NumChars(pText, pLine - pText) + GUI__GetCursorPosChar(pLine, x, WrapChars);
0000e4  eba8010a          SUB      r1,r8,r10
0000e8  4650              MOV      r0,r10
0000ea  f7fffffe          BL       GUI_UC__NumBytes2NumChars
0000ee  4607              MOV      r7,r0
0000f0  4622              MOV      r2,r4
0000f2  4631              MOV      r1,r6
0000f4  4640              MOV      r0,r8
0000f6  f7fffffe          BL       GUI__GetCursorPosChar
0000fa  183a              ADDS     r2,r7,r0
                  |L57.252|
;;;847        }
;;;848      }
;;;849      _SetCursorPos(hObj, pObj, CursorPosChar);
0000fc  4629              MOV      r1,r5
0000fe  4658              MOV      r0,r11
000100  e8bd5ff0          POP      {r4-r12,lr}
000104  f7ffbffe          B.W      _SetCursorPos
                  |L57.264|
;;;850    }
000108  e8bd9ff0          POP      {r4-r12,pc}
;;;851    
                          ENDP

                  |L57.268|
                          DCD      GUI_Context

                          AREA ||i._SetFlag||, CODE, READONLY, ALIGN=1

                  _SetFlag PROC
;;;677    */
;;;678    static void _SetFlag(MULTIEDIT_HANDLE hObj, int OnOff, U8 Flag) {
000000  b570              PUSH     {r4-r6,lr}
000002  4614              MOV      r4,r2
000004  460d              MOV      r5,r1
000006  0006              MOVS     r6,r0
000008  d00d              BEQ      |L58.38|
;;;679      if (hObj) {
;;;680        MULTIEDIT_OBJ * pObj;
;;;681        WM_LOCK();
;;;682        pObj = MULTIEDIT_H2P(hObj);
00000a  f7fffffe          BL       GUI_ALLOC_h2p
;;;683        if (OnOff) {
;;;684          pObj->Flags |= Flag;
;;;685        } else {
;;;686          pObj->Flags &= ~Flag;
00000e  f8101f78          LDRB     r1,[r0,#0x78]!
000012  b10d              CBZ      r5,|L58.24|
000014  4321              ORRS     r1,r1,r4              ;684
000016  e000              B        |L58.26|
                  |L58.24|
000018  43a1              BICS     r1,r1,r4
                  |L58.26|
00001a  7001              STRB     r1,[r0,#0]
;;;687        }
;;;688        _InvalidateTextArea(hObj);
00001c  4630              MOV      r0,r6
00001e  e8bd4070          POP      {r4-r6,lr}
000022  f7ffbffe          B.W      _InvalidateTextArea
                  |L58.38|
;;;689        WM_UNLOCK();
;;;690      }
;;;691    }
000026  bd70              POP      {r4-r6,pc}
;;;692    
                          ENDP


                          AREA ||i._SetScrollState||, CODE, READONLY, ALIGN=1

                  _SetScrollState PROC
;;;452    */
;;;453    static void _SetScrollState(WM_HWIN hObj) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;454      MULTIEDIT_OBJ* pObj = MULTIEDIT_H2P(hObj);
000004  f7fffffe          BL       GUI_ALLOC_h2p
;;;455      WIDGET__SetScrollState(hObj, &pObj->ScrollStateV, &pObj->ScrollStateH);
000008  f1000268          ADD      r2,r0,#0x68
00000c  f100015c          ADD      r1,r0,#0x5c
000010  4620              MOV      r0,r4
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      WIDGET__SetScrollState
;;;456    }
;;;457    
                          ENDP


                          AREA ||i._SetText||, CODE, READONLY, ALIGN=1

                  _SetText PROC
;;;1432   */
;;;1433   static void _SetText(MULTIEDIT_HANDLE hObj, MULTIEDIT_OBJ * pObj, const char * pNew) {
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1434     int NumCharsNew, NumCharsOld, NumBytesNew, NumBytesOld;
;;;1435     char * pText;
;;;1436     NumCharsNew = NumCharsOld = NumBytesNew = NumBytesOld = 0;
000004  2500              MOVS     r5,#0
000006  4682              MOV      r10,r0                ;1433
000008  462f              MOV      r7,r5
00000a  46b8              MOV      r8,r7
;;;1437     if (pObj->hText) {
00000c  f9b10038          LDRSH    r0,[r1,#0x38]
000010  4691              MOV      r9,r2                 ;1433
000012  460c              MOV      r4,r1                 ;1433
000014  4646              MOV      r6,r8                 ;1436
000016  b178              CBZ      r0,|L60.56|
;;;1438       pText  = (char*) GUI_ALLOC_h2p(pObj->hText);
000018  f7fffffe          BL       GUI_ALLOC_h2p
00001c  4606              MOV      r6,r0
;;;1439       pText += GUI_UC__NumChars2NumBytes(pText, pObj->NumCharsPrompt);
00001e  8fe1              LDRH     r1,[r4,#0x3e]
000020  f7fffffe          BL       GUI_UC__NumChars2NumBytes
000024  1987              ADDS     r7,r0,r6
;;;1440       NumCharsOld = GUI__GetNumChars(pText);
000026  4638              MOV      r0,r7
000028  f7fffffe          BL       GUI__GetNumChars
00002c  4606              MOV      r6,r0
;;;1441       NumBytesOld = GUI_UC__NumChars2NumBytes(pText, NumCharsOld);
00002e  4601              MOV      r1,r0
000030  4638              MOV      r0,r7
000032  f7fffffe          BL       GUI_UC__NumChars2NumBytes
000036  4607              MOV      r7,r0
                  |L60.56|
;;;1442     }
;;;1443     if (pNew) {
000038  ea5f0009          MOVS     r0,r9
00003c  d007              BEQ      |L60.78|
;;;1444       NumCharsNew = GUI__GetNumChars(pNew);
00003e  f7fffffe          BL       GUI__GetNumChars
000042  4605              MOV      r5,r0
;;;1445       NumBytesNew = GUI_UC__NumChars2NumBytes(pNew, NumCharsNew);
000044  4601              MOV      r1,r0
000046  4648              MOV      r0,r9
000048  f7fffffe          BL       GUI_UC__NumChars2NumBytes
00004c  4680              MOV      r8,r0
                  |L60.78|
;;;1446     }
;;;1447     if (_IsCharsAvailable(pObj, NumCharsNew - NumCharsOld)) {
00004e  1ba9              SUBS     r1,r5,r6
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       _IsCharsAvailable
000056  2800              CMP      r0,#0
000058  d028              BEQ      |L60.172|
;;;1448       if (_IsSpaceInBuffer(pObj, NumBytesNew - NumBytesOld)) {
00005a  eba80107          SUB      r1,r8,r7
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       _IsSpaceInBuffer
000064  2800              CMP      r0,#0
000066  d021              BEQ      |L60.172|
;;;1449         pText  = (char*) GUI_ALLOC_h2p(pObj->hText);
000068  f9b40038          LDRSH    r0,[r4,#0x38]
00006c  f7fffffe          BL       GUI_ALLOC_h2p
000070  4605              MOV      r5,r0
;;;1450         pText += GUI_UC__NumChars2NumBytes(pText, pObj->NumCharsPrompt);
000072  8fe1              LDRH     r1,[r4,#0x3e]
000074  f7fffffe          BL       GUI_UC__NumChars2NumBytes
000078  4428              ADD      r0,r0,r5
;;;1451         if (pNew) {
00007a  ea5f0109          MOVS     r1,r9
00007e  d002              BEQ      |L60.134|
;;;1452           strcpy(pText, pNew);
000080  f7fffffe          BL       strcpy
000084  e001              B        |L60.138|
                  |L60.134|
;;;1453         } else {
;;;1454           *pText = 0;
000086  2100              MOVS     r1,#0
000088  7001              STRB     r1,[r0,#0]
                  |L60.138|
;;;1455         }
;;;1456         _SetCursorPos(hObj, pObj, pObj->NumCharsPrompt);
00008a  8fe2              LDRH     r2,[r4,#0x3e]
00008c  4621              MOV      r1,r4
00008e  4650              MOV      r0,r10
000090  f7fffffe          BL       _SetCursorPos
000094  f8140f79          LDRB     r0,[r4,#0x79]!
000098  f0400007          ORR      r0,r0,#7
00009c  7020              STRB     r0,[r4,#0]
;;;1457         _InvalidateNumChars(pObj);
;;;1458         _InvalidateNumLines(pObj);
;;;1459         _InvalidateTextSizeX(pObj);
;;;1460         _InvalidateTextArea(hObj);
00009e  4650              MOV      r0,r10
0000a0  f7fffffe          BL       _InvalidateTextArea
0000a4  7820              LDRB     r0,[r4,#0]
0000a6  f0400008          ORR      r0,r0,#8
0000aa  7020              STRB     r0,[r4,#0]
                  |L60.172|
;;;1461         _InvalidateCursorXY(pObj); /* Invalidate X/Y position */
;;;1462       }
;;;1463     }
;;;1464   }
0000ac  e8bd87f0          POP      {r4-r10,pc}
;;;1465   
                          ENDP


                          AREA ||i._SetWrapMode||, CODE, READONLY, ALIGN=1

                  _SetWrapMode PROC
;;;772    */
;;;773    static int _SetWrapMode(MULTIEDIT_HANDLE hObj, GUI_WRAPMODE WrapMode) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  460f              MOV      r7,r1
000006  0006              MOVS     r6,r0
;;;774      int r;
;;;775      r = 0;
000008  f04f0500          MOV      r5,#0
00000c  d01c              BEQ      |L61.72|
;;;776      if (hObj) {
;;;777        MULTIEDIT_OBJ * pObj;
;;;778        WM_LOCK();
;;;779        pObj = MULTIEDIT_H2P(hObj);
00000e  f7fffffe          BL       GUI_ALLOC_h2p
;;;780        r = pObj->WrapMode;
000012  f890507c          LDRB     r5,[r0,#0x7c]
000016  4604              MOV      r4,r0                 ;779
;;;781        if (pObj->WrapMode != WrapMode) {
000018  42bd              CMP      r5,r7
00001a  d015              BEQ      |L61.72|
;;;782          int Position;
;;;783          pObj->WrapMode = WrapMode;
00001c  f884707c          STRB     r7,[r4,#0x7c]
000020  345d              ADDS     r4,r4,#0x5d
;;;784          _ClearCache(pObj);
000022  f7fffffe          BL       _ClearCache
000026  7f20              LDRB     r0,[r4,#0x1c]
000028  f0400006          ORR      r0,r0,#6
00002c  7720              STRB     r0,[r4,#0x1c]
;;;785          _InvalidateNumLines(pObj);
;;;786          _InvalidateTextSizeX(pObj);
;;;787          _InvalidateTextArea(hObj);
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       _InvalidateTextArea
000034  f8342d15          LDRH     r2,[r4,#-0x15]!
000038  f64f70ff          MOV      r0,#0xffff
00003c  f8240948          STRH     r0,[r4],#-0x48
;;;788          Position = _InvalidateCursorPos(pObj);
;;;789          _SetCursorPos(hObj, pObj, Position);
000040  4621              MOV      r1,r4
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       _SetCursorPos
                  |L61.72|
;;;790        }
;;;791        WM_UNLOCK();
;;;792      }
;;;793      return r;
000048  4628              MOV      r0,r5
;;;794    }
00004a  e8bd81f0          POP      {r4-r8,pc}
;;;795    
                          ENDP


                          AREA ||i._WrapGetNumBytesToNextLine||, CODE, READONLY, ALIGN=1

                  _WrapGetNumBytesToNextLine PROC
;;;252    */
;;;253    static int _WrapGetNumBytesToNextLine(MULTIEDIT_HANDLE hObj, const MULTIEDIT_OBJ* pObj, const char* pText) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4614              MOV      r4,r2
000006  460d              MOV      r5,r1
000008  4607              MOV      r7,r0
;;;254      int xSize, r;
;;;255      xSize = _GetXSize(hObj, pObj);
00000a  f7fffffe          BL       _GetXSize
00000e  4601              MOV      r1,r0
;;;256      if (pObj->Flags & MULTIEDIT_SF_PASSWORD) {
000010  f8950078          LDRB     r0,[r5,#0x78]
000014  0680              LSLS     r0,r0,#26
000016  d516              BPL      |L62.70|
;;;257        int NumChars, NumCharsPrompt;
;;;258        NumCharsPrompt = _GetNumCharsInPrompt(pObj, pText);
000018  4621              MOV      r1,r4
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       _GetNumCharsInPrompt
000020  4606              MOV      r6,r0
;;;259        NumChars = _WrapGetNumCharsDisp(hObj, pObj, pText);
000022  4622              MOV      r2,r4
000024  4629              MOV      r1,r5
000026  4638              MOV      r0,r7
000028  f7fffffe          BL       _WrapGetNumCharsDisp
00002c  4605              MOV      r5,r0
;;;260        r        = GUI_UC__NumChars2NumBytes(pText, NumChars);
00002e  4601              MOV      r1,r0
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       GUI_UC__NumChars2NumBytes
;;;261        if (NumChars < NumCharsPrompt) {
000036  42b5              CMP      r5,r6
000038  da03              BGE      |L62.66|
;;;262          if (*(pText + r) == '\n') {
00003a  5c21              LDRB     r1,[r4,r0]
00003c  290a              CMP      r1,#0xa
00003e  d100              BNE      |L62.66|
000040  1c40              ADDS     r0,r0,#1
                  |L62.66|
;;;263            r++;
;;;264          }
;;;265        }
;;;266      } else {
;;;267        r = GUI__WrapGetNumBytesToNextLine(pText, xSize, pObj->WrapMode);
;;;268      }
;;;269      return r;
;;;270    }
000042  e8bd81f0          POP      {r4-r8,pc}
                  |L62.70|
000046  f895207c          LDRB     r2,[r5,#0x7c]         ;267
00004a  4620              MOV      r0,r4                 ;267
00004c  e8bd41f0          POP      {r4-r8,lr}            ;267
000050  f7ffbffe          B.W      GUI__WrapGetNumBytesToNextLine
;;;271    
                          ENDP


                          AREA ||i._WrapGetNumCharsDisp||, CODE, READONLY, ALIGN=1

                  _WrapGetNumCharsDisp PROC
;;;215    */
;;;216    static int _WrapGetNumCharsDisp(MULTIEDIT_HANDLE hObj, const MULTIEDIT_OBJ* pObj, const char GUI_UNI_PTR * pText) {
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
000002  460d              MOV      r5,r1
;;;217      int xSize, r;
;;;218      xSize = _GetXSize(hObj, pObj);
000004  f7fffffe          BL       _GetXSize
000008  4607              MOV      r7,r0
;;;219      if (pObj->Flags & MULTIEDIT_SF_PASSWORD) {
00000a  f8950078          LDRB     r0,[r5,#0x78]
00000e  0680              LSLS     r0,r0,#26
000010  d532              BPL      |L63.120|
;;;220        int NumCharsPrompt;
;;;221        NumCharsPrompt = _GetNumCharsInPrompt(pObj, pText);
000012  4628              MOV      r0,r5
000014  9902              LDR      r1,[sp,#8]
000016  f7fffffe          BL       _GetNumCharsInPrompt
00001a  4606              MOV      r6,r0
;;;222        r = GUI__WrapGetNumCharsDisp(pText, xSize, pObj->WrapMode);
00001c  f895207c          LDRB     r2,[r5,#0x7c]
000020  4639              MOV      r1,r7
000022  9802              LDR      r0,[sp,#8]
000024  f7fffffe          BL       GUI__WrapGetNumCharsDisp
000028  4604              MOV      r4,r0
;;;223        if (r >= NumCharsPrompt) {
00002a  42b0              CMP      r0,r6
00002c  db22              BLT      |L63.116|
;;;224          int x;
;;;225          switch (pObj->WrapMode) {
00002e  f895007c          LDRB     r0,[r5,#0x7c]
000032  b168              CBZ      r0,|L63.80|
;;;226          case GUI_WRAPMODE_NONE:
;;;227            r = GUI__GetNumChars(pText);
;;;228            break;
;;;229          default:
;;;230            r = NumCharsPrompt;
000034  4634              MOV      r4,r6
;;;231            x = GUI__GetLineDistX(pText, NumCharsPrompt);
000036  4621              MOV      r1,r4
000038  9802              LDR      r0,[sp,#8]
00003a  f7fffffe          BL       GUI__GetLineDistX
00003e  4605              MOV      r5,r0
;;;232            pText += GUI_UC__NumChars2NumBytes(pText, NumCharsPrompt);
000040  4631              MOV      r1,r6
000042  9802              LDR      r0,[sp,#8]
000044  f7fffffe          BL       GUI_UC__NumChars2NumBytes
000048  9902              LDR      r1,[sp,#8]
00004a  4408              ADD      r0,r0,r1
;;;233            while (GUI_UC__GetCharCodeInc(&pText) != 0) {
00004c  9002              STR      r0,[sp,#8]
00004e  e00c              B        |L63.106|
                  |L63.80|
000050  9802              LDR      r0,[sp,#8]            ;227
000052  f7fffffe          BL       GUI__GetNumChars
                  |L63.86|
000056  4604              MOV      r4,r0                 ;227
000058  e00c              B        |L63.116|
                  |L63.90|
;;;234              x += GUI_GetCharDistX(MULTIEDIT_PASSWORD_CHAR);
00005a  202a              MOVS     r0,#0x2a
00005c  f7fffffe          BL       GUI_GetCharDistX
000060  4405              ADD      r5,r5,r0
;;;235              if (r && (x > xSize)) {
000062  b10c              CBZ      r4,|L63.104|
000064  42bd              CMP      r5,r7
000066  dc05              BGT      |L63.116|
                  |L63.104|
000068  1c64              ADDS     r4,r4,#1
                  |L63.106|
00006a  a802              ADD      r0,sp,#8              ;233
00006c  f7fffffe          BL       GUI_UC__GetCharCodeInc
000070  2800              CMP      r0,#0                 ;233
000072  d1f2              BNE      |L63.90|
                  |L63.116|
;;;236                break;
;;;237              }
;;;238              r++;
;;;239            }
;;;240            break;
;;;241          }
;;;242        }
;;;243      } else {
;;;244        r = GUI__WrapGetNumCharsDisp(pText, xSize, pObj->WrapMode);
;;;245      }
;;;246      return r;
000074  4620              MOV      r0,r4
;;;247    }
000076  bdfe              POP      {r1-r7,pc}
                  |L63.120|
000078  f895207c          LDRB     r2,[r5,#0x7c]         ;244
00007c  4639              MOV      r1,r7                 ;244
00007e  9802              LDR      r0,[sp,#8]            ;244
000080  f7fffffe          BL       GUI__WrapGetNumCharsDisp
000084  e7e7              B        |L63.86|
;;;248    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  bAreadyUp
000000  00                DCB      0x00
                  bAreadyDown
000001  000000            DCB      0x00,0x00,0x00
                  _pDefaultFont
                          DCD      GUI_Font13_1
                  yLast
                          DCD      0xffffffff
                  _aDefaultBkColor
                          DCD      0x00ffffff
                          DCD      0x00c0c0c0
                  _aDefaultColor
                          DCD      0x00000000
                          DCD      0x00000000
