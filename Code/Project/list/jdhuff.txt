; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\jdhuff.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jdhuff.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\JPEG\jdhuff.c]
                          THUMB

                          AREA ||i.decode_mcu||, CODE, READONLY, ALIGN=2

                  decode_mcu PROC
;;;516    METHODDEF(boolean)
;;;517    decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
000000  e92d4ff3          PUSH     {r0,r1,r4-r11,lr}
;;;518    {
000004  4606              MOV      r6,r0
;;;519      huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
;;;520      int blkn;
;;;521      BITREAD_STATE_VARS;
;;;522      savable_state state;
;;;523    
;;;524      /* Process restart marker if needed; may have to suspend */
;;;525      if (cinfo->restart_interval) {
000006  f8d041bc          LDR      r4,[r0,#0x1bc]
00000a  f8d00114          LDR      r0,[r0,#0x114]
00000e  b08b              SUB      sp,sp,#0x2c           ;518
000010  b338              CBZ      r0,|L1.98|
;;;526        if (entropy->restarts_to_go == 0)
000012  6a60              LDR      r0,[r4,#0x24]
000014  bb28              CBNZ     r0,|L1.98|
000016  6920              LDR      r0,[r4,#0x10]
000018  f8d621b8          LDR      r2,[r6,#0x1b8]
00001c  17c3              ASRS     r3,r0,#31
00001e  eb007053          ADD      r0,r0,r3,LSR #29
000022  6991              LDR      r1,[r2,#0x18]
000024  2700              MOVS     r7,#0
000026  eb0100e0          ADD      r0,r1,r0,ASR #3
00002a  6190              STR      r0,[r2,#0x18]
00002c  6127              STR      r7,[r4,#0x10]
00002e  f8d601b8          LDR      r0,[r6,#0x1b8]
000032  4625              MOV      r5,r4
000034  6881              LDR      r1,[r0,#8]
000036  4630              MOV      r0,r6
000038  4788              BLX      r1
00003a  2800              CMP      r0,#0
00003c  d07d              BEQ      |L1.314|
00003e  2000              MOVS     r0,#0
000040  e004              B        |L1.76|
000042  bf00              NOP      
                  |L1.68|
000044  eb050180          ADD      r1,r5,r0,LSL #2
000048  1c40              ADDS     r0,r0,#1
00004a  614f              STR      r7,[r1,#0x14]
                  |L1.76|
00004c  f8d61148          LDR      r1,[r6,#0x148]
000050  4281              CMP      r1,r0
000052  dcf7              BGT      |L1.68|
000054  f8d60114          LDR      r0,[r6,#0x114]
000058  6268              STR      r0,[r5,#0x24]
00005a  f8d601a0          LDR      r0,[r6,#0x1a0]
00005e  b900              CBNZ     r0,|L1.98|
000060  60af              STR      r7,[r5,#8]
                  |L1.98|
;;;527          if (! process_restart(cinfo))
;;;528    	return FALSE;
;;;529      }
;;;530    
;;;531      /* If we've run out of data, just leave the MCU set to zeroes.
;;;532       * This way, we return uniform gray for the remainder of the segment.
;;;533       */
;;;534      if (! entropy->pub.insufficient_data) {
000062  68a0              LDR      r0,[r4,#8]
000064  2800              CMP      r0,#0
000066  d169              BNE      |L1.316|
;;;535    
;;;536        /* Load up working state */
;;;537        BITREAD_LOAD_STATE(cinfo,entropy->bitstate);
000068  9605              STR      r6,[sp,#0x14]
00006a  69b0              LDR      r0,[r6,#0x18]
00006c  f10d0818          ADD      r8,sp,#0x18
;;;538        ASSIGN_STATE(state, entropy->saved);
;;;539    
;;;540        /* Outer loop handles each block in the MCU */
;;;541    
;;;542        for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
;;;543          JBLOCKROW block = MCU_data[blkn];
;;;544          d_derived_tbl * dctbl = entropy->dc_cur_tbls[blkn];
;;;545          d_derived_tbl * actbl = entropy->ac_cur_tbls[blkn];
;;;546          register int s, k, r;
;;;547    
;;;548          /* Decode a single block's worth of coefficients */
;;;549    
;;;550          /* Section F.2.2.1: decode the DC coefficient difference */
;;;551          HUFF_DECODE(s, br_state, dctbl, return FALSE, label1);
;;;552          if (s) {
;;;553    	CHECK_BIT_BUFFER(br_state, s, return FALSE);
;;;554    	r = GET_BITS(s);
;;;555    	s = HUFF_EXTEND(r, s);
000070  f8dfb254          LDR      r11,|L1.712|
000074  6801              LDR      r1,[r0,#0]            ;537
000076  9101              STR      r1,[sp,#4]            ;537
000078  6840              LDR      r0,[r0,#4]            ;537
00007a  9002              STR      r0,[sp,#8]            ;537
00007c  f1040014          ADD      r0,r4,#0x14           ;537
000080  e9d41203          LDRD     r1,r2,[r4,#0xc]       ;537
000084  c8a9              LDM      r0,{r0,r3,r5,r7}      ;537
000086  e88800a9          STM      r8,{r0,r3,r5,r7}      ;537
00008a  f04f0800          MOV      r8,#0                 ;542
00008e  e102              B        |L1.662|
                  |L1.144|
000090  980c              LDR      r0,[sp,#0x30]         ;543
000092  2a08              CMP      r2,#8                 ;551
000094  f850a028          LDR      r10,[r0,r8,LSL #2]    ;543
000098  eb040088          ADD      r0,r4,r8,LSL #2       ;544
00009c  4681              MOV      r9,r0                 ;544
00009e  6f07              LDR      r7,[r0,#0x70]         ;551
0000a0  6c85              LDR      r5,[r0,#0x48]         ;551
0000a2  da0b              BGE      |L1.188|
0000a4  2300              MOVS     r3,#0                 ;551
0000a6  a801              ADD      r0,sp,#4              ;551
0000a8  f7fffffe          BL       jpeg_fill_bit_buffer
0000ac  2800              CMP      r0,#0                 ;551
0000ae  d044              BEQ      |L1.314|
0000b0  e9dd1203          LDRD     r1,r2,[sp,#0xc]       ;551
0000b4  2a08              CMP      r2,#8                 ;551
0000b6  da01              BGE      |L1.188|
0000b8  2001              MOVS     r0,#1                 ;551
0000ba  e00f              B        |L1.220|
                  |L1.188|
0000bc  f1a20008          SUB      r0,r2,#8              ;551
0000c0  fa41f000          ASR      r0,r1,r0              ;551
0000c4  b2c0              UXTB     r0,r0                 ;551
0000c6  eb050380          ADD      r3,r5,r0,LSL #2       ;551
0000ca  f8d33090          LDR      r3,[r3,#0x90]         ;551
0000ce  b123              CBZ      r3,|L1.218|
0000d0  4428              ADD      r0,r0,r5              ;551
0000d2  1ad2              SUBS     r2,r2,r3              ;551
0000d4  f8905490          LDRB     r5,[r0,#0x490]        ;551
0000d8  e009              B        |L1.238|
                  |L1.218|
0000da  2009              MOVS     r0,#9                 ;551
                  |L1.220|
0000dc  9000              STR      r0,[sp,#0]            ;551
0000de  462b              MOV      r3,r5                 ;551
0000e0  a801              ADD      r0,sp,#4              ;551
0000e2  f7fffffe          BL       jpeg_huff_decode
0000e6  0005              MOVS     r5,r0                 ;551
0000e8  d474              BMI      |L1.468|
0000ea  e9dd1203          LDRD     r1,r2,[sp,#0xc]       ;551
                  |L1.238|
0000ee  b1d5              CBZ      r5,|L1.294|
0000f0  42aa              CMP      r2,r5                 ;553
0000f2  da07              BGE      |L1.260|
0000f4  462b              MOV      r3,r5                 ;553
0000f6  a801              ADD      r0,sp,#4              ;553
0000f8  f7fffffe          BL       jpeg_fill_bit_buffer
0000fc  2800              CMP      r0,#0                 ;553
0000fe  d01c              BEQ      |L1.314|
000100  e9dd1203          LDRD     r1,r2,[sp,#0xc]       ;553
                  |L1.260|
000104  1b52              SUBS     r2,r2,r5              ;554
000106  fa41f302          ASR      r3,r1,r2              ;554
00010a  2001              MOVS     r0,#1                 ;554
00010c  40a8              LSLS     r0,r0,r5              ;554
00010e  1e40              SUBS     r0,r0,#1              ;554
000110  4018              ANDS     r0,r0,r3              ;554
000112  f85b3025          LDR      r3,[r11,r5,LSL #2]
000116  4283              CMP      r3,r0
000118  dd04              BLE      |L1.292|
00011a  4b6b              LDR      r3,|L1.712|
00011c  3340              ADDS     r3,r3,#0x40
00011e  f8533025          LDR      r3,[r3,r5,LSL #2]
000122  4418              ADD      r0,r0,r3
                  |L1.292|
000124  4605              MOV      r5,r0
                  |L1.294|
;;;556          }
;;;557    
;;;558          if (entropy->dc_needed[blkn]) {
000126  f8d90098          LDR      r0,[r9,#0x98]
00012a  b178              CBZ      r0,|L1.332|
;;;559    	/* Convert DC difference to actual value, update last_dc_val */
;;;560    	int ci = cinfo->MCU_membership[blkn];
00012c  eb060088          ADD      r0,r6,r8,LSL #2
;;;561    	s += state.last_dc_val[ci];
000130  f10d0c18          ADD      r12,sp,#0x18
000134  f8d03168          LDR      r3,[r0,#0x168]
000138  e001              B        |L1.318|
                  |L1.314|
00013a  e08b              B        |L1.596|
                  |L1.316|
00013c  e0bf              B        |L1.702|
                  |L1.318|
00013e  f85c0023          LDR      r0,[r12,r3,LSL #2]
000142  4428              ADD      r0,r0,r5
;;;562    	state.last_dc_val[ci] = s;
000144  f84c0023          STR      r0,[r12,r3,LSL #2]
;;;563    	/* Output the DC coefficient (assumes jpeg_natural_order[0] = 0) */
;;;564    	(*block)[0] = (JCOEF) s;
000148  f8aa0000          STRH     r0,[r10,#0]
                  |L1.332|
;;;565          }
;;;566    
;;;567          if (entropy->ac_needed[blkn]) {
;;;568    
;;;569    	/* Section F.2.2.2: decode the AC coefficients */
;;;570    	/* Since zeroes are skipped, output area must be cleared beforehand */
;;;571    	for (k = 1; k < DCTSIZE2; k++) {
;;;572    	  HUFF_DECODE(s, br_state, actbl, return FALSE, label2);
;;;573          
;;;574    	  r = s >> 4;
;;;575    	  s &= 15;
;;;576          
;;;577    	  if (s) {
;;;578    	    k += r;
;;;579    	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
;;;580    	    r = GET_BITS(s);
;;;581    	    s = HUFF_EXTEND(r, s);
;;;582    	    /* Output coefficient in natural (dezigzagged) order.
;;;583    	     * Note: the extra entries in jpeg_natural_order[] will save us
;;;584    	     * if k >= DCTSIZE2, which could happen if the data is corrupted.
;;;585    	     */
;;;586    	    (*block)[jpeg_natural_order[k]] = (JCOEF) s;
;;;587    	  } else {
;;;588    	    if (r != 15)
;;;589    	      break;
;;;590    	    k += 15;
;;;591    	  }
;;;592    	}
;;;593    
;;;594          } else {
;;;595    
;;;596    	/* Section F.2.2.2: decode the AC coefficients */
;;;597    	/* In this path we just discard the values */
;;;598    	for (k = 1; k < DCTSIZE2; k++) {
00014c  f8d900c0          LDR      r0,[r9,#0xc0]
000150  f04f0901          MOV      r9,#1
000154  b3e8              CBZ      r0,|L1.466|
                  |L1.342|
000156  2a08              CMP      r2,#8                 ;572
000158  da0b              BGE      |L1.370|
00015a  2300              MOVS     r3,#0                 ;572
00015c  a801              ADD      r0,sp,#4              ;572
00015e  f7fffffe          BL       jpeg_fill_bit_buffer
000162  2800              CMP      r0,#0                 ;572
000164  d076              BEQ      |L1.596|
000166  e9dd1203          LDRD     r1,r2,[sp,#0xc]       ;572
00016a  2a08              CMP      r2,#8                 ;572
00016c  da01              BGE      |L1.370|
00016e  2001              MOVS     r0,#1                 ;572
000170  e00f              B        |L1.402|
                  |L1.370|
000172  f1a20008          SUB      r0,r2,#8              ;572
000176  fa41f000          ASR      r0,r1,r0              ;572
00017a  b2c0              UXTB     r0,r0                 ;572
00017c  eb070380          ADD      r3,r7,r0,LSL #2       ;572
000180  f8d33090          LDR      r3,[r3,#0x90]         ;572
000184  b123              CBZ      r3,|L1.400|
000186  4438              ADD      r0,r0,r7              ;572
000188  1ad2              SUBS     r2,r2,r3              ;572
00018a  f8900490          LDRB     r0,[r0,#0x490]        ;572
00018e  e009              B        |L1.420|
                  |L1.400|
000190  2009              MOVS     r0,#9                 ;572
                  |L1.402|
000192  9000              STR      r0,[sp,#0]            ;572
000194  463b              MOV      r3,r7                 ;572
000196  a801              ADD      r0,sp,#4              ;572
000198  f7fffffe          BL       jpeg_huff_decode
00019c  2800              CMP      r0,#0                 ;572
00019e  db58              BLT      |L1.594|
0001a0  e9dd1203          LDRD     r1,r2,[sp,#0xc]       ;572
                  |L1.420|
0001a4  1103              ASRS     r3,r0,#4              ;574
0001a6  f010050f          ANDS     r5,r0,#0xf            ;575
0001aa  d023              BEQ      |L1.500|
0001ac  4499              ADD      r9,r9,r3              ;578
0001ae  42aa              CMP      r2,r5                 ;579
0001b0  da07              BGE      |L1.450|
0001b2  462b              MOV      r3,r5                 ;579
0001b4  a801              ADD      r0,sp,#4              ;579
0001b6  f7fffffe          BL       jpeg_fill_bit_buffer
0001ba  2800              CMP      r0,#0                 ;579
0001bc  d04a              BEQ      |L1.596|
0001be  e9dd1203          LDRD     r1,r2,[sp,#0xc]       ;579
                  |L1.450|
0001c2  1b52              SUBS     r2,r2,r5              ;580
0001c4  fa41f002          ASR      r0,r1,r2              ;580
0001c8  2301              MOVS     r3,#1                 ;580
0001ca  40ab              LSLS     r3,r3,r5              ;580
0001cc  1e5b              SUBS     r3,r3,#1              ;580
0001ce  4018              ANDS     r0,r0,r3              ;580
0001d0  e001              B        |L1.470|
                  |L1.466|
0001d2  e019              B        |L1.520|
                  |L1.468|
0001d4  e03d              B        |L1.594|
                  |L1.470|
0001d6  f85b3025          LDR      r3,[r11,r5,LSL #2]    ;581
0001da  4283              CMP      r3,r0                 ;581
0001dc  dd04              BLE      |L1.488|
0001de  4b3a              LDR      r3,|L1.712|
0001e0  3340              ADDS     r3,r3,#0x40           ;581
0001e2  f8533025          LDR      r3,[r3,r5,LSL #2]     ;581
0001e6  4418              ADD      r0,r0,r3              ;581
                  |L1.488|
0001e8  4d38              LDR      r5,|L1.716|
0001ea  f8555029          LDR      r5,[r5,r9,LSL #2]     ;586
0001ee  f82a0015          STRH     r0,[r10,r5,LSL #1]    ;586
0001f2  e003              B        |L1.508|
                  |L1.500|
0001f4  2b0f              CMP      r3,#0xf               ;588
0001f6  d14c              BNE      |L1.658|
0001f8  f109090f          ADD      r9,r9,#0xf            ;590
                  |L1.508|
0001fc  f1090901          ADD      r9,r9,#1              ;571
000200  f1b90f40          CMP      r9,#0x40              ;571
000204  dba7              BLT      |L1.342|
000206  e044              B        |L1.658|
                  |L1.520|
;;;599    	  HUFF_DECODE(s, br_state, actbl, return FALSE, label3);
000208  2a08              CMP      r2,#8
00020a  da0b              BGE      |L1.548|
00020c  2300              MOVS     r3,#0
00020e  a801              ADD      r0,sp,#4
000210  f7fffffe          BL       jpeg_fill_bit_buffer
000214  2800              CMP      r0,#0
000216  d01d              BEQ      |L1.596|
000218  e9dd1203          LDRD     r1,r2,[sp,#0xc]
00021c  2a08              CMP      r2,#8
00021e  da01              BGE      |L1.548|
000220  2001              MOVS     r0,#1
000222  e00f              B        |L1.580|
                  |L1.548|
000224  f1a20008          SUB      r0,r2,#8
000228  fa41f000          ASR      r0,r1,r0
00022c  b2c0              UXTB     r0,r0
00022e  eb070380          ADD      r3,r7,r0,LSL #2
000232  f8d33090          LDR      r3,[r3,#0x90]
000236  b123              CBZ      r3,|L1.578|
000238  4438              ADD      r0,r0,r7
00023a  1ad2              SUBS     r2,r2,r3
00023c  f8900490          LDRB     r0,[r0,#0x490]
000240  e00d              B        |L1.606|
                  |L1.578|
000242  2009              MOVS     r0,#9
                  |L1.580|
000244  9000              STR      r0,[sp,#0]
000246  463b              MOV      r3,r7
000248  a801              ADD      r0,sp,#4
00024a  f7fffffe          BL       jpeg_huff_decode
00024e  2800              CMP      r0,#0
000250  da03              BGE      |L1.602|
                  |L1.594|
000252  2000              MOVS     r0,#0
                  |L1.596|
;;;600          
;;;601    	  r = s >> 4;
;;;602    	  s &= 15;
;;;603          
;;;604    	  if (s) {
;;;605    	    k += r;
;;;606    	    CHECK_BIT_BUFFER(br_state, s, return FALSE);
;;;607    	    DROP_BITS(s);
;;;608    	  } else {
;;;609    	    if (r != 15)
;;;610    	      break;
;;;611    	    k += 15;
;;;612    	  }
;;;613    	}
;;;614    
;;;615          }
;;;616        }
;;;617    
;;;618        /* Completed MCU, so update state */
;;;619        BITREAD_SAVE_STATE(cinfo,entropy->bitstate);
;;;620        ASSIGN_STATE(entropy->saved, state);
;;;621      }
;;;622    
;;;623      /* Account for restart interval (no-op if not using restarts) */
;;;624      entropy->restarts_to_go--;
;;;625    
;;;626      return TRUE;
;;;627    }
000254  b00d              ADD      sp,sp,#0x34
000256  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.602|
00025a  e9dd1203          LDRD     r1,r2,[sp,#0xc]
                  |L1.606|
00025e  1103              ASRS     r3,r0,#4              ;601
000260  f010050f          ANDS     r5,r0,#0xf            ;602
000264  d00c              BEQ      |L1.640|
000266  4499              ADD      r9,r9,r3              ;605
000268  42aa              CMP      r2,r5                 ;606
00026a  da07              BGE      |L1.636|
00026c  462b              MOV      r3,r5                 ;606
00026e  a801              ADD      r0,sp,#4              ;606
000270  f7fffffe          BL       jpeg_fill_bit_buffer
000274  2800              CMP      r0,#0                 ;606
000276  d0ed              BEQ      |L1.596|
000278  e9dd1203          LDRD     r1,r2,[sp,#0xc]       ;606
                  |L1.636|
00027c  1b52              SUBS     r2,r2,r5              ;607
00027e  e003              B        |L1.648|
                  |L1.640|
000280  2b0f              CMP      r3,#0xf               ;609
000282  d106              BNE      |L1.658|
000284  f109090f          ADD      r9,r9,#0xf            ;611
                  |L1.648|
000288  f1090901          ADD      r9,r9,#1              ;598
00028c  f1b90f40          CMP      r9,#0x40              ;598
000290  dbba              BLT      |L1.520|
                  |L1.658|
000292  f1080801          ADD      r8,r8,#1              ;542
                  |L1.662|
000296  f8d63164          LDR      r3,[r6,#0x164]        ;542
00029a  4543              CMP      r3,r8                 ;542
00029c  f73faef8          BGT      |L1.144|
0002a0  69b0              LDR      r0,[r6,#0x18]         ;619
0002a2  9b01              LDR      r3,[sp,#4]            ;619
0002a4  ad06              ADD      r5,sp,#0x18           ;619
0002a6  6003              STR      r3,[r0,#0]            ;619
0002a8  69b3              LDR      r3,[r6,#0x18]         ;619
0002aa  9802              LDR      r0,[sp,#8]            ;619
0002ac  6058              STR      r0,[r3,#4]            ;619
0002ae  e9c41203          STRD     r1,r2,[r4,#0xc]       ;619
0002b2  e895000f          LDM      r5,{r0-r3}            ;619
0002b6  f1040514          ADD      r5,r4,#0x14           ;619
0002ba  e885000f          STM      r5,{r0-r3}            ;619
                  |L1.702|
0002be  6a60              LDR      r0,[r4,#0x24]         ;624
0002c0  1e40              SUBS     r0,r0,#1              ;624
0002c2  6260              STR      r0,[r4,#0x24]         ;626
0002c4  2001              MOVS     r0,#1                 ;626
0002c6  e7c5              B        |L1.596|
;;;628    
                          ENDP

                  |L1.712|
                          DCD      ||.constdata||
                  |L1.716|
                          DCD      jpeg_natural_order

                          AREA ||i.jinit_huff_decoder||, CODE, READONLY, ALIGN=2

                  jinit_huff_decoder PROC
;;;634    GLOBAL(void)
;;;635    jinit_huff_decoder (j_decompress_ptr cinfo)
000000  b510              PUSH     {r4,lr}
;;;636    {
000002  4604              MOV      r4,r0
;;;637      huff_entropy_ptr entropy;
;;;638      int i;
;;;639    
;;;640      entropy = (huff_entropy_ptr)
000004  6840              LDR      r0,[r0,#4]
000006  22e8              MOVS     r2,#0xe8
000008  2101              MOVS     r1,#1
00000a  6803              LDR      r3,[r0,#0]
00000c  4620              MOV      r0,r4
00000e  4798              BLX      r3
;;;641        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;642    				SIZEOF(huff_entropy_decoder));
;;;643      cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
;;;644      entropy->pub.start_pass = start_pass_huff_decoder;
000010  4907              LDR      r1,|L2.48|
000012  f8c401bc          STR      r0,[r4,#0x1bc]
;;;645      entropy->pub.decode_mcu = decode_mcu;
000016  6001              STR      r1,[r0,#0]
000018  4906              LDR      r1,|L2.52|
;;;646    
;;;647      /* Mark tables unallocated */
;;;648      for (i = 0; i < NUM_HUFF_TBLS; i++) {
00001a  6041              STR      r1,[r0,#4]
00001c  2100              MOVS     r1,#0
00001e  460b              MOV      r3,r1
                  |L2.32|
;;;649        entropy->dc_derived_tbls[i] = entropy->ac_derived_tbls[i] = NULL;
000020  eb000281          ADD      r2,r0,r1,LSL #2
000024  1c49              ADDS     r1,r1,#1
000026  6393              STR      r3,[r2,#0x38]
000028  6293              STR      r3,[r2,#0x28]         ;648
00002a  2904              CMP      r1,#4                 ;648
00002c  dbf8              BLT      |L2.32|
;;;650      }
;;;651    }
00002e  bd10              POP      {r4,pc}
                          ENDP

                  |L2.48|
                          DCD      start_pass_huff_decoder
                  |L2.52|
                          DCD      decode_mcu

                          AREA ||i.jpeg_fill_bit_buffer||, CODE, READONLY, ALIGN=1

                  jpeg_fill_bit_buffer PROC
;;;291    GLOBAL(boolean)
;;;292    jpeg_fill_bit_buffer (bitread_working_state * state,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;293    		      register bit_buf_type get_buffer, register int bits_left,
;;;294    		      int nbits)
;;;295    /* Load up the bit buffer to a depth of at least nbits */
;;;296    {
000004  4680              MOV      r8,r0
;;;297      /* Copy heavily used state fields into locals (hopefully registers) */
;;;298      register const JOCTET * next_input_byte = state->next_input_byte;
;;;299      register size_t bytes_in_buffer = state->bytes_in_buffer;
;;;300      j_decompress_ptr cinfo = state->cinfo;
;;;301    
;;;302      /* Attempt to load at least MIN_GET_BITS bits into get_buffer. */
;;;303      /* (It is assumed that no request will be for more than that many bits.) */
;;;304      /* We fail to do so only if we hit a marker or are forced to suspend. */
;;;305    
;;;306      if (cinfo->unread_marker == 0) {	/* cannot advance past a marker */
000006  6904              LDR      r4,[r0,#0x10]
000008  e9d86500          LDRD     r6,r5,[r8,#0]         ;300
00000c  f8d401a0          LDR      r0,[r4,#0x1a0]        ;296
000010  469a              MOV      r10,r3                ;296
000012  4617              MOV      r7,r2                 ;296
000014  4689              MOV      r9,r1                 ;296
000016  b360              CBZ      r0,|L3.114|
000018  e020              B        |L3.92|
                  |L3.26|
;;;307        while (bits_left < MIN_GET_BITS) {
;;;308          register int c;
;;;309    
;;;310          /* Attempt to read a byte */
;;;311          if (bytes_in_buffer == 0) {
00001a  b945              CBNZ     r5,|L3.46|
;;;312    	if (! (*cinfo->src->fill_input_buffer) (cinfo))
00001c  69a0              LDR      r0,[r4,#0x18]
00001e  68c1              LDR      r1,[r0,#0xc]
000020  4620              MOV      r0,r4
000022  4788              BLX      r1
000024  2800              CMP      r0,#0
000026  d03e              BEQ      |L3.166|
;;;313    	  return FALSE;
;;;314    	next_input_byte = cinfo->src->next_input_byte;
000028  69a0              LDR      r0,[r4,#0x18]
00002a  e9d06500          LDRD     r6,r5,[r0,#0]
                  |L3.46|
;;;315    	bytes_in_buffer = cinfo->src->bytes_in_buffer;
;;;316          }
;;;317          bytes_in_buffer--;
;;;318          c = GETJOCTET(*next_input_byte++);
00002e  1e6d              SUBS     r5,r5,#1
000030  f8160b01          LDRB     r0,[r6],#1
;;;319    
;;;320          /* If it's 0xFF, check and discard stuffed zero byte */
;;;321          if (c == 0xFF) {
000034  28ff              CMP      r0,#0xff
000036  d119              BNE      |L3.108|
                  |L3.56|
;;;322    	/* Loop here to discard any padding FF's on terminating marker,
;;;323    	 * so that we can save a valid unread_marker value.  NOTE: we will
;;;324    	 * accept multiple FF's followed by a 0 as meaning a single FF data
;;;325    	 * byte.  This data pattern is not valid according to the standard.
;;;326    	 */
;;;327    	do {
;;;328    	  if (bytes_in_buffer == 0) {
000038  b945              CBNZ     r5,|L3.76|
;;;329    	    if (! (*cinfo->src->fill_input_buffer) (cinfo))
00003a  69a0              LDR      r0,[r4,#0x18]
00003c  68c1              LDR      r1,[r0,#0xc]
00003e  4620              MOV      r0,r4
000040  4788              BLX      r1
000042  2800              CMP      r0,#0
000044  d02f              BEQ      |L3.166|
;;;330    	      return FALSE;
;;;331    	    next_input_byte = cinfo->src->next_input_byte;
000046  69a0              LDR      r0,[r4,#0x18]
000048  e9d06500          LDRD     r6,r5,[r0,#0]
                  |L3.76|
;;;332    	    bytes_in_buffer = cinfo->src->bytes_in_buffer;
;;;333    	  }
;;;334    	  bytes_in_buffer--;
;;;335    	  c = GETJOCTET(*next_input_byte++);
00004c  1e6d              SUBS     r5,r5,#1
00004e  f8160b01          LDRB     r0,[r6],#1
;;;336    	} while (c == 0xFF);
000052  28ff              CMP      r0,#0xff
000054  d0f0              BEQ      |L3.56|
;;;337    
;;;338    	if (c == 0) {
000056  b140              CBZ      r0,|L3.106|
;;;339    	  /* Found FF/00, which represents an FF data byte */
;;;340    	  c = 0xFF;
;;;341    	} else {
;;;342    	  /* Oops, it's actually a marker indicating end of compressed data.
;;;343    	   * Save the marker code for later use.
;;;344    	   * Fine point: it might appear that we should save the marker into
;;;345    	   * bitread working state, not straight into permanent state.  But
;;;346    	   * once we have hit a marker, we cannot need to suspend within the
;;;347    	   * current MCU, because we will read no more bytes from the data
;;;348    	   * source.  So it is OK to update permanent state right away.
;;;349    	   */
;;;350    	  cinfo->unread_marker = c;
000058  f8c401a0          STR      r0,[r4,#0x1a0]
                  |L3.92|
;;;351    	  /* See if we need to insert some fake zero bits. */
;;;352    	  goto no_more_bytes;
;;;353    	}
;;;354          }
;;;355    
;;;356          /* OK, load c into get_buffer */
;;;357          get_buffer = (get_buffer << 8) | c;
;;;358          bits_left += 8;
;;;359        } /* end while */
;;;360      } else {
;;;361      no_more_bytes:
;;;362        /* We get here if we've read the marker that terminates the compressed
;;;363         * data segment.  There should be enough bits in the buffer register
;;;364         * to satisfy the request; if so, no problem.
;;;365         */
;;;366        if (nbits > bits_left) {
00005c  45ba              CMP      r10,r7
00005e  dd1d              BLE      |L3.156|
;;;367          /* Uh-oh.  Report corrupted data to user and stuff zeroes into
;;;368           * the data stream, so that we can produce some kind of image.
;;;369           * We use a nonvolatile flag to ensure that only one warning message
;;;370           * appears per data segment.
;;;371           */
;;;372          if (! cinfo->entropy->insufficient_data) {
000060  f8d401bc          LDR      r0,[r4,#0x1bc]
000064  6880              LDR      r0,[r0,#8]
000066  b138              CBZ      r0,|L3.120|
000068  e013              B        |L3.146|
                  |L3.106|
00006a  20ff              MOVS     r0,#0xff              ;340
                  |L3.108|
00006c  ea402909          ORR      r9,r0,r9,LSL #8       ;357
000070  3708              ADDS     r7,r7,#8              ;357
                  |L3.114|
000072  2f19              CMP      r7,#0x19              ;307
000074  dbd1              BLT      |L3.26|
000076  e011              B        |L3.156|
                  |L3.120|
;;;373    	WARNMS(cinfo, JWRN_HIT_MARKER);
000078  6821              LDR      r1,[r4,#0]
00007a  2075              MOVS     r0,#0x75
00007c  6148              STR      r0,[r1,#0x14]
00007e  6820              LDR      r0,[r4,#0]
000080  f04f31ff          MOV      r1,#0xffffffff
000084  6842              LDR      r2,[r0,#4]
000086  4620              MOV      r0,r4
000088  4790              BLX      r2
;;;374    	cinfo->entropy->insufficient_data = TRUE;
00008a  f8d411bc          LDR      r1,[r4,#0x1bc]
00008e  2001              MOVS     r0,#1
000090  6088              STR      r0,[r1,#8]
                  |L3.146|
;;;375          }
;;;376          /* Fill the buffer with zero bits */
;;;377          get_buffer <<= MIN_GET_BITS - bits_left;
000092  f1c70119          RSB      r1,r7,#0x19
000096  fa09f901          LSL      r9,r9,r1
;;;378          bits_left = MIN_GET_BITS;
00009a  2719              MOVS     r7,#0x19
                  |L3.156|
00009c  e9c86500          STRD     r6,r5,[r8,#0]
0000a0  e9c89702          STRD     r9,r7,[r8,#8]
;;;379        }
;;;380      }
;;;381    
;;;382      /* Unload the local registers */
;;;383      state->next_input_byte = next_input_byte;
;;;384      state->bytes_in_buffer = bytes_in_buffer;
;;;385      state->get_buffer = get_buffer;
;;;386      state->bits_left = bits_left;
;;;387    
;;;388      return TRUE;
0000a4  2001              MOVS     r0,#1
                  |L3.166|
;;;389    }
0000a6  e8bd87f0          POP      {r4-r10,pc}
;;;390    
                          ENDP


                          AREA ||i.jpeg_huff_decode||, CODE, READONLY, ALIGN=1

                  jpeg_huff_decode PROC
;;;397    GLOBAL(int)
;;;398    jpeg_huff_decode (bitread_working_state * state,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;399    		  register bit_buf_type get_buffer, register int bits_left,
;;;400    		  d_derived_tbl * htbl, int min_bits)
;;;401    {
000004  461e              MOV      r6,r3
;;;402      register int l = min_bits;
;;;403      register INT32 code;
;;;404    
;;;405      /* HUFF_DECODE has determined that the code is at least min_bits */
;;;406      /* bits long, so fetch that many bits in one swoop. */
;;;407    
;;;408      CHECK_BIT_BUFFER(*state, l, return -1);
000006  9c06              LDR      r4,[sp,#0x18]
000008  4605              MOV      r5,r0                 ;401
00000a  f04f38ff          MOV      r8,#0xffffffff
00000e  42a2              CMP      r2,r4
000010  da05              BGE      |L4.30|
000012  4623              MOV      r3,r4
000014  f7fffffe          BL       jpeg_fill_bit_buffer
000018  b370              CBZ      r0,|L4.120|
00001a  e9d51202          LDRD     r1,r2,[r5,#8]
                  |L4.30|
;;;409      code = GET_BITS(l);
00001e  1b12              SUBS     r2,r2,r4
000020  fa41f002          ASR      r0,r1,r2
000024  2301              MOVS     r3,#1
000026  40a3              LSLS     r3,r3,r4
000028  1e5b              SUBS     r3,r3,#1
00002a  4018              ANDS     r0,r0,r3
;;;410    
;;;411      /* Collect the rest of the Huffman code one bit at a time. */
;;;412      /* This is per Figure F.16 in the JPEG spec. */
;;;413    
;;;414      while (code > htbl->maxcode[l]) {
00002c  e010              B        |L4.80|
                  |L4.46|
;;;415        code <<= 1;
00002e  0047              LSLS     r7,r0,#1
;;;416        CHECK_BIT_BUFFER(*state, 1, return -1);
000030  2a01              CMP      r2,#1
000032  da06              BGE      |L4.66|
000034  2301              MOVS     r3,#1
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       jpeg_fill_bit_buffer
00003c  b1e0              CBZ      r0,|L4.120|
00003e  e9d51202          LDRD     r1,r2,[r5,#8]
                  |L4.66|
000042  1e52              SUBS     r2,r2,#1
;;;417        code |= GET_BITS(1);
000044  fa41f002          ASR      r0,r1,r2
000048  f0000001          AND      r0,r0,#1
00004c  4338              ORRS     r0,r0,r7
00004e  1c64              ADDS     r4,r4,#1
                  |L4.80|
000050  f8563024          LDR      r3,[r6,r4,LSL #2]     ;414
000054  4283              CMP      r3,r0                 ;414
000056  dbea              BLT      |L4.46|
;;;418        l++;
;;;419      }
;;;420    
;;;421      /* Unload the local registers */
;;;422      state->get_buffer = get_buffer;
;;;423      state->bits_left = bits_left;
;;;424    
;;;425      /* With garbage input we may reach the sentinel value l = 17. */
;;;426    
;;;427      if (l > 16) {
000058  e9c51202          STRD     r1,r2,[r5,#8]
00005c  2c10              CMP      r4,#0x10
00005e  dd0d              BLE      |L4.124|
;;;428        WARNMS(state->cinfo, JWRN_HUFF_BAD_CODE);
000060  6929              LDR      r1,[r5,#0x10]
000062  2076              MOVS     r0,#0x76
000064  6809              LDR      r1,[r1,#0]
000066  6148              STR      r0,[r1,#0x14]
000068  6928              LDR      r0,[r5,#0x10]
00006a  6801              LDR      r1,[r0,#0]
00006c  684a              LDR      r2,[r1,#4]
00006e  4641              MOV      r1,r8
000070  4790              BLX      r2
;;;429        return 0;			/* fake a zero as the safest result */
000072  2000              MOVS     r0,#0
                  |L4.116|
;;;430      }
;;;431    
;;;432      return htbl->pub->huffval[ (int) (code + htbl->valoffset[l]) ];
;;;433    }
000074  e8bd81f0          POP      {r4-r8,pc}
                  |L4.120|
000078  4640              MOV      r0,r8                 ;416
00007a  e7fb              B        |L4.116|
                  |L4.124|
00007c  eb060284          ADD      r2,r6,r4,LSL #2       ;432
000080  f8d6108c          LDR      r1,[r6,#0x8c]         ;432
000084  6c92              LDR      r2,[r2,#0x48]         ;432
000086  3011              ADDS     r0,r0,#0x11           ;432
000088  4411              ADD      r1,r1,r2              ;432
00008a  5c08              LDRB     r0,[r1,r0]            ;432
00008c  e7f2              B        |L4.116|
;;;434    
                          ENDP


                          AREA ||i.jpeg_make_d_derived_tbl||, CODE, READONLY, ALIGN=2

                  jpeg_make_d_derived_tbl PROC
;;;148    GLOBAL(void)
;;;149    jpeg_make_d_derived_tbl (j_decompress_ptr cinfo, boolean isDC, int tblno,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;150    			 d_derived_tbl ** pdtbl)
;;;151    {
000004  f2ad5d34          SUB      sp,sp,#0x534
000008  461f              MOV      r7,r3
00000a  4616              MOV      r6,r2
00000c  4604              MOV      r4,r0
;;;152      JHUFF_TBL *htbl;
;;;153      d_derived_tbl *dtbl;
;;;154      int p, i, l, si, numsymbols;
;;;155      int lookbits, ctr;
;;;156      char huffsize[257];
;;;157      unsigned int huffcode[257];
;;;158      unsigned int code;
;;;159    
;;;160      /* Note that huffsize[] and huffcode[] are filled in code-length order,
;;;161       * paralleling the order of the symbols themselves in htbl->huffval[].
;;;162       */
;;;163    
;;;164      /* Find the input Huffman table */
;;;165      if (tblno < 0 || tblno >= NUM_HUFF_TBLS)
;;;166        ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
00000e  f04f0832          MOV      r8,#0x32
000012  2a04              CMP      r2,#4                 ;165
000014  d308              BCC      |L5.40|
000016  6821              LDR      r1,[r4,#0]
000018  f8c18014          STR      r8,[r1,#0x14]
00001c  6820              LDR      r0,[r4,#0]
00001e  6186              STR      r6,[r0,#0x18]
000020  6820              LDR      r0,[r4,#0]
000022  6801              LDR      r1,[r0,#0]
000024  4620              MOV      r0,r4
000026  4788              BLX      r1
                  |L5.40|
;;;167      htbl =
000028  f8dd1538          LDR      r1,[sp,#0x538]
;;;168        isDC ? cinfo->dc_huff_tbl_ptrs[tblno] : cinfo->ac_huff_tbl_ptrs[tblno];
00002c  eb040086          ADD      r0,r4,r6,LSL #2
000030  b111              CBZ      r1,|L5.56|
000032  f8d050b4          LDR      r5,[r0,#0xb4]
000036  e001              B        |L5.60|
                  |L5.56|
000038  f8d050c4          LDR      r5,[r0,#0xc4]
                  |L5.60|
;;;169      if (htbl == NULL)
00003c  b945              CBNZ     r5,|L5.80|
;;;170        ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, tblno);
00003e  6821              LDR      r1,[r4,#0]
000040  f8c18014          STR      r8,[r1,#0x14]
000044  6820              LDR      r0,[r4,#0]
000046  6186              STR      r6,[r0,#0x18]
000048  6820              LDR      r0,[r4,#0]
00004a  6801              LDR      r1,[r0,#0]
00004c  4620              MOV      r0,r4
00004e  4788              BLX      r1
                  |L5.80|
;;;171    
;;;172      /* Allocate a workspace if we haven't already done so. */
;;;173      if (*pdtbl == NULL)
000050  6838              LDR      r0,[r7,#0]
000052  b938              CBNZ     r0,|L5.100|
;;;174        *pdtbl = (d_derived_tbl *)
000054  6860              LDR      r0,[r4,#4]
000056  f44f62b2          MOV      r2,#0x590
00005a  2101              MOVS     r1,#1
00005c  6803              LDR      r3,[r0,#0]
00005e  4620              MOV      r0,r4
000060  4798              BLX      r3
000062  6038              STR      r0,[r7,#0]
                  |L5.100|
;;;175          (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;176    				  SIZEOF(d_derived_tbl));
;;;177      dtbl = *pdtbl;
000064  4606              MOV      r6,r0
;;;178      dtbl->pub = htbl;		/* fill in back link */
;;;179      
;;;180      /* Figure C.1: make table of Huffman code length for each symbol */
;;;181    
;;;182      p = 0;
000066  f04f0800          MOV      r8,#0
;;;183      for (l = 1; l <= 16; l++) {
00006a  f04f0901          MOV      r9,#1
00006e  46ea              MOV      r10,sp                ;156
;;;184        i = (int) htbl->bits[l];
;;;185        if (i < 0 || p + i > 256)	/* protect against table overrun */
;;;186          ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
000070  f04f0b08          MOV      r11,#8
000074  f8c0508c          STR      r5,[r0,#0x8c]
                  |L5.120|
000078  f8157009          LDRB     r7,[r5,r9]            ;184
00007c  2f00              CMP      r7,#0                 ;185
00007e  db04              BLT      |L5.138|
000080  eb080007          ADD      r0,r8,r7              ;185
000084  f5b07f80          CMP      r0,#0x100             ;185
000088  dd06              BLE      |L5.152|
                  |L5.138|
00008a  6821              LDR      r1,[r4,#0]
00008c  f8c1b014          STR      r11,[r1,#0x14]
000090  6820              LDR      r0,[r4,#0]
000092  6801              LDR      r1,[r0,#0]
000094  4620              MOV      r0,r4
000096  4788              BLX      r1
                  |L5.152|
;;;187        while (i--)
;;;188          huffsize[p++] = (char) l;
000098  f00900ff          AND      r0,r9,#0xff
00009c  4651              MOV      r1,r10                ;156
                  |L5.158|
00009e  1e7f              SUBS     r7,r7,#1              ;156
0000a0  d304              BCC      |L5.172|
0000a2  f8010008          STRB     r0,[r1,r8]
0000a6  f1080801          ADD      r8,r8,#1
0000aa  e7f8              B        |L5.158|
                  |L5.172|
0000ac  f1090901          ADD      r9,r9,#1              ;183
0000b0  f1b90f10          CMP      r9,#0x10              ;183
0000b4  dde0              BLE      |L5.120|
;;;189      }
;;;190      huffsize[p] = 0;
0000b6  2200              MOVS     r2,#0
0000b8  f80a2008          STRB     r2,[r10,r8]
;;;191      numsymbols = p;
;;;192      
;;;193      /* Figure C.2: generate the codes themselves */
;;;194      /* We also validate that the counts represent a legal Huffman code tree. */
;;;195      
;;;196      code = 0;
0000bc  f8cd8520          STR      r8,[sp,#0x520]
0000c0  4690              MOV      r8,r2
;;;197      si = huffsize[0];
0000c2  f89d9000          LDRB     r9,[sp,#0]
;;;198      p = 0;
0000c6  4617              MOV      r7,r2
0000c8  f50d7a82          ADD      r10,sp,#0x104         ;157
;;;199      while (huffsize[p]) {
0000cc  e01a              B        |L5.260|
;;;200        while (((int) huffsize[p]) == si) {
;;;201          huffcode[p++] = code;
0000ce  bf00              NOP      
                  |L5.208|
0000d0  f8428027          STR      r8,[r2,r7,LSL #2]
;;;202          code++;
0000d4  f1080801          ADD      r8,r8,#1
0000d8  1c7f              ADDS     r7,r7,#1
0000da  e000              B        |L5.222|
                  |L5.220|
0000dc  4652              MOV      r2,r10                ;157
                  |L5.222|
0000de  5dc3              LDRB     r3,[r0,r7]            ;200
0000e0  454b              CMP      r3,r9                 ;200
0000e2  d0f5              BEQ      |L5.208|
;;;203        }
;;;204        /* code is now 1 more than the last code used for codelength si; but
;;;205         * it must still fit in si bits, since no code is allowed to be all ones.
;;;206         */
;;;207        if (((INT32) code) >= (((INT32) 1) << si))
0000e4  2001              MOVS     r0,#1
0000e6  fa00f009          LSL      r0,r0,r9
0000ea  4540              CMP      r0,r8
0000ec  dc06              BGT      |L5.252|
;;;208          ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
0000ee  6821              LDR      r1,[r4,#0]
0000f0  2008              MOVS     r0,#8
0000f2  6148              STR      r0,[r1,#0x14]
0000f4  6820              LDR      r0,[r4,#0]
0000f6  6801              LDR      r1,[r0,#0]
0000f8  4620              MOV      r0,r4
0000fa  4788              BLX      r1
                  |L5.252|
;;;209        code <<= 1;
0000fc  ea4f0848          LSL      r8,r8,#1
;;;210        si++;
000100  f1090901          ADD      r9,r9,#1
                  |L5.260|
000104  f81d1007          LDRB     r1,[sp,r7]            ;199
000108  4668              MOV      r0,sp                 ;199
00010a  2900              CMP      r1,#0                 ;199
00010c  d1e6              BNE      |L5.220|
;;;211      }
;;;212    
;;;213      /* Figure F.15: generate decoding tables for bit-sequential decoding */
;;;214    
;;;215      p = 0;
;;;216      for (l = 1; l <= 16; l++) {
00010e  2001              MOVS     r0,#1
000110  1e83              SUBS     r3,r0,#2              ;187
                  |L5.274|
;;;217        if (htbl->bits[l]) {
000112  5c2a              LDRB     r2,[r5,r0]
000114  b182              CBZ      r2,|L5.312|
;;;218          /* valoffset[l] = huffval[] index of 1st symbol of code length l,
;;;219           * minus the minimum code of length l
;;;220           */
;;;221          dtbl->valoffset[l] = (INT32) p - (INT32) huffcode[p];
000116  aa41              ADD      r2,sp,#0x104
000118  eb060c80          ADD      r12,r6,r0,LSL #2
00011c  f8527021          LDR      r7,[r2,r1,LSL #2]
000120  1bcf              SUBS     r7,r1,r7
;;;222          p += htbl->bits[l];
000122  f8cc7048          STR      r7,[r12,#0x48]
000126  5c2f              LDRB     r7,[r5,r0]
000128  4439              ADD      r1,r1,r7
;;;223          dtbl->maxcode[l] = huffcode[p-1]; /* maximum code of length l */
00012a  eb020281          ADD      r2,r2,r1,LSL #2
00012e  f8522c04          LDR      r2,[r2,#-4]
000132  f8462020          STR      r2,[r6,r0,LSL #2]
000136  e001              B        |L5.316|
                  |L5.312|
;;;224        } else {
;;;225          dtbl->maxcode[l] = -1;	/* -1 if no codes of this length */
000138  f8463020          STR      r3,[r6,r0,LSL #2]
                  |L5.316|
00013c  1c40              ADDS     r0,r0,#1
00013e  2810              CMP      r0,#0x10              ;216
000140  dde7              BLE      |L5.274|
;;;226        }
;;;227      }
;;;228      dtbl->maxcode[17] = 0xFFFFFL; /* ensures jpeg_huff_decode terminates */
000142  4825              LDR      r0,|L5.472|
;;;229    
;;;230      /* Compute lookahead tables to speed up decoding.
;;;231       * First we set all the table entries to 0, indicating "too long";
;;;232       * then we iterate through the Huffman codes that are short enough and
;;;233       * fill in all the entries that correspond to bit sequences starting
;;;234       * with that code.
;;;235       */
;;;236    
;;;237      MEMZERO(dtbl->look_nbits, SIZEOF(dtbl->look_nbits));
000144  6470              STR      r0,[r6,#0x44]
000146  f44f6180          MOV      r1,#0x400
00014a  f1060090          ADD      r0,r6,#0x90
00014e  f7fffffe          BL       __aeabi_memclr4
;;;238    
;;;239      p = 0;
000152  2300              MOVS     r3,#0
;;;240      for (l = 1; l <= HUFF_LOOKAHEAD; l++) {
000154  2001              MOVS     r0,#1
                  |L5.342|
;;;241        for (i = 1; i <= (int) htbl->bits[l]; i++, p++) {
000156  2701              MOVS     r7,#1
;;;242          /* l = current code's length, p = its index in huffcode[] & huffval[]. */
;;;243          /* Generate left-justified code followed by all possible bit sequences */
;;;244          lookbits = huffcode[p] << (HUFF_LOOKAHEAD-l);
000158  f1c00b08          RSB      r11,r0,#8
00015c  f50d7e82          ADD      lr,sp,#0x104          ;157
;;;245          for (ctr = 1 << (HUFF_LOOKAHEAD-l); ctr > 0; ctr--) {
000160  fa07f90b          LSL      r9,r7,r11
000164  e018              B        |L5.408|
000166  bf00              NOP                            ;244
                  |L5.360|
000168  f85e1023          LDR      r1,[lr,r3,LSL #2]     ;244
00016c  464a              MOV      r2,r9                 ;244
00016e  fa01f10b          LSL      r1,r1,r11             ;244
;;;246    	dtbl->look_nbits[lookbits] = l;
;;;247    	dtbl->look_sym[lookbits] = htbl->huffval[p];
000172  eb050a03          ADD      r10,r5,r3
000176  e00b              B        |L5.400|
                  |L5.376|
000178  eb060c81          ADD      r12,r6,r1,LSL #2      ;246
00017c  eb060801          ADD      r8,r6,r1
000180  f8cc0090          STR      r0,[r12,#0x90]
000184  f89ac011          LDRB     r12,[r10,#0x11]
000188  1c49              ADDS     r1,r1,#1
00018a  f888c490          STRB     r12,[r8,#0x490]
00018e  1e52              SUBS     r2,r2,#1
                  |L5.400|
000190  2a00              CMP      r2,#0                 ;245
000192  dcf1              BGT      |L5.376|
000194  1c5b              ADDS     r3,r3,#1              ;245
000196  1c7f              ADDS     r7,r7,#1              ;245
                  |L5.408|
000198  5c29              LDRB     r1,[r5,r0]            ;241
00019a  42b9              CMP      r1,r7                 ;241
00019c  dae4              BGE      |L5.360|
00019e  1c40              ADDS     r0,r0,#1              ;241
0001a0  2808              CMP      r0,#8                 ;240
0001a2  ddd8              BLE      |L5.342|
;;;248    	lookbits++;
;;;249          }
;;;250        }
;;;251      }
;;;252    
;;;253      /* Validate symbols as being reasonable.
;;;254       * For AC tables, we make no check, but accept all byte values 0..255.
;;;255       * For DC tables, we require the symbols to be in range 0..15.
;;;256       * (Tighter bounds could be applied depending on the data depth and mode,
;;;257       * but this is sufficient to ensure safe decoding.)
;;;258       */
;;;259      if (isDC) {
0001a4  f8dd0538          LDR      r0,[sp,#0x538]
0001a8  2800              CMP      r0,#0
0001aa  d011              BEQ      |L5.464|
;;;260        for (i = 0; i < numsymbols; i++) {
0001ac  2600              MOVS     r6,#0
0001ae  2708              MOVS     r7,#8                 ;186
0001b0  e00a              B        |L5.456|
                  |L5.434|
;;;261          int sym = htbl->huffval[i];
0001b2  19a8              ADDS     r0,r5,r6
0001b4  7c40              LDRB     r0,[r0,#0x11]
;;;262          if (sym < 0 || sym > 15)
0001b6  2810              CMP      r0,#0x10
0001b8  d305              BCC      |L5.454|
;;;263    	ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
0001ba  6820              LDR      r0,[r4,#0]
0001bc  6147              STR      r7,[r0,#0x14]
0001be  6820              LDR      r0,[r4,#0]
0001c0  6801              LDR      r1,[r0,#0]
0001c2  4620              MOV      r0,r4
0001c4  4788              BLX      r1
                  |L5.454|
0001c6  1c76              ADDS     r6,r6,#1
                  |L5.456|
0001c8  f8dd0520          LDR      r0,[sp,#0x520]        ;260
0001cc  4286              CMP      r6,r0                 ;260
0001ce  dbf0              BLT      |L5.434|
                  |L5.464|
;;;264        }
;;;265      }
;;;266    }
0001d0  f20d5d44          ADD      sp,sp,#0x544
0001d4  e8bd8ff0          POP      {r4-r11,pc}
;;;267    
                          ENDP

                  |L5.472|
                          DCD      0x000fffff

                          AREA ||i.start_pass_huff_decoder||, CODE, READONLY, ALIGN=1

                  start_pass_huff_decoder PROC
;;;85     METHODDEF(void)
;;;86     start_pass_huff_decoder (j_decompress_ptr cinfo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;87     {
000004  4604              MOV      r4,r0
;;;88       huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
;;;89       int ci, blkn, dctbl, actbl;
;;;90       jpeg_component_info * compptr;
;;;91     
;;;92       /* Check that the scan parameters Ss, Se, Ah/Al are OK for sequential JPEG.
;;;93        * This ought to be an error condition, but we make it a warning because
;;;94        * there are some baseline files out there with all zeroes in these bytes.
;;;95        */
;;;96       if (cinfo->Ss != 0 || cinfo->Se != DCTSIZE2-1 ||
000006  f8d051bc          LDR      r5,[r0,#0x1bc]
00000a  f8d00190          LDR      r0,[r0,#0x190]
00000e  b948              CBNZ     r0,|L6.36|
000010  f8d40194          LDR      r0,[r4,#0x194]
000014  283f              CMP      r0,#0x3f
000016  d105              BNE      |L6.36|
;;;97           cinfo->Ah != 0 || cinfo->Al != 0)
000018  f8d40198          LDR      r0,[r4,#0x198]
00001c  b910              CBNZ     r0,|L6.36|
00001e  f8d4019c          LDR      r0,[r4,#0x19c]
000022  b140              CBZ      r0,|L6.54|
                  |L6.36|
;;;98         WARNMS(cinfo, JWRN_NOT_SEQUENTIAL);
000024  6821              LDR      r1,[r4,#0]
000026  207a              MOVS     r0,#0x7a
000028  6148              STR      r0,[r1,#0x14]
00002a  6820              LDR      r0,[r4,#0]
00002c  f04f31ff          MOV      r1,#0xffffffff
000030  6842              LDR      r2,[r0,#4]
000032  4620              MOV      r0,r4
000034  4790              BLX      r2
                  |L6.54|
;;;99     
;;;100      for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
000036  2600              MOVS     r6,#0
000038  46b0              MOV      r8,r6
00003a  e019              B        |L6.112|
                  |L6.60|
;;;101        compptr = cinfo->cur_comp_info[ci];
00003c  eb040086          ADD      r0,r4,r6,LSL #2
;;;102        dctbl = compptr->dc_tbl_no;
;;;103        actbl = compptr->ac_tbl_no;
;;;104        /* Compute derived values for Huffman tables */
;;;105        /* We may do this more than once for a table, but it's not expensive */
;;;106        jpeg_make_d_derived_tbl(cinfo, TRUE, dctbl,
000040  2101              MOVS     r1,#1
000042  f8d0014c          LDR      r0,[r0,#0x14c]        ;101
000046  e9d02705          LDRD     r2,r7,[r0,#0x14]      ;101
00004a  eb050382          ADD      r3,r5,r2,LSL #2
00004e  4620              MOV      r0,r4
000050  3328              ADDS     r3,r3,#0x28
000052  f7fffffe          BL       jpeg_make_d_derived_tbl
;;;107    			    & entropy->dc_derived_tbls[dctbl]);
;;;108        jpeg_make_d_derived_tbl(cinfo, FALSE, actbl,
000056  eb050387          ADD      r3,r5,r7,LSL #2
00005a  463a              MOV      r2,r7
00005c  2100              MOVS     r1,#0
00005e  4620              MOV      r0,r4
000060  3338              ADDS     r3,r3,#0x38
000062  f7fffffe          BL       jpeg_make_d_derived_tbl
;;;109    			    & entropy->ac_derived_tbls[actbl]);
;;;110        /* Initialize DC predictions to 0 */
;;;111        entropy->saved.last_dc_val[ci] = 0;
000066  eb050186          ADD      r1,r5,r6,LSL #2
00006a  1c76              ADDS     r6,r6,#1
00006c  f8c18014          STR      r8,[r1,#0x14]
                  |L6.112|
000070  f8d40148          LDR      r0,[r4,#0x148]        ;100
000074  42b0              CMP      r0,r6                 ;100
000076  dce1              BGT      |L6.60|
;;;112      }
;;;113    
;;;114      /* Precalculate decoding info for each block in an MCU of this scan */
;;;115      for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
000078  2100              MOVS     r1,#0
00007a  e026              B        |L6.202|
                  |L6.124|
;;;116        ci = cinfo->MCU_membership[blkn];
00007c  eb040081          ADD      r0,r4,r1,LSL #2
000080  f8d00168          LDR      r0,[r0,#0x168]
;;;117        compptr = cinfo->cur_comp_info[ci];
000084  eb040080          ADD      r0,r4,r0,LSL #2
;;;118        /* Precalculate which table to use for each block */
;;;119        entropy->dc_cur_tbls[blkn] = entropy->dc_derived_tbls[compptr->dc_tbl_no];
000088  f8d0214c          LDR      r2,[r0,#0x14c]
00008c  6950              LDR      r0,[r2,#0x14]
00008e  eb050080          ADD      r0,r5,r0,LSL #2
000092  6a83              LDR      r3,[r0,#0x28]
000094  eb050081          ADD      r0,r5,r1,LSL #2
;;;120        entropy->ac_cur_tbls[blkn] = entropy->ac_derived_tbls[compptr->ac_tbl_no];
000098  6483              STR      r3,[r0,#0x48]
00009a  6993              LDR      r3,[r2,#0x18]
00009c  eb050383          ADD      r3,r5,r3,LSL #2
0000a0  6b9b              LDR      r3,[r3,#0x38]
;;;121        /* Decide whether we really care about the coefficient values */
;;;122        if (compptr->component_needed) {
0000a2  6703              STR      r3,[r0,#0x70]
0000a4  6b13              LDR      r3,[r2,#0x30]
0000a6  b15b              CBZ      r3,|L6.192|
;;;123          entropy->dc_needed[blkn] = TRUE;
0000a8  2301              MOVS     r3,#1
;;;124          /* we don't need the ACs if producing a 1/8th-size image */
;;;125          entropy->ac_needed[blkn] = (compptr->DCT_scaled_size > 1);
0000aa  f8c03098          STR      r3,[r0,#0x98]
0000ae  6a52              LDR      r2,[r2,#0x24]
0000b0  2a01              CMP      r2,#1
0000b2  dd01              BLE      |L6.184|
0000b4  2201              MOVS     r2,#1
0000b6  e000              B        |L6.186|
                  |L6.184|
0000b8  2200              MOVS     r2,#0
                  |L6.186|
0000ba  f8c020c0          STR      r2,[r0,#0xc0]
0000be  e003              B        |L6.200|
                  |L6.192|
;;;126        } else {
;;;127          entropy->dc_needed[blkn] = entropy->ac_needed[blkn] = FALSE;
0000c0  f8c080c0          STR      r8,[r0,#0xc0]
0000c4  f8c08098          STR      r8,[r0,#0x98]
                  |L6.200|
0000c8  1c49              ADDS     r1,r1,#1
                  |L6.202|
0000ca  f8d40164          LDR      r0,[r4,#0x164]        ;115
0000ce  4288              CMP      r0,r1                 ;115
0000d0  dcd4              BGT      |L6.124|
;;;128        }
;;;129      }
;;;130    
;;;131      /* Initialize bitread state variables */
;;;132      entropy->bitstate.bits_left = 0;
;;;133      entropy->bitstate.get_buffer = 0; /* unnecessary, but keeps Purify quiet */
0000d2  f8c58010          STR      r8,[r5,#0x10]
;;;134      entropy->pub.insufficient_data = FALSE;
0000d6  f8c5800c          STR      r8,[r5,#0xc]
;;;135    
;;;136      /* Initialize restart counter */
;;;137      entropy->restarts_to_go = cinfo->restart_interval;
0000da  f8c58008          STR      r8,[r5,#8]
0000de  f8d40114          LDR      r0,[r4,#0x114]
0000e2  6268              STR      r0,[r5,#0x24]
;;;138    }
0000e4  e8bd81f0          POP      {r4-r8,pc}
;;;139    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  extend_test
                          DCD      0x00000000
                          DCD      0x00000001
                          DCD      0x00000002
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x00000010
                          DCD      0x00000020
                          DCD      0x00000040
                          DCD      0x00000080
                          DCD      0x00000100
                          DCD      0x00000200
                          DCD      0x00000400
                          DCD      0x00000800
                          DCD      0x00001000
                          DCD      0x00002000
                          DCD      0x00004000
                  extend_offset
                          DCD      0x00000000
                          DCD      0xffffffff
                          DCD      0xfffffffd
                          DCD      0xfffffff9
                          DCD      0xfffffff1
                          DCD      0xffffffe1
                          DCD      0xffffffc1
                          DCD      0xffffff81
                          DCD      0xffffff01
                          DCD      0xfffffe01
                          DCD      0xfffffc01
                          DCD      0xfffff801
                          DCD      0xfffff001
                          DCD      0xffffe001
                          DCD      0xffffc001
                          DCD      0xffff8001
