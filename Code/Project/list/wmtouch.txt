; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\wmtouch.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\wmtouch.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\WM\WMTouch.c]
                          THUMB

                          AREA ||i.WM_HandlePID||, CODE, READONLY, ALIGN=2

                  WM_HandlePID PROC
;;;157    */
;;;158    int WM_HandlePID(void) {
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b095              SUB      sp,sp,#0x54
;;;159      int r = 0;
000006  f04f0800          MOV      r8,#0
;;;160      WM_MESSAGE Msg;
;;;161      WM_CRITICAL_HANDLE CHWin;
;;;162      GUI_PID_STATE State = {0}, StateNew;
00000a  4646              MOV      r6,r8
00000c  f8cd800c          STR      r8,[sp,#0xc]
000010  f8cd8010          STR      r8,[sp,#0x10]
;;;163      GUI_PID_GetState(&StateNew);
000014  4668              MOV      r0,sp
000016  f8cd8014          STR      r8,[sp,#0x14]
00001a  f7fffffe          BL       GUI_PID_GetState
;;;164      WM_LOCK();
;;;165      StateNew.x += GUI_OrgX;
00001e  4961              LDR      r1,|L1.420|
000020  9800              LDR      r0,[sp,#0]
000022  f9b11000          LDRSH    r1,[r1,#0]  ; GUI_OrgX
000026  4408              ADD      r0,r0,r1
;;;166      StateNew.y += GUI_OrgY;
000028  495f              LDR      r1,|L1.424|
00002a  9000              STR      r0,[sp,#0]
00002c  9801              LDR      r0,[sp,#4]
00002e  f9b11000          LDRSH    r1,[r1,#0]  ; GUI_OrgY
000032  4408              ADD      r0,r0,r1
;;;167      WM__AddCriticalHandle(&CHWin);
000034  9001              STR      r0,[sp,#4]
000036  a806              ADD      r0,sp,#0x18
000038  f7fffffe          BL       WM__AddCriticalHandle
;;;168      if ((WM_PID__StateLast.x != StateNew.x) || (WM_PID__StateLast.y != StateNew.y) || (WM_PID__StateLast.Pressed != StateNew.Pressed)) {
00003c  4c5b              LDR      r4,|L1.428|
00003e  9900              LDR      r1,[sp,#0]
000040  6820              LDR      r0,[r4,#0]  ; WM_PID__StateLast
000042  4288              CMP      r0,r1
000044  d108              BNE      |L1.88|
000046  6860              LDR      r0,[r4,#4]  ; WM_PID__StateLast
000048  9901              LDR      r1,[sp,#4]
00004a  4288              CMP      r0,r1
00004c  d104              BNE      |L1.88|
00004e  7a20              LDRB     r0,[r4,#8]  ; WM_PID__StateLast
000050  f89d1008          LDRB     r1,[sp,#8]
000054  4288              CMP      r0,r1
000056  d07d              BEQ      |L1.340|
                  |L1.88|
000058  e9dd0100          LDRD     r0,r1,[sp,#0]
;;;169        #if GUI_SUPPORT_CURSOR
;;;170          GUI_CURSOR_SetPosition(StateNew.x, StateNew.y);
00005c  f7fffffe          BL       GUI_CURSOR_SetPosition
000060  4853              LDR      r0,|L1.432|
000062  f9b00000          LDRSH    r0,[r0,#0]  ; WM__hCapture
000066  b918              CBNZ     r0,|L1.112|
000068  e9dd0100          LDRD     r0,r1,[sp,#0]
00006c  f7fffffe          BL       WM_Screen2hWin
                  |L1.112|
;;;171        #endif
;;;172        CHWin.hWin = _Screen2Win(&StateNew);
000070  f8ad001c          STRH     r0,[sp,#0x1c]
;;;173        #if GUI_SUPPORT_MOUSE
;;;174        /* Send WM_MOUSEOVER_END Message */
;;;175        if (WM__CHWinMouseOver.hWin && (WM__CHWinMouseOver.hWin != CHWin.hWin)) {
;;;176          if (WM__IsInModalArea(WM__CHWinMouseOver.hWin)) {
;;;177            /* Do not send messages to disabled windows */
;;;178            if (WM__IsEnabled(WM__CHWinMouseOver.hWin)) {
;;;179              State      = StateNew;
;;;180              Msg.MsgId  = WM_MOUSEOVER_END;
;;;181              Msg.Data.p = (void*)&State;
;;;182              WM__SendTouchMessage(WM__CHWinMouseOver.hWin, &Msg);
;;;183              WM__CHWinMouseOver.hWin = 0;
;;;184            }
;;;185          }
;;;186        }
;;;187        #endif
;;;188        if (WM__IsInModalArea(CHWin.hWin)) {
000074  f9bd001c          LDRSH    r0,[sp,#0x1c]
000078  f7fffffe          BL       WM__IsInModalArea
00007c  2800              CMP      r0,#0
00007e  d06a              BEQ      |L1.342|
;;;189          #if GUI_SUPPORT_MOUSE
;;;190            WM__CHWinMouseOver.hWin = CHWin.hWin;
;;;191          #endif
;;;192          /*
;;;193           * Send WM_PID_STATE_CHANGED message if state has changed (just pressed or just released)
;;;194           */
;;;195          if ((WM_PID__StateLast.Pressed != StateNew.Pressed) && CHWin.hWin) {
000080  7a20              LDRB     r0,[r4,#8]  ; WM_PID__StateLast
000082  f89d1008          LDRB     r1,[sp,#8]
;;;196            GUI_PID_STATE PID_StateOld;
;;;197            WM_HWIN hWinOld;
;;;198            WM_PID_STATE_CHANGED_INFO Info;
;;;199            WM_Obj* pWin;
;;;200            pWin = WM_H2P(CHWin.hWin);
;;;201            Info.State     = StateNew.Pressed;
;;;202            Info.StatePrev = WM_PID__StateLast.Pressed;
;;;203            Info.x         = StateNew.x - pWin->Rect.x0;
;;;204            Info.y         = StateNew.y - pWin->Rect.y0;
;;;205            Msg.Data.p = &Info;
;;;206            Msg.MsgId  = WM_PID_STATE_CHANGED;
;;;207            /* Make sure that this routine does not react a second time on the same press event.
;;;208             * This could happen if for example a dialog is executed during the WM_PID_STATE_CHANGED message processing
;;;209             */
;;;210            PID_StateOld = WM_PID__StateLast;
;;;211            /* Make sure that in case of creating a new window over the current PID position
;;;212             * during the WM_PID_STATE_CHANGED message processing the old window
;;;213             * will be informed that it is no longer pressed.
;;;214             */
;;;215            WM_PID__StateLast.Pressed = StateNew.Pressed;
;;;216            if (State.Pressed) {
;;;217              hWinOld            = WM__CHWinLast.hWin;
000086  4d4b              LDR      r5,|L1.436|
000088  4288              CMP      r0,r1                 ;195
00008a  d03a              BEQ      |L1.258|
00008c  f8bd001c          LDRH     r0,[sp,#0x1c]         ;195
000090  b3b8              CBZ      r0,|L1.258|
000092  f9bd001c          LDRSH    r0,[sp,#0x1c]         ;200
000096  f7fffffe          BL       GUI_ALLOC_h2p
00009a  f89d1008          LDRB     r1,[sp,#8]            ;201
00009e  f88d1048          STRB     r1,[sp,#0x48]         ;201
0000a2  7a22              LDRB     r2,[r4,#8]            ;202  ; WM_PID__StateLast
0000a4  f88d2049          STRB     r2,[sp,#0x49]         ;202
0000a8  f9b03000          LDRSH    r3,[r0,#0]            ;203
0000ac  9a00              LDR      r2,[sp,#0]            ;203
0000ae  1ad2              SUBS     r2,r2,r3              ;203
0000b0  9210              STR      r2,[sp,#0x40]         ;204
0000b2  f9b00002          LDRSH    r0,[r0,#2]            ;204
0000b6  9a01              LDR      r2,[sp,#4]            ;204
0000b8  1a10              SUBS     r0,r2,r0              ;204
0000ba  9011              STR      r0,[sp,#0x44]         ;205
0000bc  a810              ADD      r0,sp,#0x40           ;205
0000be  900b              STR      r0,[sp,#0x2c]         ;206
0000c0  2011              MOVS     r0,#0x11              ;206
0000c2  9009              STR      r0,[sp,#0x24]         ;206
0000c4  e894000d          LDM      r4,{r0,r2,r3}         ;206
0000c8  4681              MOV      r9,r0                 ;210
0000ca  7221              STRB     r1,[r4,#8]            ;215
0000cc  f89d0014          LDRB     r0,[sp,#0x14]         ;216
0000d0  4693              MOV      r11,r2                ;210
0000d2  469a              MOV      r10,r3                ;210
0000d4  b128              CBZ      r0,|L1.226|
0000d6  f9b57004          LDRSH    r7,[r5,#4]  ; WM__CHWinLast
;;;218              WM__CHWinLast.hWin = CHWin.hWin;
0000da  f8bd001c          LDRH     r0,[sp,#0x1c]
0000de  80a8              STRH     r0,[r5,#4]
0000e0  e000              B        |L1.228|
                  |L1.226|
;;;219            } else {
;;;220              hWinOld            = 0;
0000e2  2700              MOVS     r7,#0
                  |L1.228|
;;;221            }
;;;222            WM__SendMessageIfEnabled(CHWin.hWin, &Msg);
0000e4  f9bd001c          LDRSH    r0,[sp,#0x1c]
0000e8  a909              ADD      r1,sp,#0x24
0000ea  f7fffffe          BL       WM__SendMessageIfEnabled
;;;223            /* Restore state for further processing */
;;;224            WM_PID__StateLast = PID_StateOld;
0000ee  f8c4a008          STR      r10,[r4,#8]  ; WM_PID__StateLast
0000f2  e9c49b00          STRD     r9,r11,[r4,#0]
;;;225            if (hWinOld) {
0000f6  b127              CBZ      r7,|L1.258|
;;;226              /* hWinOld could be deleted during message processing. So check if it is a Window
;;;227               * before using it.
;;;228               */
;;;229              if (WM_IsWindow(hWinOld)) {
0000f8  4638              MOV      r0,r7
0000fa  f7fffffe          BL       WM_IsWindow
0000fe  b100              CBZ      r0,|L1.258|
;;;230                WM__CHWinLast.hWin        = hWinOld;
000100  80af              STRH     r7,[r5,#4]
                  |L1.258|
;;;231              }
;;;232            }
;;;233          }
;;;234          /*
;;;235           * Send WM_TOUCH message(s)
;;;236           * Note that we may have to send 2 touch messages.
;;;237           */
;;;238          if (WM_PID__StateLast.Pressed | StateNew.Pressed) {    /* Only if pressed or just released */
000102  7a21              LDRB     r1,[r4,#8]  ; WM_PID__StateLast
000104  f89d0008          LDRB     r0,[sp,#8]
000108  4301              ORRS     r1,r1,r0
00010a  d03d              BEQ      |L1.392|
;;;239            Msg.MsgId = WM_TOUCH;
00010c  210c              MOVS     r1,#0xc
;;;240            r = 1;
;;;241            /*
;;;242             * Tell window if it is no longer pressed
;;;243             * This happens for 2 possible reasons:
;;;244             * a) PID is released
;;;245             * b) PID is moved out
;;;246             */
;;;247            if (WM__CHWinLast.hWin != CHWin.hWin) {
00010e  9109              STR      r1,[sp,#0x24]
000110  f9b51004          LDRSH    r1,[r5,#4]  ; WM__CHWinLast
000114  f04f0801          MOV      r8,#1                 ;240
000118  f9bd201c          LDRSH    r2,[sp,#0x1c]
00011c  af03              ADD      r7,sp,#0xc            ;162
00011e  4291              CMP      r1,r2
000120  d011              BEQ      |L1.326|
;;;248              if (WM__CHWinLast.hWin != 0) {
000122  88a9              LDRH     r1,[r5,#4]  ; WM__CHWinLast
000124  b179              CBZ      r1,|L1.326|
;;;249                if (StateNew.Pressed) {
000126  b108              CBZ      r0,|L1.300|
;;;250                  /* Moved out -> no longer in this window
;;;251                   * Send a NULL pointer as data
;;;252                   */
;;;253                  Msg.Data.p = NULL;
000128  960b              STR      r6,[sp,#0x2c]
00012a  e006              B        |L1.314|
                  |L1.300|
;;;254                } else {
;;;255                  /* Last window needs to know that it has been "Released"
;;;256                   * Send last coordinates 
;;;257                   */
;;;258                  State.x       = WM_PID__StateLast.x;
00012c  6820              LDR      r0,[r4,#0]  ; WM_PID__StateLast
;;;259                  State.y       = WM_PID__StateLast.y;
00012e  9003              STR      r0,[sp,#0xc]
000130  6860              LDR      r0,[r4,#4]  ; WM_PID__StateLast
;;;260                  State.Pressed = 0;
000132  9004              STR      r0,[sp,#0x10]
000134  f88d6014          STRB     r6,[sp,#0x14]
;;;261                  Msg.Data.p = (void*)&State;
000138  970b              STR      r7,[sp,#0x2c]
                  |L1.314|
;;;262                }
;;;263                GUI_DEBUG_LOG1 ("\nSending WM_Touch to LastWindow %d (out of area)", WM__CHWinLast.hWin);
;;;264                WM__SendTouchMessage(WM__CHWinLast.hWin, &Msg);
00013a  f9b50004          LDRSH    r0,[r5,#4]  ; WM__CHWinLast
00013e  a909              ADD      r1,sp,#0x24
000140  f7fffffe          BL       WM__SendTouchMessage
;;;265                WM__CHWinLast.hWin = 0;
000144  80ae              STRH     r6,[r5,#4]
                  |L1.326|
;;;266              }
;;;267            }
;;;268            /* Make sure that this routine does not react a second time on the same event.
;;;269             * This could happen if for example a dialog is executed during the WM_TOUCH message processing
;;;270             */
;;;271            WM_PID__StateLast.Pressed = StateNew.Pressed;
000146  f89d0008          LDRB     r0,[sp,#8]
00014a  7220              STRB     r0,[r4,#8]
;;;272            /* Sending WM_Touch to current window */
;;;273            if (CHWin.hWin) {
00014c  f8bd001c          LDRH     r0,[sp,#0x1c]
000150  b108              CBZ      r0,|L1.342|
000152  e001              B        |L1.344|
                  |L1.340|
000154  e01f              B        |L1.406|
                  |L1.342|
000156  e017              B        |L1.392|
                  |L1.344|
000158  e89d0007          LDM      sp,{r0-r2}
00015c  ab03              ADD      r3,sp,#0xc
00015e  e8830007          STM      r3,{r0-r2}
;;;274              /* convert screen into window coordinates */
;;;275              State = StateNew;
;;;276              /* Remember window */
;;;277              if (State.Pressed) {
000162  f89d0014          LDRB     r0,[sp,#0x14]
000166  b118              CBZ      r0,|L1.368|
;;;278                WM__CHWinLast.hWin = CHWin.hWin;
000168  f8bd001c          LDRH     r0,[sp,#0x1c]
00016c  80a8              STRH     r0,[r5,#4]
00016e  e005              B        |L1.380|
                  |L1.368|
;;;279              } else {
;;;280                /* Handle automatic capture release */
;;;281                if (WM__CaptureReleaseAuto) {
000170  4811              LDR      r0,|L1.440|
000172  7800              LDRB     r0,[r0,#0]  ; WM__CaptureReleaseAuto
000174  b108              CBZ      r0,|L1.378|
;;;282                  WM_ReleaseCapture();
000176  f7fffffe          BL       WM_ReleaseCapture
                  |L1.378|
;;;283                }
;;;284                WM__CHWinLast.hWin = 0;
00017a  80ae              STRH     r6,[r5,#4]
                  |L1.380|
;;;285              }
;;;286              Msg.Data.p = (void*)&State;
;;;287              WM__SendTouchMessage(CHWin.hWin, &Msg);
00017c  f9bd001c          LDRSH    r0,[sp,#0x1c]
000180  970b              STR      r7,[sp,#0x2c]
000182  a909              ADD      r1,sp,#0x24
000184  f7fffffe          BL       WM__SendTouchMessage
                  |L1.392|
000188  e89d0007          LDM      sp,{r0-r2}
00018c  e8840007          STM      r4,{r0-r2}
;;;288            }
;;;289          }
;;;290          /*
;;;291           * Send WM_MOUSEOVER message
;;;292           */
;;;293          #if GUI_SUPPORT_MOUSE
;;;294          else {
;;;295            /* Send WM_MOUSEOVER Message */
;;;296            if (CHWin.hWin) {
;;;297              /* Do not send messages to disabled windows */
;;;298              if (WM__IsEnabled(CHWin.hWin)) {
;;;299                State      = StateNew;
;;;300                Msg.MsgId  = WM_MOUSEOVER;
;;;301                Msg.Data.p = (void*)&State;
;;;302                WM__SendTouchMessage(CHWin.hWin, &Msg);
;;;303              }
;;;304            }
;;;305          }
;;;306          #endif
;;;307        }
;;;308        /* Store the new state */
;;;309        WM_PID__StateLast = StateNew;
;;;310        WM_PID__SetPrevState(&StateNew);
000190  4668              MOV      r0,sp
000192  f7fffffe          BL       WM_PID__SetPrevState
                  |L1.406|
;;;311      }
;;;312      WM__RemoveCriticalHandle(&CHWin);
000196  a806              ADD      r0,sp,#0x18
000198  f7fffffe          BL       WM__RemoveCriticalHandle
;;;313      WM_UNLOCK();
;;;314      return r;
;;;315    }
00019c  b015              ADD      sp,sp,#0x54
00019e  4640              MOV      r0,r8                 ;314
0001a0  e8bd8ff0          POP      {r4-r11,pc}
;;;316    
                          ENDP

                  |L1.420|
                          DCD      GUI_OrgX
                  |L1.424|
                          DCD      GUI_OrgY
                  |L1.428|
                          DCD      WM_PID__StateLast
                  |L1.432|
                          DCD      WM__hCapture
                  |L1.436|
                          DCD      ||.data||+0x8
                  |L1.440|
                          DCD      WM__CaptureReleaseAuto

                          AREA ||i.WM__IsInModalArea||, CODE, READONLY, ALIGN=2

                  WM__IsInModalArea PROC
;;;48     */
;;;49     int WM__IsInModalArea(WM_HWIN hWin) {
000000  b570              PUSH     {r4-r6,lr}
;;;50       if ((WM__CHWinModal.hWin == 0) || WM__IsAncestor(hWin, WM__CHWinModal.hWin) || (hWin == WM__CHWinModal.hWin)) {
000002  4c09              LDR      r4,|L2.40|
000004  4605              MOV      r5,r0                 ;49
000006  88a0              LDRH     r0,[r4,#4]  ; WM__CHWinModal
000008  b148              CBZ      r0,|L2.30|
00000a  f9b41004          LDRSH    r1,[r4,#4]  ; WM__CHWinModal
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       WM__IsAncestor
000014  b918              CBNZ     r0,|L2.30|
000016  f9b40004          LDRSH    r0,[r4,#4]  ; WM__CHWinModal
00001a  42a8              CMP      r0,r5
00001c  d101              BNE      |L2.34|
                  |L2.30|
;;;51         return 1;
00001e  2001              MOVS     r0,#1
;;;52       }
;;;53       return 0;
;;;54     }
000020  bd70              POP      {r4-r6,pc}
                  |L2.34|
000022  2000              MOVS     r0,#0                 ;53
000024  bd70              POP      {r4-r6,pc}
;;;55     
                          ENDP

000026  0000              DCW      0x0000
                  |L2.40|
                          DCD      ||.data||

                          AREA ||i.WM__SendPIDMessage||, CODE, READONLY, ALIGN=1

                  WM__SendPIDMessage PROC
;;;65     */
;;;66     void WM__SendPIDMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
000000  b5fe              PUSH     {r1-r7,lr}
000002  460e              MOV      r6,r1
000004  4605              MOV      r5,r0
000006  e9d60101          LDRD     r0,r1,[r6,#4]
00000a  e9cd0101          STRD     r0,r1,[sp,#4]
;;;67       #if 1
;;;68       WM_HWIN iWin;
;;;69       WM_MESSAGE Msg;
;;;70       Msg = *pMsg;                 /* Save message as it may be modified in callback (as return value) */
;;;71       /* Send notification to all ancestors.
;;;72          We need to check if the window which has received the last message still exists,
;;;73          since it may have deleted itself and its parent as result of the message.
;;;74       */
;;;75       Msg.hWinSrc = hWin;
;;;76       Msg.MsgId   = WM_TOUCH_CHILD;
00000e  200d              MOVS     r0,#0xd
000010  f8ad5006          STRH     r5,[sp,#6]            ;75
;;;77       iWin = hWin;
000014  462c              MOV      r4,r5
000016  9000              STR      r0,[sp,#0]            ;66
000018  e008              B        |L3.44|
                  |L3.26|
;;;78       while (WM_IsWindow(iWin)) {
;;;79         iWin = WM_GetParent(iWin);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       WM_GetParent
000020  0004              MOVS     r4,r0
;;;80         if (iWin) {
000022  d003              BEQ      |L3.44|
;;;81           Msg.Data.p  = pMsg;            /* Needs to be set for each window, as callback is allowed to modify it */
;;;82           WM__SendMessageIfEnabled(iWin, &Msg);    /* Send message to the ancestors */
000024  4669              MOV      r1,sp
000026  9602              STR      r6,[sp,#8]
000028  f7fffffe          BL       WM__SendMessageIfEnabled
                  |L3.44|
00002c  4620              MOV      r0,r4                 ;78
00002e  f7fffffe          BL       WM_IsWindow
000032  2800              CMP      r0,#0                 ;78
000034  d1f1              BNE      |L3.26|
;;;83         }
;;;84       }
;;;85       /* Send message to the affected window */
;;;86       WM__SendMessageIfEnabled(hWin, pMsg);
000036  4631              MOV      r1,r6
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       WM__SendMessageIfEnabled
;;;87       #else
;;;88       WM_MESSAGE Msg;
;;;89       /* Send message to the affected window */
;;;90       Msg = *pMsg;                 /* Save message as it may be modified in callback (as return value) */
;;;91       WM__SendMessageIfEnabled(hWin, &Msg);
;;;92       /* Send notification to all ancestors.
;;;93          We need to check if the window which has received the last message still exists,
;;;94          since it may have deleted itself and its parent as result of the message.
;;;95       */
;;;96       Msg.hWinSrc = hWin;
;;;97       Msg.MsgId   = WM_TOUCH_CHILD;
;;;98       while (WM_IsWindow(hWin)) {
;;;99         hWin = WM_GetParent(hWin);
;;;100        if (hWin) {
;;;101          Msg.Data.p  = pMsg;            /* Needs to be set for each window, as callback is allowed to modify it */
;;;102          WM__SendMessageIfEnabled(hWin, &Msg);    /* Send message to the ancestors */
;;;103        }
;;;104      }
;;;105      #endif
;;;106    }
00003e  bdfe              POP      {r1-r7,pc}
;;;107    
                          ENDP


                          AREA ||i.WM__SendTouchMessage||, CODE, READONLY, ALIGN=1

                  WM__SendTouchMessage PROC
;;;111    */
;;;112    void WM__SendTouchMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
000000  b570              PUSH     {r4-r6,lr}
000002  688c              LDR      r4,[r1,#8]
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
000008  b15c              CBZ      r4,|L4.34|
;;;113      GUI_PID_STATE* pState;
;;;114      pState     = (GUI_PID_STATE*)pMsg->Data.p;
;;;115      if (pState) {
;;;116        WM_Obj* pWin;
;;;117        pWin       = WM_H2P(hWin);
00000a  f7fffffe          BL       GUI_ALLOC_h2p
;;;118        pState->x -= pWin->Rect.x0;
00000e  f9b02000          LDRSH    r2,[r0,#0]
000012  6821              LDR      r1,[r4,#0]
000014  1a89              SUBS     r1,r1,r2
;;;119        pState->y -= pWin->Rect.y0;
000016  6021              STR      r1,[r4,#0]
000018  f9b00002          LDRSH    r0,[r0,#2]
00001c  6861              LDR      r1,[r4,#4]
00001e  1a08              SUBS     r0,r1,r0
000020  6060              STR      r0,[r4,#4]
                  |L4.34|
;;;120      }
;;;121      WM__SendPIDMessage(hWin, pMsg);
000022  4629              MOV      r1,r5
000024  4630              MOV      r0,r6
000026  e8bd4070          POP      {r4-r6,lr}
00002a  f7ffbffe          B.W      WM__SendPIDMessage
;;;122    }
;;;123    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  WM__CHWinModal
                          %        8
                  WM__CHWinLast
                          %        8
