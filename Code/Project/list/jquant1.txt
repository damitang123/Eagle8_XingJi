; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\jquant1.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jquant1.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\JPEG\jquant1.c]
                          THUMB

                          AREA ||i.alloc_fs_workspace||, CODE, READONLY, ALIGN=1

                  alloc_fs_workspace PROC
;;;725    LOCAL(void)
;;;726    alloc_fs_workspace (j_decompress_ptr cinfo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;727    {
000004  4605              MOV      r5,r0
;;;728      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
;;;729      size_t arraysize;
;;;730      int i;
;;;731    
;;;732      arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
000006  f8d071cc          LDR      r7,[r0,#0x1cc]
00000a  6f00              LDR      r0,[r0,#0x70]
;;;733      for (i = 0; i < cinfo->out_color_components; i++) {
00000c  2400              MOVS     r4,#0
00000e  0046              LSLS     r6,r0,#1              ;732
000010  1d36              ADDS     r6,r6,#4
000012  e009              B        |L1.40|
                  |L1.20|
;;;734        cquantize->fserrors[i] = (FSERRPTR)
000014  6868              LDR      r0,[r5,#4]
000016  4632              MOV      r2,r6
000018  2101              MOVS     r1,#1
00001a  6843              LDR      r3,[r0,#4]
00001c  4628              MOV      r0,r5
00001e  4798              BLX      r3
000020  eb070184          ADD      r1,r7,r4,LSL #2
000024  1c64              ADDS     r4,r4,#1
000026  6448              STR      r0,[r1,#0x44]
                  |L1.40|
000028  6fa8              LDR      r0,[r5,#0x78]         ;733
00002a  42a0              CMP      r0,r4                 ;733
00002c  dcf2              BGT      |L1.20|
;;;735          (*cinfo->mem->alloc_large)((j_common_ptr) cinfo, JPOOL_IMAGE, arraysize);
;;;736      }
;;;737    }
00002e  e8bd81f0          POP      {r4-r8,pc}
;;;738    
                          ENDP


                          AREA ||i.color_quantize||, CODE, READONLY, ALIGN=2

                  color_quantize PROC
;;;462    METHODDEF(void)
;;;463    color_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;464    		JSAMPARRAY output_buf, int num_rows)
;;;465    /* General case, no dithering */
;;;466    {
000004  468b              MOV      r11,r1
;;;467      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
;;;468      JSAMPARRAY colorindex = cquantize->colorindex;
000006  f8d011cc          LDR      r1,[r0,#0x1cc]
00000a  469a              MOV      r10,r3                ;466
00000c  4696              MOV      lr,r2                 ;466
;;;469      register int pixcode, ci;
;;;470      register JSAMPROW ptrin, ptrout;
;;;471      int row;
;;;472      JDIMENSION col;
;;;473      JDIMENSION width = cinfo->output_width;
00000e  698e              LDR      r6,[r1,#0x18]
;;;474      register int nc = cinfo->out_color_components;
;;;475    
;;;476      for (row = 0; row < num_rows; row++) {
000010  2100              MOVS     r1,#0
000012  f8d09070          LDR      r9,[r0,#0x70]         ;466
000016  6f87              LDR      r7,[r0,#0x78]         ;466
000018  e019              B        |L2.78|
;;;477        ptrin = input_buf[row];
00001a  bf00              NOP      
                  |L2.28|
00001c  f85b4021          LDR      r4,[r11,r1,LSL #2]
;;;478        ptrout = output_buf[row];
000020  f85e5021          LDR      r5,[lr,r1,LSL #2]
;;;479        for (col = width; col > 0; col--) {
000024  ea5f0009          MOVS     r0,r9
000028  d010              BEQ      |L2.76|
                  |L2.42|
;;;480          pixcode = 0;
00002a  2300              MOVS     r3,#0
;;;481          for (ci = 0; ci < nc; ci++) {
00002c  461a              MOV      r2,r3
00002e  e007              B        |L2.64|
                  |L2.48|
;;;482    	pixcode += GETJSAMPLE(colorindex[ci][GETJSAMPLE(*ptrin++)]);
000030  f856c022          LDR      r12,[r6,r2,LSL #2]
000034  f8148b01          LDRB     r8,[r4],#1
000038  1c52              ADDS     r2,r2,#1
00003a  f81cc008          LDRB     r12,[r12,r8]
00003e  4463              ADD      r3,r3,r12
                  |L2.64|
000040  42ba              CMP      r2,r7                 ;481
000042  dbf5              BLT      |L2.48|
;;;483          }
;;;484          *ptrout++ = (JSAMPLE) pixcode;
000044  f8053b01          STRB     r3,[r5],#1
000048  1e40              SUBS     r0,r0,#1
00004a  d1ee              BNE      |L2.42|
                  |L2.76|
00004c  1c49              ADDS     r1,r1,#1              ;479
                  |L2.78|
00004e  4551              CMP      r1,r10                ;476
000050  dbe4              BLT      |L2.28|
;;;485        }
;;;486      }
;;;487    }
000052  e8bd8ff0          POP      {r4-r11,pc}
;;;488    
                          ENDP


                          AREA ||i.color_quantize3||, CODE, READONLY, ALIGN=1

                  color_quantize3 PROC
;;;490    METHODDEF(void)
;;;491    color_quantize3 (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;492    		 JSAMPARRAY output_buf, int num_rows)
;;;493    /* Fast path for out_color_components==3, no dithering */
;;;494    {
000004  468a              MOV      r10,r1
;;;495      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
;;;496      register int pixcode;
;;;497      register JSAMPROW ptrin, ptrout;
;;;498      JSAMPROW colorindex0 = cquantize->colorindex[0];
000006  f8d011cc          LDR      r1,[r0,#0x1cc]
00000a  4693              MOV      r11,r2                ;494
00000c  4699              MOV      r9,r3                 ;494
00000e  6989              LDR      r1,[r1,#0x18]
;;;499      JSAMPROW colorindex1 = cquantize->colorindex[1];
;;;500      JSAMPROW colorindex2 = cquantize->colorindex[2];
;;;501      int row;
;;;502      JDIMENSION col;
;;;503      JDIMENSION width = cinfo->output_width;
;;;504    
;;;505      for (row = 0; row < num_rows; row++) {
000010  2200              MOVS     r2,#0
000012  6f04              LDR      r4,[r0,#0x70]         ;494
000014  e9d16501          LDRD     r6,r5,[r1,#4]         ;498
000018  680f              LDR      r7,[r1,#0]            ;503
00001a  e018              B        |L3.78|
                  |L3.28|
;;;506        ptrin = input_buf[row];
00001c  f85a0022          LDR      r0,[r10,r2,LSL #2]
;;;507        ptrout = output_buf[row];
000020  f85b3022          LDR      r3,[r11,r2,LSL #2]
;;;508        for (col = width; col > 0; col--) {
000024  0021              MOVS     r1,r4
000026  d011              BEQ      |L3.76|
                  |L3.40|
;;;509          pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*ptrin++)]);
000028  f810cb01          LDRB     r12,[r0],#1
;;;510          pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*ptrin++)]);
;;;511          pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*ptrin++)]);
;;;512          *ptrout++ = (JSAMPLE) pixcode;
00002c  1e49              SUBS     r1,r1,#1
00002e  f8108b01          LDRB     r8,[r0],#1            ;510
000032  f817c00c          LDRB     r12,[r7,r12]          ;509
000036  f8168008          LDRB     r8,[r6,r8]            ;510
00003a  44c4              ADD      r12,r12,r8            ;510
00003c  f8108b01          LDRB     r8,[r0],#1            ;511
000040  f8158008          LDRB     r8,[r5,r8]            ;511
000044  44c4              ADD      r12,r12,r8            ;511
000046  f803cb01          STRB     r12,[r3],#1
00004a  d1ed              BNE      |L3.40|
                  |L3.76|
00004c  1c52              ADDS     r2,r2,#1              ;508
                  |L3.78|
00004e  454a              CMP      r2,r9                 ;505
000050  dbe4              BLT      |L3.28|
;;;513        }
;;;514      }
;;;515    }
000052  e8bd8ff0          POP      {r4-r11,pc}
;;;516    
                          ENDP


                          AREA ||i.create_colorindex||, CODE, READONLY, ALIGN=2

                  create_colorindex PROC
;;;336    LOCAL(void)
;;;337    create_colorindex (j_decompress_ptr cinfo)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;338    {
000004  4680              MOV      r8,r0
;;;339      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
;;;340      JSAMPROW indexptr;
;;;341      int i,j,k, nci, blksize, val, pad;
;;;342    
;;;343      /* For ordered dither, we pad the color index tables by MAXJSAMPLE in
;;;344       * each direction (input index values can be -MAXJSAMPLE .. 2*MAXJSAMPLE).
;;;345       * This is not necessary in the other dithering modes.  However, we
;;;346       * flag whether it was done in case user changes dithering mode.
;;;347       */
;;;348      if (cinfo->dither_mode == JDITHER_ORDERED) {
000006  f8d051cc          LDR      r5,[r0,#0x1cc]
00000a  f8900058          LDRB     r0,[r0,#0x58]
00000e  2801              CMP      r0,#1
000010  d012              BEQ      |L4.56|
;;;349        pad = MAXJSAMPLE*2;
;;;350        cquantize->is_padded = TRUE;
;;;351      } else {
;;;352        pad = 0;
000012  f04f0a00          MOV      r10,#0
;;;353        cquantize->is_padded = FALSE;
000016  4650              MOV      r0,r10
                  |L4.24|
;;;354      }
;;;355    
;;;356      cquantize->colorindex = (*cinfo->mem->alloc_sarray)
000018  61e8              STR      r0,[r5,#0x1c]
00001a  f8d80004          LDR      r0,[r8,#4]
00001e  f8d83078          LDR      r3,[r8,#0x78]
000022  f50a7280          ADD      r2,r10,#0x100
000026  6884              LDR      r4,[r0,#8]
000028  2101              MOVS     r1,#1
00002a  4640              MOV      r0,r8
00002c  47a0              BLX      r4
;;;357        ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;358         (JDIMENSION) (MAXJSAMPLE+1 + pad),
;;;359         (JDIMENSION) cinfo->out_color_components);
;;;360    
;;;361      /* blksize is number of adjacent repeated entries for a component */
;;;362      blksize = cquantize->sv_actual;
00002e  61a8              STR      r0,[r5,#0x18]
000030  6968              LDR      r0,[r5,#0x14]
;;;363    
;;;364      for (i = 0; i < cinfo->out_color_components; i++) {
000032  2400              MOVS     r4,#0
000034  9000              STR      r0,[sp,#0]
000036  e045              B        |L4.196|
                  |L4.56|
000038  f44f7aff          MOV      r10,#0x1fe            ;349
00003c  2001              MOVS     r0,#1                 ;350
00003e  e7eb              B        |L4.24|
                  |L4.64|
;;;365        /* fill in colorindex entries for i'th color component */
;;;366        nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
000040  eb050084          ADD      r0,r5,r4,LSL #2
;;;367        blksize = blksize / nci;
000044  9900              LDR      r1,[sp,#0]
000046  f8d0b020          LDR      r11,[r0,#0x20]
;;;368    
;;;369        /* adjust colorindex pointers to provide padding at negative indexes. */
;;;370        if (pad)
00004a  f1ba0f00          CMP      r10,#0
00004e  fb91f0fb          SDIV     r0,r1,r11             ;367
000052  9000              STR      r0,[sp,#0]
000054  d005              BEQ      |L4.98|
;;;371          cquantize->colorindex[i] += MAXJSAMPLE;
000056  69a8              LDR      r0,[r5,#0x18]
000058  f8501024          LDR      r1,[r0,r4,LSL #2]
00005c  31ff              ADDS     r1,r1,#0xff
00005e  f8401024          STR      r1,[r0,r4,LSL #2]
                  |L4.98|
;;;372    
;;;373        /* in loop, val = index of current output value, */
;;;374        /* and k = largest j that maps to current val */
;;;375        indexptr = cquantize->colorindex[i];
000062  69a8              LDR      r0,[r5,#0x18]
;;;376        val = 0;
000064  f04f0900          MOV      r9,#0
;;;377        k = largest_input_value(cinfo, i, 0, nci-1);
000068  f1ab0301          SUB      r3,r11,#1
00006c  f8506024          LDR      r6,[r0,r4,LSL #2]     ;375
000070  464a              MOV      r2,r9
000072  4621              MOV      r1,r4
000074  4640              MOV      r0,r8
000076  f7fffffe          BL       largest_input_value
;;;378        for (j = 0; j <= MAXJSAMPLE; j++) {
00007a  2700              MOVS     r7,#0
00007c  e009              B        |L4.146|
;;;379          while (j > k)		/* advance val if past boundary */
;;;380    	k = largest_input_value(cinfo, i, ++val, nci-1);
00007e  bf00              NOP      
                  |L4.128|
000080  f1090201          ADD      r2,r9,#1
000084  4691              MOV      r9,r2
000086  f1ab0301          SUB      r3,r11,#1
00008a  4621              MOV      r1,r4
00008c  4640              MOV      r0,r8
00008e  f7fffffe          BL       largest_input_value
                  |L4.146|
000092  4287              CMP      r7,r0                 ;379
000094  dcf4              BGT      |L4.128|
;;;381          /* premultiply so that no multiplication needed in main processing */
;;;382          indexptr[j] = (JSAMPLE) (val * blksize);
000096  9a00              LDR      r2,[sp,#0]
000098  fb09f102          MUL      r1,r9,r2
00009c  55f1              STRB     r1,[r6,r7]
00009e  1c7f              ADDS     r7,r7,#1
0000a0  2fff              CMP      r7,#0xff              ;378
0000a2  ddf6              BLE      |L4.146|
;;;383        }
;;;384        /* Pad at both ends if necessary */
;;;385        if (pad)
0000a4  f1ba0f00          CMP      r10,#0
0000a8  d00b              BEQ      |L4.194|
;;;386          for (j = 1; j <= MAXJSAMPLE; j++) {
0000aa  2001              MOVS     r0,#1
                  |L4.172|
;;;387    	indexptr[-j] = indexptr[0];
0000ac  1a32              SUBS     r2,r6,r0
0000ae  7831              LDRB     r1,[r6,#0]
0000b0  7011              STRB     r1,[r2,#0]
;;;388    	indexptr[MAXJSAMPLE+j] = indexptr[MAXJSAMPLE];
0000b2  1831              ADDS     r1,r6,r0
0000b4  f89620ff          LDRB     r2,[r6,#0xff]
0000b8  1c40              ADDS     r0,r0,#1
0000ba  f88120ff          STRB     r2,[r1,#0xff]
0000be  28ff              CMP      r0,#0xff              ;386
0000c0  ddf4              BLE      |L4.172|
                  |L4.194|
0000c2  1c64              ADDS     r4,r4,#1              ;386
                  |L4.196|
0000c4  f8d80078          LDR      r0,[r8,#0x78]         ;364
0000c8  42a0              CMP      r0,r4                 ;364
0000ca  dcb9              BGT      |L4.64|
;;;389          }
;;;390      }
;;;391    }
0000cc  e8bd8ff8          POP      {r3-r11,pc}
;;;392    
                          ENDP


                          AREA ||i.create_colormap||, CODE, READONLY, ALIGN=1

                  create_colormap PROC
;;;276    LOCAL(void)
;;;277    create_colormap (j_decompress_ptr cinfo)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;278    {
;;;279      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
000004  f8d061cc          LDR      r6,[r0,#0x1cc]
000008  4604              MOV      r4,r0                 ;278
00000a  f1060120          ADD      r1,r6,#0x20
;;;280      JSAMPARRAY colormap;		/* Created colormap */
;;;281      int total_colors;		/* Number of distinct output colors */
;;;282      int i,j,k, nci, blksize, blkdist, ptr, val;
;;;283    
;;;284      /* Select number of colors for each component */
;;;285      total_colors = select_ncolors(cinfo, cquantize->Ncolors);
00000e  f7fffffe          BL       select_ncolors
000012  4605              MOV      r5,r0
;;;286    
;;;287      /* Report selected color counts */
;;;288      if (cinfo->out_color_components == 3)
000014  6fa0              LDR      r0,[r4,#0x78]
000016  2803              CMP      r0,#3
000018  d014              BEQ      |L5.68|
;;;289        TRACEMS4(cinfo, 1, JTRC_QUANT_3_NCOLORS,
;;;290    	     total_colors, cquantize->Ncolors[0],
;;;291    	     cquantize->Ncolors[1], cquantize->Ncolors[2]);
;;;292      else
;;;293        TRACEMS1(cinfo, 1, JTRC_QUANT_NCOLORS, total_colors);
00001a  6821              LDR      r1,[r4,#0]
00001c  205f              MOVS     r0,#0x5f
00001e  6148              STR      r0,[r1,#0x14]
000020  6820              LDR      r0,[r4,#0]
000022  6185              STR      r5,[r0,#0x18]
                  |L5.36|
000024  6820              LDR      r0,[r4,#0]
000026  2101              MOVS     r1,#1
000028  6842              LDR      r2,[r0,#4]
00002a  4620              MOV      r0,r4
00002c  4790              BLX      r2
;;;294    
;;;295      /* Allocate and fill in the colormap. */
;;;296      /* The colors are ordered in the map in standard row-major order, */
;;;297      /* i.e. rightmost (highest-indexed) color changes most rapidly. */
;;;298    
;;;299      colormap = (*cinfo->mem->alloc_sarray)
00002e  6860              LDR      r0,[r4,#4]
000030  6fa3              LDR      r3,[r4,#0x78]
000032  462a              MOV      r2,r5
000034  6887              LDR      r7,[r0,#8]
000036  2101              MOVS     r1,#1
000038  4620              MOV      r0,r4
00003a  47b8              BLX      r7
00003c  4683              MOV      r11,r0
;;;300        ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;301         (JDIMENSION) total_colors, (JDIMENSION) cinfo->out_color_components);
;;;302    
;;;303      /* blksize is number of adjacent repeated entries for a component */
;;;304      /* blkdist is distance between groups of identical entries for a component */
;;;305      blkdist = total_colors;
00003e  46ae              MOV      lr,r5
;;;306    
;;;307      for (i = 0; i < cinfo->out_color_components; i++) {
000040  2000              MOVS     r0,#0
000042  e035              B        |L5.176|
                  |L5.68|
000044  6820              LDR      r0,[r4,#0]            ;289
000046  6185              STR      r5,[r0,#0x18]         ;289
000048  6a31              LDR      r1,[r6,#0x20]         ;289
00004a  61c1              STR      r1,[r0,#0x1c]         ;289
00004c  6a71              LDR      r1,[r6,#0x24]         ;289
00004e  6201              STR      r1,[r0,#0x20]         ;289
000050  6ab1              LDR      r1,[r6,#0x28]         ;289
000052  6241              STR      r1,[r0,#0x24]         ;289
000054  6821              LDR      r1,[r4,#0]            ;289
000056  205e              MOVS     r0,#0x5e              ;289
000058  6148              STR      r0,[r1,#0x14]         ;289
00005a  e7e3              B        |L5.36|
                  |L5.92|
;;;308        /* fill in colormap entries for i'th color component */
;;;309        nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
00005c  eb060089          ADD      r0,r6,r9,LSL #2
;;;310        blksize = blkdist / nci;
000060  f8d0a020          LDR      r10,[r0,#0x20]
;;;311        for (j = 0; j < nci; j++) {
000064  2000              MOVS     r0,#0
000066  fb9ef3fa          SDIV     r3,lr,r10             ;310
00006a  e01c              B        |L5.166|
                  |L5.108|
;;;312          /* Compute j'th output value (out of nci) for component */
;;;313          val = output_value(cinfo, i, j, nci-1);
00006c  f1aa0101          SUB      r1,r10,#1
000070  ebc02200          RSB      r2,r0,r0,LSL #8
000074  eb0177d1          ADD      r7,r1,r1,LSR #31
000078  eb020267          ADD      r2,r2,r7,ASR #1
00007c  fb92f2f1          SDIV     r2,r2,r1
;;;314          /* Fill in all colormap entries that have this value of this component */
;;;315          for (ptr = j * blksize; ptr < total_colors; ptr += blkdist) {
000080  fb00f103          MUL      r1,r0,r3
;;;316    	/* fill in blksize entries beginning at ptr */
;;;317    	for (k = 0; k < blksize; k++)
;;;318    	  colormap[i][ptr+k] = (JSAMPLE) val;
000084  b2d7              UXTB     r7,r2
000086  e00b              B        |L5.160|
                  |L5.136|
000088  2200              MOVS     r2,#0                 ;317
00008a  e006              B        |L5.154|
                  |L5.140|
00008c  f85bc029          LDR      r12,[r11,r9,LSL #2]
000090  eb010802          ADD      r8,r1,r2
000094  1c52              ADDS     r2,r2,#1
000096  f80c7008          STRB     r7,[r12,r8]
                  |L5.154|
00009a  429a              CMP      r2,r3                 ;317
00009c  dbf6              BLT      |L5.140|
00009e  4471              ADD      r1,r1,lr              ;315
                  |L5.160|
0000a0  42a9              CMP      r1,r5                 ;315
0000a2  dbf1              BLT      |L5.136|
0000a4  1c40              ADDS     r0,r0,#1              ;315
                  |L5.166|
0000a6  4550              CMP      r0,r10                ;311
0000a8  dbe0              BLT      |L5.108|
;;;319          }
;;;320        }
;;;321        blkdist = blksize;		/* blksize of this color is blkdist of next */
0000aa  469e              MOV      lr,r3
0000ac  f1090001          ADD      r0,r9,#1              ;307
                  |L5.176|
0000b0  6fa1              LDR      r1,[r4,#0x78]         ;307
0000b2  4681              MOV      r9,r0                 ;307
0000b4  4549              CMP      r1,r9                 ;307
0000b6  dcd1              BGT      |L5.92|
0000b8  e9c6b504          STRD     r11,r5,[r6,#0x10]     ;307
;;;322      }
;;;323    
;;;324      /* Save the colormap in private storage,
;;;325       * where it will survive color quantization mode changes.
;;;326       */
;;;327      cquantize->sv_colormap = colormap;
;;;328      cquantize->sv_actual = total_colors;
;;;329    }
0000bc  e8bd9ff0          POP      {r4-r12,pc}
;;;330    
                          ENDP


                          AREA ||i.create_odither_tables||, CODE, READONLY, ALIGN=2

                  create_odither_tables PROC
;;;435    LOCAL(void)
;;;436    create_odither_tables (j_decompress_ptr cinfo)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;437    {
000004  4682              MOV      r10,r0
;;;438      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
;;;439      ODITHER_MATRIX_PTR odither;
;;;440      int i, j, nci;
;;;441    
;;;442      for (i = 0; i < cinfo->out_color_components; i++) {
000006  2400              MOVS     r4,#0
000008  f8d091cc          LDR      r9,[r0,#0x1cc]        ;437
00000c  e040              B        |L6.144|
;;;443        nci = cquantize->Ncolors[i]; /* # of distinct values for this color */
00000e  bf00              NOP      
                  |L6.16|
000010  eb090b84          ADD      r11,r9,r4,LSL #2
;;;444        odither = NULL;		/* search for matching prior component */
;;;445        for (j = 0; j < i; j++) {
000014  2000              MOVS     r0,#0
000016  f8db5020          LDR      r5,[r11,#0x20]
00001a  e00a              B        |L6.50|
                  |L6.28|
;;;446          if (nci == cquantize->Ncolors[j]) {
00001c  eb090180          ADD      r1,r9,r0,LSL #2
000020  6a09              LDR      r1,[r1,#0x20]
000022  42a9              CMP      r1,r5
000024  d104              BNE      |L6.48|
;;;447    	odither = cquantize->odither[j];
000026  eb090080          ADD      r0,r9,r0,LSL #2
00002a  6b40              LDR      r0,[r0,#0x34]
;;;448    	break;
00002c  b118              CBZ      r0,|L6.54|
00002e  e02c              B        |L6.138|
                  |L6.48|
000030  1c40              ADDS     r0,r0,#1
                  |L6.50|
000032  42a0              CMP      r0,r4                 ;445
000034  dbf2              BLT      |L6.28|
                  |L6.54|
000036  f8da1004          LDR      r1,[r10,#4]           ;445
;;;449          }
;;;450        }
;;;451        if (odither == NULL)	/* need a new table? */
;;;452          odither = make_odither_array(cinfo, nci);
00003a  4650              MOV      r0,r10
00003c  f44f6280          MOV      r2,#0x400
000040  680b              LDR      r3,[r1,#0]
000042  2101              MOVS     r1,#1
000044  4798              BLX      r3
000046  026b              LSLS     r3,r5,#9
000048  2200              MOVS     r2,#0
00004a  f8df8050          LDR      r8,|L6.156|
00004e  27ff              MOVS     r7,#0xff
000050  f5a37300          SUB      r3,r3,#0x200
                  |L6.84|
000054  2100              MOVS     r1,#0
000056  eb081602          ADD      r6,r8,r2,LSL #4
00005a  eb001c82          ADD      r12,r0,r2,LSL #6
                  |L6.94|
00005e  5c75              LDRB     r5,[r6,r1]
000060  426d              RSBS     r5,r5,#0
000062  eb070545          ADD      r5,r7,r5,LSL #1
000066  ebd52505          RSBS     r5,r5,r5,LSL #8
00006a  d504              BPL      |L6.118|
00006c  426d              RSBS     r5,r5,#0
00006e  fb95f5f3          SDIV     r5,r5,r3
000072  426d              RSBS     r5,r5,#0
000074  e001              B        |L6.122|
                  |L6.118|
000076  fb95f5f3          SDIV     r5,r5,r3
                  |L6.122|
00007a  f84c5021          STR      r5,[r12,r1,LSL #2]
00007e  1c49              ADDS     r1,r1,#1
000080  2910              CMP      r1,#0x10
000082  dbec              BLT      |L6.94|
000084  1c52              ADDS     r2,r2,#1
000086  2a10              CMP      r2,#0x10
000088  dbe4              BLT      |L6.84|
                  |L6.138|
;;;453        cquantize->odither[i] = odither;
00008a  1c64              ADDS     r4,r4,#1
00008c  f8cb0034          STR      r0,[r11,#0x34]
                  |L6.144|
000090  f8da0078          LDR      r0,[r10,#0x78]        ;442
000094  42a0              CMP      r0,r4                 ;442
000096  dcbb              BGT      |L6.16|
;;;454      }
;;;455    }
000098  e8bd9ff0          POP      {r4-r12,pc}
;;;456    
                          ENDP

                  |L6.156|
                          DCD      ||.constdata||

                          AREA ||i.finish_pass_1_quant||, CODE, READONLY, ALIGN=1

                  finish_pass_1_quant PROC
;;;802    METHODDEF(void)
;;;803    finish_pass_1_quant (j_decompress_ptr cinfo)
000000  4770              BX       lr
;;;804    {
;;;805      GUI_USE_PARA(cinfo);
;;;806      /* no work in 1-pass case */
;;;807    }
;;;808    
                          ENDP


                          AREA ||i.jinit_1pass_quantizer||, CODE, READONLY, ALIGN=2

                  jinit_1pass_quantizer PROC
;;;826    GLOBAL(void)
;;;827    jinit_1pass_quantizer (j_decompress_ptr cinfo)
000000  b510              PUSH     {r4,lr}
;;;828    {
000002  4604              MOV      r4,r0
;;;829      my_cquantize_ptr cquantize;
;;;830    
;;;831      cquantize = (my_cquantize_ptr)
000004  6840              LDR      r0,[r0,#4]
000006  2258              MOVS     r2,#0x58
000008  2101              MOVS     r1,#1
00000a  6803              LDR      r3,[r0,#0]
00000c  4620              MOV      r0,r4
00000e  4798              BLX      r3
;;;832        (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
;;;833    				SIZEOF(my_cquantizer));
;;;834      cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
;;;835      cquantize->pub.start_pass = start_pass_1_quant;
000010  491a              LDR      r1,|L8.124|
000012  f8c401cc          STR      r0,[r4,#0x1cc]
;;;836      cquantize->pub.finish_pass = finish_pass_1_quant;
000016  6001              STR      r1,[r0,#0]
000018  4919              LDR      r1,|L8.128|
;;;837      cquantize->pub.new_color_map = new_color_map_1_quant;
00001a  6081              STR      r1,[r0,#8]
00001c  4919              LDR      r1,|L8.132|
;;;838      cquantize->fserrors[0] = NULL; /* Flag FS workspace not allocated */
00001e  60c1              STR      r1,[r0,#0xc]
000020  2100              MOVS     r1,#0
;;;839      cquantize->odither[0] = NULL;	/* Also flag odither arrays not allocated */
000022  6441              STR      r1,[r0,#0x44]
;;;840    
;;;841      /* Make sure my internal arrays won't overflow */
;;;842      if (cinfo->out_color_components > MAX_Q_COMPS)
000024  6341              STR      r1,[r0,#0x34]
000026  6fa0              LDR      r0,[r4,#0x78]
000028  2804              CMP      r0,#4
00002a  dd09              BLE      |L8.64|
;;;843        ERREXIT1(cinfo, JERR_QUANT_COMPONENTS, MAX_Q_COMPS);
00002c  6821              LDR      r1,[r4,#0]
00002e  2037              MOVS     r0,#0x37
000030  6148              STR      r0,[r1,#0x14]
000032  6821              LDR      r1,[r4,#0]
000034  2004              MOVS     r0,#4
000036  6188              STR      r0,[r1,#0x18]
000038  6820              LDR      r0,[r4,#0]
00003a  6801              LDR      r1,[r0,#0]
00003c  4620              MOV      r0,r4
00003e  4788              BLX      r1
                  |L8.64|
;;;844      /* Make sure colormap indexes can be represented by JSAMPLEs */
;;;845      if (cinfo->desired_number_of_colors > (MAXJSAMPLE+1))
000040  6e21              LDR      r1,[r4,#0x60]
000042  f44f7080          MOV      r0,#0x100
000046  4281              CMP      r1,r0
000048  dd08              BLE      |L8.92|
;;;846        ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXJSAMPLE+1);
00004a  6822              LDR      r2,[r4,#0]
00004c  2139              MOVS     r1,#0x39
00004e  6151              STR      r1,[r2,#0x14]
000050  6821              LDR      r1,[r4,#0]
000052  6188              STR      r0,[r1,#0x18]
000054  6820              LDR      r0,[r4,#0]
000056  6801              LDR      r1,[r0,#0]
000058  4620              MOV      r0,r4
00005a  4788              BLX      r1
                  |L8.92|
;;;847    
;;;848      /* Create the colormap and color index table. */
;;;849      create_colormap(cinfo);
00005c  4620              MOV      r0,r4
00005e  f7fffffe          BL       create_colormap
;;;850      create_colorindex(cinfo);
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       create_colorindex
;;;851    
;;;852      /* Allocate Floyd-Steinberg workspace now if requested.
;;;853       * We do this now since it is FAR storage and may affect the memory
;;;854       * manager's space calculations.  If the user changes to FS dither
;;;855       * mode in a later pass, we will allocate the space then, and will
;;;856       * possibly overrun the max_memory_to_use setting.
;;;857       */
;;;858      if (cinfo->dither_mode == JDITHER_FS)
000068  f8940058          LDRB     r0,[r4,#0x58]
00006c  2802              CMP      r0,#2
00006e  d104              BNE      |L8.122|
;;;859        alloc_fs_workspace(cinfo);
000070  4620              MOV      r0,r4
000072  e8bd4010          POP      {r4,lr}
000076  f7ffbffe          B.W      alloc_fs_workspace
                  |L8.122|
;;;860    }
00007a  bd10              POP      {r4,pc}
;;;861    
                          ENDP

                  |L8.124|
                          DCD      start_pass_1_quant
                  |L8.128|
                          DCD      finish_pass_1_quant
                  |L8.132|
                          DCD      new_color_map_1_quant

                          AREA ||i.largest_input_value||, CODE, READONLY, ALIGN=1

                  largest_input_value PROC
;;;260    LOCAL(int)
;;;261    largest_input_value (j_decompress_ptr cinfo, int ci, int j, int maxj)
000000  2001              MOVS     r0,#1
;;;262    /* Return largest input value that should map to j'th output value */
;;;263    /* Must have largest(j=0) >= 0, and largest(j=maxj) >= MAXJSAMPLE */
;;;264    {
;;;265      GUI_USE_PARA(cinfo);
;;;266      GUI_USE_PARA(ci);
;;;267      /* Breakpoints are halfway between values returned by output_value */
;;;268      return (int) (((INT32) (2*j + 1) * MAXJSAMPLE + maxj) / (2*maxj));
000002  eb000042          ADD      r0,r0,r2,LSL #1
000006  ebc02000          RSB      r0,r0,r0,LSL #8
00000a  4418              ADD      r0,r0,r3
00000c  0059              LSLS     r1,r3,#1
00000e  fb90f0f1          SDIV     r0,r0,r1
;;;269    }
000012  4770              BX       lr
;;;270    
                          ENDP


                          AREA ||i.new_color_map_1_quant||, CODE, READONLY, ALIGN=1

                  new_color_map_1_quant PROC
;;;815    METHODDEF(void)
;;;816    new_color_map_1_quant (j_decompress_ptr cinfo)
000000  6802              LDR      r2,[r0,#0]
;;;817    {
;;;818      ERREXIT(cinfo, JERR_MODE_CHANGE);
000002  212e              MOVS     r1,#0x2e
000004  6151              STR      r1,[r2,#0x14]
000006  6801              LDR      r1,[r0,#0]
000008  6809              LDR      r1,[r1,#0]
00000a  4708              BX       r1
;;;819    }
;;;820    
                          ENDP


                          AREA ||i.quantize3_ord_dither||, CODE, READONLY, ALIGN=2

                  quantize3_ord_dither PROC
;;;568    METHODDEF(void)
;;;569    quantize3_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;570    		      JSAMPARRAY output_buf, int num_rows)
;;;571    /* Fast path for out_color_components==3, with ordered dithering */
;;;572    {
;;;573      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
;;;574      register int pixcode;
;;;575      register JSAMPROW input_ptr;
;;;576      register JSAMPROW output_ptr;
;;;577      JSAMPROW colorindex0 = cquantize->colorindex[0];
000004  f8d011cc          LDR      r1,[r0,#0x1cc]
000008  b083              SUB      sp,sp,#0xc            ;572
;;;578      JSAMPROW colorindex1 = cquantize->colorindex[1];
;;;579      JSAMPROW colorindex2 = cquantize->colorindex[2];
;;;580      int * dither0;		/* points to active row of dither matrix */
;;;581      int * dither1;
;;;582      int * dither2;
;;;583      int row_index, col_index;	/* current indexes into dither matrix */
;;;584      int row;
;;;585      JDIMENSION col;
;;;586      JDIMENSION width = cinfo->output_width;
;;;587    
;;;588      for (row = 0; row < num_rows; row++) {
00000a  2400              MOVS     r4,#0
00000c  698a              LDR      r2,[r1,#0x18]         ;577
00000e  6813              LDR      r3,[r2,#0]            ;577
000010  9302              STR      r3,[sp,#8]            ;578
000012  6853              LDR      r3,[r2,#4]            ;578
000014  9301              STR      r3,[sp,#4]            ;579
000016  f8d2e008          LDR      lr,[r2,#8]            ;586
00001a  6f00              LDR      r0,[r0,#0x70]         ;586
00001c  9000              STR      r0,[sp,#0]            ;572
00001e  e039              B        |L11.148|
                  |L11.32|
;;;589        row_index = cquantize->row_index;
;;;590        input_ptr = input_buf[row];
;;;591        output_ptr = output_buf[row];
000020  9a05              LDR      r2,[sp,#0x14]
000022  6b0d              LDR      r5,[r1,#0x30]         ;590
000024  9804              LDR      r0,[sp,#0x10]         ;590
000026  f8526024          LDR      r6,[r2,r4,LSL #2]
;;;592        dither0 = cquantize->odither[0][row_index];
00002a  6b4a              LDR      r2,[r1,#0x34]
00002c  f8500024          LDR      r0,[r0,r4,LSL #2]     ;590
000030  eb021b85          ADD      r11,r2,r5,LSL #6
;;;593        dither1 = cquantize->odither[1][row_index];
000034  6b8a              LDR      r2,[r1,#0x38]
;;;594        dither2 = cquantize->odither[2][row_index];
;;;595        col_index = 0;
;;;596    
;;;597        for (col = width; col > 0; col--) {
000036  9b00              LDR      r3,[sp,#0]
000038  eb021a85          ADD      r10,r2,r5,LSL #6      ;593
00003c  6bca              LDR      r2,[r1,#0x3c]         ;594
00003e  eb021985          ADD      r9,r2,r5,LSL #6       ;594
000042  2200              MOVS     r2,#0                 ;595
000044  b30b              CBZ      r3,|L11.138|
;;;598          pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*input_ptr++) +
000046  bf00              NOP      
                  |L11.72|
000048  f810cb01          LDRB     r12,[r0],#1
00004c  f85b7022          LDR      r7,[r11,r2,LSL #2]
;;;599    					dither0[col_index]]);
;;;600          pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*input_ptr++) +
000050  f8108b01          LDRB     r8,[r0],#1
000054  44bc              ADD      r12,r12,r7            ;598
000056  9f02              LDR      r7,[sp,#8]            ;598
000058  f817700c          LDRB     r7,[r7,r12]           ;598
00005c  f85ac022          LDR      r12,[r10,r2,LSL #2]
000060  44e0              ADD      r8,r8,r12
000062  f8ddc004          LDR      r12,[sp,#4]
000066  f81cc008          LDRB     r12,[r12,r8]
;;;601    					dither1[col_index]]);
;;;602          pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*input_ptr++) +
00006a  f8108b01          LDRB     r8,[r0],#1
00006e  4467              ADD      r7,r7,r12             ;600
000070  f859c022          LDR      r12,[r9,r2,LSL #2]
;;;603    					dither2[col_index]]);
;;;604          *output_ptr++ = (JSAMPLE) pixcode;
000074  1c52              ADDS     r2,r2,#1
000076  44e0              ADD      r8,r8,r12             ;602
;;;605          col_index = (col_index + 1) & ODITHER_MASK;
000078  f002020f          AND      r2,r2,#0xf
00007c  f81ec008          LDRB     r12,[lr,r8]           ;602
000080  1e5b              SUBS     r3,r3,#1
000082  4467              ADD      r7,r7,r12             ;602
000084  f8067b01          STRB     r7,[r6],#1            ;604
000088  d1de              BNE      |L11.72|
                  |L11.138|
00008a  1c6d              ADDS     r5,r5,#1              ;597
;;;606        }
;;;607        row_index = (row_index + 1) & ODITHER_MASK;
00008c  f005000f          AND      r0,r5,#0xf
;;;608        cquantize->row_index = row_index;
000090  1c64              ADDS     r4,r4,#1
000092  6308              STR      r0,[r1,#0x30]
                  |L11.148|
000094  9806              LDR      r0,[sp,#0x18]         ;588
000096  4284              CMP      r4,r0                 ;588
000098  dbc2              BLT      |L11.32|
;;;609      }
;;;610    }
00009a  b007              ADD      sp,sp,#0x1c
00009c  e8bd8ff0          POP      {r4-r11,pc}
;;;611    
                          ENDP


                          AREA ||i.quantize_fs_dither||, CODE, READONLY, ALIGN=2

                  quantize_fs_dither PROC
;;;613    METHODDEF(void)
;;;614    quantize_fs_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;615    		    JSAMPARRAY output_buf, int num_rows)
;;;616    /* General case, with Floyd-Steinberg dithering */
;;;617    {
000004  b085              SUB      sp,sp,#0x14
;;;618      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
;;;619      register LOCFSERROR cur;	/* current error or pixel value */
;;;620      LOCFSERROR belowerr;		/* error for pixel below cur */
;;;621      LOCFSERROR bpreverr;		/* error for below/prev col */
;;;622      LOCFSERROR bnexterr;		/* error for below/next col */
;;;623      LOCFSERROR delta;
;;;624      register FSERRPTR errorptr;	/* => fserrors[] at column before current */
;;;625      register JSAMPROW input_ptr;
;;;626      register JSAMPROW output_ptr;
;;;627      JSAMPROW colorindex_ci;
;;;628      JSAMPROW colormap_ci;
;;;629      int pixcode;
;;;630      int nc = cinfo->out_color_components;
000006  f8d0a1cc          LDR      r10,[r0,#0x1cc]
00000a  6f81              LDR      r1,[r0,#0x78]
;;;631      int dir;			/* 1 for left-to-right, -1 for right-to-left */
;;;632      int dirnc;			/* dir * nc */
;;;633      int ci;
;;;634      int row;
;;;635      JDIMENSION col;
;;;636      JDIMENSION width = cinfo->output_width;
00000c  9101              STR      r1,[sp,#4]
00000e  6f01              LDR      r1,[r0,#0x70]
;;;637      JSAMPLE *range_limit = cinfo->sample_range_limit;
000010  9100              STR      r1,[sp,#0]
000012  f8d00144          LDR      r0,[r0,#0x144]
;;;638      SHIFT_TEMPS
;;;639    
;;;640      for (row = 0; row < num_rows; row++) {
000016  9004              STR      r0,[sp,#0x10]
000018  2000              MOVS     r0,#0
                  |L12.26|
00001a  9908              LDR      r1,[sp,#0x20]
00001c  4683              MOV      r11,r0
00001e  4288              CMP      r0,r1
000020  da7a              BGE      |L12.280|
;;;641        /* Initialize output values to 0 so can process components separately */
;;;642        jzero_far((void FAR *) output_buf[row],
000022  9807              LDR      r0,[sp,#0x1c]
000024  9900              LDR      r1,[sp,#0]
000026  f850002b          LDR      r0,[r0,r11,LSL #2]
00002a  f7fffffe          BL       jzero_far
;;;643    	      (size_t) (width * SIZEOF(JSAMPLE)));
;;;644        for (ci = 0; ci < nc; ci++) {
00002e  2000              MOVS     r0,#0
000030  e062              B        |L12.248|
                  |L12.50|
;;;645          input_ptr = input_buf[row] + ci;
000032  9906              LDR      r1,[sp,#0x18]
;;;646          output_ptr = output_buf[row];
;;;647          if (cquantize->on_odd_row) {
000034  f8da2054          LDR      r2,[r10,#0x54]
000038  f851102b          LDR      r1,[r1,r11,LSL #2]    ;645
00003c  180d              ADDS     r5,r1,r0              ;645
00003e  9907              LDR      r1,[sp,#0x1c]         ;646
000040  f851102b          LDR      r1,[r1,r11,LSL #2]    ;646
000044  b1a2              CBZ      r2,|L12.112|
;;;648    	/* work right to left in this row */
;;;649    	input_ptr += (width-1) * nc; /* so point to rightmost pixel */
000046  e9dd2300          LDRD     r2,r3,[sp,#0]
00004a  1e52              SUBS     r2,r2,#1
00004c  fb025503          MLA      r5,r2,r3,r5
;;;650    	output_ptr += width-1;
000050  9a00              LDR      r2,[sp,#0]
;;;651    	dir = -1;
;;;652    	dirnc = -nc;
000052  f1c30e00          RSB      lr,r3,#0
000056  4411              ADD      r1,r1,r2              ;650
;;;653    	errorptr = cquantize->fserrors[ci] + (width+1); /* => entry after last column */
000058  eb0a0280          ADD      r2,r10,r0,LSL #2
00005c  2402              MOVS     r4,#2
00005e  6c53              LDR      r3,[r2,#0x44]
000060  9a00              LDR      r2,[sp,#0]
000062  f04f37ff          MOV      r7,#0xffffffff        ;651
000066  eb040242          ADD      r2,r4,r2,LSL #1
00006a  441a              ADD      r2,r2,r3
00006c  1e49              SUBS     r1,r1,#1
00006e  e005              B        |L12.124|
                  |L12.112|
;;;654          } else {
;;;655    	/* work left to right in this row */
;;;656    	dir = 1;
;;;657    	dirnc = nc;
;;;658    	errorptr = cquantize->fserrors[ci]; /* => entry before first column */
000070  eb0a0280          ADD      r2,r10,r0,LSL #2
000074  f8dde004          LDR      lr,[sp,#4]
000078  6c52              LDR      r2,[r2,#0x44]
00007a  2701              MOVS     r7,#1                 ;656
                  |L12.124|
;;;659          }
;;;660          colorindex_ci = cquantize->colorindex[ci];
00007c  f8da3018          LDR      r3,[r10,#0x18]
;;;661          colormap_ci = cquantize->sv_colormap[ci];
;;;662          /* Preset error values: no error propagated to first pixel from left */
;;;663          cur = 0;
;;;664          /* and no error propagated to row below yet */
;;;665          belowerr = bpreverr = 0;
;;;666    
;;;667          for (col = width; col > 0; col--) {
000080  9c00              LDR      r4,[sp,#0]
000082  f8533020          LDR      r3,[r3,r0,LSL #2]     ;660
000086  9303              STR      r3,[sp,#0xc]          ;661
000088  f8da3010          LDR      r3,[r10,#0x10]        ;661
00008c  f8533020          LDR      r3,[r3,r0,LSL #2]     ;661
000090  9302              STR      r3,[sp,#8]            ;663
000092  2300              MOVS     r3,#0                 ;663
000094  461e              MOV      r6,r3                 ;665
000096  46b1              MOV      r9,r6                 ;665
000098  b364              CBZ      r4,|L12.244|
;;;668    	/* cur holds the error propagated from the previous pixel on the
;;;669    	 * current line.  Add the error propagated from the previous line
;;;670    	 * to form the complete error correction term for this pixel, and
;;;671    	 * round the error term (which is expressed * 16) to an integer.
;;;672    	 * RIGHT_SHIFT rounds towards minus infinity, so adding 8 is correct
;;;673    	 * for either sign of the error value.
;;;674    	 * Note: errorptr points to *previous* column's array entry.
;;;675    	 */
;;;676    	cur = RIGHT_SHIFT(cur + errorptr[dir] + 8, 4);
00009a  bf00              NOP      
                  |L12.156|
00009c  f932c017          LDRSH    r12,[r2,r7,LSL #1]
0000a0  3308              ADDS     r3,r3,#8
0000a2  4463              ADD      r3,r3,r12
;;;677    	/* Form pixel value + error, and range-limit to 0..MAXJSAMPLE.
;;;678    	 * The maximum error is +- MAXJSAMPLE; this sets the required size
;;;679    	 * of the range_limit array.
;;;680    	 */
;;;681    	cur += GETJSAMPLE(*input_ptr);
0000a4  f895c000          LDRB     r12,[r5,#0]
;;;682    	cur = GETJSAMPLE(range_limit[cur]);
;;;683    	/* Select output value, accumulate into output code for this pixel */
;;;684    	pixcode = GETJSAMPLE(colorindex_ci[cur]);
;;;685    	*output_ptr += (JSAMPLE) pixcode;
0000a8  f8918000          LDRB     r8,[r1,#0]
0000ac  eb0c1323          ADD      r3,r12,r3,ASR #4      ;681
0000b0  f8ddc010          LDR      r12,[sp,#0x10]        ;682
;;;686    	/* Compute actual representation error at this pixel */
;;;687    	/* Note: we can do this even though we don't have the final */
;;;688    	/* pixel code, because the colormap is orthogonal. */
;;;689    	cur -= GETJSAMPLE(colormap_ci[pixcode]);
;;;690    	/* Compute error fractions to be propagated to adjacent pixels.
;;;691    	 * Add these into the running sums, and simultaneously shift the
;;;692    	 * next-line error sums left by 1 column.
;;;693    	 */
;;;694    	bnexterr = cur;
;;;695    	delta = cur * 2;
;;;696    	cur += delta;		/* form error * 3 */
;;;697    	errorptr[0] = (FSERROR) (bpreverr + cur);
;;;698    	cur += delta;		/* form error * 5 */
;;;699    	bpreverr = belowerr + cur;
;;;700    	belowerr = bnexterr;
;;;701    	cur += delta;		/* form error * 7 */
;;;702    	/* At this point cur contains the 7/16 error value to be propagated
;;;703    	 * to the next pixel on the current line, and all the errors for the
;;;704    	 * next line have been shifted over. We are therefore ready to move on.
;;;705    	 */
;;;706    	input_ptr += dirnc;	/* advance input ptr to next column */
0000b4  4475              ADD      r5,r5,lr
;;;707    	output_ptr += dir;	/* advance output ptr to next column */
;;;708    	errorptr += dir;	/* advance errorptr to current column */
0000b6  1e64              SUBS     r4,r4,#1
0000b8  f81cc003          LDRB     r12,[r12,r3]          ;682
0000bc  9b03              LDR      r3,[sp,#0xc]          ;684
0000be  f813300c          LDRB     r3,[r3,r12]           ;684
0000c2  4498              ADD      r8,r8,r3              ;685
0000c4  f8818000          STRB     r8,[r1,#0]            ;685
0000c8  f8dd8008          LDR      r8,[sp,#8]            ;689
0000cc  4439              ADD      r1,r1,r7              ;707
0000ce  f8183003          LDRB     r3,[r8,r3]            ;689
0000d2  ebac0303          SUB      r3,r12,r3             ;689
0000d6  ea4f0c43          LSL      r12,r3,#1             ;695
0000da  eb03080c          ADD      r8,r3,r12             ;696
0000de  4446              ADD      r6,r6,r8              ;697
0000e0  8016              STRH     r6,[r2,#0]            ;697
0000e2  44e0              ADD      r8,r8,r12             ;698
0000e4  eb090608          ADD      r6,r9,r8              ;699
0000e8  4699              MOV      r9,r3                 ;700
0000ea  eb08030c          ADD      r3,r8,r12             ;701
0000ee  eb020247          ADD      r2,r2,r7,LSL #1
0000f2  d1d3              BNE      |L12.156|
                  |L12.244|
;;;709          }
;;;710          /* Post-loop cleanup: we must unload the final error value into the
;;;711           * final fserrors[] entry.  Note we need not unload belowerr because
;;;712           * it is for the dummy column before or after the actual array.
;;;713           */
;;;714          errorptr[0] = (FSERROR) bpreverr; /* unload prev err into array */
0000f4  8016              STRH     r6,[r2,#0]
0000f6  1c40              ADDS     r0,r0,#1
                  |L12.248|
0000f8  9901              LDR      r1,[sp,#4]            ;644
0000fa  4288              CMP      r0,r1                 ;644
0000fc  db99              BLT      |L12.50|
;;;715        }
;;;716        cquantize->on_odd_row = (cquantize->on_odd_row ? FALSE : TRUE);
0000fe  f8da0054          LDR      r0,[r10,#0x54]
000102  b138              CBZ      r0,|L12.276|
000104  f05f0100          MOVS.W   r1,#0
                  |L12.264|
000108  f10b0001          ADD      r0,r11,#1             ;640
00010c  f8ca1054          STR      r1,[r10,#0x54]        ;640
000110  e783              B        |L12.26|
000112  e001              B        |L12.280|
                  |L12.276|
000114  2101              MOVS     r1,#1
000116  e7f7              B        |L12.264|
                  |L12.280|
;;;717      }
;;;718    }
000118  b009              ADD      sp,sp,#0x24
00011a  e8bd8ff0          POP      {r4-r11,pc}
;;;719    
                          ENDP


                          AREA ||i.quantize_ord_dither||, CODE, READONLY, ALIGN=1

                  quantize_ord_dither PROC
;;;518    METHODDEF(void)
;;;519    quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;520    		     JSAMPARRAY output_buf, int num_rows)
;;;521    /* General case, with ordered dithering */
;;;522    {
000004  b081              SUB      sp,sp,#4
;;;523      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
;;;524      register JSAMPROW input_ptr;
;;;525      register JSAMPROW output_ptr;
;;;526      JSAMPROW colorindex_ci;
;;;527      int * dither;			/* points to active row of dither matrix */
;;;528      int row_index, col_index;	/* current indexes into dither matrix */
;;;529      int nc = cinfo->out_color_components;
;;;530      int ci;
;;;531      int row;
;;;532      JDIMENSION col;
;;;533      JDIMENSION width = cinfo->output_width;
000006  6f86              LDR      r6,[r0,#0x78]
000008  f8d051cc          LDR      r5,[r0,#0x1cc]
00000c  6f00              LDR      r0,[r0,#0x70]
;;;534    
;;;535      for (row = 0; row < num_rows; row++) {
00000e  2400              MOVS     r4,#0
000010  9000              STR      r0,[sp,#0]            ;522
000012  e036              B        |L13.130|
                  |L13.20|
;;;536        /* Initialize output values to 0 so can process components separately */
;;;537        jzero_far((void FAR *) output_buf[row],
000014  9803              LDR      r0,[sp,#0xc]
000016  9900              LDR      r1,[sp,#0]
000018  f8500024          LDR      r0,[r0,r4,LSL #2]
00001c  f7fffffe          BL       jzero_far
;;;538    	      (size_t) (width * SIZEOF(JSAMPLE)));
;;;539        row_index = cquantize->row_index;
;;;540        for (ci = 0; ci < nc; ci++) {
000020  2000              MOVS     r0,#0
000022  f8d5b030          LDR      r11,[r5,#0x30]
000026  e024              B        |L13.114|
                  |L13.40|
;;;541          input_ptr = input_buf[row] + ci;
000028  9902              LDR      r1,[sp,#8]
00002a  f8511024          LDR      r1,[r1,r4,LSL #2]
00002e  180f              ADDS     r7,r1,r0
;;;542          output_ptr = output_buf[row];
000030  9903              LDR      r1,[sp,#0xc]
000032  f8513024          LDR      r3,[r1,r4,LSL #2]
;;;543          colorindex_ci = cquantize->colorindex[ci];
000036  69a9              LDR      r1,[r5,#0x18]
000038  f851a020          LDR      r10,[r1,r0,LSL #2]
;;;544          dither = cquantize->odither[ci][row_index];
00003c  eb050180          ADD      r1,r5,r0,LSL #2
000040  6b4a              LDR      r2,[r1,#0x34]
;;;545          col_index = 0;
;;;546    
;;;547          for (col = width; col > 0; col--) {
000042  9900              LDR      r1,[sp,#0]
000044  eb02198b          ADD      r9,r2,r11,LSL #6      ;544
000048  2200              MOVS     r2,#0                 ;545
00004a  b189              CBZ      r1,|L13.112|
                  |L13.76|
;;;548    	/* Form pixel value + dither, range-limit to 0..MAXJSAMPLE,
;;;549    	 * select output value, accumulate into output code for this pixel.
;;;550    	 * Range-limiting need not be done explicitly, as we have extended
;;;551    	 * the colorindex table to produce the right answers for out-of-range
;;;552    	 * inputs.  The maximum dither is +- MAXJSAMPLE; this sets the
;;;553    	 * required amount of padding.
;;;554    	 */
;;;555    	*output_ptr += colorindex_ci[GETJSAMPLE(*input_ptr)+dither[col_index]];
00004c  f8978000          LDRB     r8,[r7,#0]
000050  f859c022          LDR      r12,[r9,r2,LSL #2]
;;;556    	input_ptr += nc;
000054  1c52              ADDS     r2,r2,#1
000056  44e0              ADD      r8,r8,r12             ;555
000058  4437              ADD      r7,r7,r6
00005a  f81ac008          LDRB     r12,[r10,r8]          ;555
00005e  f8938000          LDRB     r8,[r3,#0]            ;555
;;;557    	output_ptr++;
;;;558    	col_index = (col_index + 1) & ODITHER_MASK;
000062  f002020f          AND      r2,r2,#0xf
000066  44c4              ADD      r12,r12,r8            ;555
000068  f803cb01          STRB     r12,[r3],#1           ;555
00006c  1e49              SUBS     r1,r1,#1
00006e  d1ed              BNE      |L13.76|
                  |L13.112|
000070  1c40              ADDS     r0,r0,#1              ;547
                  |L13.114|
000072  42b0              CMP      r0,r6                 ;540
000074  dbd8              BLT      |L13.40|
;;;559          }
;;;560        }
;;;561        /* Advance row index for next row */
;;;562        row_index = (row_index + 1) & ODITHER_MASK;
000076  f10b0001          ADD      r0,r11,#1
00007a  f000000f          AND      r0,r0,#0xf
;;;563        cquantize->row_index = row_index;
00007e  1c64              ADDS     r4,r4,#1
000080  6328              STR      r0,[r5,#0x30]
                  |L13.130|
000082  9804              LDR      r0,[sp,#0x10]         ;535
000084  4284              CMP      r4,r0                 ;535
000086  dbc5              BLT      |L13.20|
;;;564      }
;;;565    }
000088  b005              ADD      sp,sp,#0x14
00008a  e8bd8ff0          POP      {r4-r11,pc}
;;;566    
                          ENDP


                          AREA ||i.select_ncolors||, CODE, READONLY, ALIGN=2

                  select_ncolors PROC
;;;185    LOCAL(int)
;;;186    select_ncolors (j_decompress_ptr cinfo, int Ncolors[])
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;187    /* Determine allocation of desired colors to components, */
;;;188    /* and fill in Ncolors[] array to indicate choice. */
;;;189    /* Return value is total number of colors (product of Ncolors[] values). */
;;;190    {
;;;191      int nc = cinfo->out_color_components; /* number of color components */
;;;192      int max_colors = cinfo->desired_number_of_colors;
;;;193      int total_colors, iroot, i, j;
;;;194      boolean changed;
;;;195      long temp;
;;;196      static const int RGB_order[3] = { RGB_GREEN, RGB_RED, RGB_BLUE };
;;;197    
;;;198      /* We can allocate at least the nc'th root of max_colors per component. */
;;;199      /* Compute floor(nc'th root of max_colors). */
;;;200      iroot = 1;
000004  6e07              LDR      r7,[r0,#0x60]
000006  6f86              LDR      r6,[r0,#0x78]
000008  4689              MOV      r9,r1                 ;190
00000a  4605              MOV      r5,r0                 ;190
00000c  2401              MOVS     r4,#1
                  |L14.14|
00000e  1c64              ADDS     r4,r4,#1
;;;201      do {
;;;202        iroot++;
;;;203        temp = iroot;		/* set temp = iroot ** nc */
000010  4620              MOV      r0,r4
;;;204        for (i = 1; i < nc; i++)
000012  2101              MOVS     r1,#1
000014  e001              B        |L14.26|
                  |L14.22|
;;;205          temp *= iroot;
000016  4360              MULS     r0,r4,r0
000018  1c49              ADDS     r1,r1,#1
                  |L14.26|
00001a  42b1              CMP      r1,r6                 ;204
00001c  dbfb              BLT      |L14.22|
;;;206      } while (temp <= (long) max_colors); /* repeat till iroot exceeds root */
00001e  42b8              CMP      r0,r7
000020  ddf5              BLE      |L14.14|
000022  1e64              SUBS     r4,r4,#1
;;;207      iroot--;			/* now iroot = floor(root) */
;;;208    
;;;209      /* Must have at least 2 color values per component */
;;;210      if (iroot < 2)
000024  2c02              CMP      r4,#2
000026  da08              BGE      |L14.58|
;;;211        ERREXIT1(cinfo, JERR_QUANT_FEW_COLORS, (int) temp);
000028  682a              LDR      r2,[r5,#0]
00002a  2138              MOVS     r1,#0x38
00002c  6151              STR      r1,[r2,#0x14]
00002e  6829              LDR      r1,[r5,#0]
000030  6188              STR      r0,[r1,#0x18]
000032  6828              LDR      r0,[r5,#0]
000034  6801              LDR      r1,[r0,#0]
000036  4628              MOV      r0,r5
000038  4788              BLX      r1
                  |L14.58|
;;;212    
;;;213      /* Initialize to iroot color values for each component */
;;;214      total_colors = 1;
00003a  2001              MOVS     r0,#1
;;;215      for (i = 0; i < nc; i++) {
00003c  2100              MOVS     r1,#0
00003e  e003              B        |L14.72|
                  |L14.64|
;;;216        Ncolors[i] = iroot;
000040  f8494021          STR      r4,[r9,r1,LSL #2]
;;;217        total_colors *= iroot;
000044  4360              MULS     r0,r4,r0
000046  1c49              ADDS     r1,r1,#1
                  |L14.72|
000048  42b1              CMP      r1,r6                 ;215
00004a  dbf9              BLT      |L14.64|
;;;218      }
;;;219      /* We may be able to increment the count for one or more components without
;;;220       * exceeding max_colors, though we know not all can be incremented.
;;;221       * Sometimes, the first component can be incremented more than once!
;;;222       * (Example: for 16 colors, we start at 2*2*2, go to 3*2*2, then 4*2*2.)
;;;223       * In RGB colorspace, try to increment G first, then R, then B.
;;;224       */
;;;225      do {
;;;226        changed = FALSE;
;;;227        for (i = 0; i < nc; i++) {
;;;228          j = (cinfo->out_color_space == JCS_RGB ? RGB_order[i] : i);
00004c  f8dfa044          LDR      r10,|L14.148|
                  |L14.80|
000050  2400              MOVS     r4,#0                 ;226
000052  4622              MOV      r2,r4                 ;227
000054  e015              B        |L14.130|
000056  bf00              NOP      
                  |L14.88|
000058  f8951029          LDRB     r1,[r5,#0x29]
00005c  2902              CMP      r1,#2
00005e  d016              BEQ      |L14.142|
000060  ea4f0302          MOV.W    r3,r2
                  |L14.100|
;;;229          /* calculate new total_colors if Ncolors[j] is incremented */
;;;230          temp = total_colors / Ncolors[j];
000064  f8591023          LDR      r1,[r9,r3,LSL #2]
000068  fb90fcf1          SDIV     r12,r0,r1
00006c  f1010801          ADD      r8,r1,#1
;;;231          temp *= Ncolors[j]+1;	/* done in long arith to avoid oflo */
000070  fb08f10c          MUL      r1,r8,r12
;;;232          if (temp > (long) max_colors)
000074  42b9              CMP      r1,r7
000076  dc06              BGT      |L14.134|
;;;233    	break;			/* won't fit, done with this pass */
;;;234          Ncolors[j]++;		/* OK, apply the increment */
;;;235          total_colors = (int) temp;
;;;236          changed = TRUE;
000078  2401              MOVS     r4,#1
00007a  f8498023          STR      r8,[r9,r3,LSL #2]     ;234
00007e  4608              MOV      r0,r1                 ;235
000080  1c52              ADDS     r2,r2,#1
                  |L14.130|
000082  42b2              CMP      r2,r6                 ;227
000084  dbe8              BLT      |L14.88|
                  |L14.134|
;;;237        }
;;;238      } while (changed);
000086  2c00              CMP      r4,#0
000088  d1e2              BNE      |L14.80|
;;;239    
;;;240      return total_colors;
;;;241    }
00008a  e8bd87f0          POP      {r4-r10,pc}
                  |L14.142|
00008e  f85a3022          LDR      r3,[r10,r2,LSL #2]    ;228
000092  e7e7              B        |L14.100|
;;;242    
                          ENDP

                  |L14.148|
                          DCD      ||.constdata||+0x100

                          AREA ||i.start_pass_1_quant||, CODE, READONLY, ALIGN=2

                  start_pass_1_quant PROC
;;;744    METHODDEF(void)
;;;745    start_pass_1_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;746    {
;;;747      my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
;;;748      size_t arraysize;
;;;749      int i;
;;;750    
;;;751      GUI_USE_PARA(is_pre_scan);
;;;752      /* Install my colormap. */
;;;753      cinfo->colormap = cquantize->sv_colormap;
000004  f8d041cc          LDR      r4,[r0,#0x1cc]
000008  4605              MOV      r5,r0                 ;746
00000a  6920              LDR      r0,[r4,#0x10]
;;;754      cinfo->actual_number_of_colors = cquantize->sv_actual;
00000c  f8c50088          STR      r0,[r5,#0x88]
000010  6960              LDR      r0,[r4,#0x14]
;;;755    
;;;756      /* Initialize for desired dithering mode. */
;;;757      switch (cinfo->dither_mode) {
000012  f8c50084          STR      r0,[r5,#0x84]
000016  f8951058          LDRB     r1,[r5,#0x58]
00001a  b169              CBZ      r1,|L15.56|
00001c  2000              MOVS     r0,#0                 ;746
00001e  2901              CMP      r1,#1
000020  d013              BEQ      |L15.74|
000022  2902              CMP      r1,#2
000024  d027              BEQ      |L15.118|
;;;758      case JDITHER_NONE:
;;;759        if (cinfo->out_color_components == 3)
;;;760          cquantize->pub.color_quantize = color_quantize3;
;;;761        else
;;;762          cquantize->pub.color_quantize = color_quantize;
;;;763        break;
;;;764      case JDITHER_ORDERED:
;;;765        if (cinfo->out_color_components == 3)
;;;766          cquantize->pub.color_quantize = quantize3_ord_dither;
;;;767        else
;;;768          cquantize->pub.color_quantize = quantize_ord_dither;
;;;769        cquantize->row_index = 0;	/* initialize state for ordered dither */
;;;770        /* If user changed to ordered dither from another mode,
;;;771         * we must recreate the color index table with padding.
;;;772         * This will cost extra space, but probably isn't very likely.
;;;773         */
;;;774        if (! cquantize->is_padded)
;;;775          create_colorindex(cinfo);
;;;776        /* Create ordered-dither tables if we didn't already. */
;;;777        if (cquantize->odither[0] == NULL)
;;;778          create_odither_tables(cinfo);
;;;779        break;
;;;780      case JDITHER_FS:
;;;781        cquantize->pub.color_quantize = quantize_fs_dither;
;;;782        cquantize->on_odd_row = FALSE; /* initialize state for F-S dither */
;;;783        /* Allocate Floyd-Steinberg workspace if didn't already. */
;;;784        if (cquantize->fserrors[0] == NULL)
;;;785          alloc_fs_workspace(cinfo);
;;;786        /* Initialize the propagated errors to zero. */
;;;787        arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
;;;788        for (i = 0; i < cinfo->out_color_components; i++)
;;;789          jzero_far((void FAR *) cquantize->fserrors[i], arraysize);
;;;790        break;
;;;791      default:
;;;792        ERREXIT(cinfo, JERR_NOT_COMPILED);
000026  6829              LDR      r1,[r5,#0]
000028  2030              MOVS     r0,#0x30
00002a  6148              STR      r0,[r1,#0x14]
00002c  6828              LDR      r0,[r5,#0]
00002e  6801              LDR      r1,[r0,#0]
000030  4628              MOV      r0,r5
000032  e8bd41f0          POP      {r4-r8,lr}
000036  4708              BX       r1
                  |L15.56|
000038  6fa8              LDR      r0,[r5,#0x78]         ;759
00003a  2803              CMP      r0,#3                 ;759
00003c  d003              BEQ      |L15.70|
00003e  481a              LDR      r0,|L15.168|
                  |L15.64|
000040  6060              STR      r0,[r4,#4]            ;762
                  |L15.66|
;;;793        break;
;;;794      }
;;;795    }
000042  e8bd81f0          POP      {r4-r8,pc}
                  |L15.70|
000046  4819              LDR      r0,|L15.172|
000048  e7fa              B        |L15.64|
                  |L15.74|
00004a  6fa9              LDR      r1,[r5,#0x78]         ;765
00004c  2903              CMP      r1,#3                 ;765
00004e  d005              BEQ      |L15.92|
000050  4917              LDR      r1,|L15.176|
                  |L15.82|
000052  6061              STR      r1,[r4,#4]            ;774
000054  6320              STR      r0,[r4,#0x30]         ;774
000056  69e0              LDR      r0,[r4,#0x1c]         ;774
000058  b110              CBZ      r0,|L15.96|
00005a  e004              B        |L15.102|
                  |L15.92|
00005c  4915              LDR      r1,|L15.180|
00005e  e7f8              B        |L15.82|
                  |L15.96|
000060  4628              MOV      r0,r5                 ;775
000062  f7fffffe          BL       create_colorindex
                  |L15.102|
000066  6b60              LDR      r0,[r4,#0x34]         ;777
000068  2800              CMP      r0,#0                 ;777
00006a  d1ea              BNE      |L15.66|
00006c  4628              MOV      r0,r5                 ;778
00006e  e8bd41f0          POP      {r4-r8,lr}            ;778
000072  f7ffbffe          B.W      create_odither_tables
                  |L15.118|
000076  4910              LDR      r1,|L15.184|
000078  6061              STR      r1,[r4,#4]            ;784
00007a  6560              STR      r0,[r4,#0x54]         ;784
00007c  6c60              LDR      r0,[r4,#0x44]         ;784
00007e  b910              CBNZ     r0,|L15.134|
000080  4628              MOV      r0,r5                 ;785
000082  f7fffffe          BL       alloc_fs_workspace
                  |L15.134|
000086  6f28              LDR      r0,[r5,#0x70]         ;787
000088  2600              MOVS     r6,#0                 ;788
00008a  0047              LSLS     r7,r0,#1              ;787
00008c  1d3f              ADDS     r7,r7,#4              ;788
00008e  e006              B        |L15.158|
                  |L15.144|
000090  eb040086          ADD      r0,r4,r6,LSL #2       ;789
000094  4639              MOV      r1,r7                 ;789
000096  6c40              LDR      r0,[r0,#0x44]         ;789
000098  f7fffffe          BL       jzero_far
00009c  1c76              ADDS     r6,r6,#1              ;789
                  |L15.158|
00009e  6fa8              LDR      r0,[r5,#0x78]         ;788
0000a0  42b0              CMP      r0,r6                 ;788
0000a2  dcf5              BGT      |L15.144|
0000a4  e7cd              B        |L15.66|
;;;796    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L15.168|
                          DCD      color_quantize
                  |L15.172|
                          DCD      color_quantize3
                  |L15.176|
                          DCD      quantize_ord_dither
                  |L15.180|
                          DCD      quantize3_ord_dither
                  |L15.184|
                          DCD      quantize_fs_dither

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  base_dither_matrix
000000  00c030f0          DCB      0x00,0xc0,0x30,0xf0
000004  0ccc3cfc          DCB      0x0c,0xcc,0x3c,0xfc
000008  03c333f3          DCB      0x03,0xc3,0x33,0xf3
00000c  0fcf3fff          DCB      0x0f,0xcf,0x3f,0xff
000010  8040b070          DCB      0x80,0x40,0xb0,0x70
000014  8c4cbc7c          DCB      0x8c,0x4c,0xbc,0x7c
000018  8343b373          DCB      0x83,0x43,0xb3,0x73
00001c  8f4fbf7f          DCB      0x8f,0x4f,0xbf,0x7f
000020  20e010d0          DCB      0x20,0xe0,0x10,0xd0
000024  2cec1cdc          DCB      0x2c,0xec,0x1c,0xdc
000028  23e313d3          DCB      0x23,0xe3,0x13,0xd3
00002c  2fef1fdf          DCB      0x2f,0xef,0x1f,0xdf
000030  a0609050          DCB      0xa0,0x60,0x90,0x50
000034  ac6c9c5c          DCB      0xac,0x6c,0x9c,0x5c
000038  a3639353          DCB      0xa3,0x63,0x93,0x53
00003c  af6f9f5f          DCB      0xaf,0x6f,0x9f,0x5f
000040  08c838f8          DCB      0x08,0xc8,0x38,0xf8
000044  04c434f4          DCB      0x04,0xc4,0x34,0xf4
000048  0bcb3bfb          DCB      0x0b,0xcb,0x3b,0xfb
00004c  07c737f7          DCB      0x07,0xc7,0x37,0xf7
000050  8848b878          DCB      0x88,0x48,0xb8,0x78
000054  8444b474          DCB      0x84,0x44,0xb4,0x74
000058  8b4bbb7b          DCB      0x8b,0x4b,0xbb,0x7b
00005c  8747b777          DCB      0x87,0x47,0xb7,0x77
000060  28e818d8          DCB      0x28,0xe8,0x18,0xd8
000064  24e414d4          DCB      0x24,0xe4,0x14,0xd4
000068  2beb1bdb          DCB      0x2b,0xeb,0x1b,0xdb
00006c  27e717d7          DCB      0x27,0xe7,0x17,0xd7
000070  a8689858          DCB      0xa8,0x68,0x98,0x58
000074  a4649454          DCB      0xa4,0x64,0x94,0x54
000078  ab6b9b5b          DCB      0xab,0x6b,0x9b,0x5b
00007c  a7679757          DCB      0xa7,0x67,0x97,0x57
000080  02c232f2          DCB      0x02,0xc2,0x32,0xf2
000084  0ece3efe          DCB      0x0e,0xce,0x3e,0xfe
000088  01c131f1          DCB      0x01,0xc1,0x31,0xf1
00008c  0dcd3dfd          DCB      0x0d,0xcd,0x3d,0xfd
000090  8242b272          DCB      0x82,0x42,0xb2,0x72
000094  8e4ebe7e          DCB      0x8e,0x4e,0xbe,0x7e
000098  8141b171          DCB      0x81,0x41,0xb1,0x71
00009c  8d4dbd7d          DCB      0x8d,0x4d,0xbd,0x7d
0000a0  22e212d2          DCB      0x22,0xe2,0x12,0xd2
0000a4  2eee1ede          DCB      0x2e,0xee,0x1e,0xde
0000a8  21e111d1          DCB      0x21,0xe1,0x11,0xd1
0000ac  2ded1ddd          DCB      0x2d,0xed,0x1d,0xdd
0000b0  a2629252          DCB      0xa2,0x62,0x92,0x52
0000b4  ae6e9e5e          DCB      0xae,0x6e,0x9e,0x5e
0000b8  a1619151          DCB      0xa1,0x61,0x91,0x51
0000bc  ad6d9d5d          DCB      0xad,0x6d,0x9d,0x5d
0000c0  0aca3afa          DCB      0x0a,0xca,0x3a,0xfa
0000c4  06c636f6          DCB      0x06,0xc6,0x36,0xf6
0000c8  09c939f9          DCB      0x09,0xc9,0x39,0xf9
0000cc  05c535f5          DCB      0x05,0xc5,0x35,0xf5
0000d0  8a4aba7a          DCB      0x8a,0x4a,0xba,0x7a
0000d4  8646b676          DCB      0x86,0x46,0xb6,0x76
0000d8  8949b979          DCB      0x89,0x49,0xb9,0x79
0000dc  8545b575          DCB      0x85,0x45,0xb5,0x75
0000e0  2aea1ada          DCB      0x2a,0xea,0x1a,0xda
0000e4  26e616d6          DCB      0x26,0xe6,0x16,0xd6
0000e8  29e919d9          DCB      0x29,0xe9,0x19,0xd9
0000ec  25e515d5          DCB      0x25,0xe5,0x15,0xd5
0000f0  aa6a9a5a          DCB      0xaa,0x6a,0x9a,0x5a
0000f4  a6669656          DCB      0xa6,0x66,0x96,0x56
0000f8  a9699959          DCB      0xa9,0x69,0x99,0x59
0000fc  a5659555          DCB      0xa5,0x65,0x95,0x55
                  RGB_order
                          DCD      0x00000001
                          DCD      0x00000000
                          DCD      0x00000002
