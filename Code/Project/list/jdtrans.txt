; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\jdtrans.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\jdtrans.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\JPEG\jdtrans.c]
                          THUMB

                          AREA ||i.jpeg_read_coefficients||, CODE, READONLY, ALIGN=1

                  jpeg_read_coefficients PROC
;;;44     GLOBAL(jvirt_barray_ptr *)
;;;45     jpeg_read_coefficients (j_decompress_ptr cinfo)
000000  b510              PUSH     {r4,lr}
;;;46     {
000002  4604              MOV      r4,r0
;;;47       if (cinfo->global_state == DSTATE_READY) {
000004  6940              LDR      r0,[r0,#0x14]
000006  28ca              CMP      r0,#0xca
000008  d006              BEQ      |L1.24|
;;;48         /* First call: initialize active modules */
;;;49         transdecode_master_selection(cinfo);
;;;50         cinfo->global_state = DSTATE_RDCOEFS;
;;;51       }
;;;52       if (cinfo->global_state == DSTATE_RDCOEFS) {
00000a  28d1              CMP      r0,#0xd1
00000c  d009              BEQ      |L1.34|
;;;53         /* Absorb whole file into the coef buffer */
;;;54         while(1) {
;;;55           int retcode;
;;;56           /* Call progress monitor hook if present */
;;;57           if (cinfo->progress != NULL)
;;;58     	(*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
;;;59           /* Absorb some more input */
;;;60           retcode = (*cinfo->inputctl->consume_input) (cinfo);
;;;61           if (retcode == JPEG_SUSPENDED)
;;;62     	return NULL;
;;;63           if (retcode == JPEG_REACHED_EOI)
;;;64     	break;
;;;65           /* Advance progress counter if appropriate */
;;;66           if (cinfo->progress != NULL &&
;;;67     	  (retcode == JPEG_ROW_COMPLETED || retcode == JPEG_REACHED_SOS)) {
;;;68     	if (++cinfo->progress->pass_counter >= cinfo->progress->pass_limit) {
;;;69     	  /* startup underestimated number of scans; ratchet up one scan */
;;;70     	  cinfo->progress->pass_limit += (long) cinfo->total_iMCU_rows;
;;;71     	}
;;;72           }
;;;73         }
;;;74         /* Set state so that jpeg_finish_decompress does the right thing */
;;;75         cinfo->global_state = DSTATE_STOPPING;
;;;76       }
;;;77       /* At this point we should be in state DSTATE_STOPPING if being used
;;;78        * standalone, or in state DSTATE_BUFIMAGE if being invoked to get access
;;;79        * to the coefficients during a full buffered-image-mode decompression.
;;;80        */
;;;81       if ((cinfo->global_state == DSTATE_STOPPING ||
00000e  28d2              CMP      r0,#0xd2
000010  d02a              BEQ      |L1.104|
;;;82            cinfo->global_state == DSTATE_BUFIMAGE) && cinfo->buffered_image) {
000012  28cf              CMP      r0,#0xcf
000014  d028              BEQ      |L1.104|
000016  e02d              B        |L1.116|
                  |L1.24|
000018  4620              MOV      r0,r4                 ;49
00001a  f7fffffe          BL       transdecode_master_selection
00001e  20d1              MOVS     r0,#0xd1              ;50
000020  6160              STR      r0,[r4,#0x14]         ;50
                  |L1.34|
000022  68a0              LDR      r0,[r4,#8]            ;57
000024  b110              CBZ      r0,|L1.44|
000026  6801              LDR      r1,[r0,#0]            ;58
000028  4620              MOV      r0,r4                 ;58
00002a  4788              BLX      r1                    ;58
                  |L1.44|
00002c  f8d401b4          LDR      r0,[r4,#0x1b4]        ;60
000030  6801              LDR      r1,[r0,#0]            ;60
000032  4620              MOV      r0,r4                 ;60
000034  4788              BLX      r1                    ;60
000036  2800              CMP      r0,#0                 ;61
000038  d01b              BEQ      |L1.114|
00003a  2802              CMP      r0,#2                 ;63
00003c  d012              BEQ      |L1.100|
00003e  68a1              LDR      r1,[r4,#8]            ;66
000040  2900              CMP      r1,#0                 ;66
000042  d0ee              BEQ      |L1.34|
000044  2803              CMP      r0,#3                 ;67
000046  d001              BEQ      |L1.76|
000048  2801              CMP      r0,#1                 ;67
00004a  d1ea              BNE      |L1.34|
                  |L1.76|
00004c  684a              LDR      r2,[r1,#4]            ;68
00004e  1c52              ADDS     r2,r2,#1              ;68
000050  604a              STR      r2,[r1,#4]            ;68
000052  68a0              LDR      r0,[r4,#8]            ;68
000054  6881              LDR      r1,[r0,#8]            ;68
000056  428a              CMP      r2,r1                 ;68
000058  dbe3              BLT      |L1.34|
00005a  f8d42140          LDR      r2,[r4,#0x140]        ;70
00005e  4411              ADD      r1,r1,r2              ;70
000060  6081              STR      r1,[r0,#8]            ;70
000062  e7de              B        |L1.34|
                  |L1.100|
000064  20d2              MOVS     r0,#0xd2              ;75
000066  6160              STR      r0,[r4,#0x14]         ;75
                  |L1.104|
000068  6c20              LDR      r0,[r4,#0x40]
00006a  b118              CBZ      r0,|L1.116|
;;;83         return cinfo->coef->coef_arrays;
00006c  f8d401ac          LDR      r0,[r4,#0x1ac]
000070  6900              LDR      r0,[r0,#0x10]
                  |L1.114|
;;;84       }
;;;85       /* Oops, improper usage */
;;;86       ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
;;;87       return NULL;			/* keep compiler happy */
;;;88     }
000072  bd10              POP      {r4,pc}
                  |L1.116|
000074  6821              LDR      r1,[r4,#0]            ;86
000076  2014              MOVS     r0,#0x14              ;86
000078  6148              STR      r0,[r1,#0x14]         ;86
00007a  6821              LDR      r1,[r4,#0]            ;86
00007c  6960              LDR      r0,[r4,#0x14]         ;86
00007e  6188              STR      r0,[r1,#0x18]         ;86
000080  6820              LDR      r0,[r4,#0]            ;86
000082  6801              LDR      r1,[r0,#0]            ;86
000084  4620              MOV      r0,r4                 ;86
000086  4788              BLX      r1                    ;86
000088  2000              MOVS     r0,#0                 ;87
00008a  bd10              POP      {r4,pc}
;;;89     
                          ENDP


                          AREA ||i.transdecode_master_selection||, CODE, READONLY, ALIGN=1

                  transdecode_master_selection PROC
;;;96     LOCAL(void)
;;;97     transdecode_master_selection (j_decompress_ptr cinfo)
000000  b570              PUSH     {r4-r6,lr}
;;;98     {
;;;99       /* This is effectively a buffered-image operation. */
;;;100      cinfo->buffered_image = TRUE;
000002  2501              MOVS     r5,#1
000004  4604              MOV      r4,r0                 ;98
;;;101    
;;;102      /* Entropy decoding: either Huffman or arithmetic coding. */
;;;103      if (cinfo->arith_code) {
000006  6405              STR      r5,[r0,#0x40]
000008  f8d000e0          LDR      r0,[r0,#0xe0]
00000c  b130              CBZ      r0,|L2.28|
;;;104        ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
00000e  6820              LDR      r0,[r4,#0]
000010  6145              STR      r5,[r0,#0x14]
000012  6820              LDR      r0,[r4,#0]
000014  6801              LDR      r1,[r0,#0]
000016  4620              MOV      r0,r4
000018  4788              BLX      r1
00001a  e009              B        |L2.48|
                  |L2.28|
;;;105      } else {
;;;106        if (cinfo->progressive_mode) {
00001c  f8d400dc          LDR      r0,[r4,#0xdc]
000020  2800              CMP      r0,#0
;;;107    #ifdef D_PROGRESSIVE_SUPPORTED
;;;108          jinit_phuff_decoder(cinfo);
;;;109    #else
;;;110          ERREXIT(cinfo, JERR_NOT_COMPILED);
;;;111    #endif
;;;112        } else
;;;113          jinit_huff_decoder(cinfo);
000022  4620              MOV      r0,r4
000024  d002              BEQ      |L2.44|
000026  f7fffffe          BL       jinit_phuff_decoder
00002a  e001              B        |L2.48|
                  |L2.44|
00002c  f7fffffe          BL       jinit_huff_decoder
                  |L2.48|
;;;114      }
;;;115    
;;;116      /* Always get a full-image coefficient buffer. */
;;;117      jinit_d_coef_controller(cinfo, TRUE);
000030  2101              MOVS     r1,#1
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       jinit_d_coef_controller
;;;118    
;;;119      /* We can now tell the memory manager to allocate virtual arrays. */
;;;120      (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);
000038  6860              LDR      r0,[r4,#4]
00003a  6981              LDR      r1,[r0,#0x18]
00003c  4620              MOV      r0,r4
00003e  4788              BLX      r1
;;;121    
;;;122      /* Initialize input side of decompressor to consume first scan. */
;;;123      (*cinfo->inputctl->start_input_pass) (cinfo);
000040  f8d401b4          LDR      r0,[r4,#0x1b4]
000044  6881              LDR      r1,[r0,#8]
000046  4620              MOV      r0,r4
000048  4788              BLX      r1
;;;124    
;;;125      /* Initialize progress monitoring. */
;;;126      if (cinfo->progress != NULL) {
00004a  68a1              LDR      r1,[r4,#8]
00004c  2900              CMP      r1,#0
00004e  d019              BEQ      |L2.132|
;;;127        int nscans;
;;;128        /* Estimate number of scans to set pass_limit. */
;;;129        if (cinfo->progressive_mode) {
000050  f8d400dc          LDR      r0,[r4,#0xdc]
000054  b120              CBZ      r0,|L2.96|
;;;130          /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
;;;131          nscans = 2 + 3 * cinfo->num_components;
000056  6a60              LDR      r0,[r4,#0x24]
000058  eb000040          ADD      r0,r0,r0,LSL #1
00005c  1c80              ADDS     r0,r0,#2
00005e  e006              B        |L2.110|
                  |L2.96|
;;;132        } else if (cinfo->inputctl->has_multiple_scans) {
000060  f8d401b4          LDR      r0,[r4,#0x1b4]
000064  6900              LDR      r0,[r0,#0x10]
000066  b108              CBZ      r0,|L2.108|
;;;133          /* For a nonprogressive multiscan file, estimate 1 scan per component. */
;;;134          nscans = cinfo->num_components;
000068  6a60              LDR      r0,[r4,#0x24]
00006a  e000              B        |L2.110|
                  |L2.108|
;;;135        } else {
;;;136          nscans = 1;
00006c  2001              MOVS     r0,#1
                  |L2.110|
;;;137        }
;;;138        cinfo->progress->pass_counter = 0L;
00006e  2200              MOVS     r2,#0
;;;139        cinfo->progress->pass_limit = (long) cinfo->total_iMCU_rows * nscans;
000070  604a              STR      r2,[r1,#4]
000072  f8d41140          LDR      r1,[r4,#0x140]
000076  4341              MULS     r1,r0,r1
000078  68a0              LDR      r0,[r4,#8]
;;;140        cinfo->progress->completed_passes = 0;
00007a  6081              STR      r1,[r0,#8]
00007c  68a0              LDR      r0,[r4,#8]
;;;141        cinfo->progress->total_passes = 1;
00007e  60c2              STR      r2,[r0,#0xc]
000080  68a0              LDR      r0,[r4,#8]
000082  6105              STR      r5,[r0,#0x10]
                  |L2.132|
;;;142      }
;;;143    }
000084  bd70              POP      {r4-r6,pc}
                          ENDP

