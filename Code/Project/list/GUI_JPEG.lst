L 1 "..\GUI\JPEG\GUI_JPEG.c"
N/*
N*********************************************************************************************************
N*                                                uC/GUI
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : GUI_JPEG.c
NPurpose     : Implementation of GUI_JPEG... functions
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#include <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision: 185525 $
N * Checkin $Date: 2014-05-29 12:44:48 +0100 (Thu, 29 May 2014) $
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5050041
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X    #if 0L || (1L && 199901L <= 199409L)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 21 "..\GUI\JPEG\GUI_JPEG.c" 2
N
N#include "GUI_Private.h"
L 1 "..\GUI\Core\GUI_Private.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : GUI_Private.h
NPurpose     : GUI internal declarations
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N#ifndef  GUI_PRIVATE_H
N#define  GUI_PRIVATE_H
N
N#include "GUI_Protected.h"
L 1 "..\GUI\Core\GUI_Protected.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : GUI_Protected.h
NPurpose     : GUI internal declarations
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef  GUI_PROTECTED_H
N#define  GUI_PROTECTED_H
N
N#include "GUI.h"
L 1 "..\GUI\Core\GUI.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : GUI.h
NPurpose     : GUI API include file
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N
N#ifndef  GUI_H
N#define  GUI_H
N#define __EMWIN_GSC__   /* Allow "C" to find out that emWin GSC is used */
N
N
N#include "GUI_ConfDefaults.h"
L 1 "..\GUI\Core\GUI_ConfDefaults.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : GUI_ConfDefaults.h
NPurpose     : Defaults for GUI config switches.
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N#ifndef  GUI_CONFDEFAULTS_H
N#define  GUI_CONFDEFAULTS_H
N
N#include "GUIConf.h"
L 1 "..\Config\GUIConf.h" 1
N/*
N*********************************************************************************************************
N*                                                uC/GUI
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : GUIConf.h
NPurpose     : Configures abilities, fonts etc.
N----------------------------------------------------------------------
N*/
N
N
N#ifndef GUICONF_H
N#define GUICONF_H
N
N#define GUI_OS                    (0)  /* Compile with multitasking support */
N#define GUI_SUPPORT_TOUCH         (1)  /* Support a touch screen (req. win-manager) */
N#define GUI_SUPPORT_UNICODE       (1)  /* Support mixed ASCII/UNICODE strings */
N
N#define GUI_DEFAULT_FONT          &GUI_Font6x8
N#define GUI_ALLOC_SIZE          	(1024*30)  /* Size of dynamic memory ... For WM and memory devices*/
N/*********************************************************************
N*
N*         Configuration of available packages
N*/
N
N#define GUI_WINSUPPORT            1  /* Window manager package available */
N#define GUI_SUPPORT_MEMDEV       1  /* Memory devices available */
N#define GUI_SUPPORT_AA            1  /* Anti aliasing available */
N
N#endif  /* Avoid multiple inclusion */
N
N
N
L 28 "..\GUI\Core\GUI_ConfDefaults.h" 2
N
N/**********************************************************************
N*
N*       Defaults for config switches
N*
N***********************************************************************
N*/
N
N/* Define "universal pointer". Normally, this is not needed (define will expand to nothing)
N   However, on some systems (AVR - IAR compiler) it can be necessary ( -> __generic),
N   since a default pointer can access RAM only, not the built-in Flash
N*/
N#ifndef GUI_UNI_PTR
N  #define GUI_UNI_PTR
N  #define GUI_UNI_PTR_USED 0
N#else
S  #define GUI_UNI_PTR_USED 1
N#endif
N
N/* Define const storage. Normally, this is not needed (define will expand to const)
N   However, on some systems (AVR - IAR compiler) it can be necessary ( -> __flash const),
N   since otherwise constants are copied into RAM
N*/
N#ifndef GUI_USE_MEMDEV_1BPP_FOR_SCREEN
N  #define GUI_USE_MEMDEV_1BPP_FOR_SCREEN 0
N#endif
N
N#ifndef GUI_SUPPORT_UNICODE
S  #define GUI_SUPPORT_UNICODE 1
N#endif
N
N#ifndef GUI_SUPPORT_ARABIC
N  #define GUI_SUPPORT_ARABIC 0
N#endif
N
N#ifndef GUI_ALLOC_SIZE
S  #define GUI_ALLOC_SIZE      1000
N#endif
N
N#ifndef GUI_MAXBLOCKS
N  #define GUI_MAXBLOCKS (2 + GUI_ALLOC_SIZE / 32)
N#endif
N
N#ifndef GUI_CONST_STORAGE
N  #define GUI_CONST_STORAGE const
N#endif
N
N#ifndef GUI_SUPPORT_TOUCH
S  #define GUI_SUPPORT_TOUCH   0
N#endif
N
N#ifndef GUI_SUPPORT_MOUSE
N  #define GUI_SUPPORT_MOUSE   0
N#endif
N
N#ifndef GUI_SUPPORT_MEMDEV
S  #define GUI_SUPPORT_MEMDEV  0
N#endif
N
N#ifndef GUI_SUPPORT_AA
S  #define GUI_SUPPORT_AA      0
N#endif
N
N#ifndef GUI_OS
S  #define GUI_OS              0
N#endif
N
N#ifndef GUI_SUPPORT_LARGE_BITMAPS
N  #if GUI_ALLOC_SIZE > 65535
X  #if (1024*30) > 65535
S    #define GUI_SUPPORT_LARGE_BITMAPS 1
N  #else
N    #define GUI_SUPPORT_LARGE_BITMAPS 0
N  #endif
N#endif
N
N#ifndef GUI_COMPATIBLE_MODE
N  #define GUI_COMPATIBLE_MODE 1
N#endif
N
N#ifndef GUI_NUM_LAYERS
N  #define GUI_NUM_LAYERS      1
N#endif
N
N#ifndef GUI_SUPPORT_CURSOR
N  #define GUI_SUPPORT_CURSOR  (GUI_SUPPORT_MOUSE | GUI_SUPPORT_TOUCH)
N#endif
N
N#ifndef GUI_SUPPORT_DEVICES
N  #ifdef __C51__               /* Keil C51 limitation ... Indirect function calls are limited */
S    #define GUI_SUPPORT_DEVICES 0
N  #else
N    #define GUI_SUPPORT_DEVICES (GUI_SUPPORT_MEMDEV | (GUI_NUM_LAYERS > 1))
N  #endif
N#endif
N
N/* Some compilers for very simple chips can not generate code for function pointers
Nwith parameters. In this case, we do not use function pointers, but limit the functionality slightly */
N#ifndef GUI_COMPILER_SUPPORTS_FP
N  #ifdef __C51__
S    #define GUI_COMPILER_SUPPORTS_FP 0
N  #else
N    #define GUI_COMPILER_SUPPORTS_FP 1
N  #endif
N#endif
N
N#ifndef GUI_SUPPORT_ROTATION
N  #if GUI_COMPILER_SUPPORTS_FP
X  #if 1
N    #define GUI_SUPPORT_ROTATION 1
N  #else
S    #define GUI_SUPPORT_ROTATION 0
N  #endif
N#endif
N
N/* In order to avoid warnings for undefined parameters */
N#ifndef GUI_USE_PARA
N  #if defined (__BORLANDC__) || defined(NC30) || defined(NC308)
X  #if 0L || 0L || 0L
S    #define GUI_USE_PARA(para)
N  #else
N    #define GUI_USE_PARA(para) para=para;
N  #endif
N#endif
N
N/* Default for types */
N#ifndef GUI_TIMER_TIME
N  #define GUI_TIMER_TIME int  /* default is to use 16 bits for 16 bit CPUs,
N	                           32 bits on 32 bit CPUs for timing */
N#endif
N
N/* Types used for memory allocation */
N#if GUI_ALLOC_SIZE <32767
X#if (1024*30) <32767
N  #define GUI_ALLOC_DATATYPE   I16
N  #define GUI_ALLOC_DATATYPE_U U16
N#else
S  #define GUI_ALLOC_DATATYPE   I32
S  #define GUI_ALLOC_DATATYPE_U U32
N#endif
N
N#ifndef   GUI_MEMSET
N  #define GUI_MEMSET GUI__memset
N#endif
N
N
N#endif   /* ifdef GUI_CONFDEFAULTS_H */
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 31 "..\GUI\Core\GUI.h" 2
N#include "GUIType.h"
L 1 "..\GUI\Core\GUIType.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : GUIType.h
NPurpose     : Include file define the types used for GUI
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N#ifndef  GUITYPE_H_INCLUDED
N#define  GUITYPE_H_INCLUDED
N
N#include "LCD.h"
L 1 "..\GUI\Core\LCD.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : LCD.h
NPurpose     : Declares LCD interface functions
N----------------------------------------------------------------------
N*/
N
N#ifndef LCD_H
N#define LCD_H
N
N#include "GUI_ConfDefaults.h" /* Used for GUI_UNI_PTR */
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*
N  ********************************************************************
N  *                                                                  *
N  *                   Basic type defines                             *
N  *                                                                  *
N  ********************************************************************
N
NThe follwing are defines for types used in the LCD-driver and the
NGUI layers on top of that. Since "C" does not provide data types of
Nfixed length which are identical on all platforms, this is done here.
NFor most 16/32 controllers, the settings will work fine. However, if
Nyou have similar defines in other sections of your program, you might
Nwant to change or relocate these defines, e.g. in a TYPE.h file.
N*/
N 
N#define I8    signed char
N#define U8  unsigned char     /* unsigned 8  bits. */
N#define I16   signed short    /*   signed 16 bits. */
N#define U16 unsigned short    /* unsigned 16 bits. */
N#define I32   signed long   /*   signed 32 bits. */
N#define U32 unsigned long   /* unsigned 32 bits. */
N#define I16P I16              /*   signed 16 bits OR MORE ! */
N#define U16P U16              /* unsigned 16 bits OR MORE ! */
N
N/*
N  ********************************************************************
N  *                                                                  *
N  *               Settings for windows simulation                    *
N  *                                                                  *
N  ********************************************************************
N
NSome settings in the configuration may conflict with the values required
Nin the Simulation. This is why we ignore the target settings for data
Ntypes and use the correct settings for the simulation.
N(U32 could be defined as long, which would yield a 64 bit type on
Nthe PC)
N*/
N
N#ifdef WIN32
S  #pragma warning( disable : 4244 )  // Disable warning messages in simulation
S  #pragma warning( disable : 4761 )  // Disable warning "integral size mismatch in argument; conversion supplied"
N#endif                                      
N
N
N/*      *************************************************************
N        *                                                           *
N        *                Constants                                  *
N        *                                                           *
N        *************************************************************
N*/
N#define LCD_ERR0 (0x10)
N#define LCD_ERR_CONTROLLER_NOT_FOUND (LCD_ERR0+1)
N#define LCD_ERR_MEMORY               (LCD_ERR0+2)
N
N/*
N      *********************************
N      *                               *
N      *      Drawing modes            *
N      *                               *
N      *********************************
N*/
N
N#define LCD_DRAWMODE_NORMAL (0)
N#define LCD_DRAWMODE_XOR    (1<<0)
N#define LCD_DRAWMODE_TRANS  (1<<1)
N#define LCD_DRAWMODE_REV    (1<<2)
N
N
N 
N/*      *************************************************************
N        *                                                           *
N        *                Typedefs                                   *
N        *                                                           *
N        *************************************************************
N*/
N
Ntypedef int LCD_DRAWMODE;
Ntypedef U32 LCD_COLOR;
Xtypedef unsigned long LCD_COLOR;
N
N 
N/********************************************************
N*
N*     Data structures
N*
N*********************************************************
N*/
N
Ntypedef struct { I16P x,y; } GUI_POINT;
Xtypedef struct { signed short x,y; } GUI_POINT;
Ntypedef struct { I16 x0,y0,x1,y1; } LCD_RECT;
Xtypedef struct { signed short x0,y0,x1,y1; } LCD_RECT;
N/*typedef struct { GUI_POINT P0, P1; } LCD_RECT; */
N
Ntypedef struct {
N  int              NumEntries; 
N  char             HasTrans;         
N  const LCD_COLOR GUI_UNI_PTR * pPalEntries; 
X  const LCD_COLOR  * pPalEntries; 
N} LCD_LOGPALETTE; 
N
N/* This is used for the simulation only ! */
Ntypedef struct {
N  int x,y;
N  unsigned char KeyStat;
N} LCD_tMouseState;
N
N/*********************************************************************
N*
N*     Index2Color
N
N  This function needs to be int the public part of the software
N  since it is needed by the simulation. Most other driver
N  functions are hidden in the private header file.
N*/
N
Ntypedef LCD_COLOR      tLCDDEV_Index2Color  (int Index);
Ntypedef unsigned int   tLCDDEV_Color2Index  (LCD_COLOR Color);
Ntypedef unsigned int   tLCDDEV_GetIndexMask (void);
NLCD_COLOR      LCD_L0_Index2Color  (int Index);
NLCD_COLOR      LCD_L0_1_Index2Color(int Index);
NLCD_COLOR      LCD_L0_2_Index2Color(int Index);
NLCD_COLOR      LCD_L0_3_Index2Color(int Index);
NLCD_COLOR      LCD_L0_4_Index2Color(int Index);
Nunsigned int   LCD_L0_Color2Index  (LCD_COLOR Color);
Nunsigned int   LCD_L0_1_Color2Index(LCD_COLOR Color);
Nunsigned int   LCD_L0_2_Color2Index(LCD_COLOR Color);
Nunsigned int   LCD_L0_3_Color2Index(LCD_COLOR Color);
Nunsigned int   LCD_L0_4_Color2Index(LCD_COLOR Color);
Nunsigned int   LCD_L0_GetIndexMask  (void);
Nunsigned int   LCD_L0_1_GetIndexMask(void);
Nunsigned int   LCD_L0_2_GetIndexMask(void);
Nunsigned int   LCD_L0_3_GetIndexMask(void);
Nunsigned int   LCD_L0_4_GetIndexMask(void);
N
N
N/*********************************************************************
N*
N*     Color conversion API tables
N*/
N
Ntypedef struct {
N  tLCDDEV_Color2Index*  pfColor2Index;
N  tLCDDEV_Index2Color*  pfIndex2Color;
N  tLCDDEV_GetIndexMask* pfGetIndexMask;
N} LCD_API_COLOR_CONV;
N
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_1;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_2;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_4;
Nextern const LCD_API_COLOR_CONV LCD_API_ColorConv_8666;
N
N#define GUI_COLOR_CONV_1    &LCD_API_ColorConv_1
N#define GUI_COLOR_CONV_2    &LCD_API_ColorConv_2
N#define GUI_COLOR_CONV_4    &LCD_API_ColorConv_4
N#define GUI_COLOR_CONV_8666 &LCD_API_ColorConv_8666
N
N/*********************************************************************
N*
N*      LCDDEV function table
N*
N**********************************************************************
N
N  Below the routines which need to in an LCDDEV routine table are
N  defined. All of these routines have to be in the low-level driver
N  (LCD_L0) or in the memory device which can be used to replace the
N  driver.
N  The one exception to this is the SetClipRect routine, which would
N  be identical for all drivers and is therefor contained in the
N  level above (LCD).
N*/
Ntypedef void         tLCDDEV_DrawHLine    (int x0, int y0,  int x1);
Ntypedef void         tLCDDEV_DrawVLine    (int x , int y0,  int y1);
Ntypedef void         tLCDDEV_FillRect     (int x0, int y0, int x1, int y1);
Ntypedef unsigned int tLCDDEV_GetPixelIndex(int x, int y);
Ntypedef void         tLCDDEV_SetPixelIndex(int x, int y, int ColorIndex);
Ntypedef void         tLCDDEV_XorPixel     (int x, int y);
Ntypedef void         tLCDDEV_FillPolygon  (const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Ntypedef void         tLCDDEV_FillPolygonAA(const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Ntypedef void         tLCDDEV_GetRect      (LCD_RECT*pRect);
Ntypedef int          tLCDDEV_Init         (void);
Ntypedef void         tLCDDEV_On           (void);
Ntypedef void         tLCDDEV_Off          (void);
Ntypedef void         tLCDDEV_SetLUTEntry  (U8 Pos, LCD_COLOR color);
Xtypedef void         tLCDDEV_SetLUTEntry  (unsigned char Pos, LCD_COLOR color);
Ntypedef void *       tLCDDEV_GetDevFunc   (int Index);
N
N/*********************************************************************
N*
N*     Memory device API tables
N*/
N#if GUI_COMPILER_SUPPORTS_FP
X#if 1
N  typedef struct tLCDDEV_APIList_struct tLCDDEV_APIList;
N#endif
N
Ntypedef void tLCDDEV_DrawBitmap   (int x0, int y0, int xsize, int ysize,
N                       int BitsPerPixel, int BytesPerLine,
N                       const U8 GUI_UNI_PTR * pData, int Diff,
X                       const unsigned char  * pData, int Diff,
N                       const void* pTrans);   /* Really LCD_PIXELINDEX, but is void to avoid compiler warnings*/
N
Nstruct tLCDDEV_APIList_struct {
N  tLCDDEV_Color2Index*        pfColor2Index;
N  tLCDDEV_Index2Color*        pfIndex2Color;
N  tLCDDEV_GetIndexMask*       pfGetIndexMask;
N  tLCDDEV_DrawBitmap*         pfDrawBitmap;
N  tLCDDEV_DrawHLine*          pfDrawHLine;
N  tLCDDEV_DrawVLine*          pfDrawVLine;
N  tLCDDEV_FillRect*           pfFillRect;
N  tLCDDEV_GetPixelIndex*      pfGetPixelIndex;
N  tLCDDEV_GetRect*            pfGetRect;
N  tLCDDEV_SetPixelIndex*      pfSetPixelIndex;
N  tLCDDEV_XorPixel*           pfXorPixel;
N  tLCDDEV_SetLUTEntry*        pfSetLUTEntry;
N  tLCDDEV_GetDevFunc*         pfGetDevFunc;
N  #if GUI_SUPPORT_MEMDEV
X  #if 1
N    tLCDDEV_FillPolygon*      pfFillPolygon;
N    tLCDDEV_FillPolygonAA*    pfFillPolygonAA;
N    const tLCDDEV_APIList*    pMemDevAPI;
N    unsigned                  BitsPerPixel;
N  #endif
N};
N#if GUI_COMPILER_SUPPORTS_FP
X#if 1
N  extern const struct tLCDDEV_APIList_struct GUI_MEMDEV__APIList1;
N  extern const struct tLCDDEV_APIList_struct GUI_MEMDEV__APIList8;
N  extern const struct tLCDDEV_APIList_struct GUI_MEMDEV__APIList16;
N
N  #define GUI_MEMDEV_APILIST_1  &GUI_MEMDEV__APIList1
N  #define GUI_MEMDEV_APILIST_8  &GUI_MEMDEV__APIList8
N  #define GUI_MEMDEV_APILIST_16 &GUI_MEMDEV__APIList16
N#endif
N
N/*      *************************************************************
N        *                                                           *
N        *                   Defines                                 *
N        *                                                           *
N        *    for device capabilities                                *
N        *                                                           *
N        *************************************************************
N
NThe following is the list of device capabilities which can, but do
Nnot have to be implemented in the driver. This way the driver can be
Nenhanced in the future without affecting the driver interface,
Nkeeping older drivers compatible.
NMore DevCaps can always be added in the future, as older drivers
Nare guaranteed to return 0 for all unimplemented features or queries.
N
NThe values below define the legal parameters to the LCD_GetDeviceCaps
Nand the LCD_GetpCapFunc routines.
N*/
N
N#define LCD_DEVCAP_NUMCOLORS    0x0     /* Quest number of colors
N                                           which LCD can display */
N#define LCD_DEVCAP_XSIZE        0x1     /* Quest horiz. res. of display */
N#define LCD_DEVCAP_YSIZE        0x2     /* Quest vert. res. of display */
N#define LCD_DEVCAP_VXSIZE       0x3     /* Quest vert. res. of virtual disp.*/
N#define LCD_DEVCAP_VYSIZE       0x4     /* Quest vert. res. of virtual disp.*/
N#define LCD_DEVCAP_XORG         0x5     /* X-origin ... usually 0 */
N#define LCD_DEVCAP_YORG         0x6     /* Y-origin ... usually 0 */
N#define LCD_DEVCAP_CONTROLLER   0x7     /* LCD Controller (Numerical) */
N#define LCD_DEVCAP_BITSPERPIXEL 0x8     /* Bits per pixel ... 1/2/4/8 */
N#define LCD_DEVCAP_NUMPAGES     0x10    /* Quest number of pages of display */
N
N#define LCD_DEVCAP_COLOR        0x1000  /* Quest Color[0]
N                                0x1001     Quest Color[1]
N                                0x1002     Quest Color[2]
N                                         ...                    */
N /* The next 4095 entries are reserved so up to 4096 colors
N    can be queried          ...*/
N
Nint LCD_GetXSize(void);
Nint LCD_GetXSize_1(void);
Nint LCD_GetXSizeEx(int Index);
N
Nint LCD_GetYSize(void);
Nint LCD_GetYSize_1(void);
Nint LCD_GetYSizeEx(int Index);
N
Nint LCD_GetVXSize(void);
Nint LCD_GetVXSize_1(void);
Nint LCD_GetVXSizeEx(int Index);
N
Nint LCD_GetVYSize(void);
Nint LCD_GetVYSize_1(void);
Nint LCD_GetVYSizeEx(int Index);
N
NU32 LCD_GetNumColors(void);
Xunsigned long LCD_GetNumColors(void);
NU32 LCD_GetNumColors_1(void);
Xunsigned long LCD_GetNumColors_1(void);
NU32 LCD_GetNumColorsEx(int Index);
Xunsigned long LCD_GetNumColorsEx(int Index);
N
Nint LCD_GetBitsPerPixel(void);
Nint LCD_GetBitsPerPixel_1(void);
Nint LCD_GetBitsPerPixelEx(int Index);
N
Nint LCD_GetFixedPalette(void);
Nint LCD_GetFixedPalette_1(void);
NI32 LCD_GetFixedPaletteEx(int Index);
Xsigned long LCD_GetFixedPaletteEx(int Index);
N
Nint LCD_GetXMag(void);
Nint LCD_GetXMag_1(void);
Nint LCD_GetXMagEx(int Index);
N
Nint LCD_GetYMag(void);
Nint LCD_GetYMag_1(void);
Nint LCD_GetYMagEx(int Index);
N
Nint LCD_GetMirrorXEx(int LayerIndex);
Nint LCD_GetMirrorYEx(int LayerIndex);
Nint LCD_GetSwapXYEx(int LayerIndex);
N
Nint LCD_GetSwapRBEx(int LayerIndex);
Nint LCD_GetDeltaModeEx(int LayerIndex);
Nint LCD_GetBitsPerPixel_L0Ex(int LayerIndex);
N
NtLCDDEV_Index2Color * LCD_GetpfIndex2ColorEx(int LayerIndex);
N
Nint LCD_GetNumLayers(void);
N
N#define LCD_GetNumDisplays() LCD_GetNumLayers()
N
N#define LCD_GET_XSIZE()        LCD_GetXSize()
N#define LCD_GET_YSIZE()        LCD_GetYSize()
N#define LCD_GET_VXSIZE()       LCD_GetVXSize()
N#define LCD_GET_VYSIZE()       LCD_GetVYSize()
N#define LCD_GET_NUMCOLORS()    LCD_GetNumColors()
N#define LCD_GET_BITSPERPIXEL() LCD_GetBitsPerPixel()
N
N#define LCD_DEVFUNC_READRECT  0x1     /* Request of a function pointer for reading a rectangular display area */
N
Nvoid * LCD_L0_GetDevFunc(int Index);
N
N/*********************************************************************
N*
N*      LCD_CLIP function table
N*
N**********************************************************************
N*/
Ntypedef void         tLCD_HL_DrawHLine    (int x0, int y0,  int x1);
Ntypedef void         tLCD_HL_DrawPixel    (int x0, int y0);
N
Ntypedef struct {
N  tLCD_HL_DrawHLine*          pfDrawHLine;
N  tLCD_HL_DrawPixel*          pfDrawPixel;
N} tLCD_HL_APIList;
N
Nvoid LCD_DrawHLine(int x0, int y0,  int x1);
Nvoid LCD_DrawPixel(int x0, int y0);
Nvoid LCD_DrawVLine  (int x, int y0,  int y1);
N
N
N
N/*********************************************************************
N*
N*              Declarations for LCD_
N*
N**********************************************************************
N*/
N
Nvoid LCD_SetClipRectEx(const LCD_RECT* pRect);
Nvoid LCD_SetClipRectMax(void);
N
N/* Get device capabilities (0 if not supported) */
NI32  LCD_GetDevCap(int Index);
Xsigned long  LCD_GetDevCap(int Index);
N
N/* Initialize LCD using config-paramters */
Nint LCD_Init(void);
N
Nvoid LCD_SetBkColor   (LCD_COLOR Color); /* Set background color */
Nvoid LCD_SetColor     (LCD_COLOR Color); /* Set foreground color */
Nvoid LCD_SetPixelIndex(int x, int y, int ColorIndex);
N
N/* Palette routines (Not available on all drivers) */
Nvoid LCD_InitLUT(void);
N
N/* Decompressors */
N//typedef void tfDrawSpecialBitmap(int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR *pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
Nvoid         LCD_DrawBitmap_RLE8(int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR *pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
Xvoid         LCD_DrawBitmap_RLE8(int x0,int y0,int xsize, int ysize, const unsigned char  *pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag);
Nvoid         LCD_DrawBitmap_RLE4(int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR *pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
Xvoid         LCD_DrawBitmap_RLE4(int x0,int y0,int xsize, int ysize, const unsigned char  *pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag);
Nvoid         LCD_DrawBitmap_565 (int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR *pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
Xvoid         LCD_DrawBitmap_565 (int x0,int y0,int xsize, int ysize, const unsigned char  *pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag);
Nvoid         LCD_DrawBitmap_M565(int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR *pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
Xvoid         LCD_DrawBitmap_M565(int x0,int y0,int xsize, int ysize, const unsigned char  *pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag);
N
NLCD_DRAWMODE LCD_SetDrawMode  (LCD_DRAWMODE dm);
Nvoid LCD_SetColorIndex(int Index);
Nvoid LCD_SetBkColorIndex(int Index);
Nvoid LCD_FillRect(int x0, int y0, int x1, int y1);
Ntypedef void tLCD_SetPixelAA(int x, int y, U8 Intens);
Xtypedef void tLCD_SetPixelAA(int x, int y, unsigned char Intens);
N
Nvoid LCD_SetPixelAA(int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA(int x, int y, unsigned char Intens);
Nvoid LCD_SetPixelAA_NoTrans(int x, int y, U8 Intens);
Xvoid LCD_SetPixelAA_NoTrans(int x, int y, unsigned char Intens);
N
NLCD_COLOR    LCD_AA_MixColors(LCD_COLOR Color, LCD_COLOR BkColor, U8 Intens);
XLCD_COLOR    LCD_AA_MixColors(LCD_COLOR Color, LCD_COLOR BkColor, unsigned char Intens);
NLCD_COLOR    LCD_MixColors256(LCD_COLOR Color, LCD_COLOR BkColor, unsigned Intens);
NLCD_COLOR    LCD_GetPixelColor(int x, int y);     /* Get RGB color of pixel */
Nunsigned int LCD_GetPixelIndex(int x, int y);
Nint          LCD_GetBkColorIndex (void);
Nint          LCD_GetColorIndex (void);
N
N/*********************************************************************
N*
N*       Optional support for rotatation
N*
N**********************************************************************
N*/
N
N#if GUI_SUPPORT_ROTATION
X#if 1
N
Ntypedef void tLCD_DrawBitmap(int x0, int y0, int xsize, int ysize,
N                             int xMul, int yMul, int BitsPerPixel, int BytesPerLine,
N                             const U8 GUI_UNI_PTR * pPixel, const void * pTrans);
X                             const unsigned char  * pPixel, const void * pTrans);
Ntypedef void tRect2TextRect (LCD_RECT * pRect);
N
Nstruct tLCD_APIList_struct {
N  tLCD_DrawBitmap   * pfDrawBitmap;
N  tRect2TextRect    * pfRect2TextRect;
N};
N
Ntypedef struct tLCD_APIList_struct tLCD_APIList;
N
Nextern tLCD_APIList LCD_APIListCCW;
Nextern tLCD_APIList LCD_APIListCW;
Nextern tLCD_APIList LCD_APIList180;
N
N#define GUI_ROTATION   tLCD_APIList
N#define GUI_ROTATE_CCW &LCD_APIListCCW
N#define GUI_ROTATE_CW  &LCD_APIListCW
N#define GUI_ROTATE_180 &LCD_APIList180
N#define GUI_ROTATE_0   0
N#endif
N
N
N/*      *************************************************************
N        *                                                           *
N        *      LCD  publics not used by GUI                         *
N        *                                                           *
N        *************************************************************
N  
N
NThe following functions can, but do not have to be defined in the LCD driver
Nas they are not used by the GUI level.
N
N*/
N
N
N
N#define LCD_On          LCD_L0_On
N#define LCD_Off         LCD_L0_Off
N#define LCD_ReInit      LCD_L0_ReInit
N#define LCD_SetLUTEntry LCD_L0_SetLUTEntry
N
N
N#define LCD_CC_UNLOCK (0)    /* Default mode: Cache is transparent */
N#define LCD_CC_LOCK   (1)    /* Cache is locked, no write operations */
N#define LCD_CC_FLUSH  (2)    /* Flush cache, do not change mode */
NU8 LCD_L0_ControlCache(U8 mode);
Xunsigned char LCD_L0_ControlCache(unsigned char mode);
NU8 LCD_L0_1_ControlCache(U8 mode);
Xunsigned char LCD_L0_1_ControlCache(unsigned char mode);
NU8 LCD_L0_2_ControlCache(U8 mode);
Xunsigned char LCD_L0_2_ControlCache(unsigned char mode);
NU8 LCD_L0_3_ControlCache(U8 mode);
Xunsigned char LCD_L0_3_ControlCache(unsigned char mode);
NU8 LCD_L0_4_ControlCache(U8 mode);
Xunsigned char LCD_L0_4_ControlCache(unsigned char mode);
Nvoid LCD_L0_Refresh(void);
Nvoid LCD_L0_1_Refresh(void);
Nvoid LCD_L0_2_Refresh(void);
Nvoid LCD_L0_3_Refresh(void);
Nvoid LCD_L0_4_Refresh(void);
N/* Check if controller is still properly initialized */
Nint  LCD_L0_CheckInit(void);        /* returns if init is still O.K.
N                                      by reading all available registers of
N                                      Display controller.
N                                      0: Init O.K.
N                                    */
N
N#define LCD_ControlCache LCD_L0_ControlCache
N
N/*
N        ******************************************
N        *                                        *
N        *        Support for paging              *
N        *                                        *
N        ******************************************
N*/
N
Nint LCD_SelPage  (int NewPage);    /* returns formerly sel. page */
Nint LCD_ShowPage (int NewPage);    /* sets / returns visible page */
Nint LCD_GetSelPage (void);         /* returns selected page */
Nint LCD_GetVisPage (void);         /* returns visible page */
N
N
N/*      *************************************************************
N        *                                                           *
N        *      LCD  imports                                         *
N        *                  (for routines in LCDColor)               *
N        *                                                           *
N        *************************************************************
N*/
N  
N
Nint              LCD_Color2Index     (LCD_COLOR Color);
NLCD_COLOR        LCD_Index2Color     (int Index);
NLCD_COLOR        LCD_Index2ColorEx   (int i, unsigned int LayerIndex);
N
N/*********************************************************************
N*
N*       LCD_X_...
N*
N**********************************************************************
N*/
N
Nvoid LCD_X_Init(void);
Nvoid LCD_X_On  (void);
Nvoid LCD_X_Off (void);
N
Nchar LCD_X_Read00(void);
Nchar LCD_X_Read01(void);
Nvoid LCD_X_Write00(char c);
Nvoid LCD_X_Write01(char c);
Nvoid LCD_X_WriteM01(char * pData, int NumBytes);
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N#endif /* LCD_H */
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 28 "..\GUI\Core\GUIType.h" 2
N#include "GUIConf.h"
N
N/*      *************************************************************
N        *                                                           *
N        *                Simple types                               *
N        *                                                           *
N        *************************************************************
N*/
N
Ntypedef const char *  GUI_ConstString;
N
N
N/*      *************************************************************
N        *                                                           *
N        *                Structures                                 *
N        *                                                           *
N        *************************************************************
N*/
N
Ntypedef LCD_COLOR       GUI_COLOR;
Ntypedef LCD_LOGPALETTE  GUI_LOGPALETTE;
Ntypedef LCD_DRAWMODE    GUI_DRAWMODE;
Ntypedef LCD_RECT        GUI_RECT;
N
Ntypedef struct {
N  void      (* pfDraw)(int x0,int y0,int xsize, int ysize, const U8 GUI_UNI_PTR * pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag);
X  void      (* pfDraw)(int x0,int y0,int xsize, int ysize, const unsigned char  * pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag);
N  GUI_COLOR (* pfIndex2Color)(int Index);
N} GUI_BITMAP_METHODS;
N
Ntypedef struct {
N  U16P XSize;
X  unsigned short XSize;
N  U16P YSize;
X  unsigned short YSize;
N  U16P BytesPerLine;
X  unsigned short BytesPerLine;
N  U16P BitsPerPixel;
X  unsigned short BitsPerPixel;
N  const U8 GUI_UNI_PTR * pData;
X  const unsigned char  * pData;
N  const GUI_LOGPALETTE GUI_UNI_PTR * pPal;
X  const GUI_LOGPALETTE  * pPal;
N  const GUI_BITMAP_METHODS * pMethods;
N} GUI_BITMAP;
N
N/* This structure may not be changed because the data that it
N   expects is read in binary form (via any kind of interface,
N   at runtime).
N   This structure should therefor not be changed.
N*/
Ntypedef struct {
N  U16 ID;           /* Version 1.00 => 100*/
X  unsigned short ID;            
N  U16 Version;
X  unsigned short Version;
N  U16 XSize;
X  unsigned short XSize;
N  U16 YSize;
X  unsigned short YSize;
N  U16 BytesPerLine;
X  unsigned short BytesPerLine;
N  U16 BitsPerPixel;
X  unsigned short BitsPerPixel;
N  U16 NumColors;
X  unsigned short NumColors;
N  U16 HasTrans;
X  unsigned short HasTrans;
N} GUI_BITMAP_STREAM;
N
Ntypedef struct {
N  int x,y;
N  unsigned char Pressed;
N} GUI_PID_STATE;
N
Ntypedef struct {
N  int xPos;
N  int yPos;
N  int xSize;
N  int ySize;
N  int Delay;
N} GUI_GIF_IMAGE_INFO;
N
Ntypedef struct {
N  int xSize;
N  int ySize;
N  int NumImages;
N} GUI_GIF_INFO;
N
N/*
N      ****************************************
N      *                                      *
N      *      FONT structures (new in V1.10)  *
N      *                                      *
N      ****************************************
N*/
N
N/* Translation list. Translates a character code into up to 2
N   indices of images to display on top of each other;
N   'á' -> index('a'), index('´') */
Ntypedef struct {
N  I16P c0;
X  signed short c0;
N  I16P c1;
X  signed short c1;
N} GUI_FONT_TRANSLIST;
N
Ntypedef struct {
N  U16P FirstChar;
X  unsigned short FirstChar;
N  U16P LastChar;
X  unsigned short LastChar;
N  const GUI_FONT_TRANSLIST GUI_UNI_PTR * pList;
X  const GUI_FONT_TRANSLIST  * pList;
N} GUI_FONT_TRANSINFO;
N
Ntypedef struct {
N  U8 XSize;
X  unsigned char XSize;
N  U8 XDist;
X  unsigned char XDist;
N  U8 BytesPerLine;
X  unsigned char BytesPerLine;
N  const unsigned char GUI_UNI_PTR * pData;
X  const unsigned char  * pData;
N} GUI_CHARINFO;
N
Ntypedef struct GUI_FONT_PROP {
N  U16P First;                                /* first character               */
X  unsigned short First;                                 
N  U16P Last;                                 /* last character                */
X  unsigned short Last;                                  
N  const GUI_CHARINFO GUI_UNI_PTR * paCharInfo;            /* address of first character    */
X  const GUI_CHARINFO  * paCharInfo;             
N  const struct GUI_FONT_PROP GUI_UNI_PTR * pNext;        /* pointer to next */
X  const struct GUI_FONT_PROP  * pNext;         
N} GUI_FONT_PROP;
N
Ntypedef struct {
N  const unsigned char GUI_UNI_PTR * pData;
X  const unsigned char  * pData;
N  const U8 GUI_UNI_PTR * pTransData;
X  const unsigned char  * pTransData;
N  const GUI_FONT_TRANSINFO GUI_UNI_PTR * pTrans;
X  const GUI_FONT_TRANSINFO  * pTrans;
N  U16P FirstChar;
X  unsigned short FirstChar;
N  U16P LastChar;
X  unsigned short LastChar;
N  U8 XSize;
X  unsigned char XSize;
N  U8 XDist;
X  unsigned char XDist;
N  U8 BytesPerLine;
X  unsigned char BytesPerLine;
N} GUI_FONT_MONO;
N
N
Ntypedef struct GUI_FONT_INFO {
N  U16P First;                        /* first character               */
X  unsigned short First;                         
N  U16P Last;                         /* last character                */
X  unsigned short Last;                          
N  const GUI_CHARINFO* paCharInfo;    /* address of first character    */
N  const struct GUI_FONT_INFO* pNext; /* pointer to next */
N} GUI_FONT_INFO;
N
N/*
N      ****************************************
N      *                                      *
N      *      FONT info structure             *
N      *                                      *
N      ****************************************
N
NThis structure is used when retrieving information about a font.
NIt is designed for future expansion without incompatibilities.
N*/
Ntypedef struct {
N  U16 Flags;
X  unsigned short Flags;
N  U8 Baseline;
X  unsigned char Baseline;
N  U8 LHeight;     /* height of a small lower case character (a,x) */
X  unsigned char LHeight;      
N  U8 CHeight;     /* height of a small upper case character (A,X) */
X  unsigned char CHeight;      
N} GUI_FONTINFO;
N
N#define GUI_FONTINFO_FLAG_PROP (1<<0)    /* Is proportional */
N#define GUI_FONTINFO_FLAG_MONO (1<<1)    /* Is monospaced */
N#define GUI_FONTINFO_FLAG_AA   (1<<2)    /* Is an antialiased font */
N#define GUI_FONTINFO_FLAG_AA2  (1<<3)    /* Is an antialiased font, 2bpp */
N#define GUI_FONTINFO_FLAG_AA4  (1<<4)    /* Is an antialiased font, 4bpp */
N
N
N/**********************************************************************
N*
N*         UNICODE Encoding
N*
N***********************************************************************
N*/
Ntypedef U16  tGUI_GetCharCode(const char GUI_UNI_PTR *s);
Xtypedef unsigned short  tGUI_GetCharCode(const char  *s);
Ntypedef int  tGUI_GetCharSize(const char GUI_UNI_PTR *s);
Xtypedef int  tGUI_GetCharSize(const char  *s);
Ntypedef int  tGUI_CalcSizeOfChar(U16 Char);
Xtypedef int  tGUI_CalcSizeOfChar(unsigned short Char);
Ntypedef int  tGUI_Encode(char *s, U16 Char);
Xtypedef int  tGUI_Encode(char *s, unsigned short Char);
N
Ntypedef struct {
N  tGUI_GetCharCode*            pfGetCharCode;
N  tGUI_GetCharSize*            pfGetCharSize;
N  tGUI_CalcSizeOfChar*         pfCalcSizeOfChar;
N  tGUI_Encode*                 pfEncode;
N} GUI_UC_ENC_APILIST;
N
N/**********************************************************************
N*
N*                 FONT Encoding
N*
N***********************************************************************
N*/
N
Ntypedef int  tGUI_GetLineDistX(const char GUI_UNI_PTR *s, int Len);
Xtypedef int  tGUI_GetLineDistX(const char  *s, int Len);
Ntypedef int  tGUI_GetLineLen(const char GUI_UNI_PTR *s, int MaxLen);
Xtypedef int  tGUI_GetLineLen(const char  *s, int MaxLen);
Ntypedef void tGL_DispLine(const char GUI_UNI_PTR *s, int Len);
Xtypedef void tGL_DispLine(const char  *s, int Len);
N
Ntypedef struct {
N  tGUI_GetLineDistX*          pfGetLineDistX;
N  tGUI_GetLineLen*            pfGetLineLen;
N  tGL_DispLine*               pfDispLine;
N} tGUI_ENC_APIList;
N
Nextern const tGUI_ENC_APIList GUI_ENC_APIList_SJIS;
N
N
N/*
N      ****************************************
N      *                                      *
N      *      FONT methods                    *
N      *                                      *
N      ****************************************
N
NThe parameter to the methods called pFont should be of type
NGUI_FONT, but unfortunately a lot of compilers can not handle
Nforward declarations right ...
NSo it ends up to be a void pointer.
N*/
N
Ntypedef struct GUI_FONT GUI_FONT;
N
Ntypedef void GUI_DISPCHAR(U16 c);
Xtypedef void GUI_DISPCHAR(unsigned short c);
Ntypedef int  GUI_GETCHARDISTX(U16P c);
Xtypedef int  GUI_GETCHARDISTX(unsigned short c);
Ntypedef void GUI_GETFONTINFO(const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO * pfi);
Xtypedef void GUI_GETFONTINFO(const GUI_FONT  * pFont, GUI_FONTINFO * pfi);
Ntypedef char GUI_ISINFONT   (const GUI_FONT GUI_UNI_PTR * pFont, U16 c);
Xtypedef char GUI_ISINFONT   (const GUI_FONT  * pFont, unsigned short c);
N
N#define DECLARE_FONT(Type)                                     \
Nvoid GUI##Type##_DispChar    (U16P c);                         \
Nint  GUI##Type##_GetCharDistX(U16P c);                         \
Nvoid GUI##Type##_GetFontInfo (const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO * pfi); \
Nchar GUI##Type##_IsInFont    (const GUI_FONT GUI_UNI_PTR * pFont, U16 c)
X#define DECLARE_FONT(Type)                                     void GUI##Type##_DispChar    (U16P c);                         int  GUI##Type##_GetCharDistX(U16P c);                         void GUI##Type##_GetFontInfo (const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO * pfi); char GUI##Type##_IsInFont    (const GUI_FONT GUI_UNI_PTR * pFont, U16 c)
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/* MONO: Monospaced fonts */
NDECLARE_FONT(MONO);
Xvoid GUIMONO_DispChar (unsigned short c); int GUIMONO_GetCharDistX(unsigned short c); void GUIMONO_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIMONO_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_MONO       \
N  GUIMONO_DispChar,             \
N	GUIMONO_GetCharDistX,         \
N	GUIMONO_GetFontInfo,          \
N	GUIMONO_IsInFont,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_MONO         GUIMONO_DispChar,             	GUIMONO_GetCharDistX,         	GUIMONO_GetFontInfo,          	GUIMONO_IsInFont,               (tGUI_ENC_APIList*)0
N
N/* PROP: Proportional fonts */
NDECLARE_FONT(PROP);
Xvoid GUIPROP_DispChar (unsigned short c); int GUIPROP_GetCharDistX(unsigned short c); void GUIPROP_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_PROP       \
N  GUIPROP_DispChar,             \
N	GUIPROP_GetCharDistX,         \
N	GUIPROP_GetFontInfo,          \
N	GUIPROP_IsInFont,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP         GUIPROP_DispChar,             	GUIPROP_GetCharDistX,         	GUIPROP_GetFontInfo,          	GUIPROP_IsInFont,               (tGUI_ENC_APIList*)0
N
N/* PROP: Proportional fonts SJIS */
NDECLARE_FONT(PROP);
Xvoid GUIPROP_DispChar (unsigned short c); int GUIPROP_GetCharDistX(unsigned short c); void GUIPROP_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_PROP_SJIS  \
N  GUIPROP_DispChar,             \
N	GUIPROP_GetCharDistX,         \
N	GUIPROP_GetFontInfo,          \
N	GUIPROP_IsInFont,             \
N  &GUI_ENC_APIList_SJIS
X#define GUI_FONTTYPE_PROP_SJIS    GUIPROP_DispChar,             	GUIPROP_GetCharDistX,         	GUIPROP_GetFontInfo,          	GUIPROP_IsInFont,               &GUI_ENC_APIList_SJIS
N
N/* PROPAA: Proportional, antialiased fonts */
NDECLARE_FONT(PROPAA);
Xvoid GUIPROPAA_DispChar (unsigned short c); int GUIPROPAA_GetCharDistX(unsigned short c); void GUIPROPAA_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROPAA_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_PROPAA       \
N  GUIPROPAA_DispChar,             \
N	GUIPROPAA_GetCharDistX,         \
N	GUIPROPAA_GetFontInfo,          \
N	GUIPROPAA_IsInFont,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROPAA         GUIPROPAA_DispChar,             	GUIPROPAA_GetCharDistX,         	GUIPROPAA_GetFontInfo,          	GUIPROPAA_IsInFont,               (tGUI_ENC_APIList*)0
N
N/* PROPAA: Proportional, antialiased fonts, 2bpp */
NDECLARE_FONT(PROP_AA2);
Xvoid GUIPROP_AA2_DispChar (unsigned short c); int GUIPROP_AA2_GetCharDistX(unsigned short c); void GUIPROP_AA2_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA2_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_PROP_AA2       \
N  GUIPROP_AA2_DispChar,             \
N	GUIPROP_AA2_GetCharDistX,         \
N	GUIPROP_AA2_GetFontInfo,          \
N	GUIPROP_AA2_IsInFont,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_AA2         GUIPROP_AA2_DispChar,             	GUIPROP_AA2_GetCharDistX,         	GUIPROP_AA2_GetFontInfo,          	GUIPROP_AA2_IsInFont,               (tGUI_ENC_APIList*)0
N
N/* PROPAA: Proportional, antialiased fonts, 2bpp, SJIS encoding */
NDECLARE_FONT(PROP_AA2);
Xvoid GUIPROP_AA2_DispChar (unsigned short c); int GUIPROP_AA2_GetCharDistX(unsigned short c); void GUIPROP_AA2_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA2_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_PROP_AA2_SJIS  \
N  GUIPROP_AA2_DispChar,             \
N	GUIPROP_AA2_GetCharDistX,         \
N	GUIPROP_AA2_GetFontInfo,          \
N	GUIPROP_AA2_IsInFont,             \
N  GUI_ENCODE_SJIS
X#define GUI_FONTTYPE_PROP_AA2_SJIS    GUIPROP_AA2_DispChar,             	GUIPROP_AA2_GetCharDistX,         	GUIPROP_AA2_GetFontInfo,          	GUIPROP_AA2_IsInFont,               GUI_ENCODE_SJIS
N
N/* PROPAA: Proportional, antialiased fonts, 4bpp */
NDECLARE_FONT(PROP_AA4);
Xvoid GUIPROP_AA4_DispChar (unsigned short c); int GUIPROP_AA4_GetCharDistX(unsigned short c); void GUIPROP_AA4_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA4_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_PROP_AA4       \
N  GUIPROP_AA4_DispChar,             \
N	GUIPROP_AA4_GetCharDistX,         \
N	GUIPROP_AA4_GetFontInfo,          \
N	GUIPROP_AA4_IsInFont,             \
N  (tGUI_ENC_APIList*)0
X#define GUI_FONTTYPE_PROP_AA4         GUIPROP_AA4_DispChar,             	GUIPROP_AA4_GetCharDistX,         	GUIPROP_AA4_GetFontInfo,          	GUIPROP_AA4_IsInFont,               (tGUI_ENC_APIList*)0
N
N/* PROPAA: Proportional, antialiased fonts, 4bpp, SJIS encoding */
NDECLARE_FONT(PROP_AA4);
Xvoid GUIPROP_AA4_DispChar (unsigned short c); int GUIPROP_AA4_GetCharDistX(unsigned short c); void GUIPROP_AA4_GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi); char GUIPROP_AA4_IsInFont (const GUI_FONT  * pFont, unsigned short c);
N#define GUI_FONTTYPE_PROP_AA4_SJIS  \
N  GUIPROP_AA4_DispChar,             \
N	GUIPROP_AA4_GetCharDistX,         \
N	GUIPROP_AA4_GetFontInfo,          \
N	GUIPROP_AA4_IsInFont,             \
N  GUI_ENCODE_SJIS
X#define GUI_FONTTYPE_PROP_AA4_SJIS    GUIPROP_AA4_DispChar,             	GUIPROP_AA4_GetCharDistX,         	GUIPROP_AA4_GetFontInfo,          	GUIPROP_AA4_IsInFont,               GUI_ENCODE_SJIS
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
Nstruct GUI_FONT {
N  GUI_DISPCHAR*     pfDispChar; 
N  GUI_GETCHARDISTX* pfGetCharDistX; 
N  GUI_GETFONTINFO*  pfGetFontInfo; 
N  GUI_ISINFONT*     pfIsInFont;
N  const tGUI_ENC_APIList* pafEncode;
N  U8 YSize;
X  unsigned char YSize;
N  U8 YDist;
X  unsigned char YDist;
N  U8 XMag;
X  unsigned char XMag;
N  U8 YMag;
X  unsigned char YMag;
N  union {
N    const void          GUI_UNI_PTR * pFontData;
X    const void           * pFontData;
N    const GUI_FONT_MONO GUI_UNI_PTR * pMono;
X    const GUI_FONT_MONO  * pMono;
N    const GUI_FONT_PROP GUI_UNI_PTR * pProp;
X    const GUI_FONT_PROP  * pProp;
N  } p;
N  U8 Baseline;
X  unsigned char Baseline;
N  U8 LHeight;     /* height of a small lower case character (a,x) */
X  unsigned char LHeight;      
N  U8 CHeight;     /* height of a small upper case character (A,X) */
X  unsigned char CHeight;      
N};
N
N/*********************************************************************
N*
N*       Position independent font structures
N*/
Ntypedef struct {
N  U32 ID;           /* Font file ID */
X  unsigned long ID;            
N  U16 YSize;        /* Height of font */
X  unsigned short YSize;         
N  U16 YDist;        /* Space of font Y */
X  unsigned short YDist;         
N  U16 Baseline;     /* Index of baseline */
X  unsigned short Baseline;      
N  U16 LHeight;      /* Height of a small lower case character (a) */
X  unsigned short LHeight;       
N  U16 CHeight;      /* Height of a upper case character (A) */
X  unsigned short CHeight;       
N  U16 NumAreas;     /* Number of character areas */
X  unsigned short NumAreas;      
N} GUI_SI_FONT;
N
Ntypedef struct {
N  U16 First;        /* Index of first character */
X  unsigned short First;         
N  U16 Last;         /* Index of last character */
X  unsigned short Last;          
N} GUI_SIF_CHAR_AREA;
N
Ntypedef struct {
N  U16 XSize;        /* Size of bitmap data in X */
X  unsigned short XSize;         
N  U16 XDist;        /* Number of pixels for increment cursor in X */
X  unsigned short XDist;         
N  U16 BytesPerLine; /* Number of bytes per line */
X  unsigned short BytesPerLine;  
N  U16 Dummy;
X  unsigned short Dummy;
N  U32 OffData;      /* Offset of pixel data */
X  unsigned long OffData;       
N} GUI_SIF_CHARINFO;
N
Ntypedef struct tGUI_SIF_APIList_struct {
N  GUI_DISPCHAR     * pDispChar;
N  GUI_GETCHARDISTX * pGetCharDistX;
N  GUI_GETFONTINFO  * pGetFontInfo;
N  GUI_ISINFONT     * pIsInFont;
N} tGUI_SIF_APIList;
N
N#define GUI_SIF_TYPE          tGUI_SIF_APIList
N#define GUI_SIF_TYPE_PROP     &GUI_SIF_APIList_Prop
N#define GUI_SIF_TYPE_PROP_AA2 &GUI_SIF_APIList_Prop_AA2
N#define GUI_SIF_TYPE_PROP_AA4 &GUI_SIF_APIList_Prop_AA4
N
N/*
N      *********************************
N      *                               *
N      *      Typedefs                 *
N      *                               *
N      *********************************
N*/
N
N#ifndef     GUI_HMEM
N  #if GUI_MAXBLOCKS < 32768
X  #if (2 + (1024*30) / 32) < 32768
N    #define     GUI_HMEM        I16P
N  #else
S    #define     GUI_HMEM        I32
N  #endif
N#endif
N#define     GUI_HMEM_NULL     (0)
Ntypedef     GUI_HMEM      GUI_HWIN;
Xtypedef     signed short      GUI_HWIN;
N#endif  /* GUITYPE_H_INCLUDED */
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 32 "..\GUI\Core\GUI.h" 2
N#include "GUIVersion.h"
L 1 "..\GUI\Core\GUIVersion.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : GUIVersion.h
NPurpose     : Include file defining current GUI version
N---------------------------END-OF-HEADER------------------------------
N*/
N
N#ifndef  GUI_VERSION_H
N#define  GUI_VERSION_H
N
N#define GUI_VERSION 39800
N
N#endif   /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 33 "..\GUI\Core\GUI.h" 2
N
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/*********************************************************************
N*
N*        Limitations for certain C51 Keil  (__C51__)
N*
N**********************************************************************
N*/
N#if defined (__C51__) && GUI_SUPPORT_MEMDEV
X#if 0L && 1
S  #error __C51__ (Keil) can not support function pointers sufficiently !  -> Disable memory devices  -> GUI_SUPPORT_MEMDEV 0
N#endif
N
N/*********************************************************************
N*
N*        macros, function replacement
N*
N**********************************************************************
N*/
N#define GUI_COUNTOF(a) (sizeof(a) / sizeof(a[0]))
N
N/************************************************************
N*
N*                    GUI_KEY_...
N*
N*************************************************************
NThese ID values are basically meant to be used with widgets
NNote that we have chosen the values to be close to existing
N"standards", so do not change them unless forced to.
N
N*/
N
N#define GUI_KEY_BACKSPACE         8         /* ASCII: BACKSPACE Crtl-H */
N#define GUI_KEY_TAB               9         /* ASCII: TAB       Crtl-I */
N#define GUI_KEY_BACKTAB           10
N#define GUI_KEY_ENTER             13        /* ASCII: ENTER     Crtl-M */
N#define GUI_KEY_LEFT              16
N#define GUI_KEY_UP                17
N#define GUI_KEY_RIGHT             18
N#define GUI_KEY_DOWN              19
N#define GUI_KEY_HOME              23
N#define GUI_KEY_END               24
N#define GUI_KEY_SHIFT             25
N#define GUI_KEY_CONTROL           26
N#define GUI_KEY_ESCAPE            27        /* ASCII: ESCAPE    0x1b   */
N#define GUI_KEY_INSERT            29
N#define GUI_KEY_DELETE            30
N#define GUI_KEY_SPACE             32
N#define GUI_KEY_PGUP              33
N#define GUI_KEY_PGDOWN            34
N
N#define GUI_KEY_F1                40
N#define GUI_KEY_F2                41
N
N#define GUI_KEY_NUM0		48
N#define GUI_KEY_NUM1		49
N#define GUI_KEY_NUM2		50
N#define GUI_KEY_NUM3		51
N#define GUI_KEY_NUM4		52
N#define GUI_KEY_NUM5		53
N#define GUI_KEY_NUM6		54
N#define GUI_KEY_NUM7		55
N#define GUI_KEY_NUM8		56
N#define GUI_KEY_NUM9		57
N
N#define GUI_KEY_STAR			42
N#define GUI_KEY_NUMBER_KEY	35
N
N#define GUI_KEY_LEFT_FUN		5
N#define GUI_KEY_RIGHT_FUN		6
N#define GUI_KEY_MIDDLE_FUN		GUI_KEY_ENTER
N
N
N/*********************************************************************
N*
N*       Dialog item IDs
N*
N*  The IDs below are arbitrary values. They just have to be unique
N*  within the dialog.
N*
N*  If you use your own Ids, we recommend to use values above GUI_ID_USER.
N*/
N
N#define GUI_ID_OK                1
N#define GUI_ID_CANCEL            2
N#define GUI_ID_YES               3
N#define GUI_ID_NO                4
N#define GUI_ID_CLOSE             5
N#define GUI_ID_HELP              6
N#define GUI_ID_MAXIMIZE          7
N#define GUI_ID_MINIMIZE          8
N
N#define GUI_ID_VSCROLL  0xFE
N#define GUI_ID_HSCROLL  0xFF
N
N#define GUI_ID_EDIT0    0x100
N#define GUI_ID_EDIT1    0x101
N#define GUI_ID_EDIT2    0x102
N#define GUI_ID_EDIT3    0x103
N#define GUI_ID_EDIT4    0x104
N#define GUI_ID_EDIT5    0x105
N#define GUI_ID_EDIT6    0x106
N#define GUI_ID_EDIT7    0x107
N#define GUI_ID_EDIT8    0x108
N#define GUI_ID_EDIT9    0x109
N
N#define GUI_ID_LISTBOX0 0x110
N#define GUI_ID_LISTBOX1 0x111
N#define GUI_ID_LISTBOX2 0x112
N#define GUI_ID_LISTBOX3 0x113
N#define GUI_ID_LISTBOX4 0x114
N#define GUI_ID_LISTBOX5 0x115
N#define GUI_ID_LISTBOX6 0x116
N#define GUI_ID_LISTBOX7 0x117
N#define GUI_ID_LISTBOX8 0x118
N#define GUI_ID_LISTBOX9 0x119
N
N#define GUI_ID_CHECK0   0x120
N#define GUI_ID_CHECK1   0x121
N#define GUI_ID_CHECK2   0x122
N#define GUI_ID_CHECK3   0x123
N#define GUI_ID_CHECK4   0x124
N#define GUI_ID_CHECK5   0x125
N#define GUI_ID_CHECK6   0x126
N#define GUI_ID_CHECK7   0x127
N#define GUI_ID_CHECK8   0x128
N#define GUI_ID_CHECK9   0x129
N
N#define GUI_ID_SLIDER0  0x130
N#define GUI_ID_SLIDER1  0x131
N#define GUI_ID_SLIDER2  0x132
N#define GUI_ID_SLIDER3  0x133
N#define GUI_ID_SLIDER4  0x134
N#define GUI_ID_SLIDER5  0x135
N#define GUI_ID_SLIDER6  0x136
N#define GUI_ID_SLIDER7  0x137
N#define GUI_ID_SLIDER8  0x138
N#define GUI_ID_SLIDER9  0x139
N
N#define GUI_ID_SCROLLBAR0 0x140
N#define GUI_ID_SCROLLBAR1 0x141
N#define GUI_ID_SCROLLBAR2 0x142
N#define GUI_ID_SCROLLBAR3 0x142
N
N#define GUI_ID_RADIO0 0x150
N#define GUI_ID_RADIO1 0x151
N#define GUI_ID_RADIO2 0x152
N#define GUI_ID_RADIO3 0x153
N#define GUI_ID_RADIO4 0x154
N#define GUI_ID_RADIO5 0x155
N#define GUI_ID_RADIO6 0x156
N#define GUI_ID_RADIO7 0x157
N
N#define GUI_ID_TEXT0  0x160
N#define GUI_ID_TEXT1  0x161
N#define GUI_ID_TEXT2  0x162
N#define GUI_ID_TEXT3  0x163
N#define GUI_ID_TEXT4  0x164
N#define GUI_ID_TEXT5  0x165
N#define GUI_ID_TEXT6  0x166
N#define GUI_ID_TEXT7  0x167
N#define GUI_ID_TEXT8  0x168
N#define GUI_ID_TEXT9  0x169
N
N#define GUI_ID_BUTTON0 0x170
N#define GUI_ID_BUTTON1 0x171
N#define GUI_ID_BUTTON2 0x172
N#define GUI_ID_BUTTON3 0x173
N#define GUI_ID_BUTTON4 0x174
N#define GUI_ID_BUTTON5 0x175
N#define GUI_ID_BUTTON6 0x176
N#define GUI_ID_BUTTON7 0x177
N#define GUI_ID_BUTTON8 0x178
N#define GUI_ID_BUTTON9 0x179
N
N#define GUI_ID_DROPDOWN0  0x180
N#define GUI_ID_DROPDOWN1  0x181
N#define GUI_ID_DROPDOWN2  0x182
N#define GUI_ID_DROPDOWN3  0x183
N
N#define GUI_ID_MULTIEDIT0 0x190
N#define GUI_ID_MULTIEDIT1 0x191
N#define GUI_ID_MULTIEDIT2 0x192
N#define GUI_ID_MULTIEDIT3 0x193
N
N#define GUI_ID_LISTVIEW0  0x200
N#define GUI_ID_LISTVIEW1  0x201
N#define GUI_ID_LISTVIEW2  0x202
N#define GUI_ID_LISTVIEW3  0x203
N
N#define GUI_ID_PROGBAR0   0x210
N#define GUI_ID_PROGBAR1   0x211
N#define GUI_ID_PROGBAR2   0x212
N#define GUI_ID_PROGBAR3   0x213
N
N#define GUI_ID_GRAPH0 0x220
N#define GUI_ID_GRAPH1 0x221
N#define GUI_ID_GRAPH2 0x222
N#define GUI_ID_GRAPH3 0x223
N
N#define GUI_ID_MULTIPAGE0 0x230
N#define GUI_ID_MULTIPAGE1 0x231
N#define GUI_ID_MULTIPAGE2 0x232
N#define GUI_ID_MULTIPAGE3 0x233
N
N#define GUI_ID_USER     0x800
N
N/*********************************************************************
N*
N*       Mouse buttons
N*/
N#define GUI_LBUTTON (1 << 0) /* Left button */
N#define GUI_RBUTTON (1 << 1) /* Right button */
N#define GUI_MBUTTON (1 << 2) /* Middle button */
N#define GUI_DBUTTON (1 << 7) /* Double-click button */
N
N/*********************************************************************
N*
N*       Wrap modes
N*/
Ntypedef enum { GUI_WRAPMODE_NONE, GUI_WRAPMODE_WORD, GUI_WRAPMODE_CHAR } GUI_WRAPMODE;
N
N/*********************************************************************
N*
N*               Constants  needed for GL
N*
N**********************************************************************
N*/
N
N/**********************************
N*
N*      Text styles
N*
N***********************************
N*/
N
N#define GUI_TS_NORMAL           (0)
N#define GUI_TS_UNDERLINE        (1 << 0)
N#define GUI_TS_STRIKETHRU       (1 << 1)
N#define GUI_TS_OVERLINE         (1 << 2)
N
N/**********************************
N*
N*      Line styles
N*
N***********************************
N*/
N
N#define GUI_LS_SOLID        (0)
N#define GUI_LS_DASH         (1)
N#define GUI_LS_DOT          (2)
N#define GUI_LS_DASHDOT      (3)
N#define GUI_LS_DASHDOTDOT   (4)
N
N
N/**********************************
N*
N*      Pen shapes
N*
N***********************************
N*/
N
N#define GUI_PS_ROUND        (0)
N#define GUI_PS_FLAT         (1)
N#define GUI_PS_SQUARE       (2)
N
N
N
N/*      *********************************
N        *
N        *      Standard colors
N        *
N        *********************************
N*/
N
N#define GUI_BLUE          0xFF0000
N#define GUI_GREEN         0x00FF00
N#define GUI_RED           0x0000FF
N#define GUI_CYAN          0xFFFF00
N#define GUI_MAGENTA       0xFF00FF
N#define GUI_YELLOW        0x00FFFF
N#define GUI_LIGHTBLUE     0xFF8080
N#define GUI_LIGHTGREEN    0x80FF80
N#define GUI_LIGHTRED      0x8080FF
N#define GUI_LIGHTCYAN     0xFFFF80
N#define GUI_LIGHTMAGENTA  0xFF80FF
N#define GUI_LIGHTYELLOW   0x80FFFF
N#define GUI_DARKBLUE      0x800000
N#define GUI_DARKGREEN     0x008000
N#define GUI_DARKRED       0x000080
N#define GUI_DARKCYAN      0x808000
N#define GUI_DARKMAGENTA   0x800080
N#define GUI_DARKYELLOW    0x008080
N#define GUI_WHITE         0xFFFFFF
N#define GUI_LIGHTGRAY     0xD3D3D3
N#define GUI_GRAY          0x808080
N#define GUI_DARKGRAY      0x404040
N#define GUI_BLACK         0x000000
N
N#define GUI_BROWN         0x2A2AA5
N
N#define GUI_INVALID_COLOR 0xFFFFFFF      /* Invalid color - more than 24 bits */
N
N/*      *********************************
N        *
N        *      Coordinates
N        *
N        *********************************
N*/
N#define GUI_COORD_X 0
N#define GUI_COORD_Y 1
N
N/*********************************************************************
N*
N*            Standard Fonts
N*
N**********************************************************************
N
NNote: The external declarations for the fonts are now also included in
N      this file.
N*/
N
N
N/* Proportional fonts */
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8_ASCII,        GUI_Font8_1;
Xextern const GUI_FONT GUI_Font8_ASCII,        GUI_Font8_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font10S_ASCII,      GUI_Font10S_1;
Xextern const GUI_FONT GUI_Font10S_ASCII,      GUI_Font10S_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font10_ASCII,       GUI_Font10_1;
Xextern const GUI_FONT GUI_Font10_ASCII,       GUI_Font10_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13_ASCII,       GUI_Font13_1;
Xextern const GUI_FONT GUI_Font13_ASCII,       GUI_Font13_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13B_ASCII,      GUI_Font13B_1;
Xextern const GUI_FONT GUI_Font13B_ASCII,      GUI_Font13B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13H_ASCII,      GUI_Font13H_1;
Xextern const GUI_FONT GUI_Font13H_ASCII,      GUI_Font13H_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font13HB_ASCII,     GUI_Font13HB_1;
Xextern const GUI_FONT GUI_Font13HB_ASCII,     GUI_Font13HB_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font16_ASCII,       GUI_Font16_1,       GUI_Font16_HK,    GUI_Font16_1HK;
Xextern const GUI_FONT GUI_Font16_ASCII,       GUI_Font16_1,       GUI_Font16_HK,    GUI_Font16_1HK;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font16B_ASCII,      GUI_Font16B_1;
Xextern const GUI_FONT GUI_Font16B_ASCII,      GUI_Font16B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font24_ASCII,       GUI_Font24_1;
Xextern const GUI_FONT GUI_Font24_ASCII,       GUI_Font24_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font24B_ASCII,      GUI_Font24B_1;
Xextern const GUI_FONT GUI_Font24B_ASCII,      GUI_Font24B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font32_ASCII,       GUI_Font32_1;
Xextern const GUI_FONT GUI_Font32_ASCII,       GUI_Font32_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font32B_ASCII,      GUI_Font32B_1;
Xextern const GUI_FONT GUI_Font32B_ASCII,      GUI_Font32B_1;
N
N/* Monospaced */
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font4x6;
Xextern const GUI_FONT GUI_Font4x6;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font6x8,            GUI_Font6x9;
Xextern const GUI_FONT GUI_Font6x8,            GUI_Font6x9;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x8,            GUI_Font8x9;
Xextern const GUI_FONT GUI_Font8x8,            GUI_Font8x9;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x10_ASCII;
Xextern const GUI_FONT GUI_Font8x10_ASCII;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x12_ASCII;
Xextern const GUI_FONT GUI_Font8x12_ASCII;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x13_ASCII,     GUI_Font8x13_1;
Xextern const GUI_FONT GUI_Font8x13_ASCII,     GUI_Font8x13_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x15B_ASCII,    GUI_Font8x15B_1;
Xextern const GUI_FONT GUI_Font8x15B_ASCII,    GUI_Font8x15B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x16,           GUI_Font8x17,       GUI_Font8x18;
Xextern const GUI_FONT GUI_Font8x16,           GUI_Font8x17,       GUI_Font8x18;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_Font8x16x1x2,       GUI_Font8x16x2x2,   GUI_Font8x16x3x3;
Xextern const GUI_FONT GUI_Font8x16x1x2,       GUI_Font8x16x2x2,   GUI_Font8x16x3x3;
N
N/* Digits */
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD24x32;
Xextern const GUI_FONT GUI_FontD24x32;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD32;
Xextern const GUI_FONT GUI_FontD32;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD36x48;
Xextern const GUI_FONT GUI_FontD36x48;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD48;
Xextern const GUI_FONT GUI_FontD48;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD48x64;
Xextern const GUI_FONT GUI_FontD48x64;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD64;
Xextern const GUI_FONT GUI_FontD64;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD60x80;
Xextern const GUI_FONT GUI_FontD60x80;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontD80;
Xextern const GUI_FONT GUI_FontD80;
N
N/* Comic fonts */
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontComic18B_ASCII, GUI_FontComic18B_1;
Xextern const GUI_FONT GUI_FontComic18B_ASCII, GUI_FontComic18B_1;
Nextern GUI_CONST_STORAGE GUI_FONT GUI_FontComic24B_ASCII, GUI_FontComic24B_1;
Xextern const GUI_FONT GUI_FontComic24B_ASCII, GUI_FontComic24B_1;
N
N
N/*
N      *********************************
N      *                               *
N      * Text and drawing mode defines *
N      *                               *
N      *********************************
N
NThese defines come in two flavors: the long version (.._DRAWMODE_..)
Nand the short ones (.._DM_..). They are identical, feel free to use
Nwhich ever one you like best.
N
N*/
N
N#define GUI_DRAWMODE_NORMAL  LCD_DRAWMODE_NORMAL
N#define GUI_DRAWMODE_XOR     LCD_DRAWMODE_XOR
N#define GUI_DRAWMODE_TRANS   LCD_DRAWMODE_TRANS
N#define GUI_DRAWMODE_REV     LCD_DRAWMODE_REV
N#define GUI_DM_NORMAL        LCD_DRAWMODE_NORMAL
N#define GUI_DM_XOR           LCD_DRAWMODE_XOR
N#define GUI_DM_TRANS         LCD_DRAWMODE_TRANS
N#define GUI_DM_REV           LCD_DRAWMODE_REV
N
N#define GUI_TEXTMODE_NORMAL  LCD_DRAWMODE_NORMAL
N#define GUI_TEXTMODE_XOR     LCD_DRAWMODE_XOR
N#define GUI_TEXTMODE_TRANS   LCD_DRAWMODE_TRANS
N#define GUI_TEXTMODE_REV     LCD_DRAWMODE_REV
N#define GUI_TM_NORMAL        LCD_DRAWMODE_NORMAL
N#define GUI_TM_XOR           LCD_DRAWMODE_XOR
N#define GUI_TM_TRANS         LCD_DRAWMODE_TRANS
N#define GUI_TM_REV           LCD_DRAWMODE_REV
N
N/* Text alignment flags, horizontal */
N#define GUI_TA_HORIZONTAL  (3<<0)
N#define GUI_TA_LEFT        (0<<0)
N#define GUI_TA_RIGHT	     (1<<0)
N#define GUI_TA_CENTER	     (2<<0)
N#define GUI_TA_HCENTER	   GUI_TA_CENTER  /* easier to remember :-)  */
N
N/* Text alignment flags, vertical */
N#define GUI_TA_VERTICAL   (3<<2)
N#define GUI_TA_TOP	      (0<<2)
N#define GUI_TA_BOTTOM	    (1<<2)
N#define GUI_TA_BASELINE   (2<<2)
N#define GUI_TA_VCENTER    (3<<2)
N
N/*    *********************************
N      *
N      *     Min/Max coordinates
N      *
N      *********************************
N*/
N/* Define minimum and maximum coordinates in x and y */
N#define GUI_XMIN -4095
N#define GUI_XMAX  4095
N#define GUI_YMIN -4095
N#define GUI_YMAX  4095
N
N/*********************************************************************
N*
N*       Support for multitasking systems (locking)
N*
N**********************************************************************
N*/
N
Ntypedef struct GUI_CONTEXT GUI_CONTEXT;
N
N#if !GUI_OS
X#if !(0)
N  #define GUI_LOCK()
N  #define GUI_UNLOCK()
N  #define GUITASK_INIT()
N  #define GUITASK_COPY_CONTEXT()
N#else
S  void GUI_Lock(void);
S  void GUI_Unlock(void);
S  void GUITASK_Init(void);
S  void GUITASK_CopyContext(void);
S  GUI_CONTEXT * GUITASK_GetpContext(int Index);
S  #define GUI_LOCK()             GUI_Lock()
S  #define GUI_UNLOCK()           GUI_Unlock()
S  #define GUITASK_INIT()         GUITASK_Init()
S  #define GUITASK_COPY_CONTEXT() GUITASK_CopyContext()
N#endif
N
N/*********************************************************************
N*
N*             GUI_CONTEXT
N*
N**********************************************************************
N
N  This structure is public for one reason only:
N  To allow the application to save and restore the context.
N*/
N
Ntypedef union {
N  U8  aColorIndex8[2];
X  unsigned char  aColorIndex8[2];
N  U16 aColorIndex16[2];
X  unsigned short aColorIndex16[2];
N  U32 aColorIndex32[2];
X  unsigned long aColorIndex32[2];
N} LCD_COLORINDEX_UNION;
N
Nstruct GUI_CONTEXT {
N/* Variables in LCD module */
N  LCD_COLORINDEX_UNION LCD;
N  LCD_RECT       ClipRect;
N  U8             DrawMode;
X  unsigned char             DrawMode;
N  U8             SelLayer;
X  unsigned char             SelLayer;
N  U8             TextStyle;
X  unsigned char             TextStyle;
N/* Variables in GL module */
N  GUI_RECT* pClipRect_HL;                /* High level clip rectangle ... Speed optimization so drawing routines can optimize */
N  U8        PenSize;
X  unsigned char        PenSize;
N  U8        PenShape;
X  unsigned char        PenShape;
N  U8        LineStyle;
X  unsigned char        LineStyle;
N  U8        FillStyle;
X  unsigned char        FillStyle;
N/* Variables in GUICHAR module */
N  const GUI_FONT           GUI_UNI_PTR * pAFont;
X  const GUI_FONT            * pAFont;
N  #if GUI_SUPPORT_UNICODE
X  #if (1)
N    const GUI_UC_ENC_APILIST * pUC_API;    /* Unicode encoding API */
N  #endif
N  I16P LBorder;
X  signed short LBorder;
N  I16P DispPosX, DispPosY;
X  signed short DispPosX, DispPosY;
N  I16P DrawPosX, DrawPosY;
X  signed short DrawPosX, DrawPosY;
N  I16P TextMode, TextAlign;
X  signed short TextMode, TextAlign;
N  GUI_COLOR Color, BkColor;           /* Required only when changing devices and for speed opt (caching) */
N/* Variables in WM module */
N  #if GUI_WINSUPPORT
X  #if 1
N    const GUI_RECT* WM__pUserClipRect;
N    GUI_HWIN hAWin;
N    int xOff, yOff;
N  #endif
N/* Variables in MEMDEV module (with memory devices only) */
N  #if GUI_SUPPORT_DEVICES
X  #if (1 | (1 > 1))
N    const tLCDDEV_APIList* pDeviceAPI;  /* function pointers only */
N    GUI_HMEM    hDevData;
X    signed short    hDevData;
N    GUI_RECT    ClipRectPrev;
N  #endif
N/* Variables in Anitaliasing module */
N  #if GUI_SUPPORT_AA
X  #if 1
N    const tLCD_HL_APIList* pLCD_HL;     /* Required to reroute drawing (HLine & Pixel) to the AA module */
N    U8 AA_Factor;
X    unsigned char AA_Factor;
N    U8 AA_HiResEnable;
X    unsigned char AA_HiResEnable;
N  #endif
N};
N
N/* Rename GUI_SaveContext in order to avoid crashes if wrong GUIConf is used */
N#if   ( GUI_WINSUPPORT &&  GUI_SUPPORT_DEVICES)
X#if   ( 1 &&  (1 | (1 > 1)))
N  #define GUI_SaveContext GUI_SaveContext_W_M
N#elif (!GUI_WINSUPPORT &&  GUI_SUPPORT_DEVICES)
S  #define GUI_SaveContext GUI_SaveContext_M
S#elif ( GUI_WINSUPPORT && !GUI_SUPPORT_DEVICES)
S  #define GUI_SaveContext GUI_SaveContext_W
S#else
S  #define GUI_SaveContext GUI_SaveContext_
N#endif
N
N/*********************************************************************
N*
N*             General routines
N*
N**********************************************************************
N*/
Nint          GUI_Init             (void);
Nvoid         GUI_SetDefault       (void);
NGUI_DRAWMODE GUI_SetDrawMode      (GUI_DRAWMODE dm);
Nconst char * GUI_GetVersionString (void);
Nvoid         GUI_SaveContext      (      GUI_CONTEXT* pContext);
Xvoid         GUI_SaveContext_W_M      (      GUI_CONTEXT* pContext);
Nvoid         GUI_RestoreContext   (const GUI_CONTEXT* pContext);
Nvoid         GUI_SetScreenSizeX   (int xSize);
Nvoid         GUI_SetScreenSizeY   (int ySize);
Nint          GUI_GetScreenSizeX   (void);
Nint          GUI_GetScreenSizeY   (void);
Nconst GUI_RECT * GUI_SetClipRect  (const GUI_RECT * pRect);
N
N/*********************************************************************
N*
N*           Rectangle helper functions
N*
N**********************************************************************
N*/
N
Nint  GUI_RectsIntersect(const GUI_RECT* pr0, const GUI_RECT* pr1);
Nvoid GUI_MoveRect       (GUI_RECT *pRect, int x, int y);
Nvoid GUI_MergeRect      (GUI_RECT* pDest, const GUI_RECT* pr0, const GUI_RECT* pr1);
Nint  GUI__IntersectRects(GUI_RECT* pDest, const GUI_RECT* pr0, const GUI_RECT* pr1);
Nvoid GUI__IntersectRect (GUI_RECT* pDest, const GUI_RECT* pr0);
Nvoid GUI__ReduceRect    (GUI_RECT* pDest, const GUI_RECT *pRect, int Dist);
N
N/*********************************************************************
N*
N*       Misc helper functions
N*
N**********************************************************************
N*/
N
Nint  GUI__DivideRound     (int a, int b);
NI32  GUI__DivideRound32   (I32 a, I32 b);
Xsigned long  GUI__DivideRound32   (signed long a, signed long b);
Nint  GUI__SetText(GUI_HMEM* phText, const char* s);
Xint  GUI__SetText(signed short* phText, const char* s);
N
N
N
N/*********************************************************************
N*
N*      Get / Set Attributes
N*
N**********************************************************************
N*/
N 
NGUI_COLOR GUI_GetBkColor     (void);
NGUI_COLOR GUI_GetColor       (void);
Nint       GUI_GetBkColorIndex(void);
Nint       GUI_GetColorIndex  (void);
NU8        GUI_GetPenSize     (void);
Xunsigned char        GUI_GetPenSize     (void);
NU8        GUI_GetPenShape    (void);
Xunsigned char        GUI_GetPenShape    (void);
NU8        GUI_GetLineStyle   (void);
Xunsigned char        GUI_GetLineStyle   (void);
NU8        GUI_GetFillStyle   (void);
Xunsigned char        GUI_GetFillStyle   (void);
N
Nvoid      GUI_SetBkColor   (GUI_COLOR);
Nvoid      GUI_SetColor     (GUI_COLOR);
Nvoid      GUI_SetBkColorIndex(int Index);
Nvoid      GUI_SetColorIndex(int Index);
N
NU8        GUI_SetPenSize   (U8 Size);
Xunsigned char        GUI_SetPenSize   (unsigned char Size);
NU8        GUI_SetPenShape  (U8 Shape);
Xunsigned char        GUI_SetPenShape  (unsigned char Shape);
NU8        GUI_SetLineStyle (U8 Style);
Xunsigned char        GUI_SetLineStyle (unsigned char Style);
NU8        GUI_SetFillStyle (U8 Style);
Xunsigned char        GUI_SetFillStyle (unsigned char Style);
N
N/* Get/Set Character used as decimal point (usually '.' or ',') */
Nchar      GUI_GetDecChar(void);
Nchar      GUI_SetDecChar(char c);
N
N
N/*********************************************************************
N*
N*       Color / Index related functions
N*
N**********************************************************************
N*/
N
Nint       GUI_Color2Index(GUI_COLOR color);
NGUI_COLOR GUI_Color2VisColor(GUI_COLOR color);
Nchar      GUI_ColorIsAvailable(GUI_COLOR color);
NGUI_COLOR GUI_Index2Color(int Index);
Nvoid      GUI_InitLUT(void);
Nvoid      GUI_SetLUTEntry (U8 Pos, GUI_COLOR Color);
Xvoid      GUI_SetLUTEntry (unsigned char Pos, GUI_COLOR Color);
Nvoid      GUI_SetLUTColor (U8 Pos, GUI_COLOR Color);
Xvoid      GUI_SetLUTColor (unsigned char Pos, GUI_COLOR Color);
Nvoid      GUI_SetLUTColorEx(U8 Pos, LCD_COLOR Color, unsigned int LayerIndex);
Xvoid      GUI_SetLUTColorEx(unsigned char Pos, LCD_COLOR Color, unsigned int LayerIndex);
NU32       GUI_CalcColorDist (GUI_COLOR Color0, GUI_COLOR  Color1);
Xunsigned long       GUI_CalcColorDist (GUI_COLOR Color0, GUI_COLOR  Color1);
NU32       GUI_CalcVisColorError(GUI_COLOR color);
Xunsigned long       GUI_CalcVisColorError(GUI_COLOR color);
N
N/*********************************************************************
N*
N*       Logging (for debugging primarily)
N*
N**********************************************************************
N*/
Nvoid GUI_Log      (const char *s);
Nvoid GUI_Log1     (const char *s, int p0);
Nvoid GUI_Log2     (const char *s, int p0, int p1);
Nvoid GUI_Log3     (const char *s, int p0, int p1, int p2);
Nvoid GUI_Log4     (const char *s, int p0, int p1, int p2,int p3);
Nvoid GUI_Warn     (const char *s);
Nvoid GUI_Warn1    (const char *s, int p0);
Nvoid GUI_Warn2    (const char *s, int p0, int p1);
Nvoid GUI_Warn3    (const char *s, int p0, int p1, int p2);
Nvoid GUI_Warn4    (const char *s, int p0, int p1, int p2, int p3);
Nvoid GUI_ErrorOut (const char *s);
Nvoid GUI_ErrorOut1(const char *s, int p0);
Nvoid GUI_ErrorOut2(const char *s, int p0, int p1);
Nvoid GUI_ErrorOut3(const char *s, int p0, int p1, int p2);
Nvoid GUI_ErrorOut4(const char *s, int p0, int p1, int p2, int p3);
N
N/*********************************************************************
N*
N*             2d - GL
N*
N**********************************************************************
N*/
N
Nint  GUI_BMP_Draw         (const void * pFileData, int x0, int y0);
Nint  GUI_BMP_GetXSize     (const void * pFileData);
Nint  GUI_BMP_GetYSize     (const void * pFileData);
Nvoid GUI_Clear            (void);
Nvoid GUI_ClearRect        (int x0, int y0, int x1, int y1);
Nvoid GUI_ClearRectEx      (const GUI_RECT* pRect);
Nvoid GUI_DrawArc          (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GUI_DrawBitmap       (const GUI_BITMAP GUI_UNI_PTR * pBM, int x0, int y0);
Xvoid GUI_DrawBitmap       (const GUI_BITMAP  * pBM, int x0, int y0);
Nvoid GUI_DrawBitmapMag    (const GUI_BITMAP GUI_UNI_PTR * pBM, int x0, int y0, int XMul, int YMul);
Xvoid GUI_DrawBitmapMag    (const GUI_BITMAP  * pBM, int x0, int y0, int XMul, int YMul);
Nvoid GUI_DrawBitmapEx     (const GUI_BITMAP GUI_UNI_PTR * pBitmap, int x0, int y0, int xCenter, int yCenter, int xMag, int yMag);
Xvoid GUI_DrawBitmapEx     (const GUI_BITMAP  * pBitmap, int x0, int y0, int xCenter, int yCenter, int xMag, int yMag);
Nvoid GUI_DrawBitmapExp    (int x0, int y0, int XSize, int YSize, int XMul,  int YMul, int BitsPerPixel, int BytesPerLine, const U8 GUI_UNI_PTR * pData, const GUI_LOGPALETTE GUI_UNI_PTR * pPal);
Xvoid GUI_DrawBitmapExp    (int x0, int y0, int XSize, int YSize, int XMul,  int YMul, int BitsPerPixel, int BytesPerLine, const unsigned char  * pData, const GUI_LOGPALETTE  * pPal);
Nvoid GUI_DrawCircle       (int x0, int y0, int r);
Nvoid GUI_DrawEllipse      (int x0, int y0, int rx, int ry);
Nvoid GUI_DrawGraph        (I16 *pay, int NumPoints, int x0, int y0);
Xvoid GUI_DrawGraph        (signed short *pay, int NumPoints, int x0, int y0);
Nvoid GUI_DrawGraphEx      (I16 *pay, int NumPoints, int x0, int y0, int Numerator, int Denominator);
Xvoid GUI_DrawGraphEx      (signed short *pay, int NumPoints, int x0, int y0, int Numerator, int Denominator);
Nvoid GUI_DrawHLine        (int y0, int x0, int x1);
Nvoid GUI_DrawLine         (int x0, int y0, int x1, int y1);
Nvoid GUI_DrawLineRel      (int dx, int dy);
Nvoid GUI_DrawLineTo       (int x, int y);
Nvoid GUI_DrawPie          (int x0, int y0, int r, int a0, int a1, int Type);
Nvoid GUI_DrawPixel        (int x, int y);
Nvoid GUI_DrawPoint        (int x, int y);
Nvoid GUI_DrawPolygon      (const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_DrawPolyLine     (const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_DrawFocusRect    (const GUI_RECT *pRect, int Dist);
Nvoid GUI_DrawRect         (int x0, int y0, int x1, int y1);
Nvoid GUI_DrawRectEx       (const GUI_RECT *pRect);
Nvoid GUI_DrawVLine        (int x0, int y0, int y1);
Nvoid GUI_FillCircle       (int x0, int y0, int r);
Nvoid GUI_FillEllipse      (int x0, int y0, int rx, int ry);
Nvoid GUI_FillPolygon      (const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Nvoid GUI_FillRect         (int x0, int y0, int x1, int y1);
Nvoid GUI_FillRectEx       (const GUI_RECT* pRect);
Nvoid GUI_GetClientRect    (GUI_RECT* pRect);
Nint  GUI_GIF_Draw         (const void * pGIF, U32 NumBytes, int x0, int y0);
Xint  GUI_GIF_Draw         (const void * pGIF, unsigned long NumBytes, int x0, int y0);
Nint  GUI_GIF_DrawEx       (const void * pGIF, U32 NumBytes, int x0, int y0, int Index);
Xint  GUI_GIF_DrawEx       (const void * pGIF, unsigned long NumBytes, int x0, int y0, int Index);
Nint  GUI_GIF_GetComment   (const void * pGIF, U32 NumBytes, U8 * pBuffer, int MaxSize, int Index);
Xint  GUI_GIF_GetComment   (const void * pGIF, unsigned long NumBytes, unsigned char * pBuffer, int MaxSize, int Index);
Nint  GUI_GIF_GetXSize     (const void * pGIF);
Nint  GUI_GIF_GetYSize     (const void * pGIF);
Nint  GUI_GIF_GetImageInfo (const void * pGIF, U32 NumBytes, GUI_GIF_IMAGE_INFO * pInfo, int Index);
Xint  GUI_GIF_GetImageInfo (const void * pGIF, unsigned long NumBytes, GUI_GIF_IMAGE_INFO * pInfo, int Index);
Nint  GUI_GIF_GetInfo      (const void * pGIF, U32 NumBytes, GUI_GIF_INFO * pInfo);
Xint  GUI_GIF_GetInfo      (const void * pGIF, unsigned long NumBytes, GUI_GIF_INFO * pInfo);
Nvoid GUI_InvertRect       (int x0, int y0, int x1, int y1);
Nvoid GUI_MoveRel          (int dx, int dy);
Nvoid GUI_MoveTo           (int x, int y);
N
N/*********************************************************************
N*
N*       JPEG support
N*
N**********************************************************************
N*/
Ntypedef struct {
N  int XSize;
N  int YSize;
N} GUI_JPEG_INFO;
N
Ntypedef int GUI_JPEG_GET_DATA_FUNC(void * p, int MaxNumBytes, const U8 ** ppData, unsigned StartOfFile);
Xtypedef int GUI_JPEG_GET_DATA_FUNC(void * p, int MaxNumBytes, const unsigned char ** ppData, unsigned StartOfFile);
N
Nint  GUI_JPEG_Draw        (const void * pFileData, int DataSize, int x0, int y0);
Nint  GUI_JPEG_DrawEx      (GUI_JPEG_GET_DATA_FUNC * fpGetData, void * p, int x0, int y0);
Nint  GUI_JPEG_DrawScaled  (const void * pFileData, int DataSize, int x0, int y0, int Num, int Denom);
Nint  GUI_JPEG_DrawScaledEx(GUI_JPEG_GET_DATA_FUNC * fpGetData, void * p, int x0, int y0, int Num, int Denom);
Nint  GUI_JPEG_GetInfo     (const void * pFileData, int DataSize, GUI_JPEG_INFO* pInfo);
Nint  GUI_JPEG_GetInfoEx   (GUI_JPEG_GET_DATA_FUNC * fpGetData, void * p, GUI_JPEG_INFO * pInfo);
N
N/*********************************************************************
N*
N*              Cursor routines
N*
N**********************************************************************
N*/
N
Ntypedef struct {
N  const GUI_UNI_PTR GUI_BITMAP * pBitmap;
X  const  GUI_BITMAP * pBitmap;
N  int xHot, yHot;
N} GUI_CURSOR;
N
N#if GUI_SUPPORT_CURSOR
X#if (0 | (1))
N  void               GUI_CURSOR_Activate   (void);
N  void               GUI_CURSOR_Deactivate (void);
N  int                GUI_CURSOR_GetState   (void);
N  void               GUI_CURSOR_Hide       (void);
N  void               GUI_CURSOR_SetXor     (const GUI_BITMAP * pBM, int x, int y);
N  void               GUI_CURSOR_SetPosition(int x, int y);
N  const GUI_CURSOR GUI_UNI_PTR * GUI_CURSOR_Select     (const GUI_CURSOR GUI_UNI_PTR * pCursor);
X  const GUI_CURSOR  * GUI_CURSOR_Select     (const GUI_CURSOR  * pCursor);
N  void               GUI_CURSOR_Show       (void);
N#else
S  #define GUI_CURSOR_Show()
S  #define GUI_CURSOR_Clear();
N#endif
N
N/*********************************************************************
N*
N*       Cursors and their bitmaps
N*
N**********************************************************************
N*/
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowS,  GUI_CursorArrowSI;
Xextern const GUI_CURSOR GUI_CursorArrowS,  GUI_CursorArrowSI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowM,  GUI_CursorArrowMI;
Xextern const GUI_CURSOR GUI_CursorArrowM,  GUI_CursorArrowMI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorArrowL,  GUI_CursorArrowLI;
Xextern const GUI_CURSOR GUI_CursorArrowL,  GUI_CursorArrowLI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossS,  GUI_CursorCrossSI;
Xextern const GUI_CURSOR GUI_CursorCrossS,  GUI_CursorCrossSI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossM,  GUI_CursorCrossMI;
Xextern const GUI_CURSOR GUI_CursorCrossM,  GUI_CursorCrossMI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorCrossL,  GUI_CursorCrossLI;
Xextern const GUI_CURSOR GUI_CursorCrossL,  GUI_CursorCrossLI;
Nextern GUI_CONST_STORAGE GUI_CURSOR GUI_CursorHeaderM, GUI_CursorHeaderMI;
Xextern const GUI_CURSOR GUI_CursorHeaderM, GUI_CursorHeaderMI;
N
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapArrowS, GUI_BitmapArrowSI;
Xextern const GUI_BITMAP GUI_BitmapArrowS, GUI_BitmapArrowSI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapArrowM, GUI_BitmapArrowMI;
Xextern const GUI_BITMAP GUI_BitmapArrowM, GUI_BitmapArrowMI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapArrowL, GUI_BitmapArrowLI;
Xextern const GUI_BITMAP GUI_BitmapArrowL, GUI_BitmapArrowLI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapCrossS, GUI_BitmapCrossSI;
Xextern const GUI_BITMAP GUI_BitmapCrossS, GUI_BitmapCrossSI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapCrossM, GUI_BitmapCrossMI;
Xextern const GUI_BITMAP GUI_BitmapCrossM, GUI_BitmapCrossMI;
Nextern GUI_CONST_STORAGE GUI_BITMAP GUI_BitmapCrossL, GUI_BitmapCrossLI;
Xextern const GUI_BITMAP GUI_BitmapCrossL, GUI_BitmapCrossLI;
N
N/*********************************************************************
N*
N*              Text related routines
N*
N**********************************************************************
N*/
N
Nvoid  GUI_DispCEOL (void);
Nvoid  GUI_DispChar  (U16 c);
Xvoid  GUI_DispChar  (unsigned short c);
Nvoid  GUI_DispChars (U16 c, int Cnt);
Xvoid  GUI_DispChars (unsigned short c, int Cnt);
Nvoid  GUI_DispCharAt(U16 c, I16P x, I16P y);
Xvoid  GUI_DispCharAt(unsigned short c, signed short x, signed short y);
Nvoid  GUI_DispString         (const char GUI_UNI_PTR *s);
Xvoid  GUI_DispString         (const char  *s);
Nvoid  GUI_DispStringAt       (const char GUI_UNI_PTR *s, int x, int y);
Xvoid  GUI_DispStringAt       (const char  *s, int x, int y);
Nvoid  GUI_DispStringAtCEOL   (const char GUI_UNI_PTR *s, int x, int y);
Xvoid  GUI_DispStringAtCEOL   (const char  *s, int x, int y);
Nvoid  GUI_DispStringHCenterAt(const char GUI_UNI_PTR *s, int x, int y);
Xvoid  GUI_DispStringHCenterAt(const char  *s, int x, int y);
Nvoid  GUI__DispStringInRect  (const char GUI_UNI_PTR *s, GUI_RECT* pRect, int TextAlign, int MaxNumChars);
Xvoid  GUI__DispStringInRect  (const char  *s, GUI_RECT* pRect, int TextAlign, int MaxNumChars);
Nvoid  GUI_DispStringInRect   (const char GUI_UNI_PTR *s, GUI_RECT* pRect, int Flags);
Xvoid  GUI_DispStringInRect   (const char  *s, GUI_RECT* pRect, int Flags);
N#if GUI_SUPPORT_ROTATION
X#if 1
N  void  GUI_DispStringInRectEx (const char GUI_UNI_PTR *s, GUI_RECT* pRect, int TextAlign, int MaxLen, const GUI_ROTATION * pLCD_Api);
X  void  GUI_DispStringInRectEx (const char  *s, GUI_RECT* pRect, int TextAlign, int MaxLen, const tLCD_APIList * pLCD_Api);
N#endif
Nvoid  GUI_DispStringInRectMax(const char GUI_UNI_PTR *s, GUI_RECT* pRect, int TextAlign, int MaxLen); /* Not to be doc. */
Xvoid  GUI_DispStringInRectMax(const char  *s, GUI_RECT* pRect, int TextAlign, int MaxLen);  
Nvoid  GUI_DispStringInRectWrap(const char GUI_UNI_PTR *s, GUI_RECT* pRect, int TextAlign, GUI_WRAPMODE WrapMode); /* Not to be doc. */
Xvoid  GUI_DispStringInRectWrap(const char  *s, GUI_RECT* pRect, int TextAlign, GUI_WRAPMODE WrapMode);  
Nvoid  GUI_DispStringLen      (const char GUI_UNI_PTR *s, int Len);
Xvoid  GUI_DispStringLen      (const char  *s, int Len);
Nvoid  GUI_GetTextExtend(GUI_RECT* pRect, const char GUI_UNI_PTR * s, int Len);
Xvoid  GUI_GetTextExtend(GUI_RECT* pRect, const char  * s, int Len);
Nint   GUI_GetYAdjust(void);
Nint   GUI_GetDispPosX(void);
Nint   GUI_GetDispPosY(void);
Nconst GUI_FONT GUI_UNI_PTR * GUI_GetFont(void);
Xconst GUI_FONT  * GUI_GetFont(void);
Nint   GUI_GetCharDistX(U16 c);
Xint   GUI_GetCharDistX(unsigned short c);
Nint   GUI_GetStringDistX(const char GUI_UNI_PTR *s);
Xint   GUI_GetStringDistX(const char  *s);
NGUI_DRAWMODE GUI_GetDrawMode(void);
Nint   GUI_GetFontDistY(void);
Nint   GUI_GetFontSizeY(void);
Nvoid  GUI_GetFontInfo   (const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO* pfi);
Xvoid  GUI_GetFontInfo   (const GUI_FONT  * pFont, GUI_FONTINFO* pfi);
Nvoid  GUI_GetOrg(int * px, int * py);
Nint   GUI_GetYSizeOfFont(const GUI_FONT GUI_UNI_PTR * pFont);
Xint   GUI_GetYSizeOfFont(const GUI_FONT  * pFont);
Nint   GUI_GetYDistOfFont(const GUI_FONT GUI_UNI_PTR * pFont);
Xint   GUI_GetYDistOfFont(const GUI_FONT  * pFont);
Nint   GUI_GetTextAlign(void);
Nint   GUI_GetTextMode(void);
Nchar  GUI_IsInFont(const GUI_FONT GUI_UNI_PTR * pFont, U16 c);
Xchar  GUI_IsInFont(const GUI_FONT  * pFont, unsigned short c);
Nint   GUI_SetTextAlign(int Align);
Nint   GUI_SetTextMode(int Mode);
Nchar  GUI_SetTextStyle(char Style);
Nint   GUI_SetLBorder(int x);
Nvoid  GUI_SetOrg(int x, int y);
Nconst GUI_FONT GUI_UNI_PTR * GUI_SetFont(const GUI_FONT GUI_UNI_PTR * pNewFont);
Xconst GUI_FONT  * GUI_SetFont(const GUI_FONT  * pNewFont);
Nchar  GUI_GotoXY(int x, int y);
Nchar  GUI_GotoX(int x);
Nchar  GUI_GotoY(int y);
Nvoid  GUI_DispNextLine(void);
N
N/*********************************************************************
N*
N*       Position independent fonts
N*
N**********************************************************************
N*/
Nvoid GUI_SIF_CreateFont(void * pFontData, GUI_FONT * pFont, const GUI_SIF_TYPE * pFontType);
Xvoid GUI_SIF_CreateFont(void * pFontData, GUI_FONT * pFont, const tGUI_SIF_APIList * pFontType);
Nvoid GUI_SIF_DeleteFont(GUI_FONT * pFont);
N
N/*********************************************************************
N*
N*         Unicode support
N*
N**********************************************************************
N*/
N
Nint   GUI_UC_ConvertUC2UTF8   (const U16 GUI_UNI_PTR * s, int Len, char * pBuffer, int BufferSize);
Xint   GUI_UC_ConvertUC2UTF8   (const unsigned short  * s, int Len, char * pBuffer, int BufferSize);
Nint   GUI_UC_ConvertUTF82UC   (const char GUI_UNI_PTR * s, int Len, U16 * pBuffer, int BufferSize);
Xint   GUI_UC_ConvertUTF82UC   (const char  * s, int Len, unsigned short * pBuffer, int BufferSize);
Nint   GUI_UC_Encode           (char* s, U16 Char);
Xint   GUI_UC_Encode           (char* s, unsigned short Char);
Nint   GUI_UC_GetCharSize      (const char GUI_UNI_PTR * s);
Xint   GUI_UC_GetCharSize      (const char  * s);
NU16   GUI_UC_GetCharCode      (const char GUI_UNI_PTR * s);
Xunsigned short   GUI_UC_GetCharCode      (const char  * s);
Nvoid  GUI_UC_SetEncodeNone    (void);
Nvoid  GUI_UC_SetEncodeUTF8    (void);
N
Nvoid GUI_UC_DispString(const U16 GUI_UNI_PTR *s);
Xvoid GUI_UC_DispString(const unsigned short  *s);
Nvoid GUI_UC2DB (U16 Code, U8* pOut);
Xvoid GUI_UC2DB (unsigned short Code, unsigned char* pOut);
NU16  GUI_DB2UC (U8 Byte0, U8 Byte1);
Xunsigned short  GUI_DB2UC (unsigned char Byte0, unsigned char Byte1);
N
N/*    *********************************
N      *                               *
N      *         GUIVAL.C              *
N      *                               *
N      *********************************
N*/
N
Nvoid GUI_DispBin  (U32  v, U8 Len);
Xvoid GUI_DispBin  (unsigned long  v, unsigned char Len);
Nvoid GUI_DispBinAt(U32  v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispBinAt(unsigned long  v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispDec  (I32 v, U8 Len);
Xvoid GUI_DispDec  (signed long v, unsigned char Len);
Nvoid GUI_DispDecAt (I32 v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispDecAt (signed long v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispDecMin(I32 v);
Xvoid GUI_DispDecMin(signed long v);
Nvoid GUI_DispDecShift(I32 v, U8 Len, U8 Shift);
Xvoid GUI_DispDecShift(signed long v, unsigned char Len, unsigned char Shift);
Nvoid GUI_DispDecSpace(I32 v, U8 MaxDigits);
Xvoid GUI_DispDecSpace(signed long v, unsigned char MaxDigits);
Nvoid GUI_DispHex  (U32 v, U8 Len);
Xvoid GUI_DispHex  (unsigned long v, unsigned char Len);
Nvoid GUI_DispHexAt(U32 v, I16P x, I16P y, U8 Len);
Xvoid GUI_DispHexAt(unsigned long v, signed short x, signed short y, unsigned char Len);
Nvoid GUI_DispSDec(I32 v, U8 Len);
Xvoid GUI_DispSDec(signed long v, unsigned char Len);
Nvoid GUI_DispSDecShift(I32 v, U8 Len, U8 Shift);
Xvoid GUI_DispSDecShift(signed long v, unsigned char Len, unsigned char Shift);
N
N/*    *********************************
N      *                               *
N      *         GUIVALF.C             *
N      *                               *
N      *********************************
N
NRoutines to display floating point values. These routines use the routines
Ndefined in the module GUIVAL.C as base routines.
N
N*/
N
Nvoid GUI_DispFloat    (float v, char Len);
Nvoid GUI_DispFloatFix (float v, char Len, char Fract);
Nvoid GUI_DispFloatMin (float v, char Fract);
Nvoid GUI_DispSFloatFix(float v, char Len, char Fract);
Nvoid GUI_DispSFloatMin(float v, char Fract);
N
N
N/*********************************************************************
N*
N*         Dynamic memory management
N*
N**********************************************************************
N*/
N
N#if !defined(GUI_ALLOC_ALLOC)
X#if !0L
N  /* diagnostics */
N  GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBytes (void);
X  signed short GUI_ALLOC_GetNumFreeBytes (void);
N  GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBlocks(void);
X  signed short GUI_ALLOC_GetNumFreeBlocks(void);
N  GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBytes (void);
X  signed short GUI_ALLOC_GetNumUsedBytes (void);
N  GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBlocks(void);
X  signed short GUI_ALLOC_GetNumUsedBlocks(void);
N#else
S  #define GUI_ALLOC_GetNumFreeBytes()  0
S  #define GUI_ALLOC_GetNumFreeBlocks() 0
S  #define GUI_ALLOC_GetNumUsedBytes()  0
S  #define GUI_ALLOC_GetNumUsedBlocks() 0
N#endif
N
NGUI_HMEM           GUI_ALLOC_AllocInit  (const void *pInitData, GUI_ALLOC_DATATYPE Size);
Xsigned short           GUI_ALLOC_AllocInit  (const void *pInitData, signed short Size);
NGUI_HMEM           GUI_ALLOC_AllocNoInit(GUI_ALLOC_DATATYPE size);
Xsigned short           GUI_ALLOC_AllocNoInit(signed short size);
NGUI_HMEM           GUI_ALLOC_AllocZero  (GUI_ALLOC_DATATYPE size);
Xsigned short           GUI_ALLOC_AllocZero  (signed short size);
Nvoid               GUI_ALLOC_Free       (GUI_HMEM  hMem);
Xvoid               GUI_ALLOC_Free       (signed short  hMem);
Nvoid               GUI_ALLOC_FreePtrArray(GUI_HMEM * pArray, int NumElems);
Xvoid               GUI_ALLOC_FreePtrArray(signed short * pArray, int NumElems);
Nvoid               GUI_ALLOC_FreePtr    (GUI_HMEM *phMem);
Xvoid               GUI_ALLOC_FreePtr    (signed short *phMem);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetSize    (GUI_HMEM  hMem);
Xsigned short GUI_ALLOC_GetSize    (signed short  hMem);
NGUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxSize (void);
Xsigned short GUI_ALLOC_GetMaxSize (void);
Nvoid*              GUI_ALLOC_h2p        (GUI_HMEM  hMem);
Xvoid*              GUI_ALLOC_h2p        (signed short  hMem);
Nvoid               GUI_ALLOC_Init       (void);
NGUI_HMEM           GUI_ALLOC_Realloc    (GUI_HMEM hOld, int NewSize);
Xsigned short           GUI_ALLOC_Realloc    (signed short hOld, int NewSize);
Nvoid               GUI_ALLOC_Lock       (void);
Nvoid               GUI_ALLOC_Unlock     (void);
N
N
N/*********************************************************************
N*
N*      Memory device: GUI_MEMDEV
N*
N**********************************************************************
N*/
N
N#define GUI_MEMDEV_HASTRANS       0
N#define GUI_MEMDEV_NOTRANS    (1<<0)
N
N#if GUI_SUPPORT_DEVICES
X#if (1 | (1 > 1))
N  typedef GUI_HMEM GUI_MEMDEV_Handle;
X  typedef signed short GUI_MEMDEV_Handle;
N  typedef void GUI_CALLBACK_VOID_P(void* p);
N
N  typedef struct {
N    GUI_RECT rView, rPrev;
N    char FirstCall;
N  } GUI_AUTODEV;
N
N  typedef struct {
N    char DrawFixed;
N    char IsMeasurement;
N  } GUI_AUTODEV_INFO;
N
N  int  GUI_MEMDEV_CreateAuto(GUI_AUTODEV * pAutoDev);
N  void GUI_MEMDEV_DeleteAuto(GUI_AUTODEV * pAutoDev);
N  int  GUI_MEMDEV_DrawAuto  (GUI_AUTODEV * pAutoDev, GUI_AUTODEV_INFO * pAutoDevInfo, GUI_CALLBACK_VOID_P * pfDraw, void * pData);
N
N  /* Create a memory device which is compatible to the selected LCD */
N  GUI_MEMDEV_Handle GUI_MEMDEV_Create     (int x0, int y0, int XSize, int YSize);
N  GUI_MEMDEV_Handle GUI_MEMDEV_CreateEx   (int x0, int y0, int XSize, int YSize, int Flags);
N  GUI_MEMDEV_Handle GUI_MEMDEV_CreateFixed(int x0, int y0, int xsize, int ysize, int Flags,
N                                           const tLCDDEV_APIList * pMemDevAPI,
N                                           const LCD_API_COLOR_CONV * pColorConvAPI);
N  void GUI_MEMDEV_Clear         (GUI_MEMDEV_Handle hMem);
N  void GUI_MEMDEV_CopyFromLCD   (GUI_MEMDEV_Handle hMem);
N  void GUI_MEMDEV_CopyFromLCDAA (GUI_MEMDEV_Handle hMem);
N  void GUI_MEMDEV_CopyToLCD     (GUI_MEMDEV_Handle hMem);
N  void GUI_MEMDEV_CopyToLCDAA   (GUI_MEMDEV_Handle hMem);
N  void GUI_MEMDEV_CopyToLCDAt   (GUI_MEMDEV_Handle hMem, int x, int y);
N  int  GUI_MEMDEV_CompareWithLCD(GUI_MEMDEV_Handle hMem, int*px, int*py, int *pExp, int*pAct);
N  void GUI_MEMDEV_Delete        (GUI_MEMDEV_Handle MemDev);
N  int  GUI_MEMDEV_GetXSize      (GUI_MEMDEV_Handle hMem);
N  int  GUI_MEMDEV_GetYSize      (GUI_MEMDEV_Handle hMem);
N  void GUI_MEMDEV_MarkDirty     (GUI_MEMDEV_Handle hMem, int x0, int y0, int x1, int y1);
N  void GUI_MEMDEV_ReduceYSize   (GUI_MEMDEV_Handle hMem, int YSize);
N  GUI_MEMDEV_Handle GUI_MEMDEV_Select (GUI_MEMDEV_Handle hMem);  /* Select (activate) a particular memory device. */
N  void  GUI_MEMDEV_SetOrg        (GUI_MEMDEV_Handle hMem, int x0, int y0);
N  void  GUI_MEMDEV_WriteAt       (GUI_MEMDEV_Handle hMem, int x, int y);
N  void  GUI_MEMDEV_Write         (GUI_MEMDEV_Handle hMem);
N  void  GUI_MEMDEV_WriteAlphaAt  (GUI_MEMDEV_Handle hMem, int Alpha, int x, int y);
N  void  GUI_MEMDEV_WriteAlpha    (GUI_MEMDEV_Handle hMem, int Alpha);
N  void  GUI_MEMDEV_WriteExAt     (GUI_MEMDEV_Handle hMem, int x, int y, int xMag, int yMag, int Alpha);
N  void  GUI_MEMDEV_WriteEx       (GUI_MEMDEV_Handle hMem, int xMag, int yMag, int Alpha);
N  int   GUI_MEMDEV_Draw          (GUI_RECT* pRect, GUI_CALLBACK_VOID_P* pfDraw, void* pData, int MemSize, int Flags);
N  void* GUI_MEMDEV_GetDataPtr    (GUI_MEMDEV_Handle hMem);
N  void  GUI_MEMDEV_SetColorConv  (GUI_MEMDEV_Handle hMem, const LCD_API_COLOR_CONV * pColorConvAPI);
N#endif
N
Nvoid GUI_SelectLCD(void);
Nunsigned int GUI_SelectLayer(unsigned int Index);
N
N/**************************************************************
N*
N*      Measure device: GUI_MEASDEV
N*
N***************************************************************
N*/
N
Ntypedef GUI_HMEM GUI_MEASDEV_Handle;
Xtypedef signed short GUI_MEASDEV_Handle;
N
NGUI_MEASDEV_Handle GUI_MEASDEV_Create (void);
Nvoid               GUI_MEASDEV_Delete (GUI_MEASDEV_Handle hMemDev);
Nvoid               GUI_MEASDEV_Select (GUI_MEASDEV_Handle hMem);
Nvoid               GUI_MEASDEV_GetRect(GUI_MEASDEV_Handle hMem, GUI_RECT *pRect);
Nvoid               GUI_MEASDEV_ClearRect(GUI_MEASDEV_Handle hMem);
N
N/************************************************************
N*
N*                 Polygon helpers
N*
N*************************************************************
N*/
Nvoid GUI_RotatePolygon(GUI_POINT* pDest, const GUI_POINT* pSrc, int NumPoints, float Angle);
Nvoid GUI_MagnifyPolygon(GUI_POINT* pDest, const GUI_POINT* pSrc, int NumPoints, int Mag);
Nvoid GUI_EnlargePolygon(GUI_POINT* pDest, const GUI_POINT* pSrc, int NumPoints, int Len);
N
N/************************************************************
N*
N*                 Streamed bitmap
N*
N*************************************************************
N*/
Nvoid GUI_DrawStreamedBitmap(const GUI_BITMAP_STREAM *pBitmapStream, int x, int y);
N
N/************************************************************
N*
N*                 BMP-export
N*
N*************************************************************
N*/
Ntypedef void GUI_CALLBACK_VOID_U8_P(U8 Data, void * p);
Xtypedef void GUI_CALLBACK_VOID_U8_P(unsigned char Data, void * p);
N
Nvoid GUI_BMP_SerializeEx(GUI_CALLBACK_VOID_U8_P * pfSerialize, int x0, int y0, int xSize, int ySize, void * p);
Nvoid GUI_BMP_Serialize  (GUI_CALLBACK_VOID_U8_P * pfSerialize, void * p);
N
N/*********************************************************************
N*
N*      Time / execution related routines
N*
N**********************************************************************
N*/
Nvoid GUI_Delay  (int Period);
Nint  GUI_GetTime(void);
Nint  GUI_Exec(void);         /* Execute all jobs ... Return 0 if nothing was done. */
Nint  GUI_Exec1(void);        /* Execute one job  ... Return 0 if nothing was done. */
N
N/*********************************************************************
N*
N*                 MessageBox
N*
N**********************************************************************
N
N  Note: These should be moved into a separate file.
N*/
Nint     GUI_MessageBox   (const char * sMessage, const char * sCaption, int Flags);
N#define GUI_MESSAGEBOX_CF_MOVEABLE (1 << 0)
N#define GUI_MESSAGEBOX_CF_MODAL    (1 << 1)
N
N#define GUI_MB_OK                20
N#define GUI_MB_WARNING           21
N
N/*********************************************************************
N*
N*                 GUI_TIMER module
N*
N**********************************************************************
N*/
N
Ntypedef struct {
N  GUI_TIMER_TIME Time;
X  int Time;
N  U32            Context;
X  unsigned long            Context;
N  GUI_HMEM hTimer;
X  signed short hTimer;
N} GUI_TIMER_MESSAGE;
N
Ntypedef GUI_HMEM GUI_TIMER_HANDLE;
Xtypedef signed short GUI_TIMER_HANDLE;
Ntypedef void GUI_TIMER_CALLBACK(/*const*/ GUI_TIMER_MESSAGE* pTM);
N
NGUI_TIMER_HANDLE GUI_TIMER_Create   (GUI_TIMER_CALLBACK* cb, int Time,  U32 Context, int Flags);
XGUI_TIMER_HANDLE GUI_TIMER_Create   (GUI_TIMER_CALLBACK* cb, int Time,  unsigned long Context, int Flags);
Nvoid             GUI_TIMER_Delete   (GUI_TIMER_HANDLE hObj);
N
N/* Methods changing properties */
Nvoid GUI_TIMER_SetPeriod (GUI_TIMER_HANDLE hObj, GUI_TIMER_TIME Period);
Xvoid GUI_TIMER_SetPeriod (GUI_TIMER_HANDLE hObj, int Period);
Nvoid GUI_TIMER_SetTime   (GUI_TIMER_HANDLE hObj, GUI_TIMER_TIME Period);
Xvoid GUI_TIMER_SetTime   (GUI_TIMER_HANDLE hObj, int Period);
Nvoid GUI_TIMER_SetDelay  (GUI_TIMER_HANDLE hObj, GUI_TIMER_TIME Delay);
Xvoid GUI_TIMER_SetDelay  (GUI_TIMER_HANDLE hObj, int Delay);
Nvoid GUI_TIMER_Restart   (GUI_TIMER_HANDLE hObj);
Nint  GUI_TIMER_Exec(void);
N
N
N/******************************************************************
N*
N*                 Anti Aliasing
N*
N*******************************************************************
N*/
N
Nvoid GUI_AA_DisableHiRes     (void);
Nvoid GUI_AA_EnableHiRes      (void);
Nint  GUI_AA_GetFactor        (void);
Nvoid GUI_AA_SetFactor        (int Factor);
Nvoid GUI_AA_DrawArc          (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GUI_AA_DrawLine         (int x0, int y0, int x1, int y1);
Nvoid GUI_AA_DrawPolyOutline  (const GUI_POINT * pSrc, int NumPoints, int Thickness, int x, int y);
Nvoid GUI_AA_DrawPolyOutlineEx(const GUI_POINT * pSrc, int NumPoints, int Thickness, int x, int y, GUI_POINT * pBuffer);
Nvoid GUI_AA_FillCircle       (int x0, int y0, int r);
Nvoid GUI_AA_FillPolygon      (GUI_POINT* pPoints, int NumPoints, int x0, int y0);
N
N/******************************************************************
N*
N*                 Keyboard
N*
N*******************************************************************
N*/
N
N/* Message layer */
Nvoid GUI_StoreKeyMsg(int Key, int Pressed);
Nvoid GUI_SendKeyMsg (int Key, int Pressed);
Nint  GUI_PollKeyMsg(void);
N
N/* Message hook */
Ntypedef int GUI_KEY_MSG_HOOK(int Key, int Pressed);
Nextern  GUI_KEY_MSG_HOOK* GUI_pfKeyMsgHook;
NGUI_KEY_MSG_HOOK* GUI_SetKeyMsgHook(GUI_KEY_MSG_HOOK* pHook);
N
N/* Application layer */
Nint  GUI_GetKey(void);
Nint  GUI_WaitKey(void);
Nvoid GUI_StoreKey(int c);
Nvoid GUI_ClearKeyBuffer(void);
N
N/*********************************************************************
N*
N*       Task syncronisation (depends on configuration)
N*/
Nvoid GUI_WaitEvent(void);
N
N/*********************************************************************
N*
N*          PID  (Pointer input device ... mouse/touch) 
N*/
N
Nvoid GUI_PID_StoreState(const GUI_PID_STATE *pState);
Nint  GUI_PID_GetState  (      GUI_PID_STATE *pState);
N
N/*********************************************************************
N*
N*        Mouse, generic
N*/
Nint  GUI_MOUSE_GetState  (      GUI_PID_STATE *pState);
Nvoid GUI_MOUSE_StoreState(const GUI_PID_STATE *pState);
N
N/*********************************************************************
N*
N*          TOUCH screen, generic
N*/
N
Nint  GUI_TOUCH_GetState     (GUI_PID_STATE *pState);
Nvoid GUI_TOUCH_GetUnstable  (int* px, int* py);  /* for diagnostics only */
Nvoid GUI_TOUCH_StoreState   (int x, int y);
Nvoid GUI_TOUCH_StoreStateEx (const GUI_PID_STATE *pState);
Nvoid GUI_TOUCH_StoreUnstable(int x, int y);
N
N
N/*********************************************************************
N*
N*        Mouse, PS2 driver
N*/
Nvoid GUI_MOUSE_DRIVER_PS2_Init(void);               /* optional */
Nvoid GUI_MOUSE_DRIVER_PS2_OnRx(unsigned char Data);
N
N
N/*********************************************************************
N*
N*          TOUCH screen, analog driver
N*/
Nvoid GUI_TOUCH_Exec(void);
Nint  GUI_TOUCH_Calibrate(int Coord, int Log0, int Log1, int Phys0, int Phys1);
Nvoid GUI_TOUCH_SetDefaultCalibration(void);
Nint  GUI_TOUCH_GetxPhys(void);    /* for diagnostics only */
Nint  GUI_TOUCH_GetyPhys(void);    /* for diagnostics only */
Nvoid GUI_TOUCH_GetCalData(int Coord, int* pMin,int* pMax);
Nvoid GUI_TOUCH_SetCalData(int Coord, int* pMin,int* pMax);
N
N
N/*********************************************************************
N*
N*          TOUCH
N*
N*          imports
N*
N**********************************************************************
N
NPlease note: The following functions are required by the module.
NThey need to be part of your application software (or rather, part
Nof the hardware-layer of your software).
N*/
N
Nvoid GUI_TOUCH_X_ActivateX(void);
Nvoid GUI_TOUCH_X_ActivateY(void);
Nvoid GUI_TOUCH_X_Disable(void);
Nint  GUI_TOUCH_X_MeasureX(void);
Nint  GUI_TOUCH_X_MeasureY(void);
N
N/**************************************************************
N*
N*   Constants for fonts and bitmaps
N*
N***************************************************************
N*/
N
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE4;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE8;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLE16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsRLEM16;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods555;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM555;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM565;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethods888;
Nextern const GUI_BITMAP_METHODS GUI_BitmapMethodsM888;
N
N#define GUI_COMPRESS_RLE4 0
N#define GUI_COMPRESS_RLE8 0
N
N#define GUI_DRAW_RLE4    &GUI_BitmapMethodsRLE4   /* Method table ! */
N#define GUI_DRAW_RLE8    &GUI_BitmapMethodsRLE8   /* Method table ! */
N#define GUI_DRAW_RLE16   &GUI_BitmapMethodsRLE16  /* Method table ! */
N#define GUI_DRAW_RLEM16  &GUI_BitmapMethodsRLEM16 /* Method table ! */
N#define GUI_DRAW_BMP555  &GUI_BitmapMethods555    /* Method table ! */
N#define GUI_DRAW_BMPM555 &GUI_BitmapMethodsM555   /* Method table ! */
N#define GUI_DRAW_BMP565  &GUI_BitmapMethods565    /* Method table ! */
N#define GUI_DRAW_BMPM565 &GUI_BitmapMethodsM565   /* Method table ! */
N#define GUI_DRAW_BMP888  &GUI_BitmapMethods888    /* Method table ! */
N#define GUI_DRAW_BMPM888 &GUI_BitmapMethodsM888   /* Method table ! */
N
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA2;
Nextern const tGUI_SIF_APIList GUI_SIF_APIList_Prop_AA4;
N
N/**************************************************************
N*
N*      Defines for constants
N*
N***************************************************************
N*/
N
N#define	________	0x0
N#define	_______X	0x1
N#define	______X_	0x2
N#define	______XX	0x3
N#define	_____X__	0x4
N#define	_____X_X	0x5
N#define	_____XX_	0x6
N#define	_____XXX	0x7
N#define	____X___	0x8
N#define	____X__X	0x9
N#define	____X_X_	0xa
N#define	____X_XX	0xb
N#define	____XX__	0xc
N#define	____XX_X	0xd
N#define	____XXX_	0xe
N#define	____XXXX	0xf
N#define	___X____	0x10
N#define	___X___X	0x11
N#define	___X__X_	0x12
N#define	___X__XX	0x13
N#define	___X_X__	0x14
N#define	___X_X_X	0x15
N#define	___X_XX_	0x16
N#define	___X_XXX	0x17
N#define	___XX___	0x18
N#define	___XX__X	0x19
N#define	___XX_X_	0x1a
N#define	___XX_XX	0x1b
N#define	___XXX__	0x1c
N#define	___XXX_X	0x1d
N#define	___XXXX_	0x1e
N#define	___XXXXX	0x1f
N#define	__X_____	0x20
N#define	__X____X	0x21
N#define	__X___X_	0x22
N#define	__X___XX	0x23
N#define	__X__X__	0x24
N#define	__X__X_X	0x25
N#define	__X__XX_	0x26
N#define	__X__XXX	0x27
N#define	__X_X___	0x28
N#define	__X_X__X	0x29
N#define	__X_X_X_	0x2a
N#define	__X_X_XX	0x2b
N#define	__X_XX__	0x2c
N#define	__X_XX_X	0x2d
N#define	__X_XXX_	0x2e
N#define	__X_XXXX	0x2f
N#define	__XX____	0x30
N#define	__XX___X	0x31
N#define	__XX__X_	0x32
N#define	__XX__XX	0x33
N#define	__XX_X__	0x34
N#define	__XX_X_X	0x35
N#define	__XX_XX_	0x36
N#define	__XX_XXX	0x37
N#define	__XXX___	0x38
N#define	__XXX__X	0x39
N#define	__XXX_X_	0x3a
N#define	__XXX_XX	0x3b
N#define	__XXXX__	0x3c
N#define	__XXXX_X	0x3d
N#define	__XXXXX_	0x3e
N#define	__XXXXXX	0x3f
N#define	_X______	0x40
N#define	_X_____X	0x41
N#define	_X____X_	0x42
N#define	_X____XX	0x43
N#define	_X___X__	0x44
N#define	_X___X_X	0x45
N#define	_X___XX_	0x46
N#define	_X___XXX	0x47
N#define	_X__X___	0x48
N#define	_X__X__X	0x49
N#define	_X__X_X_	0x4a
N#define	_X__X_XX	0x4b
N#define	_X__XX__	0x4c
N#define	_X__XX_X	0x4d
N#define	_X__XXX_	0x4e
N#define	_X__XXXX	0x4f
N#define	_X_X____	0x50
N#define	_X_X___X	0x51
N#define	_X_X__X_	0x52
N#define	_X_X__XX	0x53
N#define	_X_X_X__	0x54
N#define	_X_X_X_X	0x55
N#define	_X_X_XX_	0x56
N#define	_X_X_XXX	0x57
N#define	_X_XX___	0x58
N#define	_X_XX__X	0x59
N#define	_X_XX_X_	0x5a
N#define	_X_XX_XX	0x5b
N#define	_X_XXX__	0x5c
N#define	_X_XXX_X	0x5d
N#define	_X_XXXX_	0x5e
N#define	_X_XXXXX	0x5f
N#define	_XX_____	0x60
N#define	_XX____X	0x61
N#define	_XX___X_	0x62
N#define	_XX___XX	0x63
N#define	_XX__X__	0x64
N#define	_XX__X_X	0x65
N#define	_XX__XX_	0x66
N#define	_XX__XXX	0x67
N#define	_XX_X___	0x68
N#define	_XX_X__X	0x69
N#define	_XX_X_X_	0x6a
N#define	_XX_X_XX	0x6b
N#define	_XX_XX__	0x6c
N#define	_XX_XX_X	0x6d
N#define	_XX_XXX_	0x6e
N#define	_XX_XXXX	0x6f
N#define	_XXX____	0x70
N#define	_XXX___X	0x71
N#define	_XXX__X_	0x72
N#define	_XXX__XX	0x73
N#define	_XXX_X__	0x74
N#define	_XXX_X_X	0x75
N#define	_XXX_XX_	0x76
N#define	_XXX_XXX	0x77
N#define	_XXXX___	0x78
N#define	_XXXX__X	0x79
N#define	_XXXX_X_	0x7a
N#define	_XXXX_XX	0x7b
N#define	_XXXXX__	0x7c
N#define	_XXXXX_X	0x7d
N#define	_XXXXXX_	0x7e
N#define	_XXXXXXX	0x7f
N#define	X_______	0x80
N#define	X______X	0x81
N#define	X_____X_	0x82
N#define	X_____XX	0x83
N#define	X____X__	0x84
N#define	X____X_X	0x85
N#define	X____XX_	0x86
N#define	X____XXX	0x87
N#define	X___X___	0x88
N#define	X___X__X	0x89
N#define	X___X_X_	0x8a
N#define	X___X_XX	0x8b
N#define	X___XX__	0x8c
N#define	X___XX_X	0x8d
N#define	X___XXX_	0x8e
N#define	X___XXXX	0x8f
N#define	X__X____	0x90
N#define	X__X___X	0x91
N#define	X__X__X_	0x92
N#define	X__X__XX	0x93
N#define	X__X_X__	0x94
N#define	X__X_X_X	0x95
N#define	X__X_XX_	0x96
N#define	X__X_XXX	0x97
N#define	X__XX___	0x98
N#define	X__XX__X	0x99
N#define	X__XX_X_	0x9a
N#define X__XX_XX	0x9b
N#define X__XXX__	0x9c
N#define X__XXX_X	0x9d
N#define	X__XXXX_	0x9e
N#define	X__XXXXX	0x9f
N#define	X_X_____	0xa0
N#define	X_X____X	0xa1
N#define	X_X___X_	0xa2
N#define	X_X___XX	0xa3
N#define	X_X__X__	0xa4
N#define	X_X__X_X	0xa5
N#define	X_X__XX_	0xa6
N#define	X_X__XXX	0xa7
N#define	X_X_X___	0xa8
N#define	X_X_X__X	0xa9
N#define	X_X_X_X_	0xaa
N#define	X_X_X_XX	0xab
N#define	X_X_XX__	0xac
N#define	X_X_XX_X	0xad
N#define	X_X_XXX_	0xae
N#define	X_X_XXXX	0xaf
N#define	X_XX____	0xb0
N#define X_XX___X	0xb1
N#define	X_XX__X_	0xb2
N#define	X_XX__XX	0xb3
N#define	X_XX_X__	0xb4
N#define	X_XX_X_X	0xb5
N#define	X_XX_XX_	0xb6
N#define	X_XX_XXX	0xb7
N#define	X_XXX___	0xb8
N#define	X_XXX__X	0xb9
N#define	X_XXX_X_	0xba
N#define	X_XXX_XX	0xbb
N#define	X_XXXX__	0xbc
N#define	X_XXXX_X	0xbd
N#define	X_XXXXX_	0xbe
N#define	X_XXXXXX	0xbf
N#define	XX______	0xc0
N#define	XX_____X	0xc1
N#define	XX____X_	0xc2
N#define	XX____XX	0xc3
N#define	XX___X__	0xc4
N#define	XX___X_X	0xc5
N#define	XX___XX_	0xc6
N#define	XX___XXX	0xc7
N#define	XX__X___	0xc8
N#define	XX__X__X	0xc9
N#define	XX__X_X_	0xca
N#define	XX__X_XX	0xcb
N#define	XX__XX__	0xcc
N#define	XX__XX_X	0xcd
N#define	XX__XXX_	0xce
N#define XX__XXXX	0xcf
N#define	XX_X____	0xd0
N#define	XX_X___X	0xd1
N#define	XX_X__X_	0xd2
N#define	XX_X__XX	0xd3
N#define	XX_X_X__	0xd4
N#define	XX_X_X_X	0xd5
N#define	XX_X_XX_	0xd6
N#define	XX_X_XXX	0xd7
N#define	XX_XX___	0xd8
N#define	XX_XX__X	0xd9
N#define	XX_XX_X_	0xda
N#define	XX_XX_XX	0xdb
N#define	XX_XXX__	0xdc
N#define	XX_XXX_X	0xdd
N#define	XX_XXXX_	0xde
N#define	XX_XXXXX	0xdf
N#define	XXX_____	0xe0
N#define	XXX____X	0xe1
N#define	XXX___X_	0xe2
N#define	XXX___XX	0xe3
N#define	XXX__X__	0xe4
N#define	XXX__X_X	0xe5
N#define	XXX__XX_	0xe6
N#define	XXX__XXX	0xe7
N#define	XXX_X___	0xe8
N#define	XXX_X__X	0xe9
N#define	XXX_X_X_	0xea
N#define	XXX_X_XX	0xeb
N#define	XXX_XX__	0xec
N#define	XXX_XX_X	0xed
N#define	XXX_XXX_	0xee
N#define	XXX_XXXX	0xef
N#define	XXXX____	0xf0
N#define	XXXX___X	0xf1
N#define	XXXX__X_	0xf2
N#define	XXXX__XX	0xf3
N#define	XXXX_X__	0xf4
N#define	XXXX_X_X	0xf5
N#define	XXXX_XX_	0xf6
N#define	XXXX_XXX	0xf7
N#define	XXXXX___	0xf8
N#define	XXXXX__X	0xf9
N#define	XXXXX_X_	0xfa
N#define	XXXXX_XX	0xfb
N#define	XXXXXX__	0xfc
N#define	XXXXXX_X	0xfd
N#define	XXXXXXX_	0xfe
N#define	XXXXXXXX	0xff
N
N/**************************************************************
N*
N*      Compatibility with older versions
N*
N***************************************************************
N*/
N
N#define GUI_DispString_UC  GUI_UC_DispString
N#define TOUCH_X_ActivateX  GUI_TOUCH_X_ActivateX
N#define TOUCH_X_ActivateY  GUI_TOUCH_X_ActivateY
N#define TOUCH_X_Disable    GUI_TOUCH_X_Disable
N#define TOUCH_X_MeasureX   GUI_TOUCH_X_MeasureX
N#define TOUCH_X_MeasureY   GUI_TOUCH_X_MeasureY
N#define GUI_SelLayer       GUI_SelectLayer
N#if defined(__cplusplus)
X#if 0L
S}
N#endif 
N
N#endif   /* ifdef GUI_H */
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 24 "..\GUI\Core\GUI_Protected.h" 2
N#include "LCD_Protected.h"
L 1 "..\GUI\Core\LCD_Protected.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : LCD_Protected.h
NPurpose     : Internals of the LCD level
N----------------------------------------------------------------------
N*/
N
N#ifndef LCD_INTERN_H
N#define LCD_INTERN_H
N
N#include "LCD.h"
N
N/*********************************************************************
N*
N*      Data types
N*
N**********************************************************************
N*/
N
Ntypedef struct {
N  int              NumEntries; 
N  const LCD_COLOR* pPalEntries; 
N} LCD_PHYSPALETTE; 
N
N/*********************************************************************
N*
N*      Data
N*
N**********************************************************************
N*/
Nextern GUI_CONST_STORAGE U8 LCD_aMirror[256];
Xextern const unsigned char LCD_aMirror[256];
N
N
N/********************************************************
N*
N*     Color conversion routines (used internally only !
N*
N*********************************************************
N*/
Nunsigned LCD_Color2Index_User    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_0       (LCD_COLOR Color, const LCD_PHYSPALETTE* pPhysPal);
Nunsigned LCD_Color2Index_1       (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M1      (LCD_COLOR Color);
Nunsigned LCD_Color2Index_2       (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M2      (LCD_COLOR Color);
Nunsigned LCD_Color2Index_4       (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M4      (LCD_COLOR Color);
Nunsigned LCD_Color2Index_111     (LCD_COLOR Color);
Nunsigned LCD_Color2Index_222     (LCD_COLOR Color);
Nunsigned LCD_Color2Index_233     (LCD_COLOR Color);
Nunsigned LCD_Color2Index_323     (LCD_COLOR Color);
Nunsigned LCD_Color2Index_332     (LCD_COLOR Color);
Nunsigned LCD_Color2Index_444_12  (LCD_COLOR Color);
Nunsigned LCD_Color2Index_444_12_1(LCD_COLOR Color);
Nunsigned LCD_Color2Index_444_16  (LCD_COLOR Color);
Nunsigned LCD_Color2Index_555     (LCD_COLOR Color);
Nunsigned LCD_Color2Index_565     (LCD_COLOR Color);
Nunsigned LCD_Color2Index_556     (LCD_COLOR Color);
Nunsigned LCD_Color2Index_655     (LCD_COLOR Color);
Nunsigned LCD_Color2Index_666     (LCD_COLOR Color);
Nunsigned LCD_Color2Index_8666    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_8666_1  (LCD_COLOR Color);
Nunsigned LCD_Color2Index_888     (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M888    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M111    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M222    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M233    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M323    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M332    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M444_12 (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M444_16 (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M555    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M565    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M556    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M655    (LCD_COLOR Color);
Nunsigned LCD_Color2Index_M666    (LCD_COLOR Color);
N
NLCD_COLOR LCD_Index2Color_User    (int Index);
NLCD_COLOR LCD_Index2Color_0       (int Index, const LCD_PHYSPALETTE* pPhysPal);
NLCD_COLOR LCD_Index2Color_1       (int Index);
NLCD_COLOR LCD_Index2Color_2       (int Index);
NLCD_COLOR LCD_Index2Color_4       (int Index);
NLCD_COLOR LCD_Index2Color_111     (int Index);
NLCD_COLOR LCD_Index2Color_222     (int Index);
NLCD_COLOR LCD_Index2Color_233     (int Index);
NLCD_COLOR LCD_Index2Color_323     (int Index);
NLCD_COLOR LCD_Index2Color_332     (int Index);
NLCD_COLOR LCD_Index2Color_444_12  (int Index);
NLCD_COLOR LCD_Index2Color_444_12_1(int Index);
NLCD_COLOR LCD_Index2Color_444_16  (int Index);
NLCD_COLOR LCD_Index2Color_555     (int Index);
NLCD_COLOR LCD_Index2Color_565     (int Index);
NLCD_COLOR LCD_Index2Color_556     (int Index);
NLCD_COLOR LCD_Index2Color_655     (int Index);
NLCD_COLOR LCD_Index2Color_666     (int Index);
NLCD_COLOR LCD_Index2Color_8666    (int Index);
NLCD_COLOR LCD_Index2Color_8666_1  (int Index);
NLCD_COLOR LCD_Index2Color_888     (int Index);
NLCD_COLOR LCD_Index2Color_M888    (int Index);
NLCD_COLOR LCD_Index2Color_M111    (int Index);
NLCD_COLOR LCD_Index2Color_M222    (int Index);
NLCD_COLOR LCD_Index2Color_M233    (int Index);
NLCD_COLOR LCD_Index2Color_M323    (int Index);
NLCD_COLOR LCD_Index2Color_M332    (int Index);
NLCD_COLOR LCD_Index2Color_M444_12 (int Index);
NLCD_COLOR LCD_Index2Color_M444_16 (int Index);
NLCD_COLOR LCD_Index2Color_M555    (int Index);
NLCD_COLOR LCD_Index2Color_M565    (int Index);
NLCD_COLOR LCD_Index2Color_M556    (int Index);
NLCD_COLOR LCD_Index2Color_M655    (int Index);
NLCD_COLOR LCD_Index2Color_M666    (int Index);
N
Nunsigned LCD_GetIndexMask_User    (void);
Nunsigned LCD_GetIndexMask_0       (void);
Nunsigned LCD_GetIndexMask_1       (void);
Nunsigned LCD_GetIndexMask_M1      (void);
Nunsigned LCD_GetIndexMask_2       (void);
Nunsigned LCD_GetIndexMask_M2      (void);
Nunsigned LCD_GetIndexMask_4       (void);
Nunsigned LCD_GetIndexMask_M4      (void);
Nunsigned LCD_GetIndexMask_111     (void);
Nunsigned LCD_GetIndexMask_222     (void);
Nunsigned LCD_GetIndexMask_233     (void);
Nunsigned LCD_GetIndexMask_323     (void);
Nunsigned LCD_GetIndexMask_332     (void);
Nunsigned LCD_GetIndexMask_444_12  (void);
Nunsigned LCD_GetIndexMask_444_12_1(void);
Nunsigned LCD_GetIndexMask_444_16  (void);
Nunsigned LCD_GetIndexMask_555     (void);
Nunsigned LCD_GetIndexMask_565     (void);
Nunsigned LCD_GetIndexMask_556     (void);
Nunsigned LCD_GetIndexMask_655     (void);
Nunsigned LCD_GetIndexMask_666     (void);
Nunsigned LCD_GetIndexMask_8666    (void);
Nunsigned LCD_GetIndexMask_8666_1  (void);
Nunsigned LCD_GetIndexMask_888     (void);
Nunsigned LCD_GetIndexMask_M888    (void);
Nunsigned LCD_GetIndexMask_M111    (void);
Nunsigned LCD_GetIndexMask_M222    (void);
Nunsigned LCD_GetIndexMask_M233    (void);
Nunsigned LCD_GetIndexMask_M323    (void);
Nunsigned LCD_GetIndexMask_M332    (void);
Nunsigned LCD_GetIndexMask_M444_12 (void);
Nunsigned LCD_GetIndexMask_M444_16 (void);
Nunsigned LCD_GetIndexMask_M555    (void);
Nunsigned LCD_GetIndexMask_M565    (void);
Nunsigned LCD_GetIndexMask_M556    (void);
Nunsigned LCD_GetIndexMask_M655    (void);
Nunsigned LCD_GetIndexMask_M666    (void);
N
Nvoid LCD_SelectLCD(void);
N
N/*********************************************************************
N*
N*              Declarations for LCD_L0_
N*
N**********************************************************************
N
N  Prefixes are as follows:
N  LCD_L0_xxx       ... Driver for first  LCD
N  LCD_L0_1_xxx     ... Driver for second LCD/layer
N  LCD_L0_2_xxx     ... Driver for third  LCD/layer
N  LCD_L0_MAG_xxx   ... Driver for first  LCD, magnification level (calling LCD_L0_xxx after magnification)
N  LCD_L0_DELTA_xxx ... Driver for first  LCD, delta mode
N
N*/
N
Nunsigned int LCD_L0_Color2Index       (LCD_COLOR Color);
Nunsigned int LCD_L0_1_Color2Index     (LCD_COLOR Color);
Nunsigned int LCD_L0_2_Color2Index     (LCD_COLOR Color);
Nunsigned int LCD_L0_3_Color2Index     (LCD_COLOR Color);
Nunsigned int LCD_L0_4_Color2Index     (LCD_COLOR Color);
Nvoid         LCD_L0_DrawHLine         (int x0, int y0,  int x1);
Nvoid         LCD_L0_1_DrawHLine       (int x0, int y0,  int x1);
Nvoid         LCD_L0_2_DrawHLine       (int x0, int y0,  int x1);
Nvoid         LCD_L0_3_DrawHLine       (int x0, int y0,  int x1);
Nvoid         LCD_L0_4_DrawHLine       (int x0, int y0,  int x1);
Nvoid         LCD_L0_MAG_DrawHLine     (int x0, int y0,  int x1);
Nvoid         LCD_L0_DELTA_DrawHLine     (int x0, int y0,  int x1);
Nvoid         LCD_L0_DrawVLine         (int x,  int y0,  int y1);
Nvoid         LCD_L0_1_DrawVLine       (int x,  int y0,  int y1);
Nvoid         LCD_L0_2_DrawVLine       (int x,  int y0,  int y1);
Nvoid         LCD_L0_3_DrawVLine       (int x,  int y0,  int y1);
Nvoid         LCD_L0_4_DrawVLine       (int x,  int y0,  int y1);
Nvoid         LCD_L0_MAG_DrawVLine     (int x,  int y0,  int y1);
Nvoid         LCD_L0_DELTA_DrawVLine     (int x,  int y0,  int y1);
Nvoid         LCD_L0_FillRect          (int x0, int y0, int x1, int y1);
Nvoid         LCD_L0_1_FillRect        (int x0, int y0, int x1, int y1);
Nvoid         LCD_L0_2_FillRect        (int x0, int y0, int x1, int y1);
Nvoid         LCD_L0_3_FillRect        (int x0, int y0, int x1, int y1);
Nvoid         LCD_L0_4_FillRect        (int x0, int y0, int x1, int y1);
Nvoid         LCD_L0_MAG_FillRect      (int x0, int y0, int x1, int y1);
Nvoid         LCD_L0_DELTA_FillRect      (int x0, int y0, int x1, int y1);
Nunsigned int LCD_L0_GetPixelIndex     (int x,  int y);
Nunsigned int LCD_L0_1_GetPixelIndex   (int x,  int y);
Nunsigned int LCD_L0_2_GetPixelIndex   (int x,  int y);
Nunsigned int LCD_L0_3_GetPixelIndex   (int x,  int y);
Nunsigned int LCD_L0_4_GetPixelIndex   (int x,  int y);
Nunsigned int LCD_L0_MAG_GetPixelIndex (int x,  int y);
Nunsigned int LCD_L0_DELTA_GetPixelIndex (int x,  int y);
Nvoid         LCD_L0_GetRect           (LCD_RECT * pRect);
Nvoid         LCD_L0_1_GetRect         (LCD_RECT * pRect);
Nvoid         LCD_L0_2_GetRect         (LCD_RECT * pRect);
Nvoid         LCD_L0_3_GetRect         (LCD_RECT * pRect);
Nvoid         LCD_L0_4_GetRect         (LCD_RECT * pRect);
Nvoid         LCD_L0_SetPixelIndex     (int x,  int y, int ColorIndex);
Nvoid         LCD_L0_1_SetPixelIndex   (int x,  int y, int ColorIndex);
Nvoid         LCD_L0_2_SetPixelIndex   (int x,  int y, int ColorIndex);
Nvoid         LCD_L0_3_SetPixelIndex   (int x,  int y, int ColorIndex);
Nvoid         LCD_L0_4_SetPixelIndex   (int x,  int y, int ColorIndex);
Nvoid         LCD_L0_MAG_SetPixelIndex (int x,  int y, int ColorIndex);
Nvoid         LCD_L0_DELTA_SetPixelIndex (int x,  int y, int ColorIndex);
Nvoid         LCD_L0_XorPixel          (int x,  int y);
Nvoid         LCD_L0_1_XorPixel        (int x,  int y);
Nvoid         LCD_L0_2_XorPixel        (int x,  int y);
Nvoid         LCD_L0_3_XorPixel        (int x,  int y);
Nvoid         LCD_L0_4_XorPixel        (int x,  int y);
Nvoid         LCD_L0_MAG_XorPixel      (int x,  int y);
Nvoid         LCD_L0_DELTA_XorPixel      (int x,  int y);
Nint          LCD_L0_Init              (void);
Nint          LCD_L0_1_Init            (void);
Nint          LCD_L0_2_Init            (void);
Nint          LCD_L0_3_Init            (void);
Nint          LCD_L0_4_Init            (void);
Nint          LCD_L0_MAG_Init          (void);
Nint          LCD_L0_DELTA_Init          (void);
Nvoid         LCD_L0_On                (void);
Nvoid         LCD_L0_1_On              (void);
Nvoid         LCD_L0_2_On              (void);
Nvoid         LCD_L0_3_On              (void);
Nvoid         LCD_L0_4_On              (void);
Nvoid         LCD_L0_Off               (void);
Nvoid         LCD_L0_1_Off             (void);
Nvoid         LCD_L0_2_Off             (void);
Nvoid         LCD_L0_3_Off             (void);
Nvoid         LCD_L0_4_Off             (void);
Nvoid         LCD_L0_SetLUTEntry       (U8 Pos, LCD_COLOR color);
Xvoid         LCD_L0_SetLUTEntry       (unsigned char Pos, LCD_COLOR color);
Nvoid         LCD_L0_1_SetLUTEntry     (U8 Pos, LCD_COLOR color);
Xvoid         LCD_L0_1_SetLUTEntry     (unsigned char Pos, LCD_COLOR color);
Nvoid         LCD_L0_2_SetLUTEntry     (U8 Pos, LCD_COLOR color);
Xvoid         LCD_L0_2_SetLUTEntry     (unsigned char Pos, LCD_COLOR color);
Nvoid         LCD_L0_3_SetLUTEntry     (U8 Pos, LCD_COLOR color);
Xvoid         LCD_L0_3_SetLUTEntry     (unsigned char Pos, LCD_COLOR color);
Nvoid         LCD_L0_4_SetLUTEntry     (U8 Pos, LCD_COLOR color);
Xvoid         LCD_L0_4_SetLUTEntry     (unsigned char Pos, LCD_COLOR color);
Nvoid *       LCD_L0_GetDevFunc        (int Index);
Nvoid *       LCD_L0_1_GetDevFunc      (int Index);
Nvoid *       LCD_L0_2_GetDevFunc      (int Index);
Nvoid *       LCD_L0_3_GetDevFunc      (int Index);
Nvoid *       LCD_L0_4_GetDevFunc      (int Index);
NtLCDDEV_Index2Color * LCD_L0_GetpfIndex2Color(void);
NtLCDDEV_Index2Color * LCD_L0_1_GetpfIndex2Color(void);
NtLCDDEV_Index2Color * LCD_L0_2_GetpfIndex2Color(void);
NtLCDDEV_Index2Color * LCD_L0_3_GetpfIndex2Color(void);
NtLCDDEV_Index2Color * LCD_L0_4_GetpfIndex2Color(void);
N
Nvoid LCD_L0_ReInit       (void); /* Reinitialize LCD using config-paramters */
Nvoid LCD_L0_1_ReInit     (void);
Nvoid LCD_L0_2_ReInit     (void);
Nvoid LCD_L0_3_ReInit     (void);
Nvoid LCD_L0_4_ReInit     (void);
Nvoid LCD_L0_Refresh      (void); /* Refresh entire LCD */
N                                 /* Refresh LCD partially. Could be one line, depends on what
N                                    the LCD controller can handle efficiently */
Nvoid LCD_L0_1_Refresh    (void);
Nvoid LCD_L0_2_Refresh    (void);
Nvoid LCD_L0_3_Refresh    (void);
Nvoid LCD_L0_4_Refresh    (void);
Nvoid LCD_L0_SetOrg       (int x, int y);
Nvoid LCD_L0_1_SetOrg     (int x, int y);
Nvoid LCD_L0_2_SetOrg     (int x, int y);
Nvoid LCD_L0_3_SetOrg     (int x, int y);
Nvoid LCD_L0_4_SetOrg     (int x, int y);
N
N
N#endif /* LCD_INTERN_H */
N
N
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 25 "..\GUI\Core\GUI_Protected.h" 2
N#include "GUIDebug.h"
L 1 "..\GUI\Core\GUIDebug.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : GUIDebug.h
NPurpose     : Debug macros
N----------------------------------------------------------------------
N   Debug macros for logging
N
N In the GUI Simulation, all output is transferred into the log window.
N*/
N
N#ifndef GUI_DEBUG_H
N#define GUI_DEBUG_H
N
N#include "GUI.h"
N#include "GUI_X.h"
L 1 "..\GUI\Core\GUI_X.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : GUI_X.h
NPurpose     : Declarations for GUI_X module
N---------------------------END-OF-HEADER------------------------------
N
NAttention : Do not modify this file ! If you do, you will not
N            be able do update to a later GUI version !
N
N*/
N
N#ifndef  GUI_X_H
N#define  GUI_X_H
N
N#include "GUI.h"
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/************************************************************
N*
N*                    GUI_X_
N*
N*         externals, to be defined by application
N*
N*************************************************************
N
NThe externals defined below should be defined by the
Napplication. They are per default contained in the module
NGUI_X.c.
NNote that a lot if not all of these are not required in most target
Nsystems.
NFor this module, samples are available for configurations
Nwith or without operating system.
N*/
N
N/**** Init ****/
Nvoid GUI_X_Init(void);
N
N/**** ExecIdle - called if nothing else is left to do ****/
Nvoid GUI_X_ExecIdle(void);
N
N/**** Timing routines - required for blinking ****/
Nint  GUI_X_GetTime(void);
Nvoid GUI_X_Delay(int Period);
N
N/**** Multitask routines - required only if multitasking is used (#define GUI_OS 1) ****/
Nvoid GUI_X_Unlock(void);
Nvoid GUI_X_Lock(void);
NU32  GUI_X_GetTaskId(void);
Xunsigned long  GUI_X_GetTaskId(void);
Nvoid GUI_X_InitOS(void);
N
N/****      Event driving (optional with multitasking)  ****/
Nvoid GUI_X_WaitEvent(void);
Nvoid GUI_X_SignalEvent(void);
N/**** Recording (logs/warnings and errors) - required only for higher levels ****/
Nvoid GUI_X_Log(const char *s);
Nvoid GUI_X_Warn(const char *s);
Nvoid GUI_X_ErrorOut(const char *s); 
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N#endif   /* ifdef GUI_X_H */
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 28 "..\GUI\Core\GUIDebug.h" 2
N
N#define GUI_DEBUG_LEVEL_NOCHECK       0  /* No run time checks are performed */
N#define GUI_DEBUG_LEVEL_CHECK_PARA    1  /* Parameter checks are performed to avoid crashes */
N#define GUI_DEBUG_LEVEL_CHECK_ALL     2  /* Parameter checks and consistency checks are performed */
N#define GUI_DEBUG_LEVEL_LOG_ERRORS    3  /* Errors are recorded */
N#define GUI_DEBUG_LEVEL_LOG_WARNINGS  4  /* Errors & Warnings are recorded */
N#define GUI_DEBUG_LEVEL_LOG_ALL       5  /* Errors, Warnings and Messages are recorded. */
N
N#ifndef GUI_DEBUG_LEVEL
N  #ifdef WIN32
S    #define GUI_DEBUG_LEVEL GUI_DEBUG_LEVEL_LOG_WARNINGS  /* Simulation should log all warnings */
N  #else
N    #define GUI_DEBUG_LEVEL GUI_DEBUG_LEVEL_CHECK_PARA  /* For most targets, min. size is important */
N  #endif
N#endif
N
N/*******************************************************************
N*
N*               Commandline
N*
N********************************************************************
N*/
N
N#ifdef WIN32
S  #define GUI_DEBUG_GETCMDLINE() SIM_GetCmdLine()
N#else
N  #define GUI_DEBUG_GETCMDLINE() 0
N#endif
N
N/*******************************************************************
N*
N*               Error macros
N*
N********************************************************************
N*/
N
N/* Make sure the macros are actually defined */
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_ERRORS
X#if 1 >= 3
S  #define GUI_DEBUG_ERROROUT(s)              GUI_ErrorOut(s)
S  #define GUI_DEBUG_ERROROUT1(s,p0)          GUI_ErrorOut1(s,p0)
S  #define GUI_DEBUG_ERROROUT2(s,p0,p1)       GUI_ErrorOut2(s,p0,p1)
S  #define GUI_DEBUG_ERROROUT3(s,p0,p1,p2)    GUI_ErrorOut3(s,p0,p1,p2)
S  #define GUI_DEBUG_ERROROUT4(s,p0,p1,p2,p3) GUI_ErrorOut4(s,p0,p1,p2,p3)
S  #define GUI_DEBUG_ERROROUT_IF(exp,s)              { if (exp) GUI_DEBUG_ERROROUT(s); }
S  #define GUI_DEBUG_ERROROUT1_IF(exp,s,p0)          { if (exp) GUI_DEBUG_ERROROUT1(s,p0); }
S  #define GUI_DEBUG_ERROROUT2_IF(exp,s,p0,p1)       { if (exp) GUI_DEBUG_ERROROUT2(s,p0,p1); }
S  #define GUI_DEBUG_ERROROUT3_IF(exp,s,p0,p1,p2)    { if (exp) GUI_DEBUG_ERROROUT3(s,p0,p1,p2); }
S  #define GUI_DEBUG_ERROROUT4_IF(exp,s,p0,p1,p2,p3) { if (exp) GUI_DEBUG_ERROROUT4(s,p0,p1,p2,p3); }
N#else
N  #define GUI_DEBUG_ERROROUT(s)
N  #define GUI_DEBUG_ERROROUT1(s,p0)
N  #define GUI_DEBUG_ERROROUT2(s,p0,p1)
N  #define GUI_DEBUG_ERROROUT3(s,p0,p1,p2)
N  #define GUI_DEBUG_ERROROUT4(s,p0,p1,p2,p3)
N  #define GUI_DEBUG_ERROROUT_IF(exp,s)
N  #define GUI_DEBUG_ERROROUT1_IF(exp,s,p0)
N  #define GUI_DEBUG_ERROROUT2_IF(exp,s,p0,p1)
N  #define GUI_DEBUG_ERROROUT3_IF(exp,s,p0,p1,p2)
N  #define GUI_DEBUG_ERROROUT4_IF(exp,s,p0,p1,p2,p3)
N#endif
N
N/*******************************************************************
N*
N*               Warning macros
N*
N********************************************************************
N*/
N
N/* Make sure the macros are actually defined */
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_WARNINGS
X#if 1 >= 4
S  #define GUI_DEBUG_WARN(s)              GUI_Warn(s)
S  #define GUI_DEBUG_WARN1(s,p0)          GUI_Warn1(s,p0)
S  #define GUI_DEBUG_WARN2(s,p0,p1)       GUI_Warn2(s,p0,p1)
S  #define GUI_DEBUG_WARN3(s,p0,p1,p2)    GUI_Warn3(s,p0,p1,p2)
S  #define GUI_DEBUG_WARN4(s,p0,p1,p2,p3) GUI_Warn4(s,p0,p1,p2,p3)
S  #define GUI_DEBUG_WARN_IF(exp,s)                  { if (exp) GUI_DEBUG_WARN(s); }
S  #define GUI_DEBUG_WARN1_IF(exp,s,p0)              { if (exp) GUI_DEBUG_WARN1(s,p0); }
S  #define GUI_DEBUG_WARN2_IF(exp,s,p0,p1)           { if (exp) GUI_DEBUG_WARN2(s,p0,p1); }
S  #define GUI_DEBUG_WARN3_IF(exp,s,p0,p1,p2)        { if (exp) GUI_DEBUG_WARN3(s,p0,p1,p2); }
S  #define GUI_DEBUG_WARN4_IF(exp,s,p0,p1,p2,p3)     { if (exp) GUI_DEBUG_WARN4(s,p0,p1,p2,p3); }
N#else
N  #define GUI_DEBUG_WARN(s)
N  #define GUI_DEBUG_WARN1(s,p0)
N  #define GUI_DEBUG_WARN2(s,p0,p1)
N  #define GUI_DEBUG_WARN3(s,p0,p1,p2)
N  #define GUI_DEBUG_WARN4(s,p0,p1,p2,p3)
N  #define GUI_DEBUG_WARN_IF(exp,s)
N  #define GUI_DEBUG_WARN1_IF(exp,s,p0)
N  #define GUI_DEBUG_WARN2_IF(exp,s,p0,p1)
N  #define GUI_DEBUG_WARN3_IF(exp,s,p0,p1,p2)
N  #define GUI_DEBUG_WARN4_IF(exp,s,p0,p1,p2,p3)
N#endif
N
N/*******************************************************************
N*
N*               Logging macros
N*
N********************************************************************
N*/
N/* Make sure the macros are actually defined */
N
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_ALL
X#if 1 >= 5
S  #define GUI_DEBUG_LOG(s)              GUI_Log(s)
S  #define GUI_DEBUG_LOG1(s,p0)          GUI_Warn1(s,p0)
S  #define GUI_DEBUG_LOG2(s,p0,p1)       GUI_Warn2(s,p0,p1)
S  #define GUI_DEBUG_LOG3(s,p0,p1,p2)    GUI_Warn3(s,p0,p1,p2)
S  #define GUI_DEBUG_LOG4(s,p0,p1,p2,p3) GUI_Warn4(s,p0,p1,p2,p3)
S  #define GUI_DEBUG_LOG_IF(exp,s)                   { if (exp) GUI_DEBUG_LOG(s); }
S  #define GUI_DEBUG_LOG1_IF(exp,s,p0)               { if (exp) GUI_DEBUG_LOG1(s,p0); }
S  #define GUI_DEBUG_LOG2_IF(exp,s,p0,p1)            { if (exp) GUI_DEBUG_LOG2(s,p0,p1); }
S  #define GUI_DEBUG_LOG3_IF(exp,s,p0,p1,p2)         { if (exp) GUI_DEBUG_LOG3(s,p0,p1,p2); }
S  #define GUI_DEBUG_LOG4_IF(exp,s,p0,p1,p2,p3)      { if (exp) GUI_DEBUG_LOG4(s,p0,p1,p2,p3); }
N#else
N  #define GUI_DEBUG_LOG(s)
N  #define GUI_DEBUG_LOG1(s,p0)
N  #define GUI_DEBUG_LOG2(s,p0,p1)
N  #define GUI_DEBUG_LOG3(s,p0,p1,p2)
N  #define GUI_DEBUG_LOG4(s,p0,p1,p2,p3)
N  #define GUI_DEBUG_LOG_IF(exp,s)
N  #define GUI_DEBUG_LOG1_IF(exp,s,p0)
N  #define GUI_DEBUG_LOG2_IF(exp,s,p0,p1)
N  #define GUI_DEBUG_LOG3_IF(exp,s,p0,p1,p2)
N  #define GUI_DEBUG_LOG4_IF(exp,s,p0,p1,p2,p3)
N#endif
N
N/*******************************************************************
N*
N*               Asserts
N*
N********************************************************************
N*/
N#if GUI_DEBUG_LEVEL >= GUI_DEBUG_LEVEL_LOG_ERRORS
X#if 1 >= 3
S  #define GUI_DEBUG_ASSERT(exp)                     { if (!exp) GUI_DEBUG_ERROROUT(#exp); }
N#else
N  #define GUI_DEBUG_ASSERT(exp)
N#endif
N
N#endif /* LCD_H */
N
N
N
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 26 "..\GUI\Core\GUI_Protected.h" 2
N#if GUI_WINSUPPORT
X#if 1
N  #include "WM_GUI.h"
L 1 "..\GUI\WM\WM_GUI.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : WM_GUI.h
NPurpose     : Windows manager include for low level GUI routines
N----------------------------------------------------------------------
N*/
N
N#ifndef WM_GUI_H            /* Make sure we only include it once */
N#define WM_GUI_H
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
Nint       WM__InitIVRSearch(const GUI_RECT* pMaxRect);
Nint       WM__GetNextIVR   (void);
Nint       WM__GetOrgX_AA(void);
Nint       WM__GetOrgY_AA(void);
N
N#define WM_ITERATE_START(pRect)                   \
N  {                                               \
N    if (WM__InitIVRSearch(pRect))                 \
N      do {
X#define WM_ITERATE_START(pRect)                     {                                                   if (WM__InitIVRSearch(pRect))                       do {
N
N#define WM_ITERATE_END()                          \
N    } while (WM__GetNextIVR());                   \
N  }
X#define WM_ITERATE_END()                              } while (WM__GetNextIVR());                     }
N
N#define WM_ADDORGX(x)    x += GUI_Context.xOff
N#define WM_ADDORGY(y)    y += GUI_Context.yOff
N#define WM_ADDORG(x0,y0) WM_ADDORGX(x0); WM_ADDORGY(y0)
N#define WM_ADDORGX_AA(x)    x += WM__GetOrgX_AA()
N#define WM_ADDORGY_AA(y)    y += WM__GetOrgY_AA()
N#define WM_ADDORG_AA(x0,y0) WM_ADDORGX_AA(x0); WM_ADDORGY_AA(y0)
N#define WM_SUBORGX(x)    x -= GUI_Context.xOff
N#define WM_SUBORGY(y)    y -= GUI_Context.yOff
N#define WM_SUBORG(x0,y0) WM_SUBORGX(x0); WM_SUBORGY(y0)
N
N#if defined(__cplusplus)
X#if 0L
S  }
N#endif
N
N
N#endif   /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 28 "..\GUI\Core\GUI_Protected.h" 2
N#endif
N
N#if defined(__cplusplus)
X#if 0L
Sextern "C" {     /* Make sure we have C-declarations in C++ programs */
N#endif
N
N/**********************************************************************
N*
N*                        Defaults for config switches
N*
N***********************************************************************
N
N  The config switches below do not affect the interface in GUI.h and
N  are therefor not required to be in GUI.h.
N*/
N
N/* Short address area.
N   For  most compilers, this is "near" or "__near"
N   We do not use this except for some CPUs which we know to always have some
N   near memory, because the GUI_Context ans some other data will be declared
N   to be in this short address (near) memory area as it has a major effect
N   on performance.
N   Please define in GUIConf.h (if you want to use it)
N*/
N#ifndef GUI_SADDR
N  #define GUI_SADDR
N#endif
N
N#ifndef GUI_DEFAULT_FONT
S  #define GUI_DEFAULT_FONT    &GUI_Font6x8
N#endif
N
N#ifndef GUI_DEFAULT_CURSOR
N  #define GUI_DEFAULT_CURSOR  &GUI_CursorArrowM
N#endif
N
N#ifndef GUI_DEFAULT_BKCOLOR
N  #define GUI_DEFAULT_BKCOLOR GUI_BLACK
N#endif
N
N#ifndef GUI_DEFAULT_COLOR
N  #define GUI_DEFAULT_COLOR   GUI_WHITE
N#endif
N
N#ifndef GUI_X_SIGNAL_EVENT
N  #define GUI_X_SIGNAL_EVENT()
N#endif
N
N#ifndef GUI_X_WAIT_EVENT
N  #define GUI_X_WAIT_EVENT() GUI_X_ExecIdle()
N#endif
N
N
N/*      *********************************
N        *                               *
N        *      Angles                   *
N        *                               *
N        *********************************
N*/
N
N#define GUI_45DEG  512
N#define GUI_90DEG  (2*GUI_45DEG)
N#define GUI_180DEG (4*GUI_45DEG)
N#define GUI_360DEG (8*GUI_45DEG)
N
N
N
N
N
N/*****************************************************
N*
N*        Locking checks
N*
N******************************************************
N*/
N
N#if defined (WIN32) && defined (_DEBUG) && GUI_OS
X#if 0L && 0L && (0)
S  #define GUI_ASSERT_LOCK()   GUITASK_AssertLock()
S  #define GUI_ASSERT_NO_LOCK() GUITASK_AssertNoLock()
S  void GUITASK_AssertLock(void);
S  void GUITASK_AssertNoLock(void);
N#else
N  #define GUI_ASSERT_LOCK()
N  #define GUI_ASSERT_NO_LOCK()
N#endif
N
N/*****************************************************
N*
N*        Usage internals
N*
N******************************************************
N*/
N
Ntypedef GUI_HMEM GUI_USAGE_Handle;
Xtypedef signed short GUI_USAGE_Handle;
Ntypedef struct tsUSAGE_APIList tUSAGE_APIList;
Ntypedef struct GUI_Usage GUI_USAGE;
N#define GUI_USAGE_h GUI_USAGE_Handle
N
N
N
Ntypedef GUI_USAGE_h tUSAGE_CreateCompatible(GUI_USAGE* p);
Xtypedef GUI_USAGE_Handle tUSAGE_CreateCompatible(GUI_USAGE* p);
Ntypedef void        tUSAGE_AddPixel        (GUI_USAGE* p, int x, int y);
Ntypedef void        tUSAGE_AddHLine        (GUI_USAGE* p, int x0, int y0, int len);
Ntypedef void        tUSAGE_Clear           (GUI_USAGE* p);
Ntypedef void        tUSAGE_Delete          (GUI_USAGE_h h);
Xtypedef void        tUSAGE_Delete          (GUI_USAGE_Handle h);
Ntypedef int         tUSAGE_GetNextDirty    (GUI_USAGE* p, int *pxOff, int yOff);
N#define GUI_USAGE_H2P(h) ((GUI_USAGE*)GUI_ALLOC_h2p(h))
N
N
Nvoid GUI_USAGE_DecUseCnt(GUI_USAGE_Handle  hUsage);
N
NGUI_USAGE_Handle GUI_USAGE_BM_Create(int x0, int y0, int xsize, int ysize, int Flags);
Nvoid    GUI_USAGE_Select(GUI_USAGE_Handle hUsage);
Nvoid    GUI_USAGE_AddRect(GUI_USAGE*  pUsage, int x0, int y0, int xSize, int ySize);
N#define GUI_USAGE_AddPixel(p, x,y)            p->pAPI->pfAddPixel(p,x,y)
N#define GUI_USAGE_AddHLine(p,x,y,len)         p->pAPI->pfAddHLine(p,x,y,len)
N#define GUI_USAGE_Clear(p)                    p->pAPI->pfClear(p)
N#define GUI_USAGE_Delete(p)                   p->pAPI->pfDelete(p)
N#define GUI_USAGE_GetNextDirty(p,pxOff, yOff) p->pAPI->pfGetNextDirty(p,pxOff, yOff)
N
Nstruct tsUSAGE_APIList {
N  tUSAGE_AddPixel*                pfAddPixel;
N  tUSAGE_AddHLine*                pfAddHLine;
N  tUSAGE_Clear*                   pfClear;
N  tUSAGE_CreateCompatible*        pfCreateCompatible;
N  tUSAGE_Delete*                  pfDelete;
N  tUSAGE_GetNextDirty*            pfGetNextDirty;
N} ;
N
Nstruct GUI_Usage {
N  I16P x0, y0, XSize, YSize;
X  signed short x0, y0, XSize, YSize;
N  const tUSAGE_APIList *pAPI;
N  I16 UseCnt;
X  signed short UseCnt;
N};
N
N/*****************************************************
N*
N*        GUI_MEMDEV
N*
N******************************************************
N*/
N
N#if GUI_SUPPORT_MEMDEV
X#if 1
N  typedef struct {
N    I16P                   x0, y0, XSize, YSize;
X    signed short                   x0, y0, XSize, YSize;
N    int                    NumColors;
N    unsigned               BytesPerLine;
N    unsigned               BitsPerPixel;
N    unsigned               LayerIndex;
N    GUI_HMEM               hUsage;
X    signed short               hUsage;
N    tLCDDEV_Color2Index*   pfColor2Index;
N    tLCDDEV_Index2Color*   pfIndex2Color;
N    tLCDDEV_GetIndexMask*  pfGetIndexMask;
N    const tLCDDEV_APIList* pAPIList;
N  } GUI_MEMDEV;
N
N  #define      GUI_MEMDEV_H2P(h) ((GUI_MEMDEV*)GUI_ALLOC_h2p(h))
N
N  void         GUI_MEMDEV__CopyFromLCD (GUI_MEMDEV_Handle hMem);
N  void         GUI_MEMDEV__GetRect     (GUI_RECT* pRect);
N  unsigned     GUI_MEMDEV__Color2Index (LCD_COLOR Color);
N  LCD_COLOR    GUI_MEMDEV__Index2Color (int Index);
N  unsigned int GUI_MEMDEV__GetIndexMask(void);
N
N  GUI_MEMDEV_Handle GUI_MEMDEV__CreateFixed(int x0, int y0, int xsize, int ysize, int Flags
N                                          ,const tLCDDEV_APIList * pMemDevAPI
N                                          ,tLCDDEV_Color2Index*        pfColor2Index
N                                          ,tLCDDEV_Index2Color*        pfIndex2Color
N                                          ,tLCDDEV_GetIndexMask*       pfGetIndexMask);
N
N#endif
N
N/*******************************************************************
N*
N*                   LCD_HL_ level defines
N*
N********************************************************************
N*/
N
N#if GUI_SUPPORT_AA
X#if 1
N  #define LCD_HL_DrawHLine             GUI_Context.pLCD_HL->pfDrawHLine
N  #define LCD_HL_DrawPixel             GUI_Context.pLCD_HL->pfDrawPixel
N#else
S  #define LCD_HL_DrawHLine             LCD_DrawHLine
S  #define LCD_HL_DrawPixel             LCD_DrawPixel
N#endif
N
N
N/*********************************************************************
N*
N*                     Helper functions
N*
N***********************************************************************
N*/
N
N#define GUI_ZEROINIT(Obj) GUI_MEMSET(Obj, 0, sizeof(Obj))
Nint  GUI_cos(int angle);
Nint  GUI_sin(int angle);
Nextern const U32 GUI_Pow10[10];
Xextern const unsigned long GUI_Pow10[10];
N
N/* GUIAALib.c --- direct anti-aliased drawing */
Nint  GUI_AA_Init(int x0, int x1);
Nint  GUI_AA_Init_HiRes(int x0, int x1);
Nvoid GUI_AA_Exit(void);
NI16 GUI_AA_HiRes2Pixel(int HiRes);
Xsigned short GUI_AA_HiRes2Pixel(int HiRes);
N
Nvoid GL_FillCircleAA_HiRes(int x0, int y0, int r);
N
Nvoid GUI_AA__DrawCharAA2NoTrans(int x0, int y0, int XSize, int YSize, int BytesPerLine, const U8*pData);
Xvoid GUI_AA__DrawCharAA2NoTrans(int x0, int y0, int XSize, int YSize, int BytesPerLine, const unsigned char*pData);
Nvoid GUI_AA__DrawCharAA2Trans  (int x0, int y0, int XSize, int YSize, int BytesPerLine, const U8*pData);
Xvoid GUI_AA__DrawCharAA2Trans  (int x0, int y0, int XSize, int YSize, int BytesPerLine, const unsigned char*pData);
Nvoid GUI_AA__DrawCharAA4       (int x0, int y0, int XSize, int YSize, int BytesPerLine, const U8*pData);
Xvoid GUI_AA__DrawCharAA4       (int x0, int y0, int XSize, int YSize, int BytesPerLine, const unsigned char*pData);
N
N/* System independent font routines */
Nint        GUI_SIF__GetCharDistX(U16P c);
Xint        GUI_SIF__GetCharDistX(unsigned short c);
Nvoid       GUI_SIF__GetFontInfo (const GUI_FONT GUI_UNI_PTR * pFont, GUI_FONTINFO * pfi);
Xvoid       GUI_SIF__GetFontInfo (const GUI_FONT  * pFont, GUI_FONTINFO * pfi);
Nchar       GUI_SIF__IsInFont    (const GUI_FONT GUI_UNI_PTR * pFont, U16 c);
Xchar       GUI_SIF__IsInFont    (const GUI_FONT  * pFont, unsigned short c);
Nconst U8 * GUI_SIF__GetpCharInfo(const GUI_FONT GUI_UNI_PTR * pFont, U16P c);
Xconst unsigned char * GUI_SIF__GetpCharInfo(const GUI_FONT  * pFont, unsigned short c);
N
N/* Conversion routines */
Nvoid GUI_AddHex     (U32 v, U8 Len, char**ps);
Xvoid GUI_AddHex     (unsigned long v, unsigned char Len, char**ps);
Nvoid GUI_AddBin     (U32 v, U8 Len, char**ps);
Xvoid GUI_AddBin     (unsigned long v, unsigned char Len, char**ps);
Nvoid GUI_AddDecMin  (I32 v, char**ps);
Xvoid GUI_AddDecMin  (signed long v, char**ps);
Nvoid GUI_AddDec     (I32 v, U8 Len, char**ps);
Xvoid GUI_AddDec     (signed long v, unsigned char Len, char**ps);
Nvoid GUI_AddDecShift(I32 v, U8 Len, U8 Shift, char**ps);
Xvoid GUI_AddDecShift(signed long v, unsigned char Len, unsigned char Shift, char**ps);
Nlong GUI_AddSign    (long v, char**ps);
Nint  GUI_Long2Len   (I32 v);
Xint  GUI_Long2Len   (signed long v);
N
N#if GUI_SUPPORT_UNICODE
X#if (1)
N  #define GUI_UC__GetCharSize(sText)  GUI_Context.pUC_API->pfGetCharSize(sText)
N  #define GUI_UC__GetCharCode(sText)  GUI_Context.pUC_API->pfGetCharCode(sText)
N#else
S  #define GUI_UC__GetCharSize(sText)  GUI_UC_GetCharSize(sText)
S  #define GUI_UC__GetCharCode(sText)  GUI_UC_GetCharCode(sText)
N#endif
N
Nint   GUI_UC__CalcSizeOfChar   (U16 Char);
Xint   GUI_UC__CalcSizeOfChar   (unsigned short Char);
NU16   GUI_UC__GetCharCodeInc   (const char GUI_UNI_PTR ** ps);
Xunsigned short   GUI_UC__GetCharCodeInc   (const char  ** ps);
Nint   GUI_UC__NumChars2NumBytes(const char GUI_UNI_PTR * s, int NumChars);
Xint   GUI_UC__NumChars2NumBytes(const char  * s, int NumChars);
Nint   GUI_UC__NumBytes2NumChars(const char GUI_UNI_PTR * s, int NumBytes);
Xint   GUI_UC__NumBytes2NumChars(const char  * s, int NumBytes);
N
Nint  GUI__GetLineNumChars  (const char GUI_UNI_PTR *s, int MaxNumChars);
Xint  GUI__GetLineNumChars  (const char  *s, int MaxNumChars);
Nint  GUI__GetNumChars      (const char GUI_UNI_PTR *s);
Xint  GUI__GetNumChars      (const char  *s);
Nint  GUI__GetLineDistX     (const char GUI_UNI_PTR *s, int Len);
Xint  GUI__GetLineDistX     (const char  *s, int Len);
Nint  GUI__GetFontSizeY     (void);
Nint  GUI__HandleEOLine     (const char GUI_UNI_PTR **ps);
Xint  GUI__HandleEOLine     (const char  **ps);
Nvoid GUI__DispLine         (const char GUI_UNI_PTR *s, int Len, const GUI_RECT* pr);
Xvoid GUI__DispLine         (const char  *s, int Len, const GUI_RECT* pr);
Nvoid GUI__AddSpaceHex      (U32 v, U8 Len, char**ps);
Xvoid GUI__AddSpaceHex      (unsigned long v, unsigned char Len, char**ps);
Nvoid GUI__CalcTextRect     (const char GUI_UNI_PTR* pText, const GUI_RECT* pTextRectIn, GUI_RECT* pTextRectOut, int TextAlign);
Xvoid GUI__CalcTextRect     (const char * pText, const GUI_RECT* pTextRectIn, GUI_RECT* pTextRectOut, int TextAlign);
N
Nint  GUI__WrapGetNumCharsDisp       (const char GUI_UNI_PTR * pText, int xSize, GUI_WRAPMODE WrapMode);
Xint  GUI__WrapGetNumCharsDisp       (const char  * pText, int xSize, GUI_WRAPMODE WrapMode);
Nint  GUI__WrapGetNumCharsToNextLine (const char GUI_UNI_PTR * pText, int xSize, GUI_WRAPMODE WrapMode);
Xint  GUI__WrapGetNumCharsToNextLine (const char  * pText, int xSize, GUI_WRAPMODE WrapMode);
Nint  GUI__WrapGetNumBytesToNextLine (const char GUI_UNI_PTR * pText, int xSize, GUI_WRAPMODE WrapMode);
Xint  GUI__WrapGetNumBytesToNextLine (const char  * pText, int xSize, GUI_WRAPMODE WrapMode);
Nvoid GUI__memset    (U8 * p, U8 Fill, int NumBytes);
Xvoid GUI__memset    (unsigned char * p, unsigned char Fill, int NumBytes);
Nvoid GUI__memset16  (U16* p, U16 Fill, int NumWords);
Xvoid GUI__memset16  (unsigned short* p, unsigned short Fill, int NumWords);
Nint  GUI__strlen    (const char GUI_UNI_PTR * s);
Xint  GUI__strlen    (const char  * s);
Nint  GUI__strcmp    (const char GUI_UNI_PTR * s0, const char GUI_UNI_PTR * s1);
Xint  GUI__strcmp    (const char  * s0, const char  * s1);
Nint  GUI__strcmp_hp (GUI_HMEM hs0, const char GUI_UNI_PTR * s1);
Xint  GUI__strcmp_hp (signed short hs0, const char  * s1);
N
N/* Get cursor position */
Nint  GUI__GetCursorPosX     (const char GUI_UNI_PTR * s, int Index, int MaxNumChars);
Xint  GUI__GetCursorPosX     (const char  * s, int Index, int MaxNumChars);
Nint  GUI__GetCursorPosChar  (const char GUI_UNI_PTR * s, int x, int NumCharsToNextLine);
Xint  GUI__GetCursorPosChar  (const char  * s, int x, int NumCharsToNextLine);
NU16  GUI__GetCursorCharacter(const char GUI_UNI_PTR * s, int Index, int MaxNumChars, int * pIsRTL);
Xunsigned short  GUI__GetCursorCharacter(const char  * s, int Index, int MaxNumChars, int * pIsRTL);
N
N/* Arabic support */
NU16  GUI__GetPresentationForm     (U16 Char, U16 Next, U16 Prev, int * pIgnoreNext);
Xunsigned short  GUI__GetPresentationForm     (unsigned short Char, unsigned short Next, unsigned short Prev, int * pIgnoreNext);
Nvoid GUI__DispLineArabic          (const char GUI_UNI_PTR * s, int MaxNumChars, const GUI_RECT * pRect);
Xvoid GUI__DispLineArabic          (const char  * s, int MaxNumChars, const GUI_RECT * pRect);
Nint  GUI__GetLineDistXArabic      (const char GUI_UNI_PTR * s, int MaxNumChars);
Xint  GUI__GetLineDistXArabic      (const char  * s, int MaxNumChars);
Nint  GUI__IsArabicCharacter       (U16 c);
Xint  GUI__IsArabicCharacter       (unsigned short c);
Nint  GUI__GetCursorPosXArabic     (const char GUI_UNI_PTR * s, int Index, int MaxNumChars);
Xint  GUI__GetCursorPosXArabic     (const char  * s, int Index, int MaxNumChars);
Nint  GUI__GetCursorPosCharArabic  (const char GUI_UNI_PTR * s, int x, int MaxNumChars);
Xint  GUI__GetCursorPosCharArabic  (const char  * s, int x, int MaxNumChars);
NU16  GUI__GetCursorCharacterArabic(const char GUI_UNI_PTR * s, int Index, int MaxNumChars, int * pIsRTL);
Xunsigned short  GUI__GetCursorCharacterArabic(const char  * s, int Index, int MaxNumChars, int * pIsRTL);
N
N/* Reading data routines */
NU16 GUI__Read16(const U8 ** ppData);
Xunsigned short GUI__Read16(const unsigned char ** ppData);
NU32 GUI__Read32(const U8 ** ppData);
Xunsigned long GUI__Read32(const unsigned char ** ppData);
N
N/* Virtual screen support */
Nvoid GUI__GetOrg(int * px, int * py);
N
N/*********************************************************************
N*
N*             2d - GL
N*
N**********************************************************************
N*/
N
Nvoid GL_DispChar         (U16 c);
Xvoid GL_DispChar         (unsigned short c);
Nvoid GL_DrawArc          (int x0, int y0, int rx, int ry, int a0, int a1);
Nvoid GL_DrawBitmap       (const GUI_BITMAP GUI_UNI_PTR * pBM, int x0, int y0);
Xvoid GL_DrawBitmap       (const GUI_BITMAP  * pBM, int x0, int y0);
Nvoid GL_DrawCircle       (int x0, int y0, int r);
Nvoid GL_DrawEllipse      (int x0, int y0, int rx, int ry);
Nvoid GL_DrawHLine        (int y0, int x0, int x1);
Nvoid GL_DrawPolygon      (const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Nvoid GL_DrawPoint        (int x, int y);
Nvoid GL_DrawLine1        (int x0, int y0, int x1, int y1);
Nvoid GL_DrawLine1Ex      (int x0, int y0, int x1, int y1, unsigned * pPixelCnt);
Nvoid GL_DrawLineRel      (int dx, int dy);
Nvoid GL_DrawLineTo       (int x, int y);
Nvoid GL_DrawLineToEx     (int x, int y, unsigned * pPixelCnt);
Nvoid GL_DrawLine         (int x0, int y0, int x1, int y1);
Nvoid GL_DrawLineEx       (int x0, int y0, int x1, int y1, unsigned * pPixelCnt);
Nvoid GL_MoveTo           (int x, int y);
Nvoid GL_FillCircle       (int x0, int y0, int r);
Nvoid GL_FillCircleAA     (int x0, int y0, int r);
Nvoid GL_FillEllipse      (int x0, int y0, int rx, int ry);
Nvoid GL_FillPolygon      (const GUI_POINT* pPoints, int NumPoints, int x0, int y0);
Nvoid GL_SetDefault       (void);
N
N/************************************************************
N*
N*                 Callback pointers for dynamic linkage
N*
N*************************************************************
NDynamic linkage pointers reduces configuration hassles.
N*/
Ntypedef int  GUI_tfTimer(void);
Ntypedef char GUI_CURSOR_tfTempHide  (const GUI_RECT* pRect);
Ntypedef void GUI_CURSOR_tfTempUnhide(void);
Ntypedef int  WM_tfHandlePID(void);
N
N
N/************************************************************
N*
N*        Cursors 
N*
N*************************************************************
N*/
N
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_ArrowS[45];
Xextern const unsigned char  GUI_Pixels_ArrowS[45];
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_ArrowM[60];
Xextern const unsigned char  GUI_Pixels_ArrowM[60];
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_ArrowL[150];
Xextern const unsigned char  GUI_Pixels_ArrowL[150];
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_CrossS[33];
Xextern const unsigned char  GUI_Pixels_CrossS[33];
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_CrossM[126];
Xextern const unsigned char  GUI_Pixels_CrossM[126];
Nextern GUI_CONST_STORAGE unsigned char  GUI_Pixels_CrossL[248];
Xextern const unsigned char  GUI_Pixels_CrossL[248];
Nextern GUI_CONST_STORAGE unsigned char  GUI_PixelsHeaderM[5 * 17];
Xextern const unsigned char  GUI_PixelsHeaderM[5 * 17];
N
N
Nextern GUI_CONST_STORAGE GUI_LOGPALETTE GUI_CursorPal;
Xextern const GUI_LOGPALETTE GUI_CursorPal;
Nextern GUI_CONST_STORAGE GUI_LOGPALETTE GUI_CursorPalI;
Xextern const GUI_LOGPALETTE GUI_CursorPalI;
N
N/************************************************************
N*
N*        Text rotation
N*
N*************************************************************
N*/
N
Nextern GUI_RECT  GUI_RectDispString; /* Used by LCD_Rotate...() and GUI_DispStringInRect() */
N
N/*********************************************************************
N*
N*       Multitasking support
N*
N**********************************************************************
N*/
Nextern int GUITASK__EntranceCnt;
N
N/*********************************************************************
N*
N*             Bitmap related functions
N*
N**********************************************************************
N*/
N
Nint       GUI_GetBitmapPixelIndex(const GUI_BITMAP GUI_UNI_PTR * pBMP, unsigned x, unsigned y);
Xint       GUI_GetBitmapPixelIndex(const GUI_BITMAP  * pBMP, unsigned x, unsigned y);
NGUI_COLOR GUI_GetBitmapPixelColor(const GUI_BITMAP GUI_UNI_PTR * pBMP, unsigned x, unsigned y);
XGUI_COLOR GUI_GetBitmapPixelColor(const GUI_BITMAP  * pBMP, unsigned x, unsigned y);
N
Nvoid      GUI__DrawBitmap16bpp(int x0, int y0, int xsize, int ysize, const U8 GUI_UNI_PTR * pPixel, const LCD_LOGPALETTE GUI_UNI_PTR * pLogPal, int xMag, int yMag, tLCDDEV_Index2Color * pfIndex2Color);
Xvoid      GUI__DrawBitmap16bpp(int x0, int y0, int xsize, int ysize, const unsigned char  * pPixel, const LCD_LOGPALETTE  * pLogPal, int xMag, int yMag, tLCDDEV_Index2Color * pfIndex2Color);
N
Nextern const GUI_UC_ENC_APILIST GUI_UC_None;
N
N/************************************************************
N*
N*         EXTERNs for GL_CORE
N*
N*************************************************************
N*/
N
N#ifdef  GL_CORE_C
S  #define GUI_EXTERN
N#else
N  #define GUI_EXTERN extern
N#endif
N
NGUI_EXTERN GUI_SADDR GUI_CONTEXT        GUI_Context;        /* Thread wide globals */
Xextern  GUI_CONTEXT        GUI_Context;         
NGUI_EXTERN GUI_SADDR char               GUI_DecChar;
Xextern  char               GUI_DecChar;
NGUI_EXTERN           GUI_tfTimer*       GUI_pfTimerExec;
Xextern           GUI_tfTimer*       GUI_pfTimerExec;
NGUI_EXTERN           WM_tfHandlePID*    WM_pfHandlePID;
Xextern           WM_tfHandlePID*    WM_pfHandlePID;
NGUI_EXTERN      void (*GUI_pfDispCharStyle)(U16 Char);
Xextern      void (*GUI_pfDispCharStyle)(unsigned short Char);
N
N#if GUI_COMPILER_SUPPORTS_FP && GUI_SUPPORT_ROTATION
X#if 1 && 1
N  GUI_EXTERN const     tLCD_APIList *     GUI_pLCD_APIList;   /* Used for rotating text */
X  extern const     tLCD_APIList *     GUI_pLCD_APIList;    
N#endif
N
N#if GUI_SUPPORT_CURSOR
X#if (0 | (1))
N  GUI_EXTERN GUI_CURSOR_tfTempHide*   GUI_CURSOR_pfTempHide;
X  extern GUI_CURSOR_tfTempHide*   GUI_CURSOR_pfTempHide;
N  GUI_EXTERN GUI_CURSOR_tfTempUnhide* GUI_CURSOR_pfTempUnhide;
X  extern GUI_CURSOR_tfTempUnhide* GUI_CURSOR_pfTempUnhide;
N#endif
N
NGUI_EXTERN I16 GUI_OrgX, GUI_OrgY;
Xextern signed short GUI_OrgX, GUI_OrgY;
NGUI_EXTERN U8  GUI_MoveRTL;
Xextern unsigned char  GUI_MoveRTL;
N
N#undef GUI_EXTERN
N
N
N#if defined(__cplusplus)
X#if 0L
S}
N#endif 
N
N#endif   /* Avoid multiple inclusion */
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 28 "..\GUI\Core\GUI_Private.h" 2
N#include "LCD_Private.h"   /* Required because of LCD_PIXELINDEX, which depends on LCDConf */
L 1 "..\GUI\Core\LCD_Private.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : LCD_Private.h
NPurpose     : Internals of the LCD level
N----------------------------------------------------------------------
N*/
N
N#ifndef LCD_Private_H
N#define LCD_Private_H
N
N#include "LCD_ConfDefaults.h"            /* Configuration header file */
L 1 "..\GUI\Core\LCD_ConfDefaults.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : LCD_ConfDefaults.h
NPurpose     : Valid LCD configuration and defaults
N----------------------------------------------------------------------
N*/
N
N#ifndef LCD_CONFIG_DEFAULTS_H
N#define LCD_CONFIG_DEFAULTS_H
N
N#include "LCDConf.h"            /* Configuration header file */
L 1 "..\Config\LCDConf.h" 1
N/*
N*********************************************************************************************************
N*                                             uC/GUI V3.98
N*                        Universal graphic software for embedded applications
N*
N*                       (c) Copyright 2002, Micrium Inc., Weston, FL
N*                       (c) Copyright 2002, SEGGER Microcontroller Systeme GmbH
N*
N*              µC/GUI is protected by international copyright laws. Knowledge of the
N*              source code may not be used to write a similar product. This file may
N*              only be used in accordance with a license and should not be redistributed
N*              in any way. We appreciate your understanding and fairness.
N*
N----------------------------------------------------------------------
NFile        : LCDConf_1375_C8_C320x240.h
NPurpose     : Sample configuration file
N----------------------------------------------------------------------
N*/
N
N#ifndef LCDCONF_H
N#define LCDCONF_H
N
N/*********************************************************************
N*
N*                   General configuration of LCD
N*
N**********************************************************************
N*/
N
N#define LCD_XSIZE      (240)   /* X-resolution of LCD, Logical coor. */
N#define LCD_YSIZE      (320)   /* Y-resolution of LCD, Logical coor. */
N
N#define LCD_BITSPERPIXEL (16)
N
N#define LCD_CONTROLLER  -2
N
N#define LCD_SWAP_RB	1
N#define LCD_SWAP_XY	1
N
N/*********************************************************************
N*
N*                   Full bus configuration
N*
N**********************************************************************
N*/
N
N#define LCD_READ_MEM(Off)            *((U16*)         (0xc00000+(((U32)(Off))<<1)))
N#define LCD_WRITE_MEM(Off,data)      *((U16*)         (0xc00000+(((U32)(Off))<<1)))=data
N#define LCD_READ_REG(Off)            *((volatile U16*)(0xc1ffe0+(((U16)(Off))<<1)))
N#define LCD_WRITE_REG(Off,data)      *((volatile U16*)(0xc1ffe0+(((U16)(Off))<<1)))=data
N
N/*********************************************************************
N*
N*                   Define contents of registers
N*
N**********************************************************************
N*/
N
N#define LCD_REG0  (0)                                          /* Product code */
N
N#define LCD_REG1  (0x23)                                       /* Mode reg 0.    0 for 4 bit mono LCD */            \
N                                                               /*                1 for 8 bit mono LCD */            \
N                                                               /*             0x23 for 8 bit color LCD */           \
N                 |(1<<2)                                       /*             Mask FPSHIFT during h.non-display */
X#define LCD_REG1  (0x23)                                                                                                                                                                                                                            |(1<<2)                                        
N
N#define LCD_REG2 ((3<<6)                                       /* Mode reg 1: Bits per pixel 0:1, 1:2, 2:4, 3:8 */  \
N                 |(1<<5)                                       /* High performance bit for accel. of CPU access */  \
N                 |(1<<4)                                       /* Input clock divide */                             \
N                 |(0<<3)                                       /* Display blank */                                  \
N                 |(0<<2)                                       /* Frame repeat */                                   \
N                 |(0<<1)                                       /* HW video invert enable */                         \
N                 |(0<<0))                                      /* SW video invert */
X#define LCD_REG2 ((3<<6)                                                           |(1<<5)                                                           |(1<<4)                                                                                      |(0<<3)                                                                                           |(0<<2)                                                                                            |(0<<1)                                                                                  |(0<<0))                                       
N                 
N#define LCD_REG3                                               /* Mode reg 2. 0 for 4 bit mono LCD */               \
N                  (0<<7)                                       /* LUT bypass */                                     \
N                 |(0<<3)                                       /* LCDPWR override */                                \
N                 |(0<<2)                                       /* hw power save enable */                           \
N                 |(3<<0)                                       /* Software power save :3 = normal operation */
X#define LCD_REG3                                                                                 (0<<7)                                                                                              |(0<<3)                                                                                         |(0<<2)                                                                                    |(3<<0)                                        
N
N#define LCD_REG4 (LCD_XSIZE/8-1)                               /* horizontal panel size*/
N#define LCD_REG5 ((LCD_YSIZE-1)&255)                           /* Vert. panel size, lsb */
N#define LCD_REG6 ((LCD_YSIZE-1)>>8)                            /* Vert. panel size, msb */
N#define LCD_REG7 (0)                                           /* FPLine start position (TFT only) */
N#define LCD_REG8 (31)                                          /* H.non display period   (0 usually O.K.)*/
N#define LCD_REG9 (0)                                           /* FPFrame start pos.    (TFT only) */
N#define LCD_REGA (0)                                           /* v.non display period  */
N#define LCD_REGB (0)                                           /* mod rate register     0: every frame */
N#define LCD_REGC (0)                                           /* Screen 1 start lsb    */
N#define LCD_REGD (0)                                           /* Screen 1 start msb    */
N
N#define LCD_REG12 (LCD_BITSPERPIXEL*(LCD_VXSIZE-LCD_XSIZE)/16) /* Memory Address offset (usually 0) */
N#define LCD_REG13 LCD_REG5                                     /* Vert. screen 1 size, lsb */
N#define LCD_REG14 LCD_REG6                                     /* Vert. screen 1 size, msb */
N
N#define LCD_REG1B (0)                                          /* No swivel mode  (use 0xc0 for alt.swivel)  */
N#define LCD_REG1C (0x78)                                       /* bytes per line (stride, for swivel mode only)  */
N
N/*********************************************************************
N*
N*                   Init sequence for 16 bit access
N*
N**********************************************************************
N*/
N
N#if !LCD_SWAP_BYTE_ORDER
N  #define LCD_WRITE_REGLH(Adr, d0, d1) LCD_WRITE_REG(Adr, ((d0)<<8) | (d1))
N#else
S  #define LCD_WRITE_REGLH(Adr, d0, d1) LCD_WRITE_REG(Adr, ((d1)<<8) | (d0))
N#endif  
N
N#define LCD_INIT_CONTROLLER()                                                                    \
N        LCD_WRITE_REGLH(0x00>>1,LCD_REG0, LCD_REG1);                                             \
N        LCD_WRITE_REGLH(0x02>>1,LCD_REG2, LCD_REG3);                                             \
N        LCD_WRITE_REGLH(0x04>>1,LCD_REG4, LCD_REG5);                                             \
N        LCD_WRITE_REGLH(0x06>>1,LCD_REG6, LCD_REG7);                                             \
N        LCD_WRITE_REGLH(0x08>>1,LCD_REG8, LCD_REG9);                                             \
N        LCD_WRITE_REGLH(0x0a>>1,LCD_REGA, LCD_REGB);                                             \
N        LCD_WRITE_REGLH(0x0c>>1,LCD_REGC, LCD_REGD);                                             \
N        LCD_WRITE_REG  (0x0e>>1,0x00);                 /* 0, screen 2 start l*/                  \
N        LCD_WRITE_REG  (0x10>>1,0x00);                 /* screen 2 start h */                    \
N        LCD_WRITE_REGLH(0x12>>1,LCD_REG12, LCD_REG13); /* mem adr. offset, screen 1 vsize(lsb)*/ \
N        LCD_WRITE_REGLH(0x14>>1,LCD_REG14, 0);                                                   \
N        LCD_WRITE_REGLH(0x1a>>1,0, LCD_REG1B);                                                   \
N        LCD_WRITE_REGLH(0x1c>>1,LCD_REG1C, 0)
X#define LCD_INIT_CONTROLLER()                                                                            LCD_WRITE_REGLH(0x00>>1,LCD_REG0, LCD_REG1);                                                     LCD_WRITE_REGLH(0x02>>1,LCD_REG2, LCD_REG3);                                                     LCD_WRITE_REGLH(0x04>>1,LCD_REG4, LCD_REG5);                                                     LCD_WRITE_REGLH(0x06>>1,LCD_REG6, LCD_REG7);                                                     LCD_WRITE_REGLH(0x08>>1,LCD_REG8, LCD_REG9);                                                     LCD_WRITE_REGLH(0x0a>>1,LCD_REGA, LCD_REGB);                                                     LCD_WRITE_REGLH(0x0c>>1,LCD_REGC, LCD_REGD);                                                     LCD_WRITE_REG  (0x0e>>1,0x00);                                            LCD_WRITE_REG  (0x10>>1,0x00);                                              LCD_WRITE_REGLH(0x12>>1,LCD_REG12, LCD_REG13);           LCD_WRITE_REGLH(0x14>>1,LCD_REG14, 0);                                                           LCD_WRITE_REGLH(0x1a>>1,0, LCD_REG1B);                                                           LCD_WRITE_REGLH(0x1c>>1,LCD_REG1C, 0)
N 
N#endif /* LCDCONF_H */
N
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 24 "..\GUI\Core\LCD_ConfDefaults.h" 2
N#include "GUI_ConfDefaults.h"   /* Needed for GUI_NUM_LAYERS */
N/*********************************************************************
N*
N*      Map the defines for this controller
N*
N*      #define LCD_<xxx> LCD_<xxx>_0
N*
N**********************************************************************
N*/
N
N#ifdef LCD_INIT_CONTROLLER_0
S  #define LCD_INIT_CONTROLLER LCD_INIT_CONTROLLER_0
N#endif
N
N#ifdef  LCD_CONTROLLER_0
S  #define LCD_CONTROLLER     LCD_CONTROLLER_0
N#endif
N
N#ifdef LCD_XSIZE_0
S  #define LCD_XSIZE          LCD_XSIZE_0
N#endif
N
N#ifdef  LCD_YSIZE_0
S  #define LCD_YSIZE          LCD_YSIZE_0
N#endif
N
N#ifdef  LCD_BITSPERPIXEL_0
S  #define LCD_BITSPERPIXEL   LCD_BITSPERPIXEL_0
N#endif
N
N#ifdef  LCD_VYSIZE_0
S  #define LCD_VYSIZE          LCD_VYSIZE_0
N#endif
N
N#ifdef LCD_MIRROR_X_0
S  #define LCD_MIRROR_X  LCD_MIRROR_X_0
N#endif
N
N#ifdef LCD_MIRROR_Y_0
S  #define LCD_MIRROR_Y  LCD_MIRROR_Y_0
N#endif
N
N#ifdef LCD_SWAP_XY_0
S  #define LCD_SWAP_XY   LCD_SWAP_XY_0
N#endif
N
N#ifdef LCD_CACHE_CONTROL_0
S  #define LCD_CACHE_CONTROL LCD_CACHE_CONTROL_0
N#endif
N
N#ifdef LCD_FIRSTSEG0_0
S  #define LCD_FIRSTSEG0   LCD_FIRSTSEG0_0
N#endif
N
N#ifdef LCD_LASTSEG0_0
S  #define LCD_LASTSEG0    LCD_LASTSEG0_0
N#endif
N
N#ifdef LCD_FIRSTCOM0_0
S  #define LCD_FIRSTCOM0   LCD_FIRSTCOM0_0
N#endif
N
N#ifdef LCD_LASTCOM0_0
S  #define LCD_LASTCOM0    LCD_LASTCOM0_0
N#endif
N
N#ifdef LCD_BITSPERPIXEL_L0_0
S  #define LCD_BITSPERPIXEL_L0 LCD_BITSPERPIXEL_0
N#endif
N
N#ifdef LCD_DELTA_MODE_0
S  #define LCD_DELTA_MODE LCD_DELTA_MODE_0
N#endif
N
N#ifdef LCD_XORG0_0
S  #define LCD_XORG0       LCD_XORG0_0
N#endif
N
N#ifdef LCD_YORG0_0
S  #define LCD_YORG0       LCD_YORG0_0
N#endif
N
N#ifdef LCD_FIXEDPALETTE_0
S  #define LCD_FIXEDPALETTE LCD_FIXEDPALETTE_0
N#endif
N
N#ifdef LCD_CACHE_0
S  #ifdef  LCD_CACHE
S    #undef  LCD_CACHE
S  #endif
S  #define LCD_CACHE LCD_CACHE_0
N#endif
N
N#ifdef LCD_CHECKBUSY_0
S  #ifdef LCD_CHECKBUSY
S    #undef  LCD_CHECKBUSY
S  #endif
S  #define LCD_CHECKBUSY LCD_CHECKBUSY_0
N#endif
N
N#ifdef LCD_SWAP_BYTE_ORDER_0
S  #define LCD_SWAP_BYTE_ORDER LCD_SWAP_BYTE_ORDER_0
N#endif
N
N#ifdef LCD_SWAP_RB_0
S  #define LCD_SWAP_RB LCD_SWAP_RB_0
N#endif
N
N#ifdef LCD_PHYSCOLORS_0
S  #define LCD_PHYSCOLORS LCD_PHYSCOLORS_0
N#endif
N
N#ifndef LCD_ALLOW_NON_OPTIMIZED_MODE
N  #define LCD_ALLOW_NON_OPTIMIZED_MODE 0
N#endif
N
N/*********************************************************************
N*
N*      Some error checking
N*
N**********************************************************************
N*/
N  #ifndef LCD_CONTROLLER
S    #error LCD_CONTROLLER not defined !
N  #endif
N
N
N/*******************************************************************
N*
N*               Defaults for config switches
N*
N********************************************************************
N*/
N
N
N
N#ifndef LCD_NUM_CONTROLLERS
N  #define LCD_NUM_CONTROLLERS (1)
N#endif
N
N#ifndef LCD_NUM_COLORS
N  #define LCD_NUM_COLORS (1L<<LCD_BITSPERPIXEL)
N#endif
N
N
N
N/*********************************************************************
N*
N*      Map the defines for controller 0 to general defines
N*
N**********************************************************************
N*/
N
N/* Allow use of multiple physical lines for one logical line ...
N   Used for delta-type LCDs, where value should be 2 */
N
N#ifndef LCD_YMAG
N  #define LCD_YMAG 1
N#endif
N#ifndef LCD_XMAG
N  #define LCD_XMAG 1
N#endif
N
N#ifndef LCD_VXSIZE
N  #define LCD_VXSIZE      (LCD_XSIZE*LCD_XMAG) /* virtual x-size */
N#endif
N#ifndef LCD_VYSIZE
N  #define LCD_VYSIZE      (LCD_YSIZE*LCD_YMAG) /* virtual y-size */
N#endif
N
N#ifndef LCD_SWAP_BYTE_ORDER
N  #define LCD_SWAP_BYTE_ORDER (0)    /* only for 16 bit bus, default is not swapped */
N#endif
N
N#ifndef  LCD_MAX_LOG_COLORS
N  #define  LCD_MAX_LOG_COLORS (256)
N#endif
N
N/* Optionally swap red and blue components */
N#ifndef LCD_SWAP_RB
S  #define LCD_SWAP_RB 0
N#endif
N
N/*********************************************************************
N*
N*      Defaults for Display 0 (first display)
N*
N**********************************************************************
N*/
N
N#ifndef LCD_MIRROR_X
N  #define LCD_MIRROR_X   (0)    /* If active:  X -> -X */
N#endif
N#ifndef LCD_MIRROR_Y
N  #define LCD_MIRROR_Y   (0)    /* If active:  Y -> -Y */
N#endif
N#ifndef LCD_SWAP_XY
S  #define LCD_SWAP_XY    (0)    /* If active:  X <-> Y */
N#endif
N#ifndef LCD_BITSPERPIXEL_L0
N  #define LCD_BITSPERPIXEL_L0 LCD_BITSPERPIXEL
N#endif
N#ifndef LCD_DELTA_MODE
N  #define LCD_DELTA_MODE 0 /**/
N#endif
N
N/* Position data for controller 0 */
N#ifndef LCD_XORG0
N  #define LCD_XORG0     (0)     /* leftmost position covered by this controller */
N#endif
N#ifndef LCD_YORG0
N  #define LCD_YORG0     (0)     /* topmost position covered by this controller */
N#endif
N#ifndef LCD_XSIZE0
N  #define LCD_XSIZE0    (LCD_XSIZE)   /* horizontal size covered by this controller */
N#endif
N#ifndef LCD_YSIZE0
N #define LCD_YSIZE0    (LCD_YSIZE)   /* vertical size covered by this controller */
N#endif
N#ifndef LCD_FIRSTSEG0
N  #define LCD_FIRSTSEG0 (0)     /* first segment used by this controller */
N#endif
N#ifndef LCD_LASTSEG0
N  #define LCD_LASTSEG0    (LCD_XSIZE-1) /* Contr.0: last segment line used */
N#endif
N#ifndef LCD_FIRSTCOM0
N  #define LCD_FIRSTCOM0 (0)     /* first com used by this controller */
N#endif
N#ifndef LCD_LASTCOM0
N  #define LCD_LASTCOM0    (LCD_YSIZE-1) /* Contr.0: last com line used */
N#endif
N
N#if (!LCD_SWAP_XY)
X#if (!1)
S  #define LCD_XSIZE_PHYS  LCD_XSIZE
S  #define LCD_YSIZE_PHYS  LCD_YSIZE
S  #define LCD_VXSIZE_PHYS LCD_VXSIZE
S  #define LCD_VYSIZE_PHYS LCD_VYSIZE
N#else
N  #define LCD_XSIZE_PHYS  LCD_YSIZE
N  #define LCD_YSIZE_PHYS  LCD_XSIZE
N  #define LCD_VXSIZE_PHYS LCD_VYSIZE
N  #define LCD_VYSIZE_PHYS LCD_VXSIZE
N#endif
N
N
N/**********************************************************
N*
N*       Color settings
N*/
N#ifndef LCD_REVERSE
N  #define LCD_REVERSE 0
N#endif
N
N#ifndef LCD_REVERSE_LUT
N  #define LCD_REVERSE_LUT 0
N#endif
N
N#ifndef LCD_PHYSCOLORS_IN_RAM
N  #define LCD_PHYSCOLORS_IN_RAM 0
N#endif
N
N#if !defined (LCD_PHYSCOLORS)
X#if !0L
N  #if   (LCD_BITSPERPIXEL == 1) | (LCD_BITSPERPIXEL == 2) | (LCD_BITSPERPIXEL == 4)
X  #if   ((16) == 1) | ((16) == 2) | ((16) == 4)
S    #ifndef LCD_FIXEDPALETTE
S      #define LCD_FIXEDPALETTE LCD_BITSPERPIXEL
S    #endif
N  #endif
N#endif /* defined (LCD_PHYSCOLORS) */
N
N#if !defined (LCD_FIXEDPALETTE)
X#if !0L
N  #if !defined (LCD_PHYSCOLORS)
X  #if !0L
N    #if LCD_BITSPERPIXEL == 8
X    #if (16) == 8
S      #define LCD_FIXEDPALETTE 8666
S    #elif LCD_BITSPERPIXEL == 12
X    #elif (16) == 12
S      #define LCD_FIXEDPALETTE 44412
S    #elif LCD_BITSPERPIXEL == 15
X    #elif (16) == 15
S      #define LCD_FIXEDPALETTE 555
N    #elif LCD_BITSPERPIXEL == 16
X    #elif (16) == 16
N      #define LCD_FIXEDPALETTE 565
N    #elif LCD_BITSPERPIXEL == 24
S      #define LCD_FIXEDPALETTE 888
S    #else
S      #define LCD_FIXEDPALETTE 0
N    #endif
N  #else
S    #define LCD_FIXEDPALETTE 0
N  #endif
N#endif
N
N#if (LCD_BITSPERPIXEL > 8) && defined (LCD_PHYSCOLORS)
X#if ((16) > 8) && 0L
S  #error List of physical colors not permitted if more than 8 bpp are used !
N#endif
N
N#if (LCD_FIXEDPALETTE==0)
X#if (565==0)
S  #if !defined(LCD_PHYSCOLORS)
S    #error You have to define a fixed palette (LCD_FIXEDPALETTE) or
S    #error the list of physical colors (LCD_PHYSCOLORS) in LCDConf.h !
S  #endif
N#endif
N
N
N/* In order to avoid warnings for undefined parameters */
N#ifndef LCD_USE_PARA
N  #define LCD_USE_PARA(para) para=para;
N#endif
N
N/*********************************************************************
N*
N*      Defaults for Display 1 (second display)
N*
N**********************************************************************
N*/
N#if GUI_NUM_LAYERS > 1
X#if 1 > 1
S
S  #ifndef LCD_MIRROR_X_1
S    #define LCD_MIRROR_X_1   (0)    /* If active:  X -> -X */
S  #endif
S  #ifndef LCD_MIRROR_Y_1
S    #define LCD_MIRROR_Y_1   (0)    /* If active:  Y -> -Y */
S  #endif
S  #ifndef LCD_SWAP_XY_1
S    #define LCD_SWAP_XY_1    (0)    /* If active:  X <-> Y */
S  #endif
S  #ifndef LCD_BITSPERPIXEL_L0_1
S    #define LCD_BITSPERPIXEL_L0_1 LCD_BITSPERPIXEL_1
S  #endif
S  #ifndef LCD_DELTA_MODE_1
S    #define LCD_DELTA_MODE_1 0 /**/
S  #endif
S
S  #ifndef LCD_YMAG_1
S    #define LCD_YMAG_1 1
S  #endif
S
S  #ifndef LCD_XMAG_1
S    #define LCD_XMAG_1 1
S  #endif
S
S  #ifndef LCD_VXSIZE_1
S    #define LCD_VXSIZE_1      (LCD_XSIZE_1 * LCD_XMAG_1) /* virtual x-size */
S  #endif
S
S  #ifndef LCD_VYSIZE_1
S    #define LCD_VYSIZE_1      (LCD_YSIZE_1 * LCD_YMAG_1) /* virtual y-size */
S  #endif
S
S  #ifndef LCD_NUM_COLORS_1
S    #define LCD_NUM_COLORS_1 (1L<<LCD_BITSPERPIXEL_1)
S  #endif
S
S  /* Optionally swap red and blue components */
S  #ifndef LCD_SWAP_RB_1
S    #define LCD_SWAP_RB_1 0
S  #endif
S
S/**********************************************************
S*
S*       Color settings
S*/
S  #ifndef LCD_REVERSE_1
S    #define LCD_REVERSE_1 0
S  #endif
S
S  #ifndef LCD_REVERSE_LUT_1
S    #define LCD_REVERSE_LUT_1 0
S  #endif
S
S  #if !defined (LCD_PHYSCOLORS_1)
S    #if   (LCD_BITSPERPIXEL_1 == 1) | (LCD_BITSPERPIXEL_1 == 2) | (LCD_BITSPERPIXEL_1 == 4)
S      #ifndef LCD_FIXEDPALETTE_1
S        #define LCD_FIXEDPALETTE_1 LCD_BITSPERPIXEL_1
S      #endif
S    #endif
S  #endif /* defined (LCD_PHYSCOLORS) */
S
S  #if !defined (LCD_FIXEDPALETTE_1)
S    #if !defined (LCD_PHYSCOLORS_1)
S      #if LCD_BITSPERPIXEL_1 == 8
S        #define LCD_FIXEDPALETTE_1 8666
S      #elif LCD_BITSPERPIXEL_1 == 15
S        #define LCD_FIXEDPALETTE_1 555
S      #elif LCD_BITSPERPIXEL_1 == 16
S        #define LCD_FIXEDPALETTE_1 565
S      #else
S        #define LCD_FIXEDPALETTE_1 0
S      #endif
S    #else
S      #define LCD_FIXEDPALETTE_1 0
S    #endif
S  #endif
S
S  #if (LCD_BITSPERPIXEL_1 > 8) && defined (LCD_PHYSCOLORS_1)
S    #error List of physical colors not permitted if more than 8 bpp are used !
S  #endif
S
S  #if (LCD_FIXEDPALETTE_1 == 0)
S    #if !defined(LCD_PHYSCOLORS_1)
S      #error You have to define a fixed palette (LCD_FIXEDPALETTE_1) or
S      #error the list of physical colors (LCD_PHYSCOLORS_1) in LCDConf.h !
S    #endif
S  #endif
N#endif   /* GUI_NUM_LAYERS > 1 */
N
N/*********************************************************************
N*
N*      Defaults for Display 2 (third display)
N*
N**********************************************************************
N*/
N#if GUI_NUM_LAYERS > 2
X#if 1 > 2
S
S  #ifndef LCD_MIRROR_X_2
S    #define LCD_MIRROR_X_2   (0)    /* If active:  X -> -X */
S  #endif
S  #ifndef LCD_MIRROR_Y_2
S    #define LCD_MIRROR_Y_2   (0)    /* If active:  Y -> -Y */
S  #endif
S  #ifndef LCD_SWAP_XY_2
S    #define LCD_SWAP_XY_2    (0)    /* If active:  X <-> Y */
S  #endif
S  #ifndef LCD_BITSPERPIXEL_L0_2
S    #define LCD_BITSPERPIXEL_L0_2 LCD_BITSPERPIXEL_2
S  #endif
S  #ifndef LCD_DELTA_MODE_2
S    #define LCD_DELTA_MODE_2 0 /**/
S  #endif
S
S  #ifndef LCD_YMAG_2
S    #define LCD_YMAG_2 1
S  #endif
S
S  #ifndef LCD_XMAG_2
S    #define LCD_XMAG_2 1
S  #endif
S
S  #ifndef LCD_VXSIZE_2
S    #define LCD_VXSIZE_2      (LCD_XSIZE_2 * LCD_XMAG_2) /* virtual x-size */
S  #endif
S
S  #ifndef LCD_VYSIZE_2
S    #define LCD_VYSIZE_2      (LCD_YSIZE_2 * LCD_YMAG_2) /* virtual y-size */
S  #endif
S
S  #ifndef LCD_NUM_COLORS_2
S    #define LCD_NUM_COLORS_2 (1L<<LCD_BITSPERPIXEL_2)
S  #endif
S
S  /* Optionally swap red and blue components */
S  #ifndef LCD_SWAP_RB_2
S    #define LCD_SWAP_RB_2 0
S  #endif
S
S/**********************************************************
S*
S*       Color settings
S*/
S  #ifndef LCD_REVERSE_2
S    #define LCD_REVERSE_2 0
S  #endif
S
S  #ifndef LCD_REVERSE_LUT_2
S    #define LCD_REVERSE_LUT_2 0
S  #endif
S
S  #if !defined (LCD_PHYSCOLORS_2)
S    #if   (LCD_BITSPERPIXEL_2 == 1) | (LCD_BITSPERPIXEL_2 == 2) | (LCD_BITSPERPIXEL_2 == 4)
S      #ifndef LCD_FIXEDPALETTE_2
S        #define LCD_FIXEDPALETTE_2 LCD_BITSPERPIXEL_2
S      #endif
S    #endif
S  #endif /* defined (LCD_PHYSCOLORS) */
S
S  #if !defined (LCD_FIXEDPALETTE_2)
S    #if !defined (LCD_PHYSCOLORS_2)
S      #if LCD_BITSPERPIXEL_2 == 8
S        #define LCD_FIXEDPALETTE_2 8666
S      #elif LCD_BITSPERPIXEL_2 == 15
S        #define LCD_FIXEDPALETTE_2 555
S      #elif LCD_BITSPERPIXEL_2 == 16
S        #define LCD_FIXEDPALETTE_2 565
S      #else
S        #define LCD_FIXEDPALETTE_2 0
S      #endif
S    #else
S      #define LCD_FIXEDPALETTE_2 0
S    #endif
S  #endif
S
S  #if (LCD_BITSPERPIXEL_2 > 8) && defined (LCD_PHYSCOLORS_2)
S    #error List of physical colors not permitted if more than 8 bpp are used !
S  #endif
S
S  #if (LCD_FIXEDPALETTE_2 == 0)
S    #if !defined(LCD_PHYSCOLORS_2)
S      #error You have to define a fixed palette (LCD_FIXEDPALETTE_2) or
S      #error the list of physical colors (LCD_PHYSCOLORS_2) in LCDConf.h !
S    #endif
S  #endif
N#endif   /* GUI_NUM_LAYERS > 2 */
N
N/*********************************************************************
N*
N*      Defaults for Display 3 (fourth display)
N*
N**********************************************************************
N*/
N#if GUI_NUM_LAYERS > 3
X#if 1 > 3
S
S  #ifndef LCD_MIRROR_X_3
S    #define LCD_MIRROR_X_3   (0)    /* If active:  X -> -X */
S  #endif
S  #ifndef LCD_MIRROR_Y_3
S    #define LCD_MIRROR_Y_3   (0)    /* If active:  Y -> -Y */
S  #endif
S  #ifndef LCD_SWAP_XY_3
S    #define LCD_SWAP_XY_3    (0)    /* If active:  X <-> Y */
S  #endif
S  #ifndef LCD_BITSPERPIXEL_L0_3
S    #define LCD_BITSPERPIXEL_L0_3 LCD_BITSPERPIXEL_3
S  #endif
S  #ifndef LCD_DELTA_MODE_3
S    #define LCD_DELTA_MODE_3 0 /**/
S  #endif
S
S  #ifndef LCD_YMAG_3
S    #define LCD_YMAG_3 1
S  #endif
S
S  #ifndef LCD_XMAG_3
S    #define LCD_XMAG_3 1
S  #endif
S
S  #ifndef LCD_VXSIZE_3
S    #define LCD_VXSIZE_3      (LCD_XSIZE_3 * LCD_XMAG_3) /* virtual x-size */
S  #endif
S
S  #ifndef LCD_VYSIZE_3
S    #define LCD_VYSIZE_3      (LCD_YSIZE_3 * LCD_YMAG_3) /* virtual y-size */
S  #endif
S
S  #ifndef LCD_NUM_COLORS_3
S    #define LCD_NUM_COLORS_3 (1L<<LCD_BITSPERPIXEL_3)
S  #endif
S
S  /* Optionally swap red and blue components */
S  #ifndef LCD_SWAP_RB_3
S    #define LCD_SWAP_RB_3 0
S  #endif
S
S/**********************************************************
S*
S*       Color settings
S*/
S  #ifndef LCD_REVERSE_3
S    #define LCD_REVERSE_3 0
S  #endif
S
S  #ifndef LCD_REVERSE_LUT_3
S    #define LCD_REVERSE_LUT_3 0
S  #endif
S
S  #if !defined (LCD_PHYSCOLORS_3)
S    #if   (LCD_BITSPERPIXEL_3 == 1) | (LCD_BITSPERPIXEL_3 == 2) | (LCD_BITSPERPIXEL_3 == 4)
S      #ifndef LCD_FIXEDPALETTE_3
S        #define LCD_FIXEDPALETTE_3 LCD_BITSPERPIXEL_3
S      #endif
S    #endif
S  #endif /* defined (LCD_PHYSCOLORS) */
S
S  #if !defined (LCD_FIXEDPALETTE_3)
S    #if !defined (LCD_PHYSCOLORS_3)
S      #if LCD_BITSPERPIXEL_3 == 8
S        #define LCD_FIXEDPALETTE_3 8666
S      #elif LCD_BITSPERPIXEL_3 == 15
S        #define LCD_FIXEDPALETTE_3 555
S      #elif LCD_BITSPERPIXEL_3 == 16
S        #define LCD_FIXEDPALETTE_3 565
S      #else
S        #define LCD_FIXEDPALETTE_3 0
S      #endif
S    #else
S      #define LCD_FIXEDPALETTE_3 0
S    #endif
S  #endif
S
S  #if (LCD_BITSPERPIXEL_3 > 8) && defined (LCD_PHYSCOLORS_3)
S    #error List of physical colors not permitted if more than 8 bpp are used !
S  #endif
S
S  #if (LCD_FIXEDPALETTE_3 == 0)
S    #if !defined(LCD_PHYSCOLORS_3)
S      #error You have to define a fixed palette (LCD_FIXEDPALETTE_3) or
S      #error the list of physical colors (LCD_PHYSCOLORS_3) in LCDConf.h !
S    #endif
S  #endif
N#endif   /* GUI_NUM_LAYERS > 3 */
N
N/*********************************************************************
N*
N*      Defaults for Display 4 (fiveth display)
N*
N**********************************************************************
N*/
N#if GUI_NUM_LAYERS > 4
X#if 1 > 4
S
S  #ifndef LCD_MIRROR_X_4
S    #define LCD_MIRROR_X_4   (0)    /* If active:  X -> -X */
S  #endif
S  #ifndef LCD_MIRROR_Y_4
S    #define LCD_MIRROR_Y_4   (0)    /* If active:  Y -> -Y */
S  #endif
S  #ifndef LCD_SWAP_XY_4
S    #define LCD_SWAP_XY_4    (0)    /* If active:  X <-> Y */
S  #endif
S  #ifndef LCD_BITSPERPIXEL_L0_4
S    #define LCD_BITSPERPIXEL_L0_4 LCD_BITSPERPIXEL_4
S  #endif
S  #ifndef LCD_DELTA_MODE_4
S    #define LCD_DELTA_MODE_4 0 /**/
S  #endif
S
S  #ifndef LCD_YMAG_4
S    #define LCD_YMAG_4 1
S  #endif
S
S  #ifndef LCD_XMAG_4
S    #define LCD_XMAG_4 1
S  #endif
S
S  #ifndef LCD_VXSIZE_4
S    #define LCD_VXSIZE_4      (LCD_XSIZE_4 * LCD_XMAG_4) /* virtual x-size */
S  #endif
S
S  #ifndef LCD_VYSIZE_4
S    #define LCD_VYSIZE_4      (LCD_YSIZE_4 * LCD_YMAG_4) /* virtual y-size */
S  #endif
S
S  #ifndef LCD_NUM_COLORS_4
S    #define LCD_NUM_COLORS_4 (1L<<LCD_BITSPERPIXEL_4)
S  #endif
S
S  /* Optionally swap red and blue components */
S  #ifndef LCD_SWAP_RB_4
S    #define LCD_SWAP_RB_4 0
S  #endif
S
S/**********************************************************
S*
S*       Color settings
S*/
S  #ifndef LCD_REVERSE_4
S    #define LCD_REVERSE_4 0
S  #endif
S
S  #ifndef LCD_REVERSE_LUT_4
S    #define LCD_REVERSE_LUT_4 0
S  #endif
S
S  #if !defined (LCD_PHYSCOLORS_4)
S    #if   (LCD_BITSPERPIXEL_4 == 1) | (LCD_BITSPERPIXEL_4 == 2) | (LCD_BITSPERPIXEL_4 == 4)
S      #ifndef LCD_FIXEDPALETTE_4
S        #define LCD_FIXEDPALETTE_4 LCD_BITSPERPIXEL_4
S      #endif
S    #endif
S  #endif /* defined (LCD_PHYSCOLORS) */
S
S  #if !defined (LCD_FIXEDPALETTE_4)
S    #if !defined (LCD_PHYSCOLORS_4)
S      #if LCD_BITSPERPIXEL_4 == 8
S        #define LCD_FIXEDPALETTE_4 8666
S      #elif LCD_BITSPERPIXEL_4 == 15
S        #define LCD_FIXEDPALETTE_4 555
S      #elif LCD_BITSPERPIXEL_4 == 16
S        #define LCD_FIXEDPALETTE_4 565
S      #else
S        #define LCD_FIXEDPALETTE_4 0
S      #endif
S    #else
S      #define LCD_FIXEDPALETTE_4 0
S    #endif
S  #endif
S
S  #if (LCD_BITSPERPIXEL_4 > 8) && defined (LCD_PHYSCOLORS_4)
S    #error List of physical colors not permitted if more than 8 bpp are used !
S  #endif
S
S  #if (LCD_FIXEDPALETTE_4 == 0)
S    #if !defined(LCD_PHYSCOLORS_4)
S      #error You have to define a fixed palette (LCD_FIXEDPALETTE_4) or
S      #error the list of physical colors (LCD_PHYSCOLORS_4) in LCDConf.h !
S    #endif
S  #endif
N#endif   /* GUI_NUM_LAYERS > 4 */
N
N
N
N/*********************************************************************
N*
N*      Global defaults for all displays
N*
N**********************************************************************
N*/
N
N
N#if (LCD_BITSPERPIXEL <= 8) && (GUI_NUM_LAYERS < 2)
X#if ((16) <= 8) && (1 < 2)
S  #define LCD_PIXELINDEX U8
N#else
N  #if (LCD_BITSPERPIXEL < 24)
X  #if ((16) < 24)
N    #define LCD_PIXELINDEX U16
N  #else
S    #define LCD_PIXELINDEX U32
N  #endif
N#endif
N
N
N
N
N
N#endif /* LCD_INTERN_H */
N
N
N
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 24 "..\GUI\Core\LCD_Private.h" 2
N#include "LCD_Protected.h"
N#include "GUI.h"
N
Ntypedef struct {
N  LCD_COLOR * paColor;
N  I16         NumEntries;
X  signed short         NumEntries;
N} LCD_LUT_INFO;
N
N#if LCD_PHYSCOLORS_IN_RAM
X#if 0
S  #if (LCD_FIXEDPALETTE == 0)
S    #if (LCD_FIXEDPALETTE == 0)
S      extern LCD_COLOR LCD_PhysColors[1 << LCD_BITSPERPIXEL];
S    #endif
S  #endif
S  #if (GUI_NUM_LAYERS > 1)
S    #if (LCD_FIXEDPALETTE_1 == 0)
S      extern LCD_COLOR LCD_PhysColors_1[1 << LCD_BITSPERPIXEL_1];
S    #endif
S  #endif
S  #if (GUI_NUM_LAYERS > 2)
S    #if (LCD_FIXEDPALETTE_2 == 0)
S      extern LCD_COLOR LCD_PhysColors_2[1 << LCD_BITSPERPIXEL_2];
S    #endif
S  #endif
S  #if (GUI_NUM_LAYERS > 3)
S    #if (LCD_FIXEDPALETTE_3 == 0)
S      extern LCD_COLOR LCD_PhysColors_3[1 << LCD_BITSPERPIXEL_3];
S    #endif
S  #endif
S  #if (GUI_NUM_LAYERS > 4)
S    #if (LCD_FIXEDPALETTE_4 == 0)
S      extern LCD_COLOR LCD_PhysColors_4[1 << LCD_BITSPERPIXEL_4];
S    #endif
S  #endif
N#endif
N
N#if GUI_COMPILER_SUPPORTS_FP
X#if 1
N
Nextern const struct tLCDDEV_APIList_struct * /* const */ LCD_aAPI[GUI_NUM_LAYERS];
Xextern const struct tLCDDEV_APIList_struct *   LCD_aAPI[1];
N
Nconst tLCDDEV_APIList* LCD_SetAPI      (const tLCDDEV_APIList* pAPI, int Index);
Nconst tLCDDEV_APIList* LCD_SetAPIForAll(const tLCDDEV_APIList* pAPI, int Index);
N
N#endif
N
N#if (LCD_BITSPERPIXEL <= 8) && (GUI_NUM_LAYERS < 2)
X#if ((16) <= 8) && (1 < 2)
S  #define LCD_BKCOLORINDEX GUI_Context.LCD.aColorIndex8[0]
S  #define LCD_COLORINDEX   GUI_Context.LCD.aColorIndex8[1]
S  #define LCD_ACOLORINDEX  GUI_Context.LCD.aColorIndex8
N#elif (LCD_BITSPERPIXEL <= 16)
X#elif ((16) <= 16)
N  #define LCD_BKCOLORINDEX GUI_Context.LCD.aColorIndex16[0]
N  #define LCD_COLORINDEX   GUI_Context.LCD.aColorIndex16[1]
N  #define LCD_ACOLORINDEX  GUI_Context.LCD.aColorIndex16
N#else
S  #define LCD_BKCOLORINDEX GUI_Context.LCD.aColorIndex32[0]
S  #define LCD_COLORINDEX   GUI_Context.LCD.aColorIndex32[1]
S  #define LCD_ACOLORINDEX  GUI_Context.LCD.aColorIndex32
N#endif
N
Nextern LCD_PIXELINDEX LCD__aConvTable[LCD_MAX_LOG_COLORS];
Xextern unsigned short LCD__aConvTable[(256)];
Nvoid LCD_DrawBitmap   (int x0, int y0,
N                       int xsize, int ysize,
N                       int xMul, int yMul,
N                       int BitsPerPixel,
N                       int BytesPerLine,
N                       const U8 GUI_UNI_PTR * pPixel,
X                       const unsigned char  * pPixel,
N                       const LCD_PIXELINDEX* pTrans);
X                       const unsigned short* pTrans);
Nvoid LCD_UpdateColorIndices(void);
N
N#if GUI_SUPPORT_DEVICES
X#if (1 | (1 > 1))
N  void LCD_ReadRect(int x0, int y0, int x1, int y1, LCD_PIXELINDEX * pBuffer, const tLCDDEV_APIList * pAPI);
X  void LCD_ReadRect(int x0, int y0, int x1, int y1, unsigned short * pBuffer, const tLCDDEV_APIList * pAPI);
N#endif
N
N/*********************************************************************
N*
N*          Support for Segment/COMLUTs
N*
N**********************************************************************
N*/
N
N#define LCD_TYPE_SEGTRANS U16
N#define LCD_TYPE_COMTRANS U16
N
N#ifdef LCD_LUT_COM
S  #ifdef LCDCOLOR_C
S    LCD_TYPE_COMTRANS LCD__aLine2Com0[LCD_YSIZE] = { LCD_LUT_COM };
S  #else
S    extern LCD_TYPE_COMTRANS LCD__aLine2Com0[LCD_YSIZE];
S  #endif
N#endif
N
N#ifdef LCD_LUT_SEG
S  #ifdef LCDCOLOR_C
S    LCD_TYPE_SEGTRANS LCD__aCol2Seg0[LCD_XSIZE] = { LCD_LUT_SEG };
S  #else
S    extern LCD_TYPE_COMTRANS LCD__aCol2Seg0[LCD_XSIZE];
S  #endif
N#endif
N
N#endif /* Avoid multiple inclusion */
N
N
N/*************************** End of file ****************************/
N
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 29 "..\GUI\Core\GUI_Private.h" 2
N
N#if GUI_SUPPORT_DEVICES
X#if (1 | (1 > 1))
N  #define LCDDEV_L0_Color2Index         GUI_Context.pDeviceAPI->pfColor2Index
N  #define LCDDEV_L0_DrawBitmap          GUI_Context.pDeviceAPI->pfDrawBitmap
N  #define LCDDEV_L0_DrawHLine           GUI_Context.pDeviceAPI->pfDrawHLine
N  #define LCDDEV_L0_DrawVLine           GUI_Context.pDeviceAPI->pfDrawVLine
N  #define LCDDEV_L0_DrawPixel           GUI_Context.pDeviceAPI->pfDrawPixel
N  #define LCDDEV_L0_FillRect            GUI_Context.pDeviceAPI->pfFillRect
N  #define LCDDEV_L0_GetPixel            GUI_Context.pDeviceAPI->pfGetPixel
N  #define LCDDEV_L0_GetRect             GUI_Context.pDeviceAPI->pfGetRect
N  #define LCDDEV_L0_GetPixelIndex       GUI_Context.pDeviceAPI->pfGetPixelIndex
N  #define LCDDEV_L0_Index2Color         GUI_Context.pDeviceAPI->pfIndex2Color
N  #define LCDDEV_L0_SetPixelIndex       GUI_Context.pDeviceAPI->pfSetPixelIndex
N  #define LCDDEV_L0_XorPixel            GUI_Context.pDeviceAPI->pfXorPixel
N  #define LCDDEV_L0_GetDevFunc          GUI_Context.pDeviceAPI->pfGetDevFunc
N#else
S  #define LCDDEV_L0_Color2Index         LCD_L0_Color2Index
S  #define LCDDEV_L0_DrawBitmap          LCD_L0_DrawBitmap
S  #define LCDDEV_L0_DrawHLine           LCD_L0_DrawHLine
S  #define LCDDEV_L0_DrawVLine           LCD_L0_DrawVLine
S  #define LCDDEV_L0_DrawPixel           LCD_L0_DrawPixel
S  #define LCDDEV_L0_FillRect            LCD_L0_FillRect
S  #define LCDDEV_L0_GetPixel            LCD_L0_GetPixel
S  #define LCDDEV_L0_GetRect             LCD_L0_GetRect
S  #define LCDDEV_L0_GetPixelIndex       LCD_L0_GetPixelIndex
S  #define LCDDEV_L0_Index2Color         LCD_L0_Index2Color
S  #define LCDDEV_L0_SetPixelIndex       LCD_L0_SetPixelIndex
S  #define LCDDEV_L0_XorPixel            LCD_L0_XorPixel
S  #define LCDDEV_L0_GetDevFunc          LCD_L0_GetDevFunc
N#endif
N
Nvoid LCD_L0_DrawBitmap    (int x0, int y0, int xsize, int ysize, 
N                           int BitsPerPixel, int BytesPerLine, 
N                           const U8 GUI_UNI_PTR * pData, int Diff, const LCD_PIXELINDEX* pTrans);
X                           const unsigned char  * pData, int Diff, const unsigned short* pTrans);
Nvoid LCD_L0_1_DrawBitmap  (int x0, int y0, int xsize, int ysize, 
N                           int BitsPerPixel, int BytesPerLine, 
N                           const U8 GUI_UNI_PTR * pData, int Diff, const LCD_PIXELINDEX* pTrans);
X                           const unsigned char  * pData, int Diff, const unsigned short* pTrans);
Nvoid LCD_L0_2_DrawBitmap  (int x0, int y0, int xsize, int ysize, 
N                           int BitsPerPixel, int BytesPerLine, 
N                           const U8 GUI_UNI_PTR * pData, int Diff, const LCD_PIXELINDEX* pTrans);
X                           const unsigned char  * pData, int Diff, const unsigned short* pTrans);
Nvoid LCD_L0_3_DrawBitmap  (int x0, int y0, int xsize, int ysize, 
N                           int BitsPerPixel, int BytesPerLine, 
N                           const U8 GUI_UNI_PTR * pData, int Diff, const LCD_PIXELINDEX* pTrans);
X                           const unsigned char  * pData, int Diff, const unsigned short* pTrans);
Nvoid LCD_L0_4_DrawBitmap  (int x0, int y0, int xsize, int ysize, 
N                           int BitsPerPixel, int BytesPerLine, 
N                           const U8 GUI_UNI_PTR * pData, int Diff, const LCD_PIXELINDEX* pTrans);
X                           const unsigned char  * pData, int Diff, const unsigned short* pTrans);
Nvoid LCD_L0_MAG_DrawBitmap(int x0, int y0, int xsize, int ysize, 
N                           int BitsPerPixel, int BytesPerLine, 
N                           const U8 GUI_UNI_PTR * pData, int Diff, const LCD_PIXELINDEX* pTrans);
X                           const unsigned char  * pData, int Diff, const unsigned short* pTrans);
Nvoid LCD_L0_DELTA_DrawBitmap(int x0, int y0, int xsize, int ysize, 
N                           int BitsPerPixel, int BytesPerLine, 
N                           const U8 GUI_UNI_PTR * pData, int Diff, const LCD_PIXELINDEX* pTrans);
X                           const unsigned char  * pData, int Diff, const unsigned short* pTrans);
N
NLCD_PIXELINDEX*  LCD_GetpPalConvTable(const LCD_LOGPALETTE GUI_UNI_PTR *  pLogPal);
Xunsigned short*  LCD_GetpPalConvTable(const LCD_LOGPALETTE  *  pLogPal);
NLCD_PIXELINDEX*  LCD_GetpPalConvTableUncached(const LCD_LOGPALETTE GUI_UNI_PTR *  pLogPal);
Xunsigned short*  LCD_GetpPalConvTableUncached(const LCD_LOGPALETTE  *  pLogPal);
N
N
N#define GUI_POS_AUTO -4095   /* Position value for auto-pos */
N
N#if GUI_SUPPORT_MEMDEV
X#if 1
N  void*  GUI_MEMDEV__XY2PTR  (int x,int y);
N  void*  GUI_MEMDEV__XY2PTREx(GUI_MEMDEV* pDev, int x,int y);
N  void   GUI_MEMDEV__WriteToActiveAt(GUI_MEMDEV_Handle hMem,int x, int y);
N#endif
N
N#endif   /* ifdef GUI_H */
N
N/*************************** End of file ****************************/
N	 	 			 		    	 				 	  			   	 	 	 	 	 	  	  	      	   		 	 	 		  		  	 		 	  	  			     			       	   	 			  		    	 	     	 				  	 					 	 			   	  	  			 				 		 	 	 			     			 
L 23 "..\GUI\JPEG\GUI_JPEG.c" 2
N#include "jpeglib.h"
L 1 "..\GUI\JPEG\jpeglib.h" 1
N/*
N * jpeglib.h
N *
N * Copyright (C) 1991-1998, Thomas G. Lane.
N * This file is part of the Independent JPEG Group's software.
N * For conditions of distribution and use, see the accompanying README file.
N *
N * This file defines the application interface for the JPEG library.
N * Most applications using the library need only include this file,
N * and perhaps jerror.h if they want to know the exact error codes.
N */
N
N#ifndef JPEGLIB_H
N#define JPEGLIB_H
N
N/*
N * First we include the configuration files that record how this
N * installation of the JPEG library is set up.  jconfig.h can be
N * generated automatically for many systems.  jmorecfg.h contains
N * manual configuration options that most people need not worry about.
N */
N
N#ifndef JCONFIG_INCLUDED	/* in case jinclude.h already did */
N#include "jconfig.h"		/* widely used configuration options */
L 1 "..\GUI\JPEG\jconfig.h" 1
N
N
N/*
N * jconfig.doc
N *
N * Copyright (C) 1991-1994, Thomas G. Lane.
N * This file is part of the Independent JPEG Group's software.
N * For conditions of distribution and use, see the accompanying README file.
N *
N * This file documents the configuration options that are required to
N * customize the JPEG software for a particular system.
N *
N */
N
N
N#include "GUI.h" /* Only needed for GUI_USE_PARA(xxx) */
N
N/*
N * These symbols indicate the properties of your machine or compiler.
N * #define the symbol if yes, #undef it if no.
N */
N
N
N/* Does your compiler support the declaration "unsigned char" ?
N * How about "unsigned short" ?
N */
N#define HAVE_UNSIGNED_CHAR
N
N
N/* Define this if an ordinary "char" type is unsigned.
N * If you're not sure, leaving it undefined will work at some cost in speed.
N * If you defined HAVE_UNSIGNED_CHAR then the speed difference is minimal.
N */
N#ifdef CHAR_IS_UNSIGNED
S  #undef CHAR_IS_UNSIGNED
N#endif
N#define HAVE_STDDEF_H   /* Define this if your system has an ANSI-conforming <stddef.h> file. */
N#define HAVE_STDLIB_H   /* Define this if your system has an ANSI-conforming <stdlib.h> file. */
N#ifdef NEED_BSD_STRINGS
S  #undef NEED_BSD_STRINGS /* Define this if your system does not have an ANSI/SysV <string.h>, but does have a BSD-style <strings.h>. */
N#endif
N
N/* Define this if your system does not provide typedef size_t in any of the
N * ANSI-standard places (stddef.h, stdlib.h, or stdio.h), but places it in
N * <sys/types.h> instead.
N */
N#ifdef NEED_SYS_TYPES_H
S  #undef NEED_SYS_TYPES_H
N#endif
N
N/* For 80x86 machines, you need to define NEED_FAR_POINTERS,
N * unless you are using a large-data memory model or 80386 flat-memory mode.
N * On less brain-damaged CPUs this symbol must not be defined.
N * (Defining this symbol causes large data structures to be referenced through
N * "far" pointers and to be allocated with a special version of malloc.)
N */
N#ifdef NEED_SYS_TYPES_H
S  #undef NEED_FAR_POINTERS
N#endif
N
N
N/* Although a real ANSI C compiler can deal perfectly well with pointers to
N * unspecified structures (see "incomplete types" in the spec), a few pre-ANSI
N * and pseudo-ANSI compilers get confused.  To keep one of these bozos happy,
N * define INCOMPLETE_TYPES_BROKEN.  This is not recommended unless you
N * actually get "missing structure definition" warnings or errors while
N * compiling the JPEG code.
N */
N#ifdef INCOMPLETE_TYPES_BROKEN
S  #undef INCOMPLETE_TYPES_BROKEN
N#endif
N
N
N/*
N * The following options affect code selection within the JPEG library,
N * but they don't need to be visible to applications using the library.
N * To minimize application namespace pollution, the symbols won't be
N * defined unless JPEG_INTERNALS has been defined.
N */
N
N#ifdef JPEG_INTERNALS
S
S/* Define this if your compiler implements ">>" on signed values as a logical
S * (unsigned) shift; leave it undefined if ">>" is a signed (arithmetic) shift,
S * which is the normal and rational definition.
S */
S#ifdef RIGHT_SHIFT_IS_UNSIGNED
S  #undef RIGHT_SHIFT_IS_UNSIGNED
S#endif
S
S
N#endif /* JPEG_INTERNALS */
N
N#ifndef GUI_USE_PARA
S  #define GUI_USE_PARA(x)
N#endif
N
N
N
N
L 25 "..\GUI\JPEG\jpeglib.h" 2
N#endif
N#include "jmorecfg.h"		/* seldom changed options */
L 1 "..\GUI\JPEG\jmorecfg.h" 1
N/*
N * jmorecfg.h
N *
N * Copyright (C) 1991-1997, Thomas G. Lane.
N * This file is part of the Independent JPEG Group's software.
N * For conditions of distribution and use, see the accompanying README file.
N *
N * This file contains additional configuration options that customize the
N * JPEG software for special applications or support machine-dependent
N * optimizations.  Most users will not need to touch this file.
N */
N
N
N/*
N * Define BITS_IN_JSAMPLE as either
N *   8   for 8-bit sample values (the usual setting)
N *   12  for 12-bit sample values
N * Only 8 and 12 are legal data precisions for lossy JPEG according to the
N * JPEG standard, and the IJG code does not support anything else!
N * We do not support run-time selection of data precision, sorry.
N */
N
N#define BITS_IN_JSAMPLE  8	/* use 8 or 12 */
N
N
N/*
N * Maximum number of components (color channels) allowed in JPEG image.
N * To meet the letter of the JPEG spec, set this to 255.  However, darn
N * few applications need more than 4 channels (maybe 5 for CMYK + alpha
N * mask).  We recommend 10 as a reasonable compromise; use 4 if you are
N * really short on memory.  (Each allowed component costs a hundred or so
N * bytes of storage, whether actually used in an image or not.)
N */
N
N#define MAX_COMPONENTS  4	/* maximum number of image components */
N
N
N/*
N * Basic data types.
N * You may need to change these if you have a machine with unusual data
N * type sizes; for example, "char" not 8 bits, "short" not 16 bits,
N * or "long" not 32 bits.  We don't care whether "int" is 16 or 32 bits,
N * but it had better be at least 16.
N */
N
N/* Representation of a single sample (pixel element value).
N * We frequently allocate large arrays of these, so it's important to keep
N * them small.  But if you have memory to burn and access to char or short
N * arrays is very slow on your hardware, you might want to change these.
N */
N
N#if BITS_IN_JSAMPLE == 8
X#if 8 == 8
N  /* JSAMPLE should be the smallest type that will hold the values 0..255.
N   * You can use a signed char by having GETJSAMPLE mask it with 0xFF.
N   */
N  typedef unsigned char JSAMPLE;
N  #define GETJSAMPLE(value)  ((int) (value))
N  #define MAXJSAMPLE	255
N  #define CENTERJSAMPLE	128
N#elif BITS_IN_JSAMPLE == 12
S  /* JSAMPLE should be the smallest type that will hold the values 0..4095.
S   * On nearly all machines "short" will do nicely.
S   */
S  typedef short JSAMPLE;
S  #define GETJSAMPLE(value)  ((int) (value))
S  #define MAXJSAMPLE	4095
S  #define CENTERJSAMPLE	2048
N#endif /* BITS_IN_JSAMPLE == 12 */
N
N
N/* Representation of a DCT frequency coefficient.
N * This should be a signed value of at least 16 bits; "short" is usually OK.
N * Again, we allocate large arrays of these, but you can change to int
N * if you have memory to burn and "short" is really slow.
N */
N
Ntypedef short JCOEF;
N
N
N/* Compressed datastreams are represented as arrays of JOCTET.
N * These must be EXACTLY 8 bits wide, at least once they are written to
N * external storage.  Note that when using the stdio data source/destination
N * managers, this is also the data type passed to fread/fwrite.
N */
N
Ntypedef unsigned char JOCTET;
N#define GETJOCTET(value)  (value)
N
N
N/* These typedefs are used for various table entries and so forth.
N * They must be at least as wide as specified; but making them too big
N * won't cost a huge amount of memory, so we don't provide special
N * extraction code like we did for JSAMPLE.  (In other words, these
N * typedefs live at a different point on the speed/space tradeoff curve.)
N */
N
N/* UINT8 must hold at least the values 0..255. */
Ntypedef unsigned char UINT8;
N
N/* UINT16 must hold at least the values 0..65535. */
Ntypedef unsigned short UINT16;
N/* INT16 must hold at least the values -32768..32767. */
Ntypedef short INT16;
N/* INT32 must hold at least signed 32-bit values. */
Ntypedef long INT32;
N
N/* Datatype used for image dimensions.  The JPEG standard only supports
N * images up to 64K*64K due to 16-bit fields in SOF markers.  Therefore
N * "unsigned int" is sufficient on all machines.  However, if you need to
N * handle larger images and you don't mind deviating from the spec, you
N * can change this datatype.
N */
N
Ntypedef unsigned int JDIMENSION;
N
N#define JPEG_MAX_DIMENSION  65500L  /* a tad under 64K to prevent overflows */
N
N
N/* These macros are used in all function definitions and extern declarations.
N * You could modify them if you need to change function linkage conventions;
N * in particular, you'll need to do that to make the library a Windows DLL.
N * Another application is to make all functions global for use with debuggers
N * or code profilers that require it.
N */
N
N/* a function called through method pointers: */
N#define METHODDEF(type)		static type
N/* a function used only in its module: */
N#define LOCAL(type)		static type
N/* a function referenced thru EXTERNs: */
N#define GLOBAL(type)		type
N/* a reference to a GLOBAL function: */
N#define EXTERN(type)		extern type
N
N
N/* This macro is used to declare a "method", that is, a function pointer.
N * We want to supply prototype parameters if the compiler can cope.
N * Note that the arglist parameter must be parenthesized!
N * Again, you can customize this if you need special linkage keywords.
N */
N
N#define JMETHOD(type,methodname,arglist)  type (*methodname) arglist
N
N
N/* Here is the pseudo-keyword for declaring pointers that must be "far"
N * on 80x86 machines.  Most of the specialized coding for 80x86 is handled
N * by just saying "FAR *" where such a pointer is needed.  In a few places
N * explicit coding is needed; see uses of the NEED_FAR_POINTERS symbol.
N */
N
N#ifdef NEED_FAR_POINTERS
S#define FAR  far
N#else
N#define FAR
N#endif
N
N
N/*
N * On a few systems, type boolean and/or its values FALSE, TRUE may appear
N * in standard header files.  Or you may have conflicts with application-
N * specific header files that you want to include together with these files.
N * Defining HAVE_BOOLEAN before including jpeglib.h should make it work.
N */
N
N#ifndef HAVE_BOOLEAN
Ntypedef int boolean;
N#endif
N#ifndef FALSE			/* in case these macros already exist */
N#define FALSE	0		/* values of boolean */
N#endif
N#ifndef TRUE
N#define TRUE	1
N#endif
N
N
N/*
N * The remaining options affect code selection within the JPEG library,
N * but they don't need to be visible to most applications using the library.
N * To minimize application namespace pollution, the symbols won't be
N * defined unless JPEG_INTERNALS or JPEG_INTERNAL_OPTIONS has been defined.
N */
N
N#ifdef JPEG_INTERNALS
S#define JPEG_INTERNAL_OPTIONS
N#endif
N
N#ifdef JPEG_INTERNAL_OPTIONS
S
S
S/*
S * These defines indicate whether to include various optional functions.
S * Undefining some of these symbols will produce a smaller but less capable
S * library.  Note that you can leave certain source files out of the
S * compilation/linking process if you've #undef'd the corresponding symbols.
S * (You may HAVE to do that if your compiler doesn't like null source files.)
S */
S
S/* Arithmetic coding is unsupported for legal reasons.  Complaints to IBM. */
S
S/* Capability options common to encoder and decoder: */
S
S#define  DCT_ISLOW_SUPPORTED	/* slow but accurate integer algorithm */
S#define  DCT_IFAST_SUPPORTED	/* faster, less accurate integer method */
S#ifdef DCT_FLOAT_SUPPORTED
S  #undef   DCT_FLOAT_SUPPORTED	/* floating-point: accurate, fast on fast HW */
S#endif
S
S/* Encoder capability options: */
S
S#ifdef C_ARITH_CODING_SUPPORTED
S  #undef  C_ARITH_CODING_SUPPORTED    /* Arithmetic coding back end? */
S#endif
S#define C_MULTISCAN_FILES_SUPPORTED /* Multiple-scan JPEG files? */
S#define C_PROGRESSIVE_SUPPORTED	    /* Progressive JPEG? (Requires MULTISCAN)*/
S#define ENTROPY_OPT_SUPPORTED	      /* Optimization of entropy coding parms? */
S/* Note: if you selected 12-bit data precision, it is dangerous to turn off
S * ENTROPY_OPT_SUPPORTED.  The standard Huffman tables are only good for 8-bit
S * precision, so jchuff.c normally uses entropy optimization to compute
S * usable tables for higher precision.  If you don't want to do optimization,
S * you'll have to supply different default Huffman tables.
S * The exact same statements apply for progressive JPEG: the default tables
S * don't work for progressive mode.  (This may get fixed, however.)
S */
S#define INPUT_SMOOTHING_SUPPORTED   /* Input image smoothing option? */
S
S/* Decoder capability options: */
S
S#ifdef D_ARITH_CODING_SUPPORTED
S  #undef  D_ARITH_CODING_SUPPORTED    /* Arithmetic coding back end? */
S#endif
S#define D_MULTISCAN_FILES_SUPPORTED /* Multiple-scan JPEG files? */
S#define D_PROGRESSIVE_SUPPORTED	    /* Progressive JPEG? (Requires MULTISCAN)*/
S#ifdef SAVE_MARKERS_SUPPORTED
S  #undef  SAVE_MARKERS_SUPPORTED	    /* jpeg_save_markers() needed?  (Default was on, RS) */
S#endif
S#ifdef BLOCK_SMOOTHING_SUPPORTED
S  #undef  BLOCK_SMOOTHING_SUPPORTED   /* Block smoothing? (Progressive only) */
S#endif
S#ifdef IDCT_SCALING_SUPPORTED
S  #undef  IDCT_SCALING_SUPPORTED	    /* Output rescaling via IDCT? */
S#endif
S#ifdef UPSAMPLE_SCALING_SUPPORTED
S  #undef  UPSAMPLE_SCALING_SUPPORTED  /* Output rescaling at upsample stage? */
S#endif
S#define UPSAMPLE_MERGING_SUPPORTED  /* Fast path for sloppy upsampling? */
S#define QUANT_1PASS_SUPPORTED	      /* 1-pass color quantization? */
S#define QUANT_2PASS_SUPPORTED	      /* 2-pass color quantization? */
S
S/* more capability options later, no doubt */
S
S
S/*
S * Ordering of RGB data in scanlines passed to or from the application.
S * If your application wants to deal with data in the order B,G,R, just
S * change these macros.  You can also deal with formats such as R,G,B,X
S * (one extra byte per pixel) by changing RGB_PIXELSIZE.  Note that changing
S * the offsets will also change the order in which colormap data is organized.
S * RESTRICTIONS:
S * 1. The sample applications cjpeg,djpeg do NOT support modified RGB formats.
S * 2. These macros only affect RGB<=>YCbCr color conversion, so they are not
S *    useful if you are using JPEG color spaces other than YCbCr or grayscale.
S * 3. The color quantizer modules will not behave desirably if RGB_PIXELSIZE
S *    is not 3 (they don't understand about dummy color components!).  So you
S *    can't use color quantization if you change that value.
S */
S
S#define RGB_RED		0	/* Offset of Red in an RGB scanline element */
S#define RGB_GREEN	1	/* Offset of Green */
S#define RGB_BLUE	2	/* Offset of Blue */
S#define RGB_PIXELSIZE	3	/* JSAMPLEs per RGB scanline element */
S
S
S/* Definitions for speed-related optimizations. */
S
S
S/* If your compiler supports inline functions, define INLINE
S * as the inline keyword; otherwise define it as empty.
S */
S
S#ifndef INLINE
S#ifdef __GNUC__			/* for instance, GNU C knows about inline */
S#define INLINE __inline__
S#endif
S#ifndef INLINE
S#define INLINE			/* default is to define it as empty */
S#endif
S#endif
S
S
S/* On some machines (notably 68000 series) "int" is 32 bits, but multiplying
S * two 16-bit shorts is faster than multiplying two ints.  Define MULTIPLIER
S * as short on such a machine.  MULTIPLIER must be at least 16 bits wide.
S */
S
S#ifndef MULTIPLIER
S#define MULTIPLIER  int		/* type for fastest integer multiply */
S#endif
S
S
S/* FAST_FLOAT should be either float or double, whichever is done faster
S * by your compiler.  (Note that this type is only used in the floating point
S * DCT routines, so it only matters if you've defined DCT_FLOAT_SUPPORTED.)
S * Typically, float is faster in ANSI C compilers, while double is faster in
S * pre-ANSI compilers (because they insist on converting to double anyway).
S * The code below therefore chooses float if we have ANSI-style prototypes.
S */
S
S#ifndef FAST_FLOAT
S#define FAST_FLOAT  float
S#endif
S
N#endif /* JPEG_INTERNAL_OPTIONS */
L 27 "..\GUI\JPEG\jpeglib.h" 2
N
N
N/* Version ID for the JPEG library.
N * Might be useful for tests like "#if JPEG_LIB_VERSION >= 60".
N */
N
N#define JPEG_LIB_VERSION  62	/* Version 6b */
N
N
N/* Various constants determining the sizes of things.
N * All of these are specified by the JPEG standard, so don't change them
N * if you want to be compatible.
N */
N
N#define DCTSIZE		    8	/* The basic DCT block is 8x8 samples */
N#define DCTSIZE2	    64	/* DCTSIZE squared; # of elements in a block */
N#define NUM_QUANT_TBLS      4	/* Quantization tables are numbered 0..3 */
N#define NUM_HUFF_TBLS       4	/* Huffman tables are numbered 0..3 */
N#define NUM_ARITH_TBLS      16	/* Arith-coding tables are numbered 0..15 */
N#define MAX_COMPS_IN_SCAN   4	/* JPEG limit on # of components in one scan */
N#define MAX_SAMP_FACTOR     4	/* JPEG limit on sampling factors */
N/* Unfortunately, some bozo at Adobe saw no reason to be bound by the standard;
N * the PostScript DCT filter can emit files with many more than 10 blocks/MCU.
N * If you happen to run across such a file, you can up D_MAX_BLOCKS_IN_MCU
N * to handle it.  We even let you do this from the jconfig.h file.  However,
N * we strongly discourage changing C_MAX_BLOCKS_IN_MCU; just because Adobe
N * sometimes emits noncompliant files doesn't mean you should too.
N */
N#define C_MAX_BLOCKS_IN_MCU   10 /* compressor's limit on blocks per MCU */
N#ifndef D_MAX_BLOCKS_IN_MCU
N#define D_MAX_BLOCKS_IN_MCU   10 /* decompressor's limit on blocks per MCU */
N#endif
N
N
N/* Data structures for images (arrays of samples and of DCT coefficients).
N * On 80x86 machines, the image arrays are too big for near pointers,
N * but the pointer arrays can fit in near memory.
N */
N
Ntypedef JSAMPLE FAR *JSAMPROW;	/* ptr to one image row of pixel samples. */
Xtypedef JSAMPLE  *JSAMPROW;	 
Ntypedef JSAMPROW *JSAMPARRAY;	/* ptr to some rows (a 2-D sample array) */
Ntypedef JSAMPARRAY *JSAMPIMAGE;	/* a 3-D sample array: top index is color */
N
Ntypedef JCOEF JBLOCK[DCTSIZE2];	/* one block of coefficients */
Xtypedef JCOEF JBLOCK[64];	 
Ntypedef JBLOCK FAR *JBLOCKROW;	/* pointer to one row of coefficient blocks */
Xtypedef JBLOCK  *JBLOCKROW;	 
Ntypedef JBLOCKROW *JBLOCKARRAY;		/* a 2-D array of coefficient blocks */
Ntypedef JBLOCKARRAY *JBLOCKIMAGE;	/* a 3-D array of coefficient blocks */
N
Ntypedef JCOEF FAR *JCOEFPTR;	/* useful in a couple of places */
Xtypedef JCOEF  *JCOEFPTR;	 
N
N
N/* Types for JPEG compression parameters and working tables. */
N
N
N/* DCT coefficient quantization tables. */
N
Ntypedef struct {
N  /* This array gives the coefficient quantizers in natural array order
N   * (not the zigzag order in which they are stored in a JPEG DQT marker).
N   * CAUTION: IJG versions prior to v6a kept this array in zigzag order.
N   */
N  UINT16 quantval[DCTSIZE2];	/* quantization step for each coefficient */
X  UINT16 quantval[64];	 
N  /* This field is used only during compression.  It's initialized FALSE when
N   * the table is created, and set TRUE when it's been output to the file.
N   * You could suppress output of a table by setting this to TRUE.
N   * (See jpeg_suppress_tables for an example.)
N   */
N  boolean sent_table;		/* TRUE when table has been output */
N} JQUANT_TBL;
N
N
N/* Huffman coding tables. */
N
Ntypedef struct {
N  /* These two fields directly represent the contents of a JPEG DHT marker */
N  UINT8 bits[17];		/* bits[k] = # of symbols with codes of */
N				/* length k bits; bits[0] is unused */
N  UINT8 huffval[256];		/* The symbols, in order of incr code length */
N  /* This field is used only during compression.  It's initialized FALSE when
N   * the table is created, and set TRUE when it's been output to the file.
N   * You could suppress output of a table by setting this to TRUE.
N   * (See jpeg_suppress_tables for an example.)
N   */
N  boolean sent_table;		/* TRUE when table has been output */
N} JHUFF_TBL;
N
N
N/* Basic info about one component (color channel). */
N
Ntypedef struct {
N  /* These values are fixed over the whole image. */
N  /* For compression, they must be supplied by parameter setup; */
N  /* for decompression, they are read from the SOF marker. */
N  int component_id;		/* identifier for this component (0..255) */
N  int component_index;		/* its index in SOF or cinfo->comp_info[] */
N  int h_samp_factor;		/* horizontal sampling factor (1..4) */
N  int v_samp_factor;		/* vertical sampling factor (1..4) */
N  int quant_tbl_no;		/* quantization table selector (0..3) */
N  /* These values may vary between scans. */
N  /* For compression, they must be supplied by parameter setup; */
N  /* for decompression, they are read from the SOS marker. */
N  /* The decompressor output side may not use these variables. */
N  int dc_tbl_no;		/* DC entropy table selector (0..3) */
N  int ac_tbl_no;		/* AC entropy table selector (0..3) */
N  
N  /* Remaining fields should be treated as private by applications. */
N  
N  /* These values are computed during compression or decompression startup: */
N  /* Component's size in DCT blocks.
N   * Any dummy blocks added to complete an MCU are not counted; therefore
N   * these values do not depend on whether a scan is interleaved or not.
N   */
N  JDIMENSION width_in_blocks;
N  JDIMENSION height_in_blocks;
N  /* Size of a DCT block in samples.  Always DCTSIZE for compression.
N   * For decompression this is the size of the output from one DCT block,
N   * reflecting any scaling we choose to apply during the IDCT step.
N   * Values of 1,2,4,8 are likely to be supported.  Note that different
N   * components may receive different IDCT scalings.
N   */
N  int DCT_scaled_size;
N  /* The downsampled dimensions are the component's actual, unpadded number
N   * of samples at the main buffer (preprocessing/compression interface), thus
N   * downsampled_width = ceil(image_width * Hi/Hmax)
N   * and similarly for height.  For decompression, IDCT scaling is included, so
N   * downsampled_width = ceil(image_width * Hi/Hmax * DCT_scaled_size/DCTSIZE)
N   */
N  JDIMENSION downsampled_width;	 /* actual width in samples */
N  JDIMENSION downsampled_height; /* actual height in samples */
N  /* This flag is used only for decompression.  In cases where some of the
N   * components will be ignored (eg grayscale output from YCbCr image),
N   * we can skip most computations for the unused components.
N   */
N  boolean component_needed;	/* do we need the value of this component? */
N
N  /* These values are computed before starting a scan of the component. */
N  /* The decompressor output side may not use these variables. */
N  int MCU_width;		/* number of blocks per MCU, horizontally */
N  int MCU_height;		/* number of blocks per MCU, vertically */
N  int MCU_blocks;		/* MCU_width * MCU_height */
N  int MCU_sample_width;		/* MCU width in samples, MCU_width*DCT_scaled_size */
N  int last_col_width;		/* # of non-dummy blocks across in last MCU */
N  int last_row_height;		/* # of non-dummy blocks down in last MCU */
N
N  /* Saved quantization table for component; NULL if none yet saved.
N   * See jdinput.c comments about the need for this information.
N   * This field is currently used only for decompression.
N   */
N  JQUANT_TBL * quant_table;
N
N  /* Private per-component storage for DCT or IDCT subsystem. */
N  void * dct_table;
N} jpeg_component_info;
N
N
N/* The script for encoding a multiple-scan file is an array of these: */
N
Ntypedef struct {
N  int comps_in_scan;		/* number of components encoded in this scan */
N  int component_index[MAX_COMPS_IN_SCAN]; /* their SOF/comp_info[] indexes */
X  int component_index[4];  
N  int Ss, Se;			/* progressive JPEG spectral selection parms */
N  int Ah, Al;			/* progressive JPEG successive approx. parms */
N} jpeg_scan_info;
N
N/* The decompressor can save APPn and COM markers in a list of these: */
N
Ntypedef struct jpeg_marker_struct FAR * jpeg_saved_marker_ptr;
Xtypedef struct jpeg_marker_struct  * jpeg_saved_marker_ptr;
N
Nstruct jpeg_marker_struct {
N  jpeg_saved_marker_ptr next;	/* next in list, or NULL */
N  UINT8 marker;			/* marker code: JPEG_COM, or JPEG_APP0+n */
N  unsigned int original_length;	/* # bytes of data in the file */
N  unsigned int data_length;	/* # bytes of data saved at data[] */
N  JOCTET FAR * data;		/* the data contained in the marker */
X  JOCTET  * data;		 
N  /* the marker length word is not counted in data_length or original_length */
N};
N
N/* Known color spaces. */
N
Ntypedef enum {
N	JCS_UNKNOWN,		/* error/unspecified */
N	JCS_GRAYSCALE,		/* monochrome */
N	JCS_RGB,		/* red/green/blue */
N	JCS_YCbCr,		/* Y/Cb/Cr (also known as YUV) */
N	JCS_CMYK,		/* C/M/Y/K */
N	JCS_YCCK		/* Y/Cb/Cr/K */
N} J_COLOR_SPACE;
N
N/* DCT/IDCT algorithm options. */
N
Ntypedef enum {
N	JDCT_ISLOW,		/* slow but accurate integer algorithm */
N	JDCT_IFAST,		/* faster, less accurate integer method */
N	JDCT_FLOAT		/* floating-point: accurate, fast on fast HW */
N} J_DCT_METHOD;
N
N#ifndef JDCT_DEFAULT		/* may be overridden in jconfig.h */
N#define JDCT_DEFAULT  JDCT_ISLOW
N#endif
N#ifndef JDCT_FASTEST		/* may be overridden in jconfig.h */
N#define JDCT_FASTEST  JDCT_IFAST
N#endif
N
N/* Dithering options for decompression. */
N
Ntypedef enum {
N	JDITHER_NONE,		/* no dithering */
N	JDITHER_ORDERED,	/* simple ordered dither */
N	JDITHER_FS		/* Floyd-Steinberg error diffusion dither */
N} J_DITHER_MODE;
N
N
N/* Common fields between JPEG compression and decompression master structs. */
N
N#define jpeg_common_fields \
N  struct jpeg_error_mgr * err;	/* Error handler module */\
N  struct jpeg_memory_mgr * mem;	/* Memory manager module */\
N  struct jpeg_progress_mgr * progress; /* Progress monitor, or NULL if none */\
N  void * client_data;		/* Available for use by application */\
N  boolean is_decompressor;	/* So common code can tell which is which */\
N  int global_state		/* For checking call sequence validity */
X#define jpeg_common_fields   struct jpeg_error_mgr * err;	   struct jpeg_memory_mgr * mem;	   struct jpeg_progress_mgr * progress;    void * client_data;		   boolean is_decompressor;	   int global_state		 
N
N/* Routines that are to be used by both halves of the library are declared
N * to receive a pointer to this structure.  There are no actual instances of
N * jpeg_common_struct, only of jpeg_compress_struct and jpeg_decompress_struct.
N */
Nstruct jpeg_common_struct {
N  jpeg_common_fields;		/* Fields common to both master struct types */
X  struct jpeg_error_mgr * err; struct jpeg_memory_mgr * mem; struct jpeg_progress_mgr * progress; void * client_data; boolean is_decompressor; int global_state;		 
N  /* Additional fields follow in an actual jpeg_compress_struct or
N   * jpeg_decompress_struct.  All three structs must agree on these
N   * initial fields!  (This would be a lot cleaner in C++.)
N   */
N};
N
Ntypedef struct jpeg_common_struct * j_common_ptr;
Ntypedef struct jpeg_compress_struct * j_compress_ptr;
Ntypedef struct jpeg_decompress_struct * j_decompress_ptr;
N
N
N/* Master record for a compression instance */
N
Nstruct jpeg_compress_struct {
N  jpeg_common_fields;		/* Fields shared with jpeg_decompress_struct */
X  struct jpeg_error_mgr * err; struct jpeg_memory_mgr * mem; struct jpeg_progress_mgr * progress; void * client_data; boolean is_decompressor; int global_state;		 
N
N  /* Destination for compressed data */
N  struct jpeg_destination_mgr * dest;
N
N  /* Description of source image --- these fields must be filled in by
N   * outer application before starting compression.  in_color_space must
N   * be correct before you can even call jpeg_set_defaults().
N   */
N
N  JDIMENSION image_width;	/* input image width */
N  JDIMENSION image_height;	/* input image height */
N  int input_components;		/* # of color components in input image */
N  J_COLOR_SPACE in_color_space;	/* colorspace of input image */
N
N  double input_gamma;		/* image gamma of input image */
N
N  /* Compression parameters --- these fields must be set before calling
N   * jpeg_start_compress().  We recommend calling jpeg_set_defaults() to
N   * initialize everything to reasonable defaults, then changing anything
N   * the application specifically wants to change.  That way you won't get
N   * burnt when new parameters are added.  Also note that there are several
N   * helper routines to simplify changing parameters.
N   */
N
N  int data_precision;		/* bits of precision in image data */
N
N  int num_components;		/* # of color components in JPEG image */
N  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */
N
N  jpeg_component_info * comp_info;
N  /* comp_info[i] describes component that appears i'th in SOF */
N  
N  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];
X  JQUANT_TBL * quant_tbl_ptrs[4];
N  /* ptrs to coefficient quantization tables, or NULL if not defined */
N  
N  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
X  JHUFF_TBL * dc_huff_tbl_ptrs[4];
N  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
X  JHUFF_TBL * ac_huff_tbl_ptrs[4];
N  /* ptrs to Huffman coding tables, or NULL if not defined */
N  
N  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
X  UINT8 arith_dc_L[16];  
N  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
X  UINT8 arith_dc_U[16];  
N  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */
X  UINT8 arith_ac_K[16];  
N
N  int num_scans;		/* # of entries in scan_info array */
N  const jpeg_scan_info * scan_info; /* script for multi-scan file, or NULL */
N  /* The default value of scan_info is NULL, which causes a single-scan
N   * sequential JPEG file to be emitted.  To create a multi-scan file,
N   * set num_scans and scan_info to point to an array of scan definitions.
N   */
N
N  boolean raw_data_in;		/* TRUE=caller supplies downsampled data */
N  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */
N  boolean optimize_coding;	/* TRUE=optimize entropy encoding parms */
N  boolean CCIR601_sampling;	/* TRUE=first samples are cosited */
N  int smoothing_factor;		/* 1..100, or 0 for no input smoothing */
N  J_DCT_METHOD dct_method;	/* DCT algorithm selector */
N
N  /* The restart interval can be specified in absolute MCUs by setting
N   * restart_interval, or in MCU rows by setting restart_in_rows
N   * (in which case the correct restart_interval will be figured
N   * for each scan).
N   */
N  unsigned int restart_interval; /* MCUs per restart, or 0 for no restart */
N  int restart_in_rows;		/* if > 0, MCU rows per restart interval */
N
N  /* Parameters controlling emission of special markers. */
N
N  boolean write_JFIF_header;	/* should a JFIF marker be written? */
N  UINT8 JFIF_major_version;	/* What to write for the JFIF version number */
N  UINT8 JFIF_minor_version;
N  /* These three values are not used by the JPEG code, merely copied */
N  /* into the JFIF APP0 marker.  density_unit can be 0 for unknown, */
N  /* 1 for dots/inch, or 2 for dots/cm.  Note that the pixel aspect */
N  /* ratio is defined by X_density/Y_density even when density_unit=0. */
N  UINT8 density_unit;		/* JFIF code for pixel size units */
N  UINT16 X_density;		/* Horizontal pixel density */
N  UINT16 Y_density;		/* Vertical pixel density */
N  boolean write_Adobe_marker;	/* should an Adobe marker be written? */
N  
N  /* State variable: index of next scanline to be written to
N   * jpeg_write_scanlines().  Application may use this to control its
N   * processing loop, e.g., "while (next_scanline < image_height)".
N   */
N
N  JDIMENSION next_scanline;	/* 0 .. image_height-1  */
N
N  /* Remaining fields are known throughout compressor, but generally
N   * should not be touched by a surrounding application.
N   */
N
N  /*
N   * These fields are computed during compression startup
N   */
N  boolean progressive_mode;	/* TRUE if scan script uses progressive mode */
N  int max_h_samp_factor;	/* largest h_samp_factor */
N  int max_v_samp_factor;	/* largest v_samp_factor */
N
N  JDIMENSION total_iMCU_rows;	/* # of iMCU rows to be input to coef ctlr */
N  /* The coefficient controller receives data in units of MCU rows as defined
N   * for fully interleaved scans (whether the JPEG file is interleaved or not).
N   * There are v_samp_factor * DCTSIZE sample rows of each component in an
N   * "iMCU" (interleaved MCU) row.
N   */
N  
N  /*
N   * These fields are valid during any one scan.
N   * They describe the components and MCUs actually appearing in the scan.
N   */
N  int comps_in_scan;		/* # of JPEG components in this scan */
N  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
X  jpeg_component_info * cur_comp_info[4];
N  /* *cur_comp_info[i] describes component that appears i'th in SOS */
N  
N  JDIMENSION MCUs_per_row;	/* # of MCUs across the image */
N  JDIMENSION MCU_rows_in_scan;	/* # of MCU rows in the image */
N  
N  int blocks_in_MCU;		/* # of DCT blocks per MCU */
N  int MCU_membership[C_MAX_BLOCKS_IN_MCU];
X  int MCU_membership[10];
N  /* MCU_membership[i] is index in cur_comp_info of component owning */
N  /* i'th block in an MCU */
N
N  int Ss, Se, Ah, Al;		/* progressive JPEG parameters for scan */
N
N  /*
N   * Links to compression subobjects (methods and private variables of modules)
N   */
N  struct jpeg_comp_master * master;
N  struct jpeg_c_main_controller * main;
N  struct jpeg_c_prep_controller * prep;
N  struct jpeg_c_coef_controller * coef;
N  struct jpeg_marker_writer * marker;
N  struct jpeg_color_converter * cconvert;
N  struct jpeg_downsampler * downsample;
N  struct jpeg_forward_dct * fdct;
N  struct jpeg_entropy_encoder * entropy;
N  jpeg_scan_info * script_space; /* workspace for jpeg_simple_progression */
N  int script_space_size;
N};
N
N
N/* Master record for a decompression instance */
N
Nstruct jpeg_decompress_struct {
N  jpeg_common_fields;		/* Fields shared with jpeg_compress_struct */
X  struct jpeg_error_mgr * err; struct jpeg_memory_mgr * mem; struct jpeg_progress_mgr * progress; void * client_data; boolean is_decompressor; int global_state;		 
N
N  /* Source of compressed data */
N  struct jpeg_source_mgr * src;
N
N  /* Basic description of image --- filled in by jpeg_read_header(). */
N  /* Application may inspect these values to decide how to process image. */
N
N  JDIMENSION image_width;	/* nominal image width (from SOF marker) */
N  JDIMENSION image_height;	/* nominal image height */
N  int num_components;		/* # of color components in JPEG image */
N  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */
N
N  /* Decompression processing parameters --- these fields must be set before
N   * calling jpeg_start_decompress().  Note that jpeg_read_header() initializes
N   * them to default values.
N   */
N
N  J_COLOR_SPACE out_color_space; /* colorspace for output */
N
N  unsigned int scale_num, scale_denom; /* fraction by which to scale image */
N
N  double output_gamma;		/* image gamma wanted in output */
N
N  boolean buffered_image;	/* TRUE=multiple output passes */
N  boolean raw_data_out;		/* TRUE=downsampled data wanted */
N
N  J_DCT_METHOD dct_method;	/* IDCT algorithm selector */
N  boolean do_fancy_upsampling;	/* TRUE=apply fancy upsampling */
N  boolean do_block_smoothing;	/* TRUE=apply interblock smoothing */
N
N  boolean quantize_colors;	/* TRUE=colormapped output wanted */
N  /* the following are ignored if not quantize_colors: */
N  J_DITHER_MODE dither_mode;	/* type of color dithering to use */
N  boolean two_pass_quantize;	/* TRUE=use two-pass color quantization */
N  int desired_number_of_colors;	/* max # colors to use in created colormap */
N  /* these are significant only in buffered-image mode: */
N  boolean enable_1pass_quant;	/* enable future use of 1-pass quantizer */
N  boolean enable_external_quant;/* enable future use of external colormap */
N  boolean enable_2pass_quant;	/* enable future use of 2-pass quantizer */
N
N  /* Description of actual output image that will be returned to application.
N   * These fields are computed by jpeg_start_decompress().
N   * You can also use jpeg_calc_output_dimensions() to determine these values
N   * in advance of calling jpeg_start_decompress().
N   */
N
N  JDIMENSION output_width;	/* scaled image width */
N  JDIMENSION output_height;	/* scaled image height */
N  int out_color_components;	/* # of color components in out_color_space */
N  int output_components;	/* # of color components returned */
N  /* output_components is 1 (a colormap index) when quantizing colors;
N   * otherwise it equals out_color_components.
N   */
N  int rec_outbuf_height;	/* min recommended height of scanline buffer */
N  /* If the buffer passed to jpeg_read_scanlines() is less than this many rows
N   * high, space and time will be wasted due to unnecessary data copying.
N   * Usually rec_outbuf_height will be 1 or 2, at most 4.
N   */
N
N  /* When quantizing colors, the output colormap is described by these fields.
N   * The application can supply a colormap by setting colormap non-NULL before
N   * calling jpeg_start_decompress; otherwise a colormap is created during
N   * jpeg_start_decompress or jpeg_start_output.
N   * The map has out_color_components rows and actual_number_of_colors columns.
N   */
N  int actual_number_of_colors;	/* number of entries in use */
N  JSAMPARRAY colormap;		/* The color map as a 2-D pixel array */
N
N  /* State variables: these variables indicate the progress of decompression.
N   * The application may examine these but must not modify them.
N   */
N
N  /* Row index of next scanline to be read from jpeg_read_scanlines().
N   * Application may use this to control its processing loop, e.g.,
N   * "while (output_scanline < output_height)".
N   */
N  JDIMENSION output_scanline;	/* 0 .. output_height-1  */
N
N  /* Current input scan number and number of iMCU rows completed in scan.
N   * These indicate the progress of the decompressor input side.
N   */
N  int input_scan_number;	/* Number of SOS markers seen so far */
N  JDIMENSION input_iMCU_row;	/* Number of iMCU rows completed */
N
N  /* The "output scan number" is the notional scan being displayed by the
N   * output side.  The decompressor will not allow output scan/row number
N   * to get ahead of input scan/row, but it can fall arbitrarily far behind.
N   */
N  int output_scan_number;	/* Nominal scan number being displayed */
N  JDIMENSION output_iMCU_row;	/* Number of iMCU rows read */
N
N  /* Current progression status.  coef_bits[c][i] indicates the precision
N   * with which component c's DCT coefficient i (in zigzag order) is known.
N   * It is -1 when no data has yet been received, otherwise it is the point
N   * transform (shift) value for the most recent scan of the coefficient
N   * (thus, 0 at completion of the progression).
N   * This pointer is NULL when reading a non-progressive file.
N   */
N  int (*coef_bits)[DCTSIZE2];	/* -1 or current Al value for each coef */
X  int (*coef_bits)[64];	 
N
N  /* Internal JPEG parameters --- the application usually need not look at
N   * these fields.  Note that the decompressor output side may not use
N   * any parameters that can change between scans.
N   */
N
N  /* Quantization and Huffman tables are carried forward across input
N   * datastreams when processing abbreviated JPEG datastreams.
N   */
N
N  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];
X  JQUANT_TBL * quant_tbl_ptrs[4];
N  /* ptrs to coefficient quantization tables, or NULL if not defined */
N
N  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
X  JHUFF_TBL * dc_huff_tbl_ptrs[4];
N  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
X  JHUFF_TBL * ac_huff_tbl_ptrs[4];
N  /* ptrs to Huffman coding tables, or NULL if not defined */
N
N  /* These parameters are never carried across datastreams, since they
N   * are given in SOF/SOS markers or defined to be reset by SOI.
N   */
N
N  int data_precision;		/* bits of precision in image data */
N
N  jpeg_component_info * comp_info;
N  /* comp_info[i] describes component that appears i'th in SOF */
N
N  boolean progressive_mode;	/* TRUE if SOFn specifies progressive mode */
N  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */
N
N  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
X  UINT8 arith_dc_L[16];  
N  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
X  UINT8 arith_dc_U[16];  
N  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */
X  UINT8 arith_ac_K[16];  
N
N  unsigned int restart_interval; /* MCUs per restart interval, or 0 for no restart */
N
N  /* These fields record data obtained from optional markers recognized by
N   * the JPEG library.
N   */
N  boolean saw_JFIF_marker;	/* TRUE iff a JFIF APP0 marker was found */
N  /* Data copied from JFIF marker; only valid if saw_JFIF_marker is TRUE: */
N  UINT8 JFIF_major_version;	/* JFIF version number */
N  UINT8 JFIF_minor_version;
N  UINT8 density_unit;		/* JFIF code for pixel size units */
N  UINT16 X_density;		/* Horizontal pixel density */
N  UINT16 Y_density;		/* Vertical pixel density */
N  boolean saw_Adobe_marker;	/* TRUE iff an Adobe APP14 marker was found */
N  UINT8 Adobe_transform;	/* Color transform code from Adobe marker */
N
N  boolean CCIR601_sampling;	/* TRUE=first samples are cosited */
N
N  /* Aside from the specific data retained from APPn markers known to the
N   * library, the uninterpreted contents of any or all APPn and COM markers
N   * can be saved in a list for examination by the application.
N   */
N  jpeg_saved_marker_ptr marker_list; /* Head of list of saved markers */
N
N  /* Remaining fields are known throughout decompressor, but generally
N   * should not be touched by a surrounding application.
N   */
N
N  /*
N   * These fields are computed during decompression startup
N   */
N  int max_h_samp_factor;	/* largest h_samp_factor */
N  int max_v_samp_factor;	/* largest v_samp_factor */
N
N  int min_DCT_scaled_size;	/* smallest DCT_scaled_size of any component */
N
N  JDIMENSION total_iMCU_rows;	/* # of iMCU rows in image */
N  /* The coefficient controller's input and output progress is measured in
N   * units of "iMCU" (interleaved MCU) rows.  These are the same as MCU rows
N   * in fully interleaved JPEG scans, but are used whether the scan is
N   * interleaved or not.  We define an iMCU row as v_samp_factor DCT block
N   * rows of each component.  Therefore, the IDCT output contains
N   * v_samp_factor*DCT_scaled_size sample rows of a component per iMCU row.
N   */
N
N  JSAMPLE * sample_range_limit; /* table for fast range-limiting */
N
N  /*
N   * These fields are valid during any one scan.
N   * They describe the components and MCUs actually appearing in the scan.
N   * Note that the decompressor output side must not use these fields.
N   */
N  int comps_in_scan;		/* # of JPEG components in this scan */
N  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
X  jpeg_component_info * cur_comp_info[4];
N  /* *cur_comp_info[i] describes component that appears i'th in SOS */
N
N  JDIMENSION MCUs_per_row;	/* # of MCUs across the image */
N  JDIMENSION MCU_rows_in_scan;	/* # of MCU rows in the image */
N
N  int blocks_in_MCU;		/* # of DCT blocks per MCU */
N  int MCU_membership[D_MAX_BLOCKS_IN_MCU];
X  int MCU_membership[10];
N  /* MCU_membership[i] is index in cur_comp_info of component owning */
N  /* i'th block in an MCU */
N
N  int Ss, Se, Ah, Al;		/* progressive JPEG parameters for scan */
N
N  /* This field is shared between entropy decoder and marker parser.
N   * It is either zero or the code of a JPEG marker that has been
N   * read from the data source, but has not yet been processed.
N   */
N  int unread_marker;
N
N  /*
N   * Links to decompression subobjects (methods, private variables of modules)
N   */
N  struct jpeg_decomp_master * master;
N  struct jpeg_d_main_controller * main;
N  struct jpeg_d_coef_controller * coef;
N  struct jpeg_d_post_controller * post;
N  struct jpeg_input_controller * inputctl;
N  struct jpeg_marker_reader * marker;
N  struct jpeg_entropy_decoder * entropy;
N  struct jpeg_inverse_dct * idct;
N  struct jpeg_upsampler * upsample;
N  struct jpeg_color_deconverter * cconvert;
N  struct jpeg_color_quantizer * cquantize;
N};
N
N
N/* "Object" declarations for JPEG modules that may be supplied or called
N * directly by the surrounding application.
N * As with all objects in the JPEG library, these structs only define the
N * publicly visible methods and state variables of a module.  Additional
N * private fields may exist after the public ones.
N */
N
N
N/* Error handler object */
N
Nstruct jpeg_error_mgr {
N  /* Error exit handler: does not return to caller */
N  JMETHOD(void, error_exit, (j_common_ptr cinfo));
X  void (*error_exit) (j_common_ptr cinfo);
N  /* Conditionally emit a trace or warning message */
N  JMETHOD(void, emit_message, (j_common_ptr cinfo, int msg_level));
X  void (*emit_message) (j_common_ptr cinfo, int msg_level);
N  /* Routine that actually outputs a trace or error message */
N  JMETHOD(void, output_message, (j_common_ptr cinfo));
X  void (*output_message) (j_common_ptr cinfo);
N  /* Format a message string for the most recent JPEG error or message */
N  JMETHOD(void, format_message, (j_common_ptr cinfo, char * buffer));
X  void (*format_message) (j_common_ptr cinfo, char * buffer);
N#define JMSG_LENGTH_MAX  200	/* recommended size of format_message buffer */
N  /* Reset error state variables at start of a new image */
N  JMETHOD(void, reset_error_mgr, (j_common_ptr cinfo));
X  void (*reset_error_mgr) (j_common_ptr cinfo);
N  
N  /* The message ID code and any parameters are saved here.
N   * A message can have one string parameter or up to 8 int parameters.
N   */
N  int msg_code;
N#define JMSG_STR_PARM_MAX  80
N  union {
N    int i[8];
N    char s[JMSG_STR_PARM_MAX];
X    char s[80];
N  } msg_parm;
N  
N  /* Standard state variables for error facility */
N  
N  int trace_level;		/* max msg_level that will be displayed */
N  
N  /* For recoverable corrupt-data errors, we emit a warning message,
N   * but keep going unless emit_message chooses to abort.  emit_message
N   * should count warnings in num_warnings.  The surrounding application
N   * can check for bad data by seeing if num_warnings is nonzero at the
N   * end of processing.
N   */
N  long num_warnings;		/* number of corrupt-data warnings */
N
N  /* These fields point to the table(s) of error message strings.
N   * An application can change the table pointer to switch to a different
N   * message list (typically, to change the language in which errors are
N   * reported).  Some applications may wish to add additional error codes
N   * that will be handled by the JPEG library error mechanism; the second
N   * table pointer is used for this purpose.
N   *
N   * First table includes all errors generated by JPEG library itself.
N   * Error code 0 is reserved for a "no such error string" message.
N   */
N  const char * const * jpeg_message_table; /* Library errors */
N  int last_jpeg_message;    /* Table contains strings 0..last_jpeg_message */
N  /* Second table can be added by application (see cjpeg/djpeg for example).
N   * It contains strings numbered first_addon_message..last_addon_message.
N   */
N  const char * const * addon_message_table; /* Non-library errors */
N  int first_addon_message;	/* code for first string in addon table */
N  int last_addon_message;	/* code for last string in addon table */
N};
N
N
N/* Progress monitor object */
N
Nstruct jpeg_progress_mgr {
N  JMETHOD(void, progress_monitor, (j_common_ptr cinfo));
X  void (*progress_monitor) (j_common_ptr cinfo);
N
N  long pass_counter;		/* work units completed in this pass */
N  long pass_limit;		/* total number of work units in this pass */
N  int completed_passes;		/* passes completed so far */
N  int total_passes;		/* total number of passes expected */
N};
N
N
N/* Data destination object for compression */
N
Nstruct jpeg_destination_mgr {
N  JOCTET * next_output_byte;	/* => next byte to write in buffer */
N  size_t free_in_buffer;	/* # of byte spaces remaining in buffer */
N
N  JMETHOD(void, init_destination, (j_compress_ptr cinfo));
X  void (*init_destination) (j_compress_ptr cinfo);
N  JMETHOD(boolean, empty_output_buffer, (j_compress_ptr cinfo));
X  boolean (*empty_output_buffer) (j_compress_ptr cinfo);
N  JMETHOD(void, term_destination, (j_compress_ptr cinfo));
X  void (*term_destination) (j_compress_ptr cinfo);
N};
N
N
N/* Data source object for decompression */
N
Ntypedef struct jpeg_source_mgr {
N  const JOCTET * next_input_byte; /* => next byte to read from buffer */
N  size_t bytes_in_buffer;	/* # of bytes remaining in buffer */
N
N  JMETHOD(void, init_source, (j_decompress_ptr cinfo));
X  void (*init_source) (j_decompress_ptr cinfo);
N  JMETHOD(boolean, fill_input_buffer, (j_decompress_ptr cinfo));
X  boolean (*fill_input_buffer) (j_decompress_ptr cinfo);
N  JMETHOD(void, skip_input_data, (j_decompress_ptr cinfo, long num_bytes));
X  void (*skip_input_data) (j_decompress_ptr cinfo, long num_bytes);
N  JMETHOD(boolean, resync_to_restart, (j_decompress_ptr cinfo, int desired));
X  boolean (*resync_to_restart) (j_decompress_ptr cinfo, int desired);
N  JMETHOD(void, term_source, (j_decompress_ptr cinfo));
X  void (*term_source) (j_decompress_ptr cinfo);
N} jpeg_source_mgr;
N
N
N/* Memory manager object.
N * Allocates "small" objects (a few K total), "large" objects (tens of K),
N * and "really big" objects (virtual arrays with backing store if needed).
N * The memory manager does not allow individual objects to be freed; rather,
N * each created object is assigned to a pool, and whole pools can be freed
N * at once.  This is faster and more convenient than remembering exactly what
N * to free, especially where malloc()/free() are not too speedy.
N * NB: alloc routines never return NULL.  They exit to error_exit if not
N * successful.
N */
N
N#define JPOOL_PERMANENT	0	/* lasts until master record is destroyed */
N#define JPOOL_IMAGE	1	/* lasts until done with image/datastream */
N#define JPOOL_NUMPOOLS	2
N
Ntypedef struct jvirt_sarray_control * jvirt_sarray_ptr;
Ntypedef struct jvirt_barray_control * jvirt_barray_ptr;
N
N
Nstruct jpeg_memory_mgr {
N  /* Method pointers */
N  JMETHOD(void *, alloc_small, (j_common_ptr cinfo, int pool_id,
N				size_t sizeofobject));
X  void * (*alloc_small) (j_common_ptr cinfo, int pool_id, size_t sizeofobject);
N  JMETHOD(void FAR *, alloc_large, (j_common_ptr cinfo, int pool_id,
N				     size_t sizeofobject));
X  void * (*alloc_large) (j_common_ptr cinfo, int pool_id, size_t sizeofobject);
N  JMETHOD(JSAMPARRAY, alloc_sarray, (j_common_ptr cinfo, int pool_id,
N				     JDIMENSION samplesperrow,
N				     JDIMENSION numrows));
X  JSAMPARRAY (*alloc_sarray) (j_common_ptr cinfo, int pool_id, JDIMENSION samplesperrow, JDIMENSION numrows);
N  JMETHOD(JBLOCKARRAY, alloc_barray, (j_common_ptr cinfo, int pool_id,
N				      JDIMENSION blocksperrow,
N				      JDIMENSION numrows));
X  JBLOCKARRAY (*alloc_barray) (j_common_ptr cinfo, int pool_id, JDIMENSION blocksperrow, JDIMENSION numrows);
N  JMETHOD(jvirt_sarray_ptr, request_virt_sarray, (j_common_ptr cinfo,
N						  int pool_id,
N						  boolean pre_zero,
N						  JDIMENSION samplesperrow,
N						  JDIMENSION numrows,
N						  JDIMENSION maxaccess));
X  jvirt_sarray_ptr (*request_virt_sarray) (j_common_ptr cinfo, int pool_id, boolean pre_zero, JDIMENSION samplesperrow, JDIMENSION numrows, JDIMENSION maxaccess);
N  JMETHOD(jvirt_barray_ptr, request_virt_barray, (j_common_ptr cinfo,
N						  int pool_id,
N						  boolean pre_zero,
N						  JDIMENSION blocksperrow,
N						  JDIMENSION numrows,
N						  JDIMENSION maxaccess));
X  jvirt_barray_ptr (*request_virt_barray) (j_common_ptr cinfo, int pool_id, boolean pre_zero, JDIMENSION blocksperrow, JDIMENSION numrows, JDIMENSION maxaccess);
N  JMETHOD(void, realize_virt_arrays, (j_common_ptr cinfo));
X  void (*realize_virt_arrays) (j_common_ptr cinfo);
N  JMETHOD(JSAMPARRAY, access_virt_sarray, (j_common_ptr cinfo,
N					   jvirt_sarray_ptr ptr,
N					   JDIMENSION start_row,
N					   JDIMENSION num_rows,
N					   boolean writable));
X  JSAMPARRAY (*access_virt_sarray) (j_common_ptr cinfo, jvirt_sarray_ptr ptr, JDIMENSION start_row, JDIMENSION num_rows, boolean writable);
N  JMETHOD(JBLOCKARRAY, access_virt_barray, (j_common_ptr cinfo,
N					    jvirt_barray_ptr ptr,
N					    JDIMENSION start_row,
N					    JDIMENSION num_rows,
N					    boolean writable));
X  JBLOCKARRAY (*access_virt_barray) (j_common_ptr cinfo, jvirt_barray_ptr ptr, JDIMENSION start_row, JDIMENSION num_rows, boolean writable);
N  JMETHOD(void, free_pool, (j_common_ptr cinfo, int pool_id));
X  void (*free_pool) (j_common_ptr cinfo, int pool_id);
N  JMETHOD(void, self_destruct, (j_common_ptr cinfo));
X  void (*self_destruct) (j_common_ptr cinfo);
N
N  /* Limit on memory allocation for this JPEG object.  (Note that this is
N   * merely advisory, not a guaranteed maximum; it only affects the space
N   * used for virtual-array buffers.)  May be changed by outer application
N   * after creating the JPEG object.
N   */
N  long max_memory_to_use;
N
N  /* Maximum allocation request accepted by alloc_large. */
N  long max_alloc_chunk;
N};
N
N
N/* Routine signature for application-supplied marker processing methods.
N * Need not pass marker code since it is stored in cinfo->unread_marker.
N */
Ntypedef JMETHOD(boolean, jpeg_marker_parser_method, (j_decompress_ptr cinfo));
Xtypedef boolean (*jpeg_marker_parser_method) (j_decompress_ptr cinfo);
N
N
N/* Declarations for routines called by application.
N * The JPP macro hides prototype parameters from compilers that can't cope.
N * Note JPP requires double parentheses.
N */
N
N#define JPP(arglist)	arglist
N
N
N
N/* Default error-management setup */
NEXTERN(struct jpeg_error_mgr *) jpeg_std_error
Xextern struct jpeg_error_mgr * jpeg_std_error
N	JPP((struct jpeg_error_mgr * err));
X	(struct jpeg_error_mgr * err);
N
N/* Initialization of JPEG compression objects.
N * jpeg_create_compress() and jpeg_create_decompress() are the exported
N * names that applications should call.  These expand to calls on
N * jpeg_CreateCompress and jpeg_CreateDecompress with additional information
N * passed for version mismatch checking.
N * NB: you must set up the error-manager BEFORE calling jpeg_create_xxx.
N */
N#define jpeg_create_compress(cinfo) \
N    jpeg_CreateCompress((cinfo), JPEG_LIB_VERSION, \
N			(size_t) sizeof(struct jpeg_compress_struct))
X#define jpeg_create_compress(cinfo)     jpeg_CreateCompress((cinfo), JPEG_LIB_VERSION, 			(size_t) sizeof(struct jpeg_compress_struct))
N#define jpeg_create_decompress(cinfo) \
N    jpeg_CreateDecompress((cinfo), JPEG_LIB_VERSION, \
N			  (size_t) sizeof(struct jpeg_decompress_struct))
X#define jpeg_create_decompress(cinfo)     jpeg_CreateDecompress((cinfo), JPEG_LIB_VERSION, 			  (size_t) sizeof(struct jpeg_decompress_struct))
NEXTERN(void) jpeg_CreateCompress JPP((j_compress_ptr cinfo,
N				      int version, size_t structsize));
Xextern void jpeg_CreateCompress (j_compress_ptr cinfo, int version, size_t structsize);
NEXTERN(void) jpeg_CreateDecompress JPP((j_decompress_ptr cinfo,
N					int version, size_t structsize));
Xextern void jpeg_CreateDecompress (j_decompress_ptr cinfo, int version, size_t structsize);
N/* Destruction of JPEG compression objects */
NEXTERN(void) jpeg_destroy_compress JPP((j_compress_ptr cinfo));
Xextern void jpeg_destroy_compress (j_compress_ptr cinfo);
NEXTERN(void) jpeg_destroy_decompress JPP((j_decompress_ptr cinfo));
Xextern void jpeg_destroy_decompress (j_decompress_ptr cinfo);
N
N/* Standard data source and destination managers: stdio streams. */
N/* Caller is responsible for opening the file before and closing after. */
N/* EXTERN(void) jpeg_stdio_dest JPP((j_compress_ptr cinfo, FILE * outfile)); */
N/* EXTERN(void) jpeg_stdio_src JPP((j_decompress_ptr cinfo, FILE * infile)); */
N
N/* Default parameter setup for compression */
NEXTERN(void) jpeg_set_defaults JPP((j_compress_ptr cinfo));
Xextern void jpeg_set_defaults (j_compress_ptr cinfo);
N/* Compression parameter setup aids */
NEXTERN(void) jpeg_set_colorspace JPP((j_compress_ptr cinfo,
N				      J_COLOR_SPACE colorspace));
Xextern void jpeg_set_colorspace (j_compress_ptr cinfo, J_COLOR_SPACE colorspace);
NEXTERN(void) jpeg_default_colorspace JPP((j_compress_ptr cinfo));
Xextern void jpeg_default_colorspace (j_compress_ptr cinfo);
NEXTERN(void) jpeg_set_quality JPP((j_compress_ptr cinfo, int quality,
N				   boolean force_baseline));
Xextern void jpeg_set_quality (j_compress_ptr cinfo, int quality, boolean force_baseline);
NEXTERN(void) jpeg_set_linear_quality JPP((j_compress_ptr cinfo,
N					  int scale_factor,
N					  boolean force_baseline));
Xextern void jpeg_set_linear_quality (j_compress_ptr cinfo, int scale_factor, boolean force_baseline);
NEXTERN(void) jpeg_add_quant_table JPP((j_compress_ptr cinfo, int which_tbl,
N				       const unsigned int *basic_table,
N				       int scale_factor,
N				       boolean force_baseline));
Xextern void jpeg_add_quant_table (j_compress_ptr cinfo, int which_tbl, const unsigned int *basic_table, int scale_factor, boolean force_baseline);
NEXTERN(int) jpeg_quality_scaling JPP((int quality));
Xextern int jpeg_quality_scaling (int quality);
NEXTERN(void) jpeg_simple_progression JPP((j_compress_ptr cinfo));
Xextern void jpeg_simple_progression (j_compress_ptr cinfo);
NEXTERN(void) jpeg_suppress_tables JPP((j_compress_ptr cinfo,
N				       boolean suppress));
Xextern void jpeg_suppress_tables (j_compress_ptr cinfo, boolean suppress);
NEXTERN(JQUANT_TBL *) jpeg_alloc_quant_table JPP((j_common_ptr cinfo));
Xextern JQUANT_TBL * jpeg_alloc_quant_table (j_common_ptr cinfo);
NEXTERN(JHUFF_TBL *) jpeg_alloc_huff_table JPP((j_common_ptr cinfo));
Xextern JHUFF_TBL * jpeg_alloc_huff_table (j_common_ptr cinfo);
N
N/* Main entry points for compression */
NEXTERN(void) jpeg_start_compress JPP((j_compress_ptr cinfo,
N				      boolean write_all_tables));
Xextern void jpeg_start_compress (j_compress_ptr cinfo, boolean write_all_tables);
NEXTERN(JDIMENSION) jpeg_write_scanlines JPP((j_compress_ptr cinfo,
N					     JSAMPARRAY scanlines,
N					     JDIMENSION num_lines));
Xextern JDIMENSION jpeg_write_scanlines (j_compress_ptr cinfo, JSAMPARRAY scanlines, JDIMENSION num_lines);
NEXTERN(void) jpeg_finish_compress JPP((j_compress_ptr cinfo));
Xextern void jpeg_finish_compress (j_compress_ptr cinfo);
N
N/* Replaces jpeg_write_scanlines when writing raw downsampled data. */
NEXTERN(JDIMENSION) jpeg_write_raw_data JPP((j_compress_ptr cinfo,
N					    JSAMPIMAGE data,
N					    JDIMENSION num_lines));
Xextern JDIMENSION jpeg_write_raw_data (j_compress_ptr cinfo, JSAMPIMAGE data, JDIMENSION num_lines);
N
N/* Write a special marker.  See libjpeg.doc concerning safe usage. */
NEXTERN(void) jpeg_write_marker
Xextern void jpeg_write_marker
N	JPP((j_compress_ptr cinfo, int marker,
N	     const JOCTET * dataptr, unsigned int datalen));
X	(j_compress_ptr cinfo, int marker, const JOCTET * dataptr, unsigned int datalen);
N/* Same, but piecemeal. */
NEXTERN(void) jpeg_write_m_header
Xextern void jpeg_write_m_header
N	JPP((j_compress_ptr cinfo, int marker, unsigned int datalen));
X	(j_compress_ptr cinfo, int marker, unsigned int datalen);
NEXTERN(void) jpeg_write_m_byte
Xextern void jpeg_write_m_byte
N	JPP((j_compress_ptr cinfo, int val));
X	(j_compress_ptr cinfo, int val);
N
N/* Alternate compression function: just write an abbreviated table file */
NEXTERN(void) jpeg_write_tables JPP((j_compress_ptr cinfo));
Xextern void jpeg_write_tables (j_compress_ptr cinfo);
N
N/* Decompression startup: read start of JPEG datastream to see what's there */
NEXTERN(int) jpeg_read_header JPP((j_decompress_ptr cinfo,
N				  boolean require_image));
Xextern int jpeg_read_header (j_decompress_ptr cinfo, boolean require_image);
N/* Return value is one of: */
N#define JPEG_SUSPENDED		0 /* Suspended due to lack of input data */
N#define JPEG_HEADER_OK		1 /* Found valid image datastream */
N#define JPEG_HEADER_TABLES_ONLY	2 /* Found valid table-specs-only datastream */
N/* If you pass require_image = TRUE (normal case), you need not check for
N * a TABLES_ONLY return code; an abbreviated file will cause an error exit.
N * JPEG_SUSPENDED is only possible if you use a data source module that can
N * give a suspension return (the stdio source module doesn't).
N */
N
N/* Main entry points for decompression */
NEXTERN(boolean) jpeg_start_decompress JPP((j_decompress_ptr cinfo));
Xextern boolean jpeg_start_decompress (j_decompress_ptr cinfo);
NEXTERN(JDIMENSION) jpeg_read_scanlines JPP((j_decompress_ptr cinfo,
N					    JSAMPARRAY scanlines,
N					    JDIMENSION max_lines));
Xextern JDIMENSION jpeg_read_scanlines (j_decompress_ptr cinfo, JSAMPARRAY scanlines, JDIMENSION max_lines);
NEXTERN(boolean) jpeg_finish_decompress JPP((j_decompress_ptr cinfo));
Xextern boolean jpeg_finish_decompress (j_decompress_ptr cinfo);
N
N/* Replaces jpeg_read_scanlines when reading raw downsampled data. */
NEXTERN(JDIMENSION) jpeg_read_raw_data JPP((j_decompress_ptr cinfo,
N					   JSAMPIMAGE data,
N					   JDIMENSION max_lines));
Xextern JDIMENSION jpeg_read_raw_data (j_decompress_ptr cinfo, JSAMPIMAGE data, JDIMENSION max_lines);
N
N/* Additional entry points for buffered-image mode. */
NEXTERN(boolean) jpeg_has_multiple_scans JPP((j_decompress_ptr cinfo));
Xextern boolean jpeg_has_multiple_scans (j_decompress_ptr cinfo);
NEXTERN(boolean) jpeg_start_output JPP((j_decompress_ptr cinfo,
N				       int scan_number));
Xextern boolean jpeg_start_output (j_decompress_ptr cinfo, int scan_number);
NEXTERN(boolean) jpeg_finish_output JPP((j_decompress_ptr cinfo));
Xextern boolean jpeg_finish_output (j_decompress_ptr cinfo);
NEXTERN(boolean) jpeg_input_complete JPP((j_decompress_ptr cinfo));
Xextern boolean jpeg_input_complete (j_decompress_ptr cinfo);
NEXTERN(void) jpeg_new_colormap JPP((j_decompress_ptr cinfo));
Xextern void jpeg_new_colormap (j_decompress_ptr cinfo);
NEXTERN(int) jpeg_consume_input JPP((j_decompress_ptr cinfo));
Xextern int jpeg_consume_input (j_decompress_ptr cinfo);
N/* Return value is one of: */
N/* #define JPEG_SUSPENDED	0    Suspended due to lack of input data */
N#define JPEG_REACHED_SOS	1 /* Reached start of new scan */
N#define JPEG_REACHED_EOI	2 /* Reached end of image */
N#define JPEG_ROW_COMPLETED	3 /* Completed one iMCU row */
N#define JPEG_SCAN_COMPLETED	4 /* Completed last iMCU row of a scan */
N
N/* Precalculate output dimensions for current decompression parameters. */
NEXTERN(void) jpeg_calc_output_dimensions JPP((j_decompress_ptr cinfo));
Xextern void jpeg_calc_output_dimensions (j_decompress_ptr cinfo);
N
N/* Control saving of COM and APPn markers into marker_list. */
NEXTERN(void) jpeg_save_markers
Xextern void jpeg_save_markers
N	JPP((j_decompress_ptr cinfo, int marker_code,
N	     unsigned int length_limit));
X	(j_decompress_ptr cinfo, int marker_code, unsigned int length_limit);
N
N/* Install a special processing method for COM or APPn markers. */
NEXTERN(void) jpeg_set_marker_processor
Xextern void jpeg_set_marker_processor
N	JPP((j_decompress_ptr cinfo, int marker_code,
N	     jpeg_marker_parser_method routine));
X	(j_decompress_ptr cinfo, int marker_code, jpeg_marker_parser_method routine);
N
N/* Read or write raw DCT coefficients --- useful for lossless transcoding. */
NEXTERN(jvirt_barray_ptr *) jpeg_read_coefficients JPP((j_decompress_ptr cinfo));
Xextern jvirt_barray_ptr * jpeg_read_coefficients (j_decompress_ptr cinfo);
NEXTERN(void) jpeg_write_coefficients JPP((j_compress_ptr cinfo,
N					  jvirt_barray_ptr * coef_arrays));
Xextern void jpeg_write_coefficients (j_compress_ptr cinfo, jvirt_barray_ptr * coef_arrays);
NEXTERN(void) jpeg_copy_critical_parameters JPP((j_decompress_ptr srcinfo,
N						j_compress_ptr dstinfo));
Xextern void jpeg_copy_critical_parameters (j_decompress_ptr srcinfo, j_compress_ptr dstinfo);
N
N/* If you choose to abort compression or decompression before completing
N * jpeg_finish_(de)compress, then you need to clean up to release memory,
N * temporary files, etc.  You can just call jpeg_destroy_(de)compress
N * if you're done with the JPEG object, but if you want to clean it up and
N * reuse it, call this:
N */
NEXTERN(void) jpeg_abort_compress JPP((j_compress_ptr cinfo));
Xextern void jpeg_abort_compress (j_compress_ptr cinfo);
NEXTERN(void) jpeg_abort_decompress JPP((j_decompress_ptr cinfo));
Xextern void jpeg_abort_decompress (j_decompress_ptr cinfo);
N
N/* Generic versions of jpeg_abort and jpeg_destroy that work on either
N * flavor of JPEG object.  These may be more convenient in some places.
N */
NEXTERN(void) jpeg_abort JPP((j_common_ptr cinfo));
Xextern void jpeg_abort (j_common_ptr cinfo);
NEXTERN(void) jpeg_destroy JPP((j_common_ptr cinfo));
Xextern void jpeg_destroy (j_common_ptr cinfo);
N
N/* Default restart-marker-resync procedure for use by data source modules */
NEXTERN(boolean) jpeg_resync_to_restart JPP((j_decompress_ptr cinfo,
N					    int desired));
Xextern boolean jpeg_resync_to_restart (j_decompress_ptr cinfo, int desired);
N
N
N/* These marker codes are exported since applications and data source modules
N * are likely to want to use them.
N */
N
N#define JPEG_RST0	0xD0	/* RST0 marker code */
N#define JPEG_EOI	0xD9	/* EOI marker code */
N#define JPEG_APP0	0xE0	/* APP0 marker code */
N#define JPEG_COM	0xFE	/* COM marker code */
N
N
N/* If we have a brain-damaged compiler that emits warnings (or worse, errors)
N * for structure definitions that are never filled in, keep it quiet by
N * supplying dummy definitions for the various substructures.
N */
N
N#ifdef INCOMPLETE_TYPES_BROKEN
S#ifndef JPEG_INTERNALS		/* will be defined in jpegint.h */
Sstruct jvirt_sarray_control { long dummy; };
Sstruct jvirt_barray_control { long dummy; };
Sstruct jpeg_comp_master { long dummy; };
Sstruct jpeg_c_main_controller { long dummy; };
Sstruct jpeg_c_prep_controller { long dummy; };
Sstruct jpeg_c_coef_controller { long dummy; };
Sstruct jpeg_marker_writer { long dummy; };
Sstruct jpeg_color_converter { long dummy; };
Sstruct jpeg_downsampler { long dummy; };
Sstruct jpeg_forward_dct { long dummy; };
Sstruct jpeg_entropy_encoder { long dummy; };
Sstruct jpeg_decomp_master { long dummy; };
Sstruct jpeg_d_main_controller { long dummy; };
Sstruct jpeg_d_coef_controller { long dummy; };
Sstruct jpeg_d_post_controller { long dummy; };
Sstruct jpeg_input_controller { long dummy; };
Sstruct jpeg_marker_reader { long dummy; };
Sstruct jpeg_entropy_decoder { long dummy; };
Sstruct jpeg_inverse_dct { long dummy; };
Sstruct jpeg_upsampler { long dummy; };
Sstruct jpeg_color_deconverter { long dummy; };
Sstruct jpeg_color_quantizer { long dummy; };
S#endif /* JPEG_INTERNALS */
N#endif /* INCOMPLETE_TYPES_BROKEN */
N
N
N/*
N * The JPEG library modules define JPEG_INTERNALS before including this file.
N * The internal structure declarations are read only when that is true.
N * Applications using the library should not include jpegint.h, but may wish
N * to include jerror.h.
N */
N
N#ifdef JPEG_INTERNALS
S#include "jpegint.h"		/* fetch private declarations */
S#include "jerror.h"		/* fetch error codes too */
N#endif
N
N#endif /* JPEGLIB_H */
L 24 "..\GUI\JPEG\GUI_JPEG.c" 2
N#include "jerror.h"
L 1 "..\GUI\JPEG\jerror.h" 1
N/*
N * jerror.h
N *
N * Copyright (C) 1994-1997, Thomas G. Lane.
N * This file is part of the Independent JPEG Group's software.
N * For conditions of distribution and use, see the accompanying README file.
N *
N * This file defines the error and message codes for the JPEG library.
N * Edit this file to add new codes, or to translate the message strings to
N * some other language.
N * A set of error-reporting macros are defined too.  Some applications using
N * the JPEG library may wish to include this file to get the error codes
N * and/or the macros.
N */
N
N/*
N * To define the enum list of message codes, include this file without
N * defining macro JMESSAGE.  To create a message string table, include it
N * again with a suitable JMESSAGE definition (see jerror.c for an example).
N */
N#ifndef JMESSAGE
N#ifndef JERROR_H
N/* First time through, define the enum list */
N#define JMAKE_ENUM_LIST
N#else
S/* Repeated inclusions of this file are no-ops unless JMESSAGE is defined */
S#define JMESSAGE(code,string)
N#endif /* JERROR_H */
N#endif /* JMESSAGE */
N
N#ifdef JMAKE_ENUM_LIST
N
Ntypedef enum {
N
N#define JMESSAGE(code,string)	code ,
N
N#endif /* JMAKE_ENUM_LIST */
N
NJMESSAGE(JMSG_NOMESSAGE, "Bogus message code %d") /* Must be first entry! */
XJMSG_NOMESSAGE ,  
N
N/* For maintenance convenience, list is alphabetical by message code name */
NJMESSAGE(JERR_ARITH_NOTIMPL,
N	 "Sorry, there are legal restrictions on arithmetic coding")
XJERR_ARITH_NOTIMPL ,
NJMESSAGE(JERR_BAD_ALIGN_TYPE, "ALIGN_TYPE is wrong, please fix")
XJERR_BAD_ALIGN_TYPE ,
NJMESSAGE(JERR_BAD_ALLOC_CHUNK, "MAX_ALLOC_CHUNK is wrong, please fix")
XJERR_BAD_ALLOC_CHUNK ,
NJMESSAGE(JERR_BAD_BUFFER_MODE, "Bogus buffer control mode")
XJERR_BAD_BUFFER_MODE ,
NJMESSAGE(JERR_BAD_COMPONENT_ID, "Invalid component ID %d in SOS")
XJERR_BAD_COMPONENT_ID ,
NJMESSAGE(JERR_BAD_DCT_COEF, "DCT coefficient out of range")
XJERR_BAD_DCT_COEF ,
NJMESSAGE(JERR_BAD_DCTSIZE, "IDCT output block size %d not supported")
XJERR_BAD_DCTSIZE ,
NJMESSAGE(JERR_BAD_HUFF_TABLE, "Bogus Huffman table definition")
XJERR_BAD_HUFF_TABLE ,
NJMESSAGE(JERR_BAD_IN_COLORSPACE, "Bogus input colorspace")
XJERR_BAD_IN_COLORSPACE ,
NJMESSAGE(JERR_BAD_J_COLORSPACE, "Bogus JPEG colorspace")
XJERR_BAD_J_COLORSPACE ,
NJMESSAGE(JERR_BAD_LENGTH, "Bogus marker length")
XJERR_BAD_LENGTH ,
NJMESSAGE(JERR_BAD_LIB_VERSION,
N	 "Wrong JPEG library version: library is %d, caller expects %d")
XJERR_BAD_LIB_VERSION ,
NJMESSAGE(JERR_BAD_MCU_SIZE, "Sampling factors too large for interleaved scan")
XJERR_BAD_MCU_SIZE ,
NJMESSAGE(JERR_BAD_POOL_ID, "Invalid memory pool code %d")
XJERR_BAD_POOL_ID ,
NJMESSAGE(JERR_BAD_PRECISION, "Unsupported JPEG data precision %d")
XJERR_BAD_PRECISION ,
NJMESSAGE(JERR_BAD_PROGRESSION,
N	 "Invalid progressive parameters Ss=%d Se=%d Ah=%d Al=%d")
XJERR_BAD_PROGRESSION ,
NJMESSAGE(JERR_BAD_PROG_SCRIPT,
N	 "Invalid progressive parameters at scan script entry %d")
XJERR_BAD_PROG_SCRIPT ,
NJMESSAGE(JERR_BAD_SAMPLING, "Bogus sampling factors")
XJERR_BAD_SAMPLING ,
NJMESSAGE(JERR_BAD_SCAN_SCRIPT, "Invalid scan script at entry %d")
XJERR_BAD_SCAN_SCRIPT ,
NJMESSAGE(JERR_BAD_STATE, "Improper call to JPEG library in state %d")
XJERR_BAD_STATE ,
NJMESSAGE(JERR_BAD_STRUCT_SIZE,
N	 "JPEG parameter struct mismatch: library thinks size is %u, caller expects %u")
XJERR_BAD_STRUCT_SIZE ,
NJMESSAGE(JERR_BAD_VIRTUAL_ACCESS, "Bogus virtual array access")
XJERR_BAD_VIRTUAL_ACCESS ,
NJMESSAGE(JERR_BUFFER_SIZE, "Buffer passed to JPEG library is too small")
XJERR_BUFFER_SIZE ,
NJMESSAGE(JERR_CANT_SUSPEND, "Suspension not allowed here")
XJERR_CANT_SUSPEND ,
NJMESSAGE(JERR_CCIR601_NOTIMPL, "CCIR601 sampling not implemented yet")
XJERR_CCIR601_NOTIMPL ,
NJMESSAGE(JERR_COMPONENT_COUNT, "Too many color components: %d, max %d")
XJERR_COMPONENT_COUNT ,
NJMESSAGE(JERR_CONVERSION_NOTIMPL, "Unsupported color conversion request")
XJERR_CONVERSION_NOTIMPL ,
NJMESSAGE(JERR_DAC_INDEX, "Bogus DAC index %d")
XJERR_DAC_INDEX ,
NJMESSAGE(JERR_DAC_VALUE, "Bogus DAC value 0x%x")
XJERR_DAC_VALUE ,
NJMESSAGE(JERR_DHT_INDEX, "Bogus DHT index %d")
XJERR_DHT_INDEX ,
NJMESSAGE(JERR_DQT_INDEX, "Bogus DQT index %d")
XJERR_DQT_INDEX ,
NJMESSAGE(JERR_EMPTY_IMAGE, "Empty JPEG image (DNL not supported)")
XJERR_EMPTY_IMAGE ,
NJMESSAGE(JERR_EMS_READ, "Read from EMS failed")
XJERR_EMS_READ ,
NJMESSAGE(JERR_EMS_WRITE, "Write to EMS failed")
XJERR_EMS_WRITE ,
NJMESSAGE(JERR_EOI_EXPECTED, "Didn't expect more than one scan")
XJERR_EOI_EXPECTED ,
NJMESSAGE(JERR_FILE_READ, "Input file read error")
XJERR_FILE_READ ,
NJMESSAGE(JERR_FILE_WRITE, "Output file write error --- out of disk space?")
XJERR_FILE_WRITE ,
NJMESSAGE(JERR_FRACT_SAMPLE_NOTIMPL, "Fractional sampling not implemented yet")
XJERR_FRACT_SAMPLE_NOTIMPL ,
NJMESSAGE(JERR_HUFF_CLEN_OVERFLOW, "Huffman code size table overflow")
XJERR_HUFF_CLEN_OVERFLOW ,
NJMESSAGE(JERR_HUFF_MISSING_CODE, "Missing Huffman code table entry")
XJERR_HUFF_MISSING_CODE ,
NJMESSAGE(JERR_IMAGE_TOO_BIG, "Maximum supported image dimension is %u pixels")
XJERR_IMAGE_TOO_BIG ,
NJMESSAGE(JERR_INPUT_EMPTY, "Empty input file")
XJERR_INPUT_EMPTY ,
NJMESSAGE(JERR_INPUT_EOF, "Premature end of input file")
XJERR_INPUT_EOF ,
NJMESSAGE(JERR_MISMATCHED_QUANT_TABLE,
N	 "Cannot transcode due to multiple use of quantization table %d")
XJERR_MISMATCHED_QUANT_TABLE ,
NJMESSAGE(JERR_MISSING_DATA, "Scan script does not transmit all data")
XJERR_MISSING_DATA ,
NJMESSAGE(JERR_MODE_CHANGE, "Invalid color quantization mode change")
XJERR_MODE_CHANGE ,
NJMESSAGE(JERR_NOTIMPL, "Not implemented yet")
XJERR_NOTIMPL ,
NJMESSAGE(JERR_NOT_COMPILED, "Requested feature was omitted at compile time")
XJERR_NOT_COMPILED ,
NJMESSAGE(JERR_NO_BACKING_STORE, "Backing store not supported")
XJERR_NO_BACKING_STORE ,
NJMESSAGE(JERR_NO_HUFF_TABLE, "Huffman table 0x%02x was not defined")
XJERR_NO_HUFF_TABLE ,
NJMESSAGE(JERR_NO_IMAGE, "JPEG datastream contains no image")
XJERR_NO_IMAGE ,
NJMESSAGE(JERR_NO_QUANT_TABLE, "Quantization table 0x%02x was not defined")
XJERR_NO_QUANT_TABLE ,
NJMESSAGE(JERR_NO_SOI, "Not a JPEG file: starts with 0x%02x 0x%02x")
XJERR_NO_SOI ,
NJMESSAGE(JERR_OUT_OF_MEMORY, "Insufficient memory (case %d)")
XJERR_OUT_OF_MEMORY ,
NJMESSAGE(JERR_QUANT_COMPONENTS,
N	 "Cannot quantize more than %d color components")
XJERR_QUANT_COMPONENTS ,
NJMESSAGE(JERR_QUANT_FEW_COLORS, "Cannot quantize to fewer than %d colors")
XJERR_QUANT_FEW_COLORS ,
NJMESSAGE(JERR_QUANT_MANY_COLORS, "Cannot quantize to more than %d colors")
XJERR_QUANT_MANY_COLORS ,
NJMESSAGE(JERR_SOF_DUPLICATE, "Invalid JPEG file structure: two SOF markers")
XJERR_SOF_DUPLICATE ,
NJMESSAGE(JERR_SOF_NO_SOS, "Invalid JPEG file structure: missing SOS marker")
XJERR_SOF_NO_SOS ,
NJMESSAGE(JERR_SOF_UNSUPPORTED, "Unsupported JPEG process: SOF type 0x%02x")
XJERR_SOF_UNSUPPORTED ,
NJMESSAGE(JERR_SOI_DUPLICATE, "Invalid JPEG file structure: two SOI markers")
XJERR_SOI_DUPLICATE ,
NJMESSAGE(JERR_SOS_NO_SOF, "Invalid JPEG file structure: SOS before SOF")
XJERR_SOS_NO_SOF ,
NJMESSAGE(JERR_TFILE_CREATE, "Failed to create temporary file %s")
XJERR_TFILE_CREATE ,
NJMESSAGE(JERR_TFILE_READ, "Read failed on temporary file")
XJERR_TFILE_READ ,
NJMESSAGE(JERR_TFILE_SEEK, "Seek failed on temporary file")
XJERR_TFILE_SEEK ,
NJMESSAGE(JERR_TFILE_WRITE,
N	 "Write failed on temporary file --- out of disk space?")
XJERR_TFILE_WRITE ,
NJMESSAGE(JERR_TOO_LITTLE_DATA, "Application transferred too few scanlines")
XJERR_TOO_LITTLE_DATA ,
NJMESSAGE(JERR_UNKNOWN_MARKER, "Unsupported marker type 0x%02x")
XJERR_UNKNOWN_MARKER ,
NJMESSAGE(JERR_VIRTUAL_BUG, "Virtual array controller messed up")
XJERR_VIRTUAL_BUG ,
NJMESSAGE(JERR_WIDTH_OVERFLOW, "Image too wide for this implementation")
XJERR_WIDTH_OVERFLOW ,
NJMESSAGE(JERR_XMS_READ, "Read from XMS failed")
XJERR_XMS_READ ,
NJMESSAGE(JERR_XMS_WRITE, "Write to XMS failed")
XJERR_XMS_WRITE ,
NJMESSAGE(JMSG_COPYRIGHT, JCOPYRIGHT)
XJMSG_COPYRIGHT ,
NJMESSAGE(JMSG_VERSION, JVERSION)
XJMSG_VERSION ,
NJMESSAGE(JTRC_16BIT_TABLES,
N	 "Caution: quantization tables are too coarse for baseline JPEG")
XJTRC_16BIT_TABLES ,
NJMESSAGE(JTRC_ADOBE,
N	 "Adobe APP14 marker: version %d, flags 0x%04x 0x%04x, transform %d")
XJTRC_ADOBE ,
NJMESSAGE(JTRC_APP0, "Unknown APP0 marker (not JFIF), length %u")
XJTRC_APP0 ,
NJMESSAGE(JTRC_APP14, "Unknown APP14 marker (not Adobe), length %u")
XJTRC_APP14 ,
NJMESSAGE(JTRC_DAC, "Define Arithmetic Table 0x%02x: 0x%02x")
XJTRC_DAC ,
NJMESSAGE(JTRC_DHT, "Define Huffman Table 0x%02x")
XJTRC_DHT ,
NJMESSAGE(JTRC_DQT, "Define Quantization Table %d  precision %d")
XJTRC_DQT ,
NJMESSAGE(JTRC_DRI, "Define Restart Interval %u")
XJTRC_DRI ,
NJMESSAGE(JTRC_EMS_CLOSE, "Freed EMS handle %u")
XJTRC_EMS_CLOSE ,
NJMESSAGE(JTRC_EMS_OPEN, "Obtained EMS handle %u")
XJTRC_EMS_OPEN ,
NJMESSAGE(JTRC_EOI, "End Of Image")
XJTRC_EOI ,
NJMESSAGE(JTRC_HUFFBITS, "        %3d %3d %3d %3d %3d %3d %3d %3d")
XJTRC_HUFFBITS ,
NJMESSAGE(JTRC_JFIF, "JFIF APP0 marker: version %d.%02d, density %dx%d  %d")
XJTRC_JFIF ,
NJMESSAGE(JTRC_JFIF_BADTHUMBNAILSIZE,
N	 "Warning: thumbnail image size does not match data length %u")
XJTRC_JFIF_BADTHUMBNAILSIZE ,
NJMESSAGE(JTRC_JFIF_EXTENSION,
N	 "JFIF extension marker: type 0x%02x, length %u")
XJTRC_JFIF_EXTENSION ,
NJMESSAGE(JTRC_JFIF_THUMBNAIL, "    with %d x %d thumbnail image")
XJTRC_JFIF_THUMBNAIL ,
NJMESSAGE(JTRC_MISC_MARKER, "Miscellaneous marker 0x%02x, length %u")
XJTRC_MISC_MARKER ,
NJMESSAGE(JTRC_PARMLESS_MARKER, "Unexpected marker 0x%02x")
XJTRC_PARMLESS_MARKER ,
NJMESSAGE(JTRC_QUANTVALS, "        %4u %4u %4u %4u %4u %4u %4u %4u")
XJTRC_QUANTVALS ,
NJMESSAGE(JTRC_QUANT_3_NCOLORS, "Quantizing to %d = %d*%d*%d colors")
XJTRC_QUANT_3_NCOLORS ,
NJMESSAGE(JTRC_QUANT_NCOLORS, "Quantizing to %d colors")
XJTRC_QUANT_NCOLORS ,
NJMESSAGE(JTRC_QUANT_SELECTED, "Selected %d colors for quantization")
XJTRC_QUANT_SELECTED ,
NJMESSAGE(JTRC_RECOVERY_ACTION, "At marker 0x%02x, recovery action %d")
XJTRC_RECOVERY_ACTION ,
NJMESSAGE(JTRC_RST, "RST%d")
XJTRC_RST ,
NJMESSAGE(JTRC_SMOOTH_NOTIMPL,
N	 "Smoothing not supported with nonstandard sampling ratios")
XJTRC_SMOOTH_NOTIMPL ,
NJMESSAGE(JTRC_SOF, "Start Of Frame 0x%02x: width=%u, height=%u, components=%d")
XJTRC_SOF ,
NJMESSAGE(JTRC_SOF_COMPONENT, "    Component %d: %dhx%dv q=%d")
XJTRC_SOF_COMPONENT ,
NJMESSAGE(JTRC_SOI, "Start of Image")
XJTRC_SOI ,
NJMESSAGE(JTRC_SOS, "Start Of Scan: %d components")
XJTRC_SOS ,
NJMESSAGE(JTRC_SOS_COMPONENT, "    Component %d: dc=%d ac=%d")
XJTRC_SOS_COMPONENT ,
NJMESSAGE(JTRC_SOS_PARAMS, "  Ss=%d, Se=%d, Ah=%d, Al=%d")
XJTRC_SOS_PARAMS ,
NJMESSAGE(JTRC_TFILE_CLOSE, "Closed temporary file %s")
XJTRC_TFILE_CLOSE ,
NJMESSAGE(JTRC_TFILE_OPEN, "Opened temporary file %s")
XJTRC_TFILE_OPEN ,
NJMESSAGE(JTRC_THUMB_JPEG,
N	 "JFIF extension marker: JPEG-compressed thumbnail image, length %u")
XJTRC_THUMB_JPEG ,
NJMESSAGE(JTRC_THUMB_PALETTE,
N	 "JFIF extension marker: palette thumbnail image, length %u")
XJTRC_THUMB_PALETTE ,
NJMESSAGE(JTRC_THUMB_RGB,
N	 "JFIF extension marker: RGB thumbnail image, length %u")
XJTRC_THUMB_RGB ,
NJMESSAGE(JTRC_UNKNOWN_IDS,
N	 "Unrecognized component IDs %d %d %d, assuming YCbCr")
XJTRC_UNKNOWN_IDS ,
NJMESSAGE(JTRC_XMS_CLOSE, "Freed XMS handle %u")
XJTRC_XMS_CLOSE ,
NJMESSAGE(JTRC_XMS_OPEN, "Obtained XMS handle %u")
XJTRC_XMS_OPEN ,
NJMESSAGE(JWRN_ADOBE_XFORM, "Unknown Adobe color transform code %d")
XJWRN_ADOBE_XFORM ,
NJMESSAGE(JWRN_BOGUS_PROGRESSION,
N	 "Inconsistent progression sequence for component %d coefficient %d")
XJWRN_BOGUS_PROGRESSION ,
NJMESSAGE(JWRN_EXTRANEOUS_DATA,
N	 "Corrupt JPEG data: %u extraneous bytes before marker 0x%02x")
XJWRN_EXTRANEOUS_DATA ,
NJMESSAGE(JWRN_HIT_MARKER, "Corrupt JPEG data: premature end of data segment")
XJWRN_HIT_MARKER ,
NJMESSAGE(JWRN_HUFF_BAD_CODE, "Corrupt JPEG data: bad Huffman code")
XJWRN_HUFF_BAD_CODE ,
NJMESSAGE(JWRN_JFIF_MAJOR, "Warning: unknown JFIF revision number %d.%02d")
XJWRN_JFIF_MAJOR ,
NJMESSAGE(JWRN_JPEG_EOF, "Premature end of JPEG file")
XJWRN_JPEG_EOF ,
NJMESSAGE(JWRN_MUST_RESYNC,
N	 "Corrupt JPEG data: found marker 0x%02x instead of RST%d")
XJWRN_MUST_RESYNC ,
NJMESSAGE(JWRN_NOT_SEQUENTIAL, "Invalid SOS parameters for sequential JPEG")
XJWRN_NOT_SEQUENTIAL ,
NJMESSAGE(JWRN_TOO_MUCH_DATA, "Application transferred too many scanlines")
XJWRN_TOO_MUCH_DATA ,
N
N#ifdef JMAKE_ENUM_LIST
N
N  JMSG_LASTMSGCODE
N} J_MESSAGE_CODE;
N
N#undef JMAKE_ENUM_LIST
N#endif /* JMAKE_ENUM_LIST */
N
N/* Zap JMESSAGE macro so that future re-inclusions do nothing by default */
N#undef JMESSAGE
N
N
N#ifndef JERROR_H
N#define JERROR_H
N
N/* Macros to simplify using the error and trace message stuff */
N/* The first parameter is either type of cinfo pointer */
N
N/* Fatal errors (print message and exit) */
N#define ERREXIT(cinfo,code)  \
N  ((cinfo)->err->msg_code = (code), \
N   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
X#define ERREXIT(cinfo,code)    ((cinfo)->err->msg_code = (code),    (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
N#define ERREXIT1(cinfo,code,p1)  \
N  ((cinfo)->err->msg_code = (code), \
N   (cinfo)->err->msg_parm.i[0] = (p1), \
N   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
X#define ERREXIT1(cinfo,code,p1)    ((cinfo)->err->msg_code = (code),    (cinfo)->err->msg_parm.i[0] = (p1),    (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
N#define ERREXIT2(cinfo,code,p1,p2)  \
N  ((cinfo)->err->msg_code = (code), \
N   (cinfo)->err->msg_parm.i[0] = (p1), \
N   (cinfo)->err->msg_parm.i[1] = (p2), \
N   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
X#define ERREXIT2(cinfo,code,p1,p2)    ((cinfo)->err->msg_code = (code),    (cinfo)->err->msg_parm.i[0] = (p1),    (cinfo)->err->msg_parm.i[1] = (p2),    (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
N#define ERREXIT3(cinfo,code,p1,p2,p3)  \
N  ((cinfo)->err->msg_code = (code), \
N   (cinfo)->err->msg_parm.i[0] = (p1), \
N   (cinfo)->err->msg_parm.i[1] = (p2), \
N   (cinfo)->err->msg_parm.i[2] = (p3), \
N   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
X#define ERREXIT3(cinfo,code,p1,p2,p3)    ((cinfo)->err->msg_code = (code),    (cinfo)->err->msg_parm.i[0] = (p1),    (cinfo)->err->msg_parm.i[1] = (p2),    (cinfo)->err->msg_parm.i[2] = (p3),    (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
N#define ERREXIT4(cinfo,code,p1,p2,p3,p4)  \
N  ((cinfo)->err->msg_code = (code), \
N   (cinfo)->err->msg_parm.i[0] = (p1), \
N   (cinfo)->err->msg_parm.i[1] = (p2), \
N   (cinfo)->err->msg_parm.i[2] = (p3), \
N   (cinfo)->err->msg_parm.i[3] = (p4), \
N   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
X#define ERREXIT4(cinfo,code,p1,p2,p3,p4)    ((cinfo)->err->msg_code = (code),    (cinfo)->err->msg_parm.i[0] = (p1),    (cinfo)->err->msg_parm.i[1] = (p2),    (cinfo)->err->msg_parm.i[2] = (p3),    (cinfo)->err->msg_parm.i[3] = (p4),    (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
N#define ERREXITS(cinfo,code,str)  \
N  ((cinfo)->err->msg_code = (code), \
N   strncpy((cinfo)->err->msg_parm.s, (str), JMSG_STR_PARM_MAX), \
N   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
X#define ERREXITS(cinfo,code,str)    ((cinfo)->err->msg_code = (code),    strncpy((cinfo)->err->msg_parm.s, (str), JMSG_STR_PARM_MAX),    (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
N
N#define MAKESTMT(stuff)		do { stuff } while (0)
N
N/* Nonfatal errors (we can keep going, but the data is probably corrupt) */
N#define WARNMS(cinfo,code)  \
N  ((cinfo)->err->msg_code = (code), \
N   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), -1))
X#define WARNMS(cinfo,code)    ((cinfo)->err->msg_code = (code),    (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), -1))
N#define WARNMS1(cinfo,code,p1)  \
N  ((cinfo)->err->msg_code = (code), \
N   (cinfo)->err->msg_parm.i[0] = (p1), \
N   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), -1))
X#define WARNMS1(cinfo,code,p1)    ((cinfo)->err->msg_code = (code),    (cinfo)->err->msg_parm.i[0] = (p1),    (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), -1))
N#define WARNMS2(cinfo,code,p1,p2)  \
N  ((cinfo)->err->msg_code = (code), \
N   (cinfo)->err->msg_parm.i[0] = (p1), \
N   (cinfo)->err->msg_parm.i[1] = (p2), \
N   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), -1))
X#define WARNMS2(cinfo,code,p1,p2)    ((cinfo)->err->msg_code = (code),    (cinfo)->err->msg_parm.i[0] = (p1),    (cinfo)->err->msg_parm.i[1] = (p2),    (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), -1))
N
N/* Informational/debugging messages */
N#define TRACEMS(cinfo,lvl,code)  \
N  ((cinfo)->err->msg_code = (code), \
N   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
X#define TRACEMS(cinfo,lvl,code)    ((cinfo)->err->msg_code = (code),    (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
N#define TRACEMS1(cinfo,lvl,code,p1)  \
N  ((cinfo)->err->msg_code = (code), \
N   (cinfo)->err->msg_parm.i[0] = (p1), \
N   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
X#define TRACEMS1(cinfo,lvl,code,p1)    ((cinfo)->err->msg_code = (code),    (cinfo)->err->msg_parm.i[0] = (p1),    (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
N#define TRACEMS2(cinfo,lvl,code,p1,p2)  \
N  ((cinfo)->err->msg_code = (code), \
N   (cinfo)->err->msg_parm.i[0] = (p1), \
N   (cinfo)->err->msg_parm.i[1] = (p2), \
N   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
X#define TRACEMS2(cinfo,lvl,code,p1,p2)    ((cinfo)->err->msg_code = (code),    (cinfo)->err->msg_parm.i[0] = (p1),    (cinfo)->err->msg_parm.i[1] = (p2),    (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
N#define TRACEMS3(cinfo,lvl,code,p1,p2,p3)  \
N  MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; \
N	   _mp[0] = (p1); _mp[1] = (p2); _mp[2] = (p3); \
N	   (cinfo)->err->msg_code = (code); \
N	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
X#define TRACEMS3(cinfo,lvl,code,p1,p2,p3)    MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; 	   _mp[0] = (p1); _mp[1] = (p2); _mp[2] = (p3); 	   (cinfo)->err->msg_code = (code); 	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
N#define TRACEMS4(cinfo,lvl,code,p1,p2,p3,p4)  \
N  MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; \
N	   _mp[0] = (p1); _mp[1] = (p2); _mp[2] = (p3); _mp[3] = (p4); \
N	   (cinfo)->err->msg_code = (code); \
N	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
X#define TRACEMS4(cinfo,lvl,code,p1,p2,p3,p4)    MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; 	   _mp[0] = (p1); _mp[1] = (p2); _mp[2] = (p3); _mp[3] = (p4); 	   (cinfo)->err->msg_code = (code); 	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
N#define TRACEMS5(cinfo,lvl,code,p1,p2,p3,p4,p5)  \
N  MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; \
N	   _mp[0] = (p1); _mp[1] = (p2); _mp[2] = (p3); _mp[3] = (p4); \
N	   _mp[4] = (p5); \
N	   (cinfo)->err->msg_code = (code); \
N	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
X#define TRACEMS5(cinfo,lvl,code,p1,p2,p3,p4,p5)    MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; 	   _mp[0] = (p1); _mp[1] = (p2); _mp[2] = (p3); _mp[3] = (p4); 	   _mp[4] = (p5); 	   (cinfo)->err->msg_code = (code); 	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
N#define TRACEMS8(cinfo,lvl,code,p1,p2,p3,p4,p5,p6,p7,p8)  \
N  MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; \
N	   _mp[0] = (p1); _mp[1] = (p2); _mp[2] = (p3); _mp[3] = (p4); \
N	   _mp[4] = (p5); _mp[5] = (p6); _mp[6] = (p7); _mp[7] = (p8); \
N	   (cinfo)->err->msg_code = (code); \
N	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
X#define TRACEMS8(cinfo,lvl,code,p1,p2,p3,p4,p5,p6,p7,p8)    MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; 	   _mp[0] = (p1); _mp[1] = (p2); _mp[2] = (p3); _mp[3] = (p4); 	   _mp[4] = (p5); _mp[5] = (p6); _mp[6] = (p7); _mp[7] = (p8); 	   (cinfo)->err->msg_code = (code); 	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
N#define TRACEMSS(cinfo,lvl,code,str)  \
N  ((cinfo)->err->msg_code = (code), \
N   strncpy((cinfo)->err->msg_parm.s, (str), JMSG_STR_PARM_MAX), \
N   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
X#define TRACEMSS(cinfo,lvl,code,str)    ((cinfo)->err->msg_code = (code),    strncpy((cinfo)->err->msg_parm.s, (str), JMSG_STR_PARM_MAX),    (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
N
N#endif /* JERROR_H */
L 25 "..\GUI\JPEG\GUI_JPEG.c" 2
N#include "jmemsys.h"
L 1 "..\GUI\JPEG\jmemsys.h" 1
N/*
N * jmemsys.h
N *
N * Copyright (C) 1992-1997, Thomas G. Lane.
N * This file is part of the Independent JPEG Group's software.
N * For conditions of distribution and use, see the accompanying README file.
N *
N * This include file defines the interface between the system-independent
N * and system-dependent portions of the JPEG memory manager.  No other
N * modules need include it.  (The system-independent portion is jmemmgr.c;
N * there are several different versions of the system-dependent portion.)
N *
N * This file works as-is for the system-dependent memory managers supplied
N * in the IJG distribution.  You may need to modify it if you write a
N * custom memory manager.  If system-dependent changes are needed in
N * this file, the best method is to #ifdef them based on a configuration
N * symbol supplied in jconfig.h, as we have done with USE_MSDOS_MEMMGR
N * and USE_MAC_MEMMGR.
N */
N
N
N
N/*
N * These two functions are used to allocate and release small chunks of
N * memory.  (Typically the total amount requested through jpeg_get_small is
N * no more than 20K or so; this will be requested in chunks of a few K each.)
N * Behavior should be the same as for the standard library functions malloc
N * and free; in particular, jpeg_get_small must return NULL on failure.
N * On most systems, these ARE malloc and free.  jpeg_free_small is passed the
N * size of the object being freed, just in case it's needed.
N * On an 80x86 machine using small-data memory model, these manage near heap.
N */
N
NEXTERN(void *) jpeg_get_small JPP((j_common_ptr cinfo, size_t sizeofobject));
Xextern void * jpeg_get_small (j_common_ptr cinfo, size_t sizeofobject);
NEXTERN(void) jpeg_free_small JPP((j_common_ptr cinfo, void * object,
N				  size_t sizeofobject));
Xextern void jpeg_free_small (j_common_ptr cinfo, void * object, size_t sizeofobject);
N
N/*
N * These two functions are used to allocate and release large chunks of
N * memory (up to the total free space designated by jpeg_mem_available).
N * The interface is the same as above, except that on an 80x86 machine,
N * far pointers are used.  On most other machines these are identical to
N * the jpeg_get/free_small routines; but we keep them separate anyway,
N * in case a different allocation strategy is desirable for large chunks.
N */
N
NEXTERN(void FAR *) jpeg_get_large JPP((j_common_ptr cinfo,
N				       size_t sizeofobject));
Xextern void * jpeg_get_large (j_common_ptr cinfo, size_t sizeofobject);
NEXTERN(void) jpeg_free_large JPP((j_common_ptr cinfo, void FAR * object,
N				  size_t sizeofobject));
Xextern void jpeg_free_large (j_common_ptr cinfo, void * object, size_t sizeofobject);
N
N/*
N * The macro MAX_ALLOC_CHUNK designates the maximum number of bytes that may
N * be requested in a single call to jpeg_get_large (and jpeg_get_small for that
N * matter, but that case should never come into play).  This macro is needed
N * to model the 64Kb-segment-size limit of far addressing on 80x86 machines.
N * On those machines, we expect that jconfig.h will provide a proper value.
N * On machines with 32-bit flat address spaces, any large constant may be used.
N *
N * NB: jmemmgr.c expects that MAX_ALLOC_CHUNK will be representable as type
N * size_t and will be a multiple of sizeof(align_type).
N */
N
N#ifndef MAX_ALLOC_CHUNK		/* may be overridden in jconfig.h */
N#define MAX_ALLOC_CHUNK  1000000000L
N#endif
N
N/*
N * This routine computes the total space still available for allocation by
N * jpeg_get_large.  If more space than this is needed, backing store will be
N * used.  NOTE: any memory already allocated must not be counted.
N *
N * There is a minimum space requirement, corresponding to the minimum
N * feasible buffer sizes; jmemmgr.c will request that much space even if
N * jpeg_mem_available returns zero.  The maximum space needed, enough to hold
N * all working storage in memory, is also passed in case it is useful.
N * Finally, the total space already allocated is passed.  If no better
N * method is available, cinfo->mem->max_memory_to_use - already_allocated
N * is often a suitable calculation.
N *
N * It is OK for jpeg_mem_available to underestimate the space available
N * (that'll just lead to more backing-store access than is really necessary).
N * However, an overestimate will lead to failure.  Hence it's wise to subtract
N * a slop factor from the true available space.  5% should be enough.
N *
N * On machines with lots of virtual memory, any large constant may be returned.
N * Conversely, zero may be returned to always use the minimum amount of memory.
N */
N
NEXTERN(long) jpeg_mem_available JPP((j_common_ptr cinfo,
N				     long min_bytes_needed,
N				     long max_bytes_needed,
N				     long already_allocated));
Xextern long jpeg_mem_available (j_common_ptr cinfo, long min_bytes_needed, long max_bytes_needed, long already_allocated);
N
N
N/*
N * This structure holds whatever state is needed to access a single
N * backing-store object.  The read/write/close method pointers are called
N * by jmemmgr.c to manipulate the backing-store object; all other fields
N * are private to the system-dependent backing store routines.
N */
N
N#define TEMP_NAME_LENGTH   64	/* max length of a temporary file's name */
N
N
N#ifdef USE_MSDOS_MEMMGR		/* DOS-specific junk */
S
Stypedef unsigned short XMSH;	/* type of extended-memory handles */
Stypedef unsigned short EMSH;	/* type of expanded-memory handles */
S
Stypedef union {
S  short file_handle;		/* DOS file handle if it's a temp file */
S  XMSH xms_handle;		/* handle if it's a chunk of XMS */
S  EMSH ems_handle;		/* handle if it's a chunk of EMS */
S} handle_union;
S
N#endif /* USE_MSDOS_MEMMGR */
N
N#ifdef USE_MAC_MEMMGR		/* Mac-specific junk */
S#include <Files.h>
N#endif /* USE_MAC_MEMMGR */
N
N
Ntypedef struct backing_store_struct * backing_store_ptr;
N
Ntypedef struct backing_store_struct {
N  /* Methods for reading/writing/closing this backing-store object */
N  JMETHOD(void, read_backing_store,  (j_common_ptr cinfo, backing_store_ptr info, void FAR * buffer_address, long file_offset, long byte_count));
X  void (*read_backing_store) (j_common_ptr cinfo, backing_store_ptr info, void * buffer_address, long file_offset, long byte_count);
N  JMETHOD(void, write_backing_store, (j_common_ptr cinfo, backing_store_ptr info, void FAR * buffer_address, long file_offset, long byte_count));
X  void (*write_backing_store) (j_common_ptr cinfo, backing_store_ptr info, void * buffer_address, long file_offset, long byte_count);
N  JMETHOD(void, close_backing_store, (j_common_ptr cinfo, backing_store_ptr info));
X  void (*close_backing_store) (j_common_ptr cinfo, backing_store_ptr info);
N
N  /* Private fields for system-dependent backing-store management */
N#ifdef USE_MSDOS_MEMMGR
S  /* For the MS-DOS manager (jmemdos.c), we need: */
S  handle_union handle;		/* reference to backing-store storage object */
S  char temp_name[TEMP_NAME_LENGTH]; /* name if it's a file */
N#else
N#ifdef USE_MAC_MEMMGR
S  /* For the Mac manager (jmemmac.c), we need: */
S  short temp_file;		/* file reference number to temp file */
S  FSSpec tempSpec;		/* the FSSpec for the temp file */
S  char temp_name[TEMP_NAME_LENGTH]; /* name if it's a file */
N#else
N  /* For a typical implementation with temp files, we need: */
N /*  FILE * temp_file;	*/	/* stdio reference to temp file */
N  char temp_name[TEMP_NAME_LENGTH]; /* name of temp file */
X  char temp_name[64];  
N#endif
N#endif
N} backing_store_info;
N
N
N/*
N * Initial opening of a backing-store object.  This must fill in the
N * read/write/close pointers in the object.  The read/write routines
N * may take an error exit if the specified maximum file size is exceeded.
N * (If jpeg_mem_available always returns a large value, this routine can
N * just take an error exit.)
N */
N
NEXTERN(void) jpeg_open_backing_store JPP((j_common_ptr cinfo,
N					  backing_store_ptr info,
N					  long total_bytes_needed));
Xextern void jpeg_open_backing_store (j_common_ptr cinfo, backing_store_ptr info, long total_bytes_needed);
N
N
N/*
N * These routines take care of any system-dependent initialization and
N * cleanup required.  jpeg_mem_init will be called before anything is
N * allocated (and, therefore, nothing in cinfo is of use except the error
N * manager pointer).  It should return a suitable default value for
N * max_memory_to_use; this may subsequently be overridden by the surrounding
N * application.  (Note that max_memory_to_use is only important if
N * jpeg_mem_available chooses to consult it ... no one else will.)
N * jpeg_mem_term may assume that all requested memory has been freed and that
N * all opened backing-store objects have been closed.
N */
N
NEXTERN(long) jpeg_mem_init JPP((j_common_ptr cinfo));
Xextern long jpeg_mem_init (j_common_ptr cinfo);
NEXTERN(void) jpeg_mem_term JPP((j_common_ptr cinfo));
Xextern void jpeg_mem_term (j_common_ptr cinfo);
L 26 "..\GUI\JPEG\GUI_JPEG.c" 2
N
N
N/*********************************************************************
N*
N*       Local defines & data types
N*
N**********************************************************************
N*/
N#define INPUT_BUF_SIZE  4096	/* choose an efficiently fread'able size */
N
N/* Expanded data source object for stdio input */
N
Ntypedef struct {
N  struct jpeg_source_mgr pub;	/* public fields */
N  const U8* pFileData;
X  const unsigned char* pFileData;
N  I32   FileSize;
X  signed long   FileSize;
N  I32   Off;
X  signed long   Off;
N  boolean start_of_file;	/* have we gotten any data yet? */
N} SOURCE_MANAGER;
N
Nstatic const U8 _abEnd[2] = {
Xstatic const unsigned char _abEnd[2] = {
N    0xFF, JPEG_EOI
X    0xFF, 0xD9
N};
N
N/*********************************************************************
N*
N*       Static code
N*
N**********************************************************************
N*/
N
N/*
N * Initialize source --- called by jpeg_read_header
N * before any data is actually read.
N */
N
Nstatic void _InitSource (j_decompress_ptr cinfo) {
N  SOURCE_MANAGER* pSrc = (SOURCE_MANAGER*) cinfo->src;
N
N  /* We reset the empty-input-file flag for each image,
N   * but we don't clear the input buffer.
N   * This is correct behavior for reading a series of images from one source.
N   */
N  pSrc->start_of_file = TRUE;
X  pSrc->start_of_file = 1;
N}
N
N/*
N * Fill the input buffer --- called whenever buffer is emptied.
N *
N * In typical applications, this should read fresh data into the buffer
N * (ignoring the current state of next_input_byte & bytes_in_buffer),
N * reset the pointer & count to the start of the buffer, and return TRUE
N * indicating that the buffer has been reloaded.  It is not necessary to
N * fill the buffer entirely, only to obtain at least one more byte.
N *
N * There is no such thing as an EOF return.  If the end of the file has been
N * reached, the routine has a choice of ERREXIT() or inserting fake data into
N * the buffer.  In most cases, generating a warning message and inserting a
N * fake EOI marker is the best course of action --- this will allow the
N * decompressor to output however much of the image is there.  However,
N * the resulting error message is misleading if the real problem is an empty
N * input file, so we handle that case specially.
N *
N * In applications that need to be able to suspend compression due to input
N * not being available yet, a FALSE return indicates that no more data can be
N * obtained right now, but more may be forthcoming later.  In this situation,
N * the decompressor will return to its caller (with an indication of the
N * number of scanlines it has read, if any).  The application should resume
N * decompression after it has loaded more data into the input buffer.  Note
N * that there are substantial restrictions on the use of suspension --- see
N * the documentation.
N *
N * When suspending, the decompressor will back up to a convenient restart point
N * (typically the start of the current MCU). next_input_byte & bytes_in_buffer
N * indicate where the restart point will be if the current call returns FALSE.
N * Data beyond this point must be rescanned after resumption, so move it to
N * the front of the buffer rather than discarding it.
N */
N
Nstatic boolean _FillInputBuffer(j_decompress_ptr cinfo) {
N  SOURCE_MANAGER* pSrc = (SOURCE_MANAGER*) cinfo->src;
N  size_t nbytes;
N  int RemBytes = pSrc->FileSize - pSrc->Off;
N  if (RemBytes > 0) {
N    nbytes = (RemBytes > INPUT_BUF_SIZE) ? INPUT_BUF_SIZE : RemBytes;
X    nbytes = (RemBytes > 4096) ? 4096 : RemBytes;
N    pSrc->pub.next_input_byte = pSrc->pFileData + pSrc->Off;
N    pSrc->Off += nbytes;
N  } else {
N    if (pSrc->start_of_file)	/* Treat empty input file as fatal error */
N      ERREXIT(cinfo, JERR_INPUT_EMPTY);
X      ((cinfo)->err->msg_code = (JERR_INPUT_EMPTY), (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)));
N    WARNMS(cinfo, JWRN_JPEG_EOF);
X    ((cinfo)->err->msg_code = (JWRN_JPEG_EOF), (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), -1));
N    /* Insert a fake EOI marker */
N    nbytes = 2;
N    pSrc->pub.next_input_byte = _abEnd;
N  }
N
N  pSrc->pub.bytes_in_buffer = nbytes;
N  pSrc->start_of_file = FALSE;
X  pSrc->start_of_file = 0;
N  return TRUE;
X  return 1;
N}
N
N/*
N * Skip data --- used to skip over a potentially large amount of
N * uninteresting data (such as an APPn marker).
N *
N * Writers of suspendable-input applications must note that skip_input_data
N * is not granted the right to give a suspension return.  If the skip extends
N * beyond the data currently in the buffer, the buffer can be marked empty so
N * that the next read will cause a fill_input_buffer call that can suspend.
N * Arranging for additional bytes to be discarded before reloading the input
N * buffer is the application writer's problem.
N */
N
Nstatic void _SkipInputData (j_decompress_ptr cinfo, long num_bytes) {
N  SOURCE_MANAGER* pSrc = (SOURCE_MANAGER*) cinfo->src;
N  /* Just a dumb implementation for now.  Could use fseek() except
N   * it doesn't work on pipes.  Not clear that being smart is worth
N   * any trouble anyway --- large skips are infrequent.
N   */
N  if (num_bytes > 0) {
N    while (num_bytes > (long) pSrc->pub.bytes_in_buffer) {
N      num_bytes -= (long) pSrc->pub.bytes_in_buffer;
N      (void) _FillInputBuffer(cinfo);
N      /* note we assume that fill_input_buffer will never return FALSE,
N       * so suspension need not be handled.
N       */
N    }
N    pSrc->pub.next_input_byte += (size_t) num_bytes;
N    pSrc->pub.bytes_in_buffer -= (size_t) num_bytes;
N  }
N}
N/*
N * An additional method that can be provided by data source modules is the
N * resync_to_restart method for error recovery in the presence of RST markers.
N * For the moment, this source module just uses the default resync method
N * provided by the JPEG library.  That method assumes that no backtracking
N * is possible.
N */
N
N
N/*
N * Terminate source --- called by jpeg_finish_decompress
N * after all data has been read.  Often a no-op.
N *
N * NB: *not* called by jpeg_abort or jpeg_destroy; surrounding
N * application must deal with any cleanup that should happen even
N * for error exit.
N */
N
Nstatic void _TermSource(j_decompress_ptr cinfo) {
N  /* no work necessary here */
N  GUI_USE_PARA(cinfo);
X  cinfo=cinfo;;
N}
N
N
Nstatic void _InitSrc(j_decompress_ptr cinfo, const U8* pFileData, I32 FileSize) {
Xstatic void _InitSrc(j_decompress_ptr cinfo, const unsigned char* pFileData, signed long FileSize) {
N  SOURCE_MANAGER* pSrc;
N  /* The source object and input buffer are made permanent so that a series
N   * of JPEG images can be read from the same file by calling jpeg_stdio_src
N   * only before the first one.  (If we discarded the buffer at the end of
N   * one image, we'd likely lose the start of the next one.)
N   * This makes it unsafe to use this manager and a different source
N   * manager serially with the same JPEG object.  Caveat programmer.
N   */
N  if (cinfo->src == NULL) {	/* first time for this JPEG object? */
X  if (cinfo->src == 0) {	 
N    cinfo->src = (jpeg_source_mgr *) (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT, sizeof(SOURCE_MANAGER));
X    cinfo->src = (jpeg_source_mgr *) (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, 0, sizeof(SOURCE_MANAGER));
N  }
N  pSrc = (SOURCE_MANAGER*) cinfo->src;
N  pSrc->pub.init_source       = _InitSource;
N  pSrc->pub.fill_input_buffer = _FillInputBuffer;
N  pSrc->pub.skip_input_data   = _SkipInputData;
N  pSrc->pub.resync_to_restart = jpeg_resync_to_restart; /* use default method */
N  pSrc->pub.term_source       = _TermSource;
N  pSrc->pub.bytes_in_buffer   = 0;    /* forces fill_input_buffer on first read */
N  pSrc->pub.next_input_byte   = NULL; /* until buffer loaded */
X  pSrc->pub.next_input_byte   = 0;  
N  /*
N   *  Init private part of Source manager
N   */
N  pSrc->FileSize  = FileSize;
N  pSrc->pFileData = pFileData;
N  pSrc->Off       = 0;
N}
N
N
N/*********************************************************************
N*
N*       Memory allocation
N*
N**********************************************************************
N*/
N
Nint AllocCnt;   /* for debugging only */
Nint TotalSize;
N/*
N * Memory allocation and freeing are controlled by the regular library
N * routines malloc() and free().
N */
N
NGLOBAL(void *) jpeg_get_small (j_common_ptr cinfo, size_t sizeofobject) {
Xvoid * jpeg_get_small (j_common_ptr cinfo, size_t sizeofobject) {
N  GUI_USE_PARA(cinfo);
X  cinfo=cinfo;;
N  AllocCnt++;
N  TotalSize += sizeofobject;
N  return (void *) malloc(sizeofobject);
N}
N
NGLOBAL(void) jpeg_free_small (j_common_ptr cinfo, void * object, size_t sizeofobject) {
Xvoid jpeg_free_small (j_common_ptr cinfo, void * object, size_t sizeofobject) {
N  GUI_USE_PARA(cinfo);
X  cinfo=cinfo;;
N  GUI_USE_PARA(sizeofobject);
X  sizeofobject=sizeofobject;;
N  if (--AllocCnt) {
N    TotalSize = 0;
N  }
N  free(object);
N}
N
N/*
N * This routine computes the total memory space available for allocation.
N * Here we always say, "we got all you want bud!"
N */
N
NGLOBAL(long) jpeg_mem_available (j_common_ptr cinfo, long min_bytes_needed, long max_bytes_needed, long already_allocated) {
Xlong jpeg_mem_available (j_common_ptr cinfo, long min_bytes_needed, long max_bytes_needed, long already_allocated) {
N  GUI_USE_PARA(cinfo);
X  cinfo=cinfo;;
N  GUI_USE_PARA(min_bytes_needed);
X  min_bytes_needed=min_bytes_needed;;
N  GUI_USE_PARA(already_allocated);
X  already_allocated=already_allocated;;
N  return max_bytes_needed;
N}
N
N
N/*
N * These routines take care of any system-dependent initialization and
N * cleanup required.  Here, there isn't any.
N * just set max_memory_to_use to 0
N */
N
NGLOBAL(long) jpeg_mem_init (j_common_ptr cinfo) { 
Xlong jpeg_mem_init (j_common_ptr cinfo) { 
N  GUI_USE_PARA(cinfo);
X  cinfo=cinfo;;
N  return 0;
N}
N
NGLOBAL(void) jpeg_mem_term (j_common_ptr cinfo) {
Xvoid jpeg_mem_term (j_common_ptr cinfo) {
N  GUI_USE_PARA(cinfo);
X  cinfo=cinfo;;
N}
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N
N/*********************************************************************
N*
N*       _Init
N*/
Nstatic void _Init(struct jpeg_error_mgr* pjerr, struct jpeg_decompress_struct *pcinfo, const void * pFileData, int DataSize) {
N  /* 1. Allocate and initialize a JPEG decompression object. */
N  pcinfo->err = jpeg_std_error(pjerr);
N	jpeg_create_decompress(pcinfo);
X	jpeg_CreateDecompress((pcinfo), 62, (size_t) sizeof(struct jpeg_decompress_struct));
N  /* 2. Init the source manager so the library can retrieve data via methods */
N  _InitSrc(pcinfo, (const U8*)pFileData, DataSize);
X  _InitSrc(pcinfo, (const unsigned char*)pFileData, DataSize);
N  /* 3. Call jpeg_read_header() to obtain image info. */
N	jpeg_read_header(pcinfo, TRUE);
X	jpeg_read_header(pcinfo, 1);
N}
N
N/*********************************************************************
N*
N*       _WritePixelsRGB
N*/
Nstatic void _WritePixelsRGB(const U8*p, int x0, int y0, int xSize) {
Xstatic void _WritePixelsRGB(const unsigned char*p, int x0, int y0, int xSize) {
N  U8 r,g,b;
X  unsigned char r,g,b;
N  while (xSize) {
N    r = *p++;
N    g = *p++;
N    b = *p++;
N    LCD_SetColor(r | (g << 8) | (U32)((U32)b << 16));
X    LCD_SetColor(r | (g << 8) | (unsigned long)((unsigned long)b << 16));
N    LCD_DrawPixel(x0++, y0);
N    xSize--;
N  }
N}
N
N/*********************************************************************
N*
N*       _WritePixelsGray
N*/
Nstatic void _WritePixelsGray(const U8*p, int x0, int y0, int xSize) {
Xstatic void _WritePixelsGray(const unsigned char*p, int x0, int y0, int xSize) {
N  U8 u;
X  unsigned char u;
N  while (xSize) {
N    u = *p++;
N    LCD_SetColor(u * (U32)0x10101);
X    LCD_SetColor(u * (unsigned long)0x10101);
N    LCD_DrawPixel(x0++, y0);
N    xSize--;
N  }
N}
N
N/*********************************************************************
N*
N*       Public code
N*
N**********************************************************************
N*/
N/*********************************************************************
N*
N*       GUI_JPEG_GetInfo
N*/
Nint GUI_JPEG_GetInfo(const void * pFileData, int DataSize, GUI_JPEG_INFO* pInfo) {
N	struct jpeg_decompress_struct cinfo;
N	struct jpeg_error_mgr jerr;
N  _Init(&jerr, &cinfo, pFileData, DataSize);
N  /*
N   * Release the JPEG decompression object.
N   */
N  jpeg_destroy_decompress(&cinfo);
N  if (pInfo) {
N    pInfo->XSize = cinfo.image_width;
N    pInfo->YSize = cinfo.image_height;
N  }
N  return 0;
N}
N
N
N/*********************************************************************
N*
N*       GUI_JPEG_Draw
N*/
Nint GUI_JPEG_Draw(const void * pFileData, int DataSize, int x0, int y0) {
N  #if (GUI_WINSUPPORT)
X  #if (1)
N    GUI_RECT r;
N  #endif
N  int Ret = 0;
N  GUI_HMEM hBuffer = 0;
X  signed short hBuffer = 0;
N	struct jpeg_decompress_struct cinfo;
N	struct jpeg_error_mgr jerr;
N  GUI_LOCK();
X  ;
N  _Init(&jerr, &cinfo, pFileData, DataSize);
N  #if (GUI_WINSUPPORT)
X  #if (1)
N    WM_ADDORG(x0,y0);
X    x0 += GUI_Context . xOff; y0 += GUI_Context . yOff;
N    r.x1 = (r.x0 = x0) + cinfo.image_width - 1;
N    r.y1 = (r.y0 = y0) + cinfo.image_height - 1;
N    WM_ITERATE_START(&r) {
X    { if (WM__InitIVRSearch(&r)) do { {
N  #endif
N    if (hBuffer) {
N      _Init(&jerr, &cinfo, pFileData, DataSize);
N    }
N    /* 4. Set up parameters for decompression (optional ...) */
N    /* 5. jpeg_start_decompress(...); Should normally return quickly */
N	  jpeg_start_decompress(&cinfo);
N    /* 6. while (scan lines remain to be read) */
N	  /*     jpeg_read_scanlines(...); */
N    if (!hBuffer) {
N      hBuffer = GUI_ALLOC_AllocNoInit(cinfo.image_width * 3);
N    }
N    while (cinfo.output_scanline < cinfo.output_height) {
N      U8* p;
X      unsigned char* p;
N      p = (U8*)GUI_ALLOC_h2p(hBuffer);
X      p = (unsigned char*)GUI_ALLOC_h2p(hBuffer);
N      jpeg_read_scanlines(&cinfo, &p, 1);
N      if (cinfo.jpeg_color_space == JCS_GRAYSCALE) {
N        _WritePixelsGray(p, x0, y0 + cinfo.output_scanline, cinfo.image_width);
N      } else {
N        _WritePixelsRGB(p, x0, y0 + cinfo.output_scanline, cinfo.image_width);
N      }
N    }
N    /* 7. jpeg_finish_decompress(...); */
N    /*    Complete the decompression cycle.  This causes working memory associated */
N    /*    with the JPEG object to be released. */
N	  jpeg_finish_decompress(&cinfo);
N    /* 8. Release the JPEG decompression object. */
N    jpeg_destroy_decompress(&cinfo);
N  #if (GUI_WINSUPPORT)
X  #if (1)
N    } WM_ITERATE_END();
X    } } while (WM__GetNextIVR()); };
N  #endif
N  GUI_ALLOC_Free(hBuffer);
N  GUI_UNLOCK();
X  ;
N  return Ret;
N}
N
N/*************************** End of file ****************************/
N
N
