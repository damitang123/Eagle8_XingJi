; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\wm.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\wm.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\WM\WM.c]
                          THUMB

                          AREA ||i.WM_Activate||, CODE, READONLY, ALIGN=2

                  WM_Activate PROC
;;;1730   */
;;;1731   void WM_Activate(void) {
000000  4901              LDR      r1,|L1.8|
;;;1732     WM_IsActive = 1;       /* Running */
000002  2001              MOVS     r0,#1
000004  7048              STRB     r0,[r1,#1]
;;;1733   }
000006  4770              BX       lr
;;;1734   
                          ENDP

                  |L1.8|
                          DCD      ||.data||

                          AREA ||i.WM_CreateWindow||, CODE, READONLY, ALIGN=1

                  WM_CreateWindow PROC
;;;928    */
;;;929    WM_HWIN WM_CreateWindow(int x0, int y0, int width, int height, U16 Style, WM_CALLBACK* cb, int NumExtraBytes) {
000000  e92d41ff          PUSH     {r0-r8,lr}
000004  af0a              ADD      r7,sp,#0x28
;;;930      return WM_CreateWindowAsChild(x0,y0,width,height, 0 /* No parent */,  Style, cb, NumExtraBytes);
000006  f10d0804          ADD      r8,sp,#4
00000a  e8970070          LDM      r7,{r4-r6}            ;929
00000e  2700              MOVS     r7,#0
000010  9700              STR      r7,[sp,#0]
000012  e8880070          STM      r8,{r4-r6}
000016  f7fffffe          BL       WM_CreateWindowAsChild
;;;931    }
00001a  b004              ADD      sp,sp,#0x10
00001c  e8bd81f0          POP      {r4-r8,pc}
;;;932    
                          ENDP


                          AREA ||i.WM_CreateWindowAsChild||, CODE, READONLY, ALIGN=2

                  WM_CreateWindowAsChild PROC
;;;843    */
;;;844    WM_HWIN WM_CreateWindowAsChild( int x0, int y0, int width, int height
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;845                                   ,WM_HWIN hParent, U16 Style, WM_CALLBACK* cb
;;;846                                   ,int NumExtraBytes) {
;;;847      WM_Obj* pWin;
;;;848      WM_HWIN hWin;
;;;849      WM_ASSERT_NOT_IN_PAINT();
;;;850      WM_LOCK();
;;;851      Style |= WM__CreateFlags;
000004  4c46              LDR      r4,|L3.288|
000006  4680              MOV      r8,r0                 ;846
000008  e9dd650a          LDRD     r6,r5,[sp,#0x28]      ;846
00000c  89a0              LDRH     r0,[r4,#0xc]  ; WM__CreateFlags
00000e  f8ddb034          LDR      r11,[sp,#0x34]        ;846
000012  4699              MOV      r9,r3                 ;846
000014  4692              MOV      r10,r2                ;846
000016  460f              MOV      r7,r1                 ;846
000018  4305              ORRS     r5,r5,r0
00001a  b92e              CBNZ     r6,|L3.40|
;;;852      /* Default parent is Desktop 0 */
;;;853      if (!hParent) {
;;;854        if (WM__NumWindows) {
00001c  88a0              LDRH     r0,[r4,#4]  ; WM__NumWindows
00001e  b310              CBZ      r0,|L3.102|
;;;855        #if GUI_NUM_LAYERS == 1
;;;856          hParent = WM__ahDesktopWin[0];
000020  f104000a          ADD      r0,r4,#0xa
000024  f9b06000          LDRSH    r6,[r0,#0]  ; WM__ahDesktopWin
                  |L3.40|
;;;857        #else
;;;858          hParent = WM__ahDesktopWin[GUI_Context.SelLayer];
;;;859        #endif
;;;860        }
;;;861      }
;;;862      if (hParent == WM_UNATTACHED) {
000028  1c70              ADDS     r0,r6,#1
00002a  d00d              BEQ      |L3.72|
;;;863        hParent = WM_HWIN_NULL;
;;;864      }  
;;;865      if (hParent) {
00002c  b1de              CBZ      r6,|L3.102|
;;;866        WM_Obj* pParent = WM_H2P(hParent);
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       GUI_ALLOC_h2p
;;;867        x0 += pParent->Rect.x0;
000034  f9b02000          LDRSH    r2,[r0,#0]
;;;868        y0 += pParent->Rect.y0;
000038  f9b01002          LDRSH    r1,[r0,#2]
00003c  4490              ADD      r8,r8,r2              ;867
00003e  440f              ADD      r7,r7,r1
;;;869        if (width==0) {
000040  f1ba0f00          CMP      r10,#0
000044  d002              BEQ      |L3.76|
000046  e006              B        |L3.86|
                  |L3.72|
000048  2600              MOVS     r6,#0                 ;863
00004a  e00c              B        |L3.102|
                  |L3.76|
;;;870          width = pParent->Rect.x1 - pParent->Rect.x0+1;
00004c  f9b03004          LDRSH    r3,[r0,#4]
000050  1a9a              SUBS     r2,r3,r2
000052  f1020a01          ADD      r10,r2,#1
                  |L3.86|
;;;871        }
;;;872        if (height==0) {
000056  f1b90f00          CMP      r9,#0
00005a  d104              BNE      |L3.102|
;;;873          height = pParent->Rect.y1 - pParent->Rect.y0+1;
00005c  f9b00006          LDRSH    r0,[r0,#6]
000060  1a40              SUBS     r0,r0,r1
000062  f1000901          ADD      r9,r0,#1
                  |L3.102|
;;;874        }
;;;875      }
;;;876      if ((hWin = (WM_HWIN) GUI_ALLOC_AllocZero(NumExtraBytes + sizeof(WM_Obj))) == 0) {
000066  f10b0020          ADD      r0,r11,#0x20
00006a  b200              SXTH     r0,r0
00006c  f7fffffe          BL       GUI_ALLOC_AllocZero
000070  9000              STR      r0,[sp,#0]
000072  b3e0              CBZ      r0,|L3.238|
;;;877        GUI_DEBUG_ERROROUT("WM_CreateWindow: No memory to create window");
;;;878      } else {
;;;879        WM__NumWindows++;
000074  88a0              LDRH     r0,[r4,#4]  ; WM__NumWindows
000076  46a3              MOV      r11,r4
000078  1c40              ADDS     r0,r0,#1
00007a  80a0              STRH     r0,[r4,#4]
;;;880        pWin = WM_H2P(hWin);
00007c  9800              LDR      r0,[sp,#0]
00007e  f7fffffe          BL       GUI_ALLOC_h2p
;;;881        pWin->Rect.x0 = x0;
000082  f8a08000          STRH     r8,[r0,#0]
;;;882        pWin->Rect.y0 = y0;
;;;883        pWin->Rect.x1 = x0 + width - 1;
000086  eb08010a          ADD      r1,r8,r10
00008a  8047              STRH     r7,[r0,#2]            ;882
00008c  1e49              SUBS     r1,r1,#1
00008e  8081              STRH     r1,[r0,#4]
;;;884        pWin->Rect.y1 = y0 + height - 1;
000090  eb070109          ADD      r1,r7,r9
000094  1e49              SUBS     r1,r1,#1
000096  80c1              STRH     r1,[r0,#6]
;;;885        pWin->cb = cb;
000098  990c              LDR      r1,[sp,#0x30]
;;;886        /* Copy the flags which can simply be accepted */
;;;887        pWin->Status |= (Style & (WM_CF_SHOW |
00009a  6101              STR      r1,[r0,#0x10]
00009c  4604              MOV      r4,r0                 ;880
00009e  8b81              LDRH     r1,[r0,#0x1c]
0000a0  f643709f          MOV      r0,#0x3f9f
0000a4  4028              ANDS     r0,r0,r5
0000a6  4301              ORRS     r1,r1,r0
0000a8  83a1              STRH     r1,[r4,#0x1c]
0000aa  f9bb0008          LDRSH    r0,[r11,#8]  ; WM__FirstWin
0000ae  9f00              LDR      r7,[sp,#0]
0000b0  b160              CBZ      r0,|L3.204|
0000b2  f7fffffe          BL       GUI_ALLOC_h2p
0000b6  4680              MOV      r8,r0
0000b8  4638              MOV      r0,r7
0000ba  f7fffffe          BL       GUI_ALLOC_h2p
0000be  4601              MOV      r1,r0
0000c0  f8b80014          LDRH     r0,[r8,#0x14]
0000c4  8288              STRH     r0,[r1,#0x14]
0000c6  f8a87014          STRH     r7,[r8,#0x14]
0000ca  e001              B        |L3.208|
                  |L3.204|
0000cc  f8ab7008          STRH     r7,[r11,#8]
                  |L3.208|
;;;888                                  WM_SF_MEMDEV |
;;;889                                  WM_CF_MEMDEV_ON_REDRAW |
;;;890                                  WM_SF_STAYONTOP |
;;;891                                  WM_CF_DISABLED |
;;;892                                  WM_SF_CONST_OUTLINE |
;;;893                                  WM_SF_HASTRANS |
;;;894                                  WM_CF_ANCHOR_RIGHT |
;;;895                                  WM_CF_ANCHOR_BOTTOM |
;;;896                                  WM_CF_ANCHOR_LEFT |
;;;897                                  WM_CF_ANCHOR_TOP |
;;;898                                  WM_CF_LATE_CLIP));
;;;899        /* Add to linked lists */
;;;900        _AddToLinList(hWin);
;;;901        WM__InsertWindowIntoList(hWin, hParent);
0000d0  4631              MOV      r1,r6
0000d2  9800              LDR      r0,[sp,#0]
0000d4  f7fffffe          BL       WM__InsertWindowIntoList
;;;902        /* Activate window if WM_CF_ACTIVATE is specified */
;;;903        if (Style & WM_CF_ACTIVATE) {
0000d8  06a8              LSLS     r0,r5,#26
0000da  d502              BPL      |L3.226|
;;;904          WM_SelectWindow(hWin);  /* This is not needed if callbacks are being used, but it does not cost a lot and makes life easier ... */
0000dc  9800              LDR      r0,[sp,#0]
0000de  f7fffffe          BL       WM_SelectWindow
                  |L3.226|
;;;905        }
;;;906        /* Handle the Style flags, one at a time */
;;;907        #if WM_SUPPORT_TRANSPARENCY
;;;908          if (Style & WM_SF_HASTRANS) {
0000e2  07e8              LSLS     r0,r5,#31
0000e4  d006              BEQ      |L3.244|
;;;909            WM__TransWindowCnt++;          /* Increment counter for transparency windows */
0000e6  f8db1024          LDR      r1,[r11,#0x24]  ; WM__TransWindowCnt
0000ea  1c49              ADDS     r1,r1,#1
0000ec  e000              B        |L3.240|
                  |L3.238|
0000ee  e013              B        |L3.280|
                  |L3.240|
0000f0  f8cb1024          STR      r1,[r11,#0x24]  ; WM__TransWindowCnt
                  |L3.244|
;;;910          }
;;;911        #endif
;;;912        if (Style & WM_CF_BGND) {
0000f4  0668              LSLS     r0,r5,#25
0000f6  d502              BPL      |L3.254|
;;;913          WM_BringToBottom(hWin);
0000f8  9800              LDR      r0,[sp,#0]
0000fa  f7fffffe          BL       WM_BringToBottom
                  |L3.254|
;;;914        }
;;;915        if (Style & WM_CF_SHOW) {
0000fe  07a8              LSLS     r0,r5,#30
000100  d506              BPL      |L3.272|
;;;916          pWin->Status |= WM_SF_ISVIS;  /* Set Visibility flag */
000102  8ba0              LDRH     r0,[r4,#0x1c]
000104  f0400002          ORR      r0,r0,#2
000108  83a0              STRH     r0,[r4,#0x1c]
;;;917          WM_InvalidateWindow(hWin);    /* Mark content as invalid */
00010a  9800              LDR      r0,[sp,#0]
00010c  f7fffffe          BL       WM_InvalidateWindow
                  |L3.272|
;;;918        }
;;;919        WM__SendMsgNoData(hWin, WM_CREATE);
000110  2101              MOVS     r1,#1
000112  9800              LDR      r0,[sp,#0]
000114  f7fffffe          BL       WM__SendMsgNoData
                  |L3.280|
;;;920      }
;;;921      WM_UNLOCK();
;;;922      return hWin;
000118  9800              LDR      r0,[sp,#0]
;;;923    }
00011a  e8bd8ff8          POP      {r3-r11,pc}
;;;924    
                          ENDP

00011e  0000              DCW      0x0000
                  |L3.288|
                          DCD      ||.data||

                          AREA ||i.WM_Deactivate||, CODE, READONLY, ALIGN=2

                  WM_Deactivate PROC
;;;1738   */
;;;1739   void WM_Deactivate(void) {
000000  4902              LDR      r1,|L4.12|
;;;1740     WM_IsActive = 0;       /* No clipping performed by WM */
000002  2000              MOVS     r0,#0
000004  7048              STRB     r0,[r1,#1]
;;;1741     WM_LOCK();
;;;1742     LCD_SetClipRectMax();
000006  f7ffbffe          B.W      LCD_SetClipRectMax
;;;1743     WM_UNLOCK();
;;;1744   }
;;;1745   
                          ENDP

00000a  0000              DCW      0x0000
                  |L4.12|
                          DCD      ||.data||

                          AREA ||i.WM_DefaultProc||, CODE, READONLY, ALIGN=1

                  WM_DefaultProc PROC
;;;1755   */
;;;1756   void WM_DefaultProc(WM_MESSAGE* pMsg) {
000000  b570              PUSH     {r4-r6,lr}
;;;1757     WM_HWIN hWin = pMsg->hWin;
000002  f9b05004          LDRSH    r5,[r0,#4]
000006  4604              MOV      r4,r0                 ;1756
;;;1758     const void *p = pMsg->Data.p;
;;;1759     WM_Obj* pWin = WM_H2P(hWin);
000008  6886              LDR      r6,[r0,#8]
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       GUI_ALLOC_h2p
;;;1760     /* Exec message */
;;;1761     switch (pMsg->MsgId) {
000010  6821              LDR      r1,[r4,#0]
000012  2917              CMP      r1,#0x17
000014  d010              BEQ      |L5.56|
000016  dc04              BGT      |L5.34|
000018  290e              CMP      r1,#0xe
00001a  d00f              BEQ      |L5.60|
00001c  2914              CMP      r1,#0x14
00001e  d108              BNE      |L5.50|
000020  e004              B        |L5.44|
                  |L5.34|
000022  2922              CMP      r1,#0x22
000024  d010              BEQ      |L5.72|
000026  2928              CMP      r1,#0x28
000028  d103              BNE      |L5.50|
00002a  e010              B        |L5.78|
                  |L5.44|
;;;1762     case WM_GET_INSIDE_RECT:      /* return client window in absolute (screen) coordinates */
;;;1763       WM__GetClientRectWin(pWin, (GUI_RECT*)p);
00002c  4631              MOV      r1,r6
00002e  f7fffffe          BL       WM__GetClientRectWin
                  |L5.50|
;;;1764       break;
;;;1765     case WM_GET_CLIENT_WINDOW:      /* return handle to client window. For most windows, there is no seperate client window, so it is the same handle */
;;;1766       pMsg->Data.v = (int)hWin;
;;;1767       return;                       /* Message handled */
;;;1768     case WM_KEY:
;;;1769       WM_SendToParent(hWin, pMsg);
;;;1770       return;                       /* Message handled */
;;;1771      case WM_GET_BKCOLOR:
;;;1772       pMsg->Data.Color = GUI_INVALID_COLOR;
;;;1773       return;                       /* Message handled */
;;;1774     case WM_NOTIFY_ENABLE:
;;;1775       WM_InvalidateWindow(hWin);    
;;;1776       return;                       /* Message handled */
;;;1777     }
;;;1778     /* Message not handled. If it queries something, we return 0 to be on the safe side. */
;;;1779     pMsg->Data.v = 0;
000032  2000              MOVS     r0,#0
                  |L5.52|
000034  60a0              STR      r0,[r4,#8]
;;;1780     pMsg->Data.p = 0;
;;;1781   }
000036  bd70              POP      {r4-r6,pc}
                  |L5.56|
000038  60a5              STR      r5,[r4,#8]            ;1767
00003a  bd70              POP      {r4-r6,pc}
                  |L5.60|
00003c  4621              MOV      r1,r4                 ;1769
00003e  4628              MOV      r0,r5                 ;1769
000040  e8bd4070          POP      {r4-r6,lr}            ;1769
000044  f7ffbffe          B.W      WM_SendToParent
                  |L5.72|
000048  f06f4070          MVN      r0,#0xf0000000        ;1772
00004c  e7f2              B        |L5.52|
                  |L5.78|
00004e  4628              MOV      r0,r5                 ;1775
000050  e8bd4070          POP      {r4-r6,lr}            ;1775
000054  f7ffbffe          B.W      WM_InvalidateWindow
;;;1782   
                          ENDP


                          AREA ||i.WM_DeleteWindow||, CODE, READONLY, ALIGN=2

                  WM_DeleteWindow PROC
;;;942    */
;;;943    void WM_DeleteWindow (WM_HWIN hWin) {
000000  b570              PUSH     {r4-r6,lr}
000002  0005              MOVS     r5,r0
000004  d046              BEQ      |L6.148|
;;;944      WM_Obj* pWin;
;;;945      if (!hWin) {
;;;946        return;
;;;947      }
;;;948      WM_ASSERT_NOT_IN_PAINT();
;;;949      WM_LOCK();
;;;950      if (WM__IsWindow(hWin)) {
000006  f7fffffe          BL       WM__IsWindow
00000a  2800              CMP      r0,#0
00000c  d042              BEQ      |L6.148|
;;;951        pWin = WM_H2P(hWin);
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       GUI_ALLOC_h2p
000014  4c20              LDR      r4,|L6.152|
000016  2100              MOVS     r1,#0
000018  4606              MOV      r6,r0
00001a  82a1              STRH     r1,[r4,#0x14]
;;;952        ResetNextDrawWin();              /* Make sure the window will no longer receive drawing messages */
;;;953      /* Make sure that focus is set to an existing window */
;;;954        if (WM__hWinFocus == hWin) {
00001c  f9b40010          LDRSH    r0,[r4,#0x10]  ; WM__hWinFocus
000020  42a8              CMP      r0,r5
000022  d100              BNE      |L6.38|
;;;955          WM__hWinFocus = 0;
000024  8221              STRH     r1,[r4,#0x10]
                  |L6.38|
;;;956        }
;;;957        if (WM__hCapture == hWin) {
000026  f9b4000e          LDRSH    r0,[r4,#0xe]  ; WM__hCapture
00002a  42a8              CMP      r0,r5
00002c  d100              BNE      |L6.48|
;;;958          WM__hCapture = 0;
00002e  81e1              STRH     r1,[r4,#0xe]
                  |L6.48|
;;;959        }
;;;960        /* check if critical handles are affected. If so, reset the window handle to 0 */
;;;961        _CheckCriticalHandles(hWin);
000030  69a0              LDR      r0,[r4,#0x18]  ; WM__pFirstCriticalHandle
000032  e005              B        |L6.64|
                  |L6.52|
000034  f9b03004          LDRSH    r3,[r0,#4]
000038  42ab              CMP      r3,r5
00003a  d100              BNE      |L6.62|
00003c  8081              STRH     r1,[r0,#4]
                  |L6.62|
00003e  6800              LDR      r0,[r0,#0]
                  |L6.64|
000040  2800              CMP      r0,#0
000042  d1f7              BNE      |L6.52|
;;;962        /* Inform parent */
;;;963        WM_NotifyParent(hWin, WM_NOTIFICATION_CHILD_DELETED);
000044  2107              MOVS     r1,#7
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       WM_NotifyParent
;;;964        /* Delete all children */
;;;965        _DeleteAllChildren(pWin);
00004c  4630              MOV      r0,r6
00004e  f7fffffe          BL       _DeleteAllChildren
;;;966        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;967          WM__SendMsgNoData(hWin, WM_NOTIFY_VIS_CHANGED);             /* Notify window that visibility may have changed */
;;;968        #endif
;;;969        /* Send WM_DELETE message to window in order to inform window itself */
;;;970        WM__SendMsgNoData(hWin, WM_DELETE);     /* tell window about it */
000052  210b              MOVS     r1,#0xb
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       WM__SendMsgNoData
;;;971        WM__DetachWindow(hWin);
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       WM__DetachWindow
;;;972        /* Remove window from window stack */
;;;973        WM__RemoveFromLinList(hWin);
000060  4628              MOV      r0,r5
000062  f7fffffe          BL       WM__RemoveFromLinList
;;;974        /* Handle transparency counter if necessary */
;;;975        #if WM_SUPPORT_TRANSPARENCY
;;;976          if (pWin->Status & WM_SF_HASTRANS) {
000066  8bb0              LDRH     r0,[r6,#0x1c]
000068  07c1              LSLS     r1,r0,#31
00006a  d002              BEQ      |L6.114|
;;;977            WM__TransWindowCnt--;
00006c  6a61              LDR      r1,[r4,#0x24]  ; WM__TransWindowCnt
00006e  1e49              SUBS     r1,r1,#1
000070  6261              STR      r1,[r4,#0x24]  ; WM__TransWindowCnt
                  |L6.114|
;;;978          }
;;;979        #endif
;;;980        /* Make sure window is no longer counted as invalid */
;;;981        if (pWin->Status & WM_SF_INVALID) {
000072  0680              LSLS     r0,r0,#26
000074  d502              BPL      |L6.124|
;;;982          WM__NumInvalidWindows--;
000076  88e0              LDRH     r0,[r4,#6]  ; WM__NumInvalidWindows
000078  1e40              SUBS     r0,r0,#1
00007a  80e0              STRH     r0,[r4,#6]
                  |L6.124|
;;;983        }
;;;984      /* Free window memory */
;;;985        WM__NumWindows--;
00007c  88a0              LDRH     r0,[r4,#4]  ; WM__NumWindows
00007e  1e40              SUBS     r0,r0,#1
000080  80a0              STRH     r0,[r4,#4]
;;;986        GUI_ALLOC_Free(hWin);
000082  4628              MOV      r0,r5
000084  f7fffffe          BL       GUI_ALLOC_Free
;;;987      /* Select a valid window */
;;;988        WM_SelectWindow(WM__FirstWin);
000088  f9b40008          LDRSH    r0,[r4,#8]  ; WM__FirstWin
00008c  e8bd4070          POP      {r4-r6,lr}
000090  f7ffbffe          B.W      WM_SelectWindow
                  |L6.148|
;;;989      } else {
;;;990        GUI_DEBUG_WARN("WM_DeleteWindow: Invalid handle");
;;;991      }
;;;992      WM_UNLOCK();
;;;993    }
000094  bd70              POP      {r4-r6,pc}
;;;994    
                          ENDP

000096  0000              DCW      0x0000
                  |L6.152|
                          DCD      ||.data||

                          AREA ||i.WM_Exec||, CODE, READONLY, ALIGN=1

                  WM_Exec PROC
;;;1683   */
;;;1684   int WM_Exec(void) {
000000  b510              PUSH     {r4,lr}
;;;1685     int r = 0;
000002  2400              MOVS     r4,#0
000004  e000              B        |L7.8|
                  |L7.6|
;;;1686     while (WM_Exec1()) {
;;;1687       r = 1;                  /* We have done something */
000006  2401              MOVS     r4,#1
                  |L7.8|
000008  f7fffffe          BL       WM_Exec1
00000c  2800              CMP      r0,#0                 ;1686
00000e  d1fa              BNE      |L7.6|
;;;1688     }
;;;1689     return r;
000010  4620              MOV      r0,r4
;;;1690   }
000012  bd10              POP      {r4,pc}
;;;1691   
                          ENDP


                          AREA ||i.WM_Exec1||, CODE, READONLY, ALIGN=2

                  WM_Exec1 PROC
;;;1651   */
;;;1652   int WM_Exec1(void) {
000000  b5f0              PUSH     {r4-r7,lr}
;;;1653     /* Poll PID if necessary */
;;;1654     if (WM_pfPollPID) {
000002  4c1b              LDR      r4,|L8.112|
000004  b099              SUB      sp,sp,#0x64           ;1652
000006  6a20              LDR      r0,[r4,#0x20]         ;1652  ; WM_pfPollPID
000008  b100              CBZ      r0,|L8.12|
;;;1655       WM_pfPollPID();
00000a  4780              BLX      r0
                  |L8.12|
;;;1656     }
;;;1657     if (WM_pfHandlePID) {
00000c  4819              LDR      r0,|L8.116|
00000e  6800              LDR      r0,[r0,#0]  ; WM_pfHandlePID
000010  b108              CBZ      r0,|L8.22|
;;;1658       if (WM_pfHandlePID())
000012  4780              BLX      r0
000014  b920              CBNZ     r0,|L8.32|
                  |L8.22|
;;;1659         return 1;               /* We have done something ... */
;;;1660     }
;;;1661     if (WM_IsActive) {
000016  7860              LDRB     r0,[r4,#1]  ; WM_IsActive
000018  b338              CBZ      r0,|L8.106|
;;;1662       if (GUI_PollKeyMsg()) {
00001a  f7fffffe          BL       GUI_PollKeyMsg
00001e  b110              CBZ      r0,|L8.38|
                  |L8.32|
;;;1663         return 1;               /* We have done something ... */
000020  2001              MOVS     r0,#1
                  |L8.34|
;;;1664       }
;;;1665     }
;;;1666   #ifdef WIN32
;;;1667     if (WM_PollSimMsg()) {
;;;1668       return 1;               /* We have done something ... */
;;;1669     }
;;;1670   #endif
;;;1671     if (WM_IsActive && WM__NumInvalidWindows) {
;;;1672       WM_LOCK();
;;;1673       _DrawNext();
;;;1674       WM_UNLOCK();
;;;1675       return 1;               /* We have done something ... */
;;;1676     }
;;;1677     return 0;                  /* There was nothing to do ... */
;;;1678   }
000022  b019              ADD      sp,sp,#0x64
000024  bdf0              POP      {r4-r7,pc}
                  |L8.38|
000026  7860              LDRB     r0,[r4,#1]            ;1671  ; WM_IsActive
000028  b1f8              CBZ      r0,|L8.106|
00002a  88e0              LDRH     r0,[r4,#6]            ;1671  ; WM__NumInvalidWindows
00002c  b1e8              CBZ      r0,|L8.106|
00002e  f9b45014          LDRSH    r5,[r4,#0x14]         ;1671  ; NextDrawWin
000032  2601              MOVS     r6,#1                 ;1671
000034  b90d              CBNZ     r5,|L8.58|
000036  f9b45008          LDRSH    r5,[r4,#8]            ;1671  ; WM__FirstWin
                  |L8.58|
00003a  4668              MOV      r0,sp                 ;1671
00003c  f7fffffe          BL       GUI_SaveContext_W_M
000040  b175              CBZ      r5,|L8.96|
                  |L8.66|
000042  4628              MOV      r0,r5                 ;1671
000044  f7fffffe          BL       GUI_ALLOC_h2p
000048  4607              MOV      r7,r0                 ;1671
00004a  4601              MOV      r1,r0                 ;1671
00004c  4628              MOV      r0,r5                 ;1671
00004e  f7fffffe          BL       WM__Paint
000052  b100              CBZ      r0,|L8.86|
000054  1e76              SUBS     r6,r6,#1              ;1671
                  |L8.86|
000056  f9b75014          LDRSH    r5,[r7,#0x14]         ;1671
00005a  b10d              CBZ      r5,|L8.96|
00005c  2e00              CMP      r6,#0                 ;1671
00005e  d1f0              BNE      |L8.66|
                  |L8.96|
000060  82a5              STRH     r5,[r4,#0x14]         ;1671
000062  4668              MOV      r0,sp                 ;1671
000064  f7fffffe          BL       GUI_RestoreContext
000068  e7da              B        |L8.32|
                  |L8.106|
00006a  2000              MOVS     r0,#0                 ;1677
00006c  e7d9              B        |L8.34|
;;;1679   
                          ENDP

00006e  0000              DCW      0x0000
                  |L8.112|
                          DCD      ||.data||
                  |L8.116|
                          DCD      WM_pfHandlePID

                          AREA ||i.WM_GetActiveWindow||, CODE, READONLY, ALIGN=2

                  WM_GetActiveWindow PROC
;;;1036   */
;;;1037   WM_HWIN WM_GetActiveWindow(void) {
000000  4801              LDR      r0,|L9.8|
;;;1038     return GUI_Context.hAWin;
000002  f9b00040          LDRSH    r0,[r0,#0x40]  ; GUI_Context
;;;1039   }
000006  4770              BX       lr
;;;1040   
                          ENDP

                  |L9.8|
                          DCD      GUI_Context

                          AREA ||i.WM_Init||, CODE, READONLY, ALIGN=2

                  WM_Init PROC
;;;1786   */
;;;1787   void WM_Init(void) {
000000  b53e              PUSH     {r1-r5,lr}
;;;1788   	if (!_IsInited) {
000002  4c16              LDR      r4,|L10.92|
000004  78e0              LDRB     r0,[r4,#3]  ; _IsInited
000006  2800              CMP      r0,#0                 ;1787
000008  d127              BNE      |L10.90|
;;;1789   	  NextDrawWin = WM__FirstWin = WM_HWIN_NULL;
;;;1790   	  GUI_Context.WM__pUserClipRect = NULL;
00000a  4915              LDR      r1,|L10.96|
00000c  8120              STRH     r0,[r4,#8]            ;1789
00000e  82a0              STRH     r0,[r4,#0x14]         ;1789
;;;1791   	  WM__NumWindows = WM__NumInvalidWindows =0;
000010  63c8              STR      r0,[r1,#0x3c]  ; GUI_Context
000012  80e0              STRH     r0,[r4,#6]
000014  80a0              STRH     r0,[r4,#4]
;;;1792   	  /* Make sure we have at least one window. This greatly simplifies the
;;;1793   		  drawing routines as they do not have to check if the window is valid.
;;;1794   	  */
;;;1795       #if GUI_NUM_LAYERS == 1
;;;1796         WM__ahDesktopWin[0] = WM_CreateWindow(0, 0, GUI_XMAX, GUI_YMAX, WM_CF_SHOW, cbBackWin, 0);
000016  4913              LDR      r1,|L10.100|
000018  2202              MOVS     r2,#2
00001a  e9cd2100          STRD     r2,r1,[sp,#0]
00001e  f64072ff          MOV      r2,#0xfff
000022  9002              STR      r0,[sp,#8]
000024  4613              MOV      r3,r2
000026  4601              MOV      r1,r0
000028  f7fffffe          BL       WM_CreateWindow
00002c  f104050a          ADD      r5,r4,#0xa
;;;1797         WM__aBkColor[0] = GUI_INVALID_COLOR;
000030  f104021c          ADD      r2,r4,#0x1c
000034  8028              STRH     r0,[r5,#0]            ;1796
000036  f06f4170          MVN      r1,#0xf0000000
;;;1798         WM_InvalidateWindow(WM__ahDesktopWin[0]); /* Required because a desktop window has no parent. */
00003a  6011              STR      r1,[r2,#0]  ; WM__aBkColor
00003c  f7fffffe          BL       WM_InvalidateWindow
;;;1799       #else
;;;1800       {
;;;1801         int i;
;;;1802         for (i = 0; i < GUI_NUM_LAYERS; i++) {
;;;1803           WM__ahDesktopWin[i] = WM_CreateWindowAsChild(0, 0, GUI_XMAX, GUI_YMAX, WM_UNATTACHED, WM_CF_SHOW, cbBackWin, 0);
;;;1804           WM__aBkColor[i] = GUI_INVALID_COLOR;
;;;1805           WM_InvalidateWindow(WM__ahDesktopWin[i]); /* Required because a desktop window has no parent. */
;;;1806         }
;;;1807       }
;;;1808       #endif
;;;1809       /* Register the critical handles ... Note: This could be moved into the module setting the Window handle */
;;;1810       WM__AddCriticalHandle(&WM__CHWinModal);
000040  4809              LDR      r0,|L10.104|
000042  f7fffffe          BL       WM__AddCriticalHandle
;;;1811       WM__AddCriticalHandle(&WM__CHWinLast);
000046  4809              LDR      r0,|L10.108|
000048  f7fffffe          BL       WM__AddCriticalHandle
;;;1812       #if GUI_SUPPORT_MOUSE
;;;1813         WM__AddCriticalHandle(&WM__CHWinMouseOver);
;;;1814       #endif
;;;1815   
;;;1816       WM_SelectWindow(WM__ahDesktopWin[0]);
00004c  f9b50000          LDRSH    r0,[r5,#0]  ; WM__ahDesktopWin
000050  f7fffffe          BL       WM_SelectWindow
000054  2001              MOVS     r0,#1
000056  7060              STRB     r0,[r4,#1]
;;;1817   	  WM_Activate();
;;;1818       _IsInited =1;
000058  70e0              STRB     r0,[r4,#3]
                  |L10.90|
;;;1819   	}
;;;1820   }
00005a  bd3e              POP      {r1-r5,pc}
;;;1821   
                          ENDP

                  |L10.92|
                          DCD      ||.data||
                  |L10.96|
                          DCD      GUI_Context
                  |L10.100|
                          DCD      cbBackWin
                  |L10.104|
                          DCD      WM__CHWinModal
                  |L10.108|
                          DCD      WM__CHWinLast

                          AREA ||i.WM_InvalidateRect||, CODE, READONLY, ALIGN=1

                  WM_InvalidateRect PROC
;;;795    */
;;;796    void WM_InvalidateRect(WM_HWIN hWin, const GUI_RECT*pRect) {
000000  e92d41ff          PUSH     {r0-r8,lr}
000004  460e              MOV      r6,r1
000006  0007              MOVS     r7,r0
000008  d025              BEQ      |L11.86|
;;;797      GUI_RECT r;
;;;798      WM_Obj* pWin;
;;;799      int Status;
;;;800      if (hWin) {
;;;801        WM_LOCK();
;;;802        pWin = WM_H2P(hWin);
00000a  f7fffffe          BL       GUI_ALLOC_h2p
;;;803        Status = pWin->Status;
00000e  8b85              LDRH     r5,[r0,#0x1c]
000010  4604              MOV      r4,r0                 ;802
;;;804        if (Status & WM_SF_ISVIS) {
000012  07a8              LSLS     r0,r5,#30
000014  d51f              BPL      |L11.86|
000016  e9d40100          LDRD     r0,r1,[r4,#0]
00001a  e9cd0100          STRD     r0,r1,[sp,#0]
;;;805          r = pWin->Rect;
;;;806          if (pRect) {
00001e  b15e              CBZ      r6,|L11.56|
;;;807            GUI_RECT rPara;
;;;808            rPara = *pRect;
000020  6830              LDR      r0,[r6,#0]
000022  9002              STR      r0,[sp,#8]
000024  6870              LDR      r0,[r6,#4]
;;;809            WM__Client2Screen(pWin, &rPara);
000026  9003              STR      r0,[sp,#0xc]
000028  a902              ADD      r1,sp,#8
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       WM__Client2Screen
;;;810            GUI__IntersectRect(&r, &rPara);
000030  a902              ADD      r1,sp,#8
000032  4668              MOV      r0,sp
000034  f7fffffe          BL       GUI__IntersectRect
                  |L11.56|
;;;811          }
;;;812          if (WM__ClipAtParentBorders(&r, hWin)) {      /* Optimization that saves invalidation if window area is not visible ... Not required */
000038  4639              MOV      r1,r7
00003a  4668              MOV      r0,sp
00003c  f7fffffe          BL       WM__ClipAtParentBorders
000040  2800              CMP      r0,#0
000042  d008              BEQ      |L11.86|
;;;813            if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
000044  f6400001          MOV      r0,#0x801
000048  4005              ANDS     r5,r5,r0
00004a  2d01              CMP      r5,#1
00004c  d005              BEQ      |L11.90|
;;;814              WM__InvalidateRectEx(&r, pWin->hParent, pWin->hNext);
;;;815            } else {
;;;816              WM__Invalidate1Abs(hWin, &r);
00004e  4669              MOV      r1,sp
000050  4638              MOV      r0,r7
000052  f7fffffe          BL       WM__Invalidate1Abs
                  |L11.86|
;;;817            }
;;;818          }
;;;819        }
;;;820        WM_UNLOCK();
;;;821      }
;;;822    }
000056  e8bd81ff          POP      {r0-r8,pc}
                  |L11.90|
00005a  f9b4201a          LDRSH    r2,[r4,#0x1a]         ;814
00005e  f9b41016          LDRSH    r1,[r4,#0x16]         ;814
000062  4668              MOV      r0,sp                 ;814
000064  f7fffffe          BL       WM__InvalidateRectEx
000068  e7f5              B        |L11.86|
;;;823    
                          ENDP


                          AREA ||i.WM_InvalidateWindow||, CODE, READONLY, ALIGN=1

                  WM_InvalidateWindow PROC
;;;829    */
;;;830    void WM_InvalidateWindow(WM_HWIN hWin) {
000000  2100              MOVS     r1,#0
;;;831      WM_InvalidateRect(hWin, NULL);
000002  f7ffbffe          B.W      WM_InvalidateRect
;;;832    }
;;;833    
                          ENDP


                          AREA ||i.WM_InvalidateWindowAndDescsEx||, CODE, READONLY, ALIGN=1

                  WM_InvalidateWindowAndDescsEx PROC
;;;490    */
;;;491    void WM_InvalidateWindowAndDescsEx(WM_HWIN hWin, const GUI_RECT * pInvalidRect) {
000000  b57c              PUSH     {r2-r6,lr}
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d01f              BEQ      |L13.72|
;;;492      GUI_RECT Rect;
;;;493      WM_Obj*  pWin;
;;;494      WM_Obj* pChild;
;;;495      WM_HWIN hChild;
;;;496      int Status;
;;;497    
;;;498      if (hWin) {
;;;499        pWin = WM_H2P(hWin);
000008  f7fffffe          BL       GUI_ALLOC_h2p
00000c  4602              MOV      r2,r0
;;;500        Status  = pWin->Status;
00000e  7f00              LDRB     r0,[r0,#0x1c]
;;;501        if ((Status & WM_SF_ISVIS) == 0) {
000010  0780              LSLS     r0,r0,#30
000012  d519              BPL      |L13.72|
;;;502          return;                                                            /* Window is not visible... we are done */
;;;503        }
;;;504        if (GUI__IntersectRects(&Rect, pInvalidRect, &pWin->Rect) == 0) {  /* Limit the given rect to the area of the parent window */
000014  4629              MOV      r1,r5
000016  4668              MOV      r0,sp
000018  f7fffffe          BL       GUI__IntersectRects
00001c  2800              CMP      r0,#0
00001e  d013              BEQ      |L13.72|
;;;505          return;                                                            /* No intersection, nothing to do */
;;;506        }
;;;507        WM__Invalidate1Abs(hWin, &Rect);    /* Invalidate window itself */
000020  4669              MOV      r1,sp
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       WM__Invalidate1Abs
;;;508        for (hChild = WM_GetFirstChild(hWin); hChild; hChild = pChild->hNext) {
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       WM_GetFirstChild
00002e  4604              MOV      r4,r0
000030  e008              B        |L13.68|
                  |L13.50|
;;;509          WM_InvalidateWindowAndDescsEx(hChild, &Rect);
000032  4669              MOV      r1,sp
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       WM_InvalidateWindowAndDescsEx
;;;510          pChild = WM_H2P(hChild);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       GUI_ALLOC_h2p
000040  f9b0401a          LDRSH    r4,[r0,#0x1a]         ;508
                  |L13.68|
000044  2c00              CMP      r4,#0                 ;508
000046  d1f4              BNE      |L13.50|
                  |L13.72|
;;;511        }
;;;512      }
;;;513    }
000048  bd7c              POP      {r2-r6,pc}
;;;514    
                          ENDP


                          AREA ||i.WM_SelectWindow||, CODE, READONLY, ALIGN=2

                  WM_SelectWindow PROC
;;;1001   */
;;;1002   WM_HWIN WM_SelectWindow(WM_HWIN  hWin) {
000000  b570              PUSH     {r4-r6,lr}
;;;1003     WM_HWIN hWinPrev;
;;;1004     WM_Obj* pObj;
;;;1005   
;;;1006     WM_ASSERT_NOT_IN_PAINT();
;;;1007     WM_LOCK();
;;;1008     hWinPrev = GUI_Context.hAWin;
000002  4c0b              LDR      r4,|L14.48|
000004  f9b45040          LDRSH    r5,[r4,#0x40]  ; GUI_Context
000008  b910              CBNZ     r0,|L14.16|
;;;1009     if (hWin == 0) {
;;;1010       hWin = WM__FirstWin;
00000a  480a              LDR      r0,|L14.52|
00000c  f9b00008          LDRSH    r0,[r0,#8]  ; WM__FirstWin
                  |L14.16|
;;;1011     }
;;;1012     /* Select new window */
;;;1013     GUI_Context.hAWin = hWin;
000010  f8a40040          STRH     r0,[r4,#0x40]
;;;1014     #if GUI_NUM_LAYERS > 1
;;;1015     {
;;;1016       WM_HWIN hTop;
;;;1017       int LayerIndex;
;;;1018       hTop = _GetTopLevelWindow(hWin);
;;;1019       LayerIndex = _DesktopHandle2Index(hTop);
;;;1020       if (LayerIndex >= 0) {
;;;1021         GUI_SelectLayer(LayerIndex);
;;;1022       }
;;;1023     }
;;;1024     #endif
;;;1025     pObj = WM_H2P(hWin);
000014  f7fffffe          BL       GUI_ALLOC_h2p
000018  4606              MOV      r6,r0
;;;1026     LCD_SetClipRectMax();             /* Drawing operations will clip ... If WM is deactivated, allow all */
00001a  f7fffffe          BL       LCD_SetClipRectMax
;;;1027     GUI_Context.xOff = pObj->Rect.x0;
00001e  f9b60000          LDRSH    r0,[r6,#0]
;;;1028     GUI_Context.yOff = pObj->Rect.y0;
000022  6460              STR      r0,[r4,#0x44]  ; GUI_Context
000024  f9b60002          LDRSH    r0,[r6,#2]
;;;1029     WM_UNLOCK();
;;;1030     return hWinPrev;
000028  64a0              STR      r0,[r4,#0x48]  ; GUI_Context
00002a  4628              MOV      r0,r5
;;;1031   }
00002c  bd70              POP      {r4-r6,pc}
;;;1032   
                          ENDP

00002e  0000              DCW      0x0000
                  |L14.48|
                          DCD      GUI_Context
                  |L14.52|
                          DCD      ||.data||

                          AREA ||i.WM_SendMessage||, CODE, READONLY, ALIGN=1

                  WM_SendMessage PROC
;;;741    */
;;;742    void WM_SendMessage(WM_HWIN hWin, WM_MESSAGE* pMsg) {
000000  2800              CMP      r0,#0
000002  d001              BEQ      |L15.8|
;;;743      if (hWin) {
;;;744        WM_LOCK();
;;;745        WM__SendMessage(hWin, pMsg);
000004  f7ffbffe          B.W      WM__SendMessage
                  |L15.8|
;;;746        WM_UNLOCK();
;;;747      }  
;;;748    }
000008  4770              BX       lr
;;;749    
                          ENDP


                          AREA ||i.WM_SetDefault||, CODE, READONLY, ALIGN=2

                  WM_SetDefault PROC
;;;1326   */
;;;1327   void WM_SetDefault(void) {
000000  b510              PUSH     {r4,lr}
;;;1328     GL_SetDefault();
000002  f7fffffe          BL       GL_SetDefault
;;;1329     GUI_Context.WM__pUserClipRect = NULL;   /* No add. clipping */
000006  4902              LDR      r1,|L16.16|
000008  2000              MOVS     r0,#0
00000a  63c8              STR      r0,[r1,#0x3c]  ; GUI_Context
;;;1330   }
00000c  bd10              POP      {r4,pc}
;;;1331   
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      GUI_Context

                          AREA ||i.WM__ActivateClipRect||, CODE, READONLY, ALIGN=2

                  WM__ActivateClipRect PROC
;;;314    */
;;;315    void  WM__ActivateClipRect(void) {
000000  b51c              PUSH     {r2-r4,lr}
;;;316      if (WM_IsActive) {
000002  4c0d              LDR      r4,|L17.56|
000004  7860              LDRB     r0,[r4,#1]  ; WM_IsActive
000006  b120              CBZ      r0,|L17.18|
;;;317        _SetClipRectUserIntersect(&_ClipContext.CurRect);
000008  e8bd401c          POP      {r2-r4,lr}
00000c  480b              LDR      r0,|L17.60|
00000e  f7ffbffe          B.W      _SetClipRectUserIntersect
                  |L17.18|
;;;318      } else {    /* Window manager disabled, typically because meory device is active */
;;;319        GUI_RECT r;
;;;320        WM_Obj *pAWin;
;;;321        pAWin = WM_H2P(GUI_Context.hAWin);
000012  480b              LDR      r0,|L17.64|
000014  f9b00040          LDRSH    r0,[r0,#0x40]  ; GUI_Context
000018  f7fffffe          BL       GUI_ALLOC_h2p
00001c  e9d01000          LDRD     r1,r0,[r0,#0]
000020  e9cd1000          STRD     r1,r0,[sp,#0]
;;;322        r = pAWin->Rect;
;;;323        #if WM_SUPPORT_TRANSPARENCY
;;;324          if (WM__hATransWindow) {
000024  f9b41012          LDRSH    r1,[r4,#0x12]  ; WM__hATransWindow
000028  b111              CBZ      r1,|L17.48|
;;;325            WM__ClipAtParentBorders(&r, WM__hATransWindow);
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       WM__ClipAtParentBorders
                  |L17.48|
;;;326          }
;;;327        #endif
;;;328        /* Take UserClipRect into account */
;;;329        _SetClipRectUserIntersect(&r);
000030  4668              MOV      r0,sp
000032  f7fffffe          BL       _SetClipRectUserIntersect
;;;330      }
;;;331    }
000036  bd1c              POP      {r2-r4,pc}
;;;332    
                          ENDP

                  |L17.56|
                          DCD      ||.data||
                  |L17.60|
                          DCD      ||area_number.47||+0x8
                  |L17.64|
                          DCD      GUI_Context

                          AREA ||i.WM__Client2Screen||, CODE, READONLY, ALIGN=1

                  WM__Client2Screen PROC
;;;462    */
;;;463    void WM__Client2Screen(const WM_Obj* pWin, GUI_RECT *pRect) {
000000  460b              MOV      r3,r1
;;;464      GUI_MoveRect(pRect, pWin->Rect.x0, pWin->Rect.y0);
000002  f9b02002          LDRSH    r2,[r0,#2]
000006  f9b01000          LDRSH    r1,[r0,#0]
00000a  4618              MOV      r0,r3
00000c  f7ffbffe          B.W      GUI_MoveRect
;;;465    }
;;;466    
                          ENDP


                          AREA ||i.WM__ClipAtParentBorders||, CODE, READONLY, ALIGN=2

                  WM__ClipAtParentBorders PROC
;;;281    */
;;;282    int WM__ClipAtParentBorders(GUI_RECT* pRect, WM_HWIN hWin) {
000000  b570              PUSH     {r4-r6,lr}
000002  460c              MOV      r4,r1
000004  4606              MOV      r6,r0
                  |L19.6|
;;;283      WM_Obj* pWin;
;;;284    
;;;285      /* Iterate up the window hierarchy.
;;;286         If the window is invisible, we are done.
;;;287         Clip at parent boarders.
;;;288         We are done with iterating if hWin has no parent.
;;;289      */
;;;290      do {
;;;291        pWin = WM_H2P(hWin);
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       GUI_ALLOC_h2p
00000c  4605              MOV      r5,r0
;;;292        if ((pWin->Status & WM_SF_ISVIS) == 0) {
00000e  7f00              LDRB     r0,[r0,#0x1c]
000010  0780              LSLS     r0,r0,#30
000012  d50f              BPL      |L19.52|
;;;293          return 0;                     /* Invisible */
;;;294        }
;;;295        GUI__IntersectRect(pRect, &pWin->Rect);  /* And clip on borders */
000014  4629              MOV      r1,r5
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       GUI__IntersectRect
;;;296        if (pWin->hParent == 0) {
00001c  f9b50016          LDRSH    r0,[r5,#0x16]
000020  b108              CBZ      r0,|L19.38|
;;;297          break;   /* hWin is now the top level window which has no parent */
;;;298        }
;;;299        hWin = pWin->hParent;                    /* Go one level up (parent)*/
000022  4604              MOV      r4,r0
;;;300      } while (1);                               /* Only way out is in the loop. Required for efficiency, no bug, even though some compilers may complain. */
000024  e7ef              B        |L19.6|
                  |L19.38|
000026  4804              LDR      r0,|L19.56|
000028  f9b00000          LDRSH    r0,[r0,#0]  ; WM__ahDesktopWin
00002c  42a0              CMP      r0,r4
00002e  d101              BNE      |L19.52|
;;;301      
;;;302      /* Now check if the top level window is a desktop window. If it is not,
;;;303        then the window is not visible.
;;;304      */
;;;305      if (_DesktopHandle2Index(hWin) < 0) {
;;;306        return 0;           /* No desktop - (unattached) - Nothing to draw */
;;;307      }
;;;308      return 1;               /* Something may be visible */
000030  2001              MOVS     r0,#1
;;;309    }
000032  bd70              POP      {r4-r6,pc}
                  |L19.52|
000034  2000              MOVS     r0,#0                 ;306
000036  bd70              POP      {r4-r6,pc}
;;;310    
                          ENDP

                  |L19.56|
                          DCD      ||.data||+0xa

                          AREA ||i.WM__DetachWindow||, CODE, READONLY, ALIGN=1

                  WM__DetachWindow PROC
;;;430    */
;;;431    void WM__DetachWindow(WM_HWIN hWin) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;432      WM_Obj* pWin;
;;;433      WM_HWIN hParent;
;;;434      pWin = WM_H2P(hWin);
000004  f7fffffe          BL       GUI_ALLOC_h2p
;;;435      hParent = pWin->hParent;
000008  f9b01016          LDRSH    r1,[r0,#0x16]
00000c  4604              MOV      r4,r0                 ;434
;;;436      if (hParent) {
00000e  2900              CMP      r1,#0
000010  d008              BEQ      |L20.36|
;;;437        WM__InvalidateRectEx(&pWin->Rect, pWin->hParent, pWin->hNext);
000012  f9b4201a          LDRSH    r2,[r4,#0x1a]
000016  f7fffffe          BL       WM__InvalidateRectEx
;;;438        WM__RemoveWindowFromList(hWin);
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       WM__RemoveWindowFromList
;;;439        pWin->hParent = 0;
000020  2000              MOVS     r0,#0
000022  82e0              STRH     r0,[r4,#0x16]
                  |L20.36|
;;;440      }
;;;441    }
000024  bd70              POP      {r4-r6,pc}
;;;442    
                          ENDP


                          AREA ||i.WM__GetClientRectWin||, CODE, READONLY, ALIGN=1

                  WM__GetClientRectWin PROC
;;;767    */
;;;768    void WM__GetClientRectWin(const WM_Obj* pWin, GUI_RECT* pRect) {
000000  2200              MOVS     r2,#0
;;;769      pRect->x0 = pRect->y0 = 0;
000002  804a              STRH     r2,[r1,#2]
000004  800a              STRH     r2,[r1,#0]
;;;770      pRect->x1 = pWin->Rect.x1 - pWin->Rect.x0;
000006  8882              LDRH     r2,[r0,#4]
000008  8803              LDRH     r3,[r0,#0]
00000a  1ad2              SUBS     r2,r2,r3
00000c  808a              STRH     r2,[r1,#4]
;;;771      pRect->y1 = pWin->Rect.y1 - pWin->Rect.y0;
00000e  88c2              LDRH     r2,[r0,#6]
000010  8840              LDRH     r0,[r0,#2]
000012  1a10              SUBS     r0,r2,r0
000014  80c8              STRH     r0,[r1,#6]
;;;772    }
000016  4770              BX       lr
;;;773    
                          ENDP


                          AREA ||i.WM__GetNextIVR||, CODE, READONLY, ALIGN=2

                  WM__GetNextIVR PROC
;;;1210   */
;;;1211   int  WM__GetNextIVR(void) {
000000  b570              PUSH     {r4-r6,lr}
;;;1212     #if GUI_SUPPORT_CURSOR
;;;1213       static char _CursorHidden;
;;;1214     #endif
;;;1215     /* If WM is not active, we have no rectangles to return */
;;;1216     if (WM_IsActive==0) {
000002  4d13              LDR      r5,|L22.80|
000004  7868              LDRB     r0,[r5,#1]  ; WM_IsActive
000006  2800              CMP      r0,#0                 ;1211
000008  d006              BEQ      |L22.24|
;;;1217       return 0;
;;;1218     }
;;;1219     if (_ClipContext.EntranceCnt > 1) {
00000a  4c12              LDR      r4,|L22.84|
00000c  6960              LDR      r0,[r4,#0x14]  ; _ClipContext
00000e  2801              CMP      r0,#1
000010  dd03              BLE      |L22.26|
                  |L22.18|
000012  1e40              SUBS     r0,r0,#1
;;;1220       _ClipContext.EntranceCnt--;
;;;1221       return 0;
000014  6160              STR      r0,[r4,#0x14]  ; _ClipContext
000016  2000              MOVS     r0,#0
                  |L22.24|
;;;1222     }
;;;1223     #if GUI_SUPPORT_CURSOR
;;;1224       if (_CursorHidden) {
;;;1225         _CursorHidden = 0;
;;;1226         (*GUI_CURSOR_pfTempUnhide) ();
;;;1227       }
;;;1228     #endif
;;;1229     ++_ClipContext.Cnt;
;;;1230     /* Find next rectangle and use it as ClipRect */
;;;1231     if (!_FindNext_IVR()) {
;;;1232       _ClipContext.EntranceCnt--;  /* This search is over ! */
;;;1233       return 0;        /* Could not find an other one ! */
;;;1234     }
;;;1235     WM__ActivateClipRect();
;;;1236     /* Hide cursor if necessary */
;;;1237     #if GUI_SUPPORT_CURSOR
;;;1238       if (GUI_CURSOR_pfTempHide) {
;;;1239         _CursorHidden = (*GUI_CURSOR_pfTempHide) ( &_ClipContext.CurRect);
;;;1240       }
;;;1241     #endif
;;;1242     return 1;
;;;1243   }
000018  bd70              POP      {r4-r6,pc}
                  |L22.26|
00001a  7828              LDRB     r0,[r5,#0]            ;1224  ; _CursorHidden
00001c  b120              CBZ      r0,|L22.40|
00001e  2000              MOVS     r0,#0                 ;1225
000020  7028              STRB     r0,[r5,#0]            ;1225
000022  480d              LDR      r0,|L22.88|
000024  6800              LDR      r0,[r0,#0]            ;1226  ; GUI_CURSOR_pfTempUnhide
000026  4780              BLX      r0                    ;1226
                  |L22.40|
000028  6920              LDR      r0,[r4,#0x10]         ;1229  ; _ClipContext
00002a  1c40              ADDS     r0,r0,#1              ;1229
00002c  6120              STR      r0,[r4,#0x10]         ;1231  ; _ClipContext
00002e  f7fffffe          BL       _FindNext_IVR
000032  b150              CBZ      r0,|L22.74|
000034  f7fffffe          BL       WM__ActivateClipRect
000038  4808              LDR      r0,|L22.92|
00003a  6801              LDR      r1,[r0,#0]            ;1238  ; GUI_CURSOR_pfTempHide
00003c  b119              CBZ      r1,|L22.70|
00003e  4805              LDR      r0,|L22.84|
000040  3008              ADDS     r0,r0,#8              ;1239
000042  4788              BLX      r1                    ;1239
000044  7028              STRB     r0,[r5,#0]            ;1239
                  |L22.70|
000046  2001              MOVS     r0,#1                 ;1242
000048  bd70              POP      {r4-r6,pc}
                  |L22.74|
00004a  6960              LDR      r0,[r4,#0x14]         ;1233  ; _ClipContext
00004c  e7e1              B        |L22.18|
;;;1244   
                          ENDP

00004e  0000              DCW      0x0000
                  |L22.80|
                          DCD      ||.data||
                  |L22.84|
                          DCD      ||area_number.47||
                  |L22.88|
                          DCD      GUI_CURSOR_pfTempUnhide
                  |L22.92|
                          DCD      GUI_CURSOR_pfTempHide

                          AREA ||i.WM__InitIVRSearch||, CODE, READONLY, ALIGN=2

                  WM__InitIVRSearch PROC
;;;1256   */
;;;1257   int WM__InitIVRSearch(const GUI_RECT* pMaxRect) {
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;1258     GUI_RECT r;
;;;1259     WM_Obj* pAWin;
;;;1260     GUI_ASSERT_LOCK();   /* GUI_LOCK must have been "called" before entering this (normally done indrawing routine) */
;;;1261      /* If WM is not active -> nothing to do, leave cliprect alone */
;;;1262     if (WM_IsActive==0) {
000004  4e2d              LDR      r6,|L23.188|
000006  4680              MOV      r8,r0                 ;1257
000008  7870              LDRB     r0,[r6,#1]  ; WM_IsActive
00000a  b148              CBZ      r0,|L23.32|
;;;1263       WM__ActivateClipRect();
;;;1264       return 1;
;;;1265     }
;;;1266     /* If we entered multiple times, leave Cliprect alone */
;;;1267     if (++_ClipContext.EntranceCnt > 1)
00000c  4c2c              LDR      r4,|L23.192|
00000e  6960              LDR      r0,[r4,#0x14]  ; _ClipContext
000010  1c40              ADDS     r0,r0,#1
000012  6160              STR      r0,[r4,#0x14]  ; _ClipContext
000014  2801              CMP      r0,#1
000016  dd06              BLE      |L23.38|
                  |L23.24|
;;;1268       return 1;
000018  2001              MOVS     r0,#1
                  |L23.26|
;;;1269     pAWin = WM_H2P(GUI_Context.hAWin);
;;;1270     _ClipContext.Cnt        = -1;
;;;1271    /* When using callback mechanism, it is legal to reduce drawing
;;;1272       area to the invalid area ! */
;;;1273     if (WM__PaintCallbackCnt) {
;;;1274       WM__GetInvalidRectAbs(pAWin, &r);
;;;1275     } else {  /* Not using callback mechanism, therefor allow entire rectangle */
;;;1276       if (pAWin->Status & WM_SF_ISVIS) {
;;;1277         r = pAWin->Rect;
;;;1278       } else {
;;;1279         --_ClipContext.EntranceCnt;
;;;1280         return 0;  /* window is not even visible ! */
;;;1281       }
;;;1282     }
;;;1283     /* If the drawing routine has specified a rectangle, use it to reduce the rectangle */
;;;1284     if (pMaxRect) {
;;;1285       GUI__IntersectRect(&r, pMaxRect);
;;;1286     }
;;;1287     /* If user has reduced the cliprect size, reduce the rectangle */
;;;1288     if (GUI_Context.WM__pUserClipRect) {
;;;1289       WM_Obj* pWin = pAWin;
;;;1290       GUI_RECT rUser = *(GUI_Context.WM__pUserClipRect);
;;;1291       #if WM_SUPPORT_TRANSPARENCY
;;;1292         if (WM__hATransWindow) {
;;;1293           pWin = WM_H2P(WM__hATransWindow);
;;;1294         }   
;;;1295       #endif
;;;1296       WM__Client2Screen(pWin, &rUser);
;;;1297       GUI__IntersectRect(&r, &rUser);
;;;1298     }
;;;1299     /* For transparent windows, we need to further reduce the rectangle */
;;;1300     #if WM_SUPPORT_TRANSPARENCY
;;;1301       if (WM__hATransWindow) {
;;;1302         if (WM__ClipAtParentBorders(&r, WM__hATransWindow) == 0) {
;;;1303           --_ClipContext.EntranceCnt;
;;;1304           return 0;           /* Nothing to draw */
;;;1305         }
;;;1306       }
;;;1307     #endif
;;;1308     /* Iterate over all ancestors and clip at their borders. If there is no visible part, we are done */
;;;1309     if (WM__ClipAtParentBorders(&r, GUI_Context.hAWin) == 0) {
;;;1310       --_ClipContext.EntranceCnt;
;;;1311       return 0;           /* Nothing to draw */
;;;1312     }
;;;1313     /* Store the rectangle and find the first rectangle of the area */
;;;1314     _ClipContext.ClientRect = r;
;;;1315     return WM__GetNextIVR();
;;;1316   }
00001a  b004              ADD      sp,sp,#0x10
00001c  e8bd81f0          POP      {r4-r8,pc}
                  |L23.32|
000020  f7fffffe          BL       WM__ActivateClipRect
000024  e7f8              B        |L23.24|
                  |L23.38|
000026  4f27              LDR      r7,|L23.196|
000028  f9b70040          LDRSH    r0,[r7,#0x40]         ;1269  ; GUI_Context
00002c  f7fffffe          BL       GUI_ALLOC_h2p
000030  4605              MOV      r5,r0                 ;1269
000032  f04f30ff          MOV      r0,#0xffffffff        ;1270
000036  6120              STR      r0,[r4,#0x10]         ;1273  ; _ClipContext
000038  78b0              LDRB     r0,[r6,#2]            ;1273  ; WM__PaintCallbackCnt
00003a  b120              CBZ      r0,|L23.70|
00003c  68a8              LDR      r0,[r5,#8]            ;1273
00003e  9000              STR      r0,[sp,#0]            ;1273
000040  68e8              LDR      r0,[r5,#0xc]          ;1273
000042  9001              STR      r0,[sp,#4]            ;1274
000044  e006              B        |L23.84|
                  |L23.70|
000046  7f28              LDRB     r0,[r5,#0x1c]         ;1276
000048  0780              LSLS     r0,r0,#30             ;1276
00004a  d532              BPL      |L23.178|
00004c  e9d50100          LDRD     r0,r1,[r5,#0]         ;1276
000050  e9cd0100          STRD     r0,r1,[sp,#0]         ;1276
                  |L23.84|
000054  ea5f0008          MOVS     r0,r8                 ;1284
000058  d003              BEQ      |L23.98|
00005a  4601              MOV      r1,r0                 ;1285
00005c  4668              MOV      r0,sp                 ;1285
00005e  f7fffffe          BL       GUI__IntersectRect
                  |L23.98|
000062  6bf9              LDR      r1,[r7,#0x3c]         ;1288  ; GUI_Context
000064  b189              CBZ      r1,|L23.138|
000066  680a              LDR      r2,[r1,#0]            ;1290
000068  9202              STR      r2,[sp,#8]            ;1290
00006a  6849              LDR      r1,[r1,#4]            ;1290
00006c  9103              STR      r1,[sp,#0xc]          ;1292
00006e  f9b61012          LDRSH    r1,[r6,#0x12]         ;1292  ; WM__hATransWindow
000072  4628              MOV      r0,r5                 ;1289
000074  b111              CBZ      r1,|L23.124|
000076  4608              MOV      r0,r1                 ;1292
000078  f7fffffe          BL       GUI_ALLOC_h2p
                  |L23.124|
00007c  a902              ADD      r1,sp,#8              ;1296
00007e  f7fffffe          BL       WM__Client2Screen
000082  a902              ADD      r1,sp,#8              ;1297
000084  4668              MOV      r0,sp                 ;1297
000086  f7fffffe          BL       GUI__IntersectRect
                  |L23.138|
00008a  f9b61012          LDRSH    r1,[r6,#0x12]         ;1301  ; WM__hATransWindow
00008e  b119              CBZ      r1,|L23.152|
000090  4668              MOV      r0,sp                 ;1302
000092  f7fffffe          BL       WM__ClipAtParentBorders
000096  b160              CBZ      r0,|L23.178|
                  |L23.152|
000098  f9b71040          LDRSH    r1,[r7,#0x40]         ;1309  ; GUI_Context
00009c  4668              MOV      r0,sp                 ;1309
00009e  f7fffffe          BL       WM__ClipAtParentBorders
0000a2  b130              CBZ      r0,|L23.178|
0000a4  e9dd0100          LDRD     r0,r1,[sp,#0]         ;1309
0000a8  e9c40100          STRD     r0,r1,[r4,#0]         ;1309
0000ac  f7fffffe          BL       WM__GetNextIVR
0000b0  e7b3              B        |L23.26|
                  |L23.178|
0000b2  6960              LDR      r0,[r4,#0x14]         ;1310  ; _ClipContext
0000b4  1e40              SUBS     r0,r0,#1              ;1310
0000b6  6160              STR      r0,[r4,#0x14]         ;1311  ; _ClipContext
0000b8  2000              MOVS     r0,#0                 ;1311
0000ba  e7ae              B        |L23.26|
;;;1317   
                          ENDP

                  |L23.188|
                          DCD      ||.data||
                  |L23.192|
                          DCD      ||area_number.47||
                  |L23.196|
                          DCD      GUI_Context

                          AREA ||i.WM__InsertWindowIntoList||, CODE, READONLY, ALIGN=1

                  WM__InsertWindowIntoList PROC
;;;341    */
;;;342    void WM__InsertWindowIntoList(WM_HWIN hWin, WM_HWIN hParent) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  000c              MOVS     r4,r1
000006  4607              MOV      r7,r0
000008  d019              BEQ      |L24.62|
;;;343      int OnTop;
;;;344      WM_HWIN hi;
;;;345      WM_Obj * pWin;
;;;346      WM_Obj * pParent;
;;;347      WM_Obj * pi;
;;;348    
;;;349      if (hParent) {
;;;350        pWin = WM_H2P(hWin);
00000a  f7fffffe          BL       GUI_ALLOC_h2p
00000e  4605              MOV      r5,r0
;;;351        pWin->hNext = 0;
000010  2000              MOVS     r0,#0
000012  8368              STRH     r0,[r5,#0x1a]
;;;352        pWin->hParent = hParent;
000014  82ec              STRH     r4,[r5,#0x16]
;;;353        pParent = WM_H2P(hParent);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       GUI_ALLOC_h2p
00001c  4606              MOV      r6,r0
;;;354        OnTop   = pWin->Status & WM_CF_STAYONTOP;
00001e  7f28              LDRB     r0,[r5,#0x1c]
000020  f0000908          AND      r9,r0,#8
;;;355        hi = pParent->hFirstChild;
000024  f9b60018          LDRSH    r0,[r6,#0x18]
000028  ea5f0800          MOVS     r8,r0
;;;356        /* Put it at beginning of the list if there is no child */
;;;357        if (hi == 0) {   /* No child yet ... Makes things easy ! */
00002c  d006              BEQ      |L24.60|
;;;358          pParent->hFirstChild = hWin;
;;;359          return;                         /* Early out ... We are done */
;;;360        }
;;;361        /* Put it at beginning of the list if first child is a TOP window and new one is not */
;;;362        pi = WM_H2P(hi);
00002e  f7fffffe          BL       GUI_ALLOC_h2p
000032  4604              MOV      r4,r0
;;;363        if (!OnTop) {
000034  f1b90f00          CMP      r9,#0
000038  d003              BEQ      |L24.66|
00003a  e008              B        |L24.78|
                  |L24.60|
00003c  8337              STRH     r7,[r6,#0x18]         ;358
                  |L24.62|
;;;364          if (pi->Status & WM_SF_STAYONTOP) {
;;;365            pWin->hNext = hi;
;;;366            pParent->hFirstChild = hWin;
;;;367            return;                         /* Early out ... We are done */
;;;368          }
;;;369        }
;;;370        /* Put it at the end of the list or before the last non "STAY-ON-TOP" child */
;;;371        do {
;;;372          WM_Obj* pNext;
;;;373          WM_HWIN hNext;
;;;374          if ((hNext = pi->hNext) == 0) {   /* End of sibling list ? */
;;;375            pi->hNext = hWin;             /* Then modify this last element to point to new one and we are done */
;;;376            break;
;;;377          }
;;;378          pNext = WM_H2P(hNext);
;;;379          if (!OnTop) {
;;;380            if (pNext->Status & WM_SF_STAYONTOP) {
;;;381              pi->hNext = hWin;
;;;382              pWin->hNext = hNext;
;;;383              break;
;;;384            }
;;;385          }
;;;386          pi = pNext;
;;;387        }  while (1);
;;;388        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;389          WM__NotifyVisChanged(hWin, &pWin->Rect);
;;;390        #endif
;;;391      }
;;;392    }
00003e  e8bd87f0          POP      {r4-r10,pc}
                  |L24.66|
000042  7f20              LDRB     r0,[r4,#0x1c]         ;364
000044  0700              LSLS     r0,r0,#28             ;364
000046  d502              BPL      |L24.78|
000048  f8a5801a          STRH     r8,[r5,#0x1a]         ;365
00004c  e7f6              B        |L24.60|
                  |L24.78|
00004e  f9b4601a          LDRSH    r6,[r4,#0x1a]         ;374
000052  b136              CBZ      r6,|L24.98|
000054  4630              MOV      r0,r6                 ;378
000056  f7fffffe          BL       GUI_ALLOC_h2p
00005a  f1b90f00          CMP      r9,#0                 ;379
00005e  d002              BEQ      |L24.102|
000060  e007              B        |L24.114|
                  |L24.98|
000062  8367              STRH     r7,[r4,#0x1a]         ;375
000064  e7eb              B        |L24.62|
                  |L24.102|
000066  7f01              LDRB     r1,[r0,#0x1c]         ;380
000068  0709              LSLS     r1,r1,#28             ;380
00006a  d502              BPL      |L24.114|
00006c  8367              STRH     r7,[r4,#0x1a]         ;381
00006e  836e              STRH     r6,[r5,#0x1a]         ;382
000070  e7e5              B        |L24.62|
                  |L24.114|
000072  4604              MOV      r4,r0                 ;386
000074  e7eb              B        |L24.78|
;;;393    
                          ENDP


                          AREA ||i.WM__Invalidate1Abs||, CODE, READONLY, ALIGN=2

                  WM__Invalidate1Abs PROC
;;;209    */
;;;210    void WM__Invalidate1Abs(WM_HWIN hWin, const GUI_RECT * pRect) {
000000  b57c              PUSH     {r2-r6,lr}
000002  460d              MOV      r5,r1
;;;211      GUI_RECT r;
;;;212      WM_Obj* pWin;
;;;213      int Status;
;;;214      pWin = WM_H2P(hWin);
000004  f7fffffe          BL       GUI_ALLOC_h2p
000008  4604              MOV      r4,r0
;;;215      Status = pWin->Status;
00000a  8b80              LDRH     r0,[r0,#0x1c]
;;;216      if ((Status & WM_SF_ISVIS) == 0) {
00000c  0781              LSLS     r1,r0,#30
00000e  d51c              BPL      |L25.74|
;;;217        return;   /* Window is not visible... we are done */
;;;218      }
;;;219      if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
000010  f6400101          MOV      r1,#0x801
000014  4008              ANDS     r0,r0,r1
000016  2801              CMP      r0,#1
000018  d017              BEQ      |L25.74|
;;;220        return;   /* Window is transparent; transparency may change... we are done, since background will be invalidated */
;;;221      }
;;;222      if (WM__RectIsNZ(pRect) == 0) {
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       WM__RectIsNZ
000020  2800              CMP      r0,#0
000022  d012              BEQ      |L25.74|
;;;223        return;   /* Nothing to do ... */
;;;224      }
;;;225      /* Calc affected area */
;;;226      GUI__IntersectRects(&r, pRect, &pWin->Rect);
000024  4622              MOV      r2,r4
000026  4629              MOV      r1,r5
000028  4668              MOV      r0,sp
00002a  f7fffffe          BL       GUI__IntersectRects
;;;227      if (WM__RectIsNZ(&r)) {
00002e  4668              MOV      r0,sp
000030  f7fffffe          BL       WM__RectIsNZ
000034  2800              CMP      r0,#0
000036  d008              BEQ      |L25.74|
;;;228        #if WM_SUPPORT_NOTIFY_VIS_CHANGED
;;;229          WM__SendMsgNoData(hWin, WM_NOTIFY_VIS_CHANGED);             /* Notify window that visibility may have changed */
;;;230        #endif
;;;231    
;;;232        if (pWin->Status & WM_SF_INVALID) {
000038  8ba0              LDRH     r0,[r4,#0x1c]
00003a  0681              LSLS     r1,r0,#26
00003c  d506              BPL      |L25.76|
;;;233          GUI_MergeRect(&pWin->InvalidRect, &pWin->InvalidRect, &r);
00003e  f1040108          ADD      r1,r4,#8
000042  466a              MOV      r2,sp
000044  4608              MOV      r0,r1
000046  f7fffffe          BL       GUI_MergeRect
                  |L25.74|
;;;234        } else {
;;;235          pWin->InvalidRect = r;
;;;236          pWin->Status |= WM_SF_INVALID;
;;;237          WM__NumInvalidWindows++;
;;;238          /* Optional code: Call external routine to notify that drawing is required */
;;;239          #ifdef GUI_X_REDRAW
;;;240          if (_IsInited) {
;;;241            GUI_RECT r;
;;;242            r = pWin->Rect;
;;;243            if (WM__ClipAtParentBorders(&r,  hWin)) {
;;;244              GUI_X_REDRAW(); /* Call hook function to signal an invalidation */
;;;245            }
;;;246          }
;;;247          #endif
;;;248          GUI_X_SIGNAL_EVENT();
;;;249        }
;;;250        /* Debug code: shows invalid areas */
;;;251        #if (WM_SUPPORT_DIAG)
;;;252          if (WM__pfShowInvalid) {
;;;253            (WM__pfShowInvalid)(hWin);
;;;254          }
;;;255        #endif
;;;256      }
;;;257    }
00004a  bd7c              POP      {r2-r6,pc}
                  |L25.76|
00004c  e9dd1200          LDRD     r1,r2,[sp,#0]
000050  e9c41202          STRD     r1,r2,[r4,#8]         ;236
000054  f0400020          ORR      r0,r0,#0x20           ;236
000058  83a0              STRH     r0,[r4,#0x1c]         ;236
00005a  4802              LDR      r0,|L25.100|
00005c  88c1              LDRH     r1,[r0,#6]            ;237  ; WM__NumInvalidWindows
00005e  1c49              ADDS     r1,r1,#1              ;237
000060  80c1              STRH     r1,[r0,#6]            ;237
000062  bd7c              POP      {r2-r6,pc}
;;;258    
                          ENDP

                  |L25.100|
                          DCD      ||.data||

                          AREA ||i.WM__InvalidateRectEx||, CODE, READONLY, ALIGN=2

                  WM__InvalidateRectEx PROC
;;;534    */
;;;535    void WM__InvalidateRectEx(const GUI_RECT* pInvalidRect, WM_HWIN hParent, WM_HWIN hStop) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4616              MOV      r6,r2
000006  4680              MOV      r8,r0
000008  000f              MOVS     r7,r1
00000a  d02f              BEQ      |L26.108|
;;;536      GUI_RECT Rect;
;;;537      WM_Obj*  pParent;
;;;538      WM_Obj*  pi;
;;;539      WM_HWIN  hi;
;;;540      int Status;
;;;541    
;;;542      /* Perform some parameter checks and check for "early out" conditions. */
;;;543      if (hParent == 0) {
;;;544        return;                                                            /* Desktop window or unattached wind. Nothing to do. */
;;;545      }
;;;546      pParent = WM_H2P(hParent);
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       GUI_ALLOC_h2p
;;;547      Status  = pParent->Status;
000012  8b85              LDRH     r5,[r0,#0x1c]
000014  4604              MOV      r4,r0                 ;546
;;;548      if ((Status & WM_SF_ISVIS) == 0) {
000016  07a8              LSLS     r0,r5,#30
000018  d528              BPL      |L26.108|
;;;549        return;                                                            /* Window is not visible... we are done */
;;;550      }
;;;551      if (GUI__IntersectRects(&Rect, pInvalidRect, &pParent->Rect) == 0) {  /* Limit the given rect to the area of the parent window */
00001a  4622              MOV      r2,r4
00001c  4641              MOV      r1,r8
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       GUI__IntersectRects
000024  2800              CMP      r0,#0
000026  d021              BEQ      |L26.108|
;;;552        return;                                                            /* No intersection, nothing to do */
;;;553      }
;;;554      /* Invalidate the rectangle in the parent */
;;;555      /* If the parent is (partially) transparent, we need to move up in the hierarchy */
;;;556      if ((Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) == WM_SF_HASTRANS) {
000028  f6400001          MOV      r0,#0x801
00002c  4005              ANDS     r5,r5,r0
00002e  2d01              CMP      r5,#1
000030  d007              BEQ      |L26.66|
;;;557        WM__InvalidateRectEx(&Rect, pParent->hParent, pParent->hNext);
;;;558      } else {
;;;559        WM__Invalidate1Abs(hParent, &Rect);
000032  4669              MOV      r1,sp
000034  4638              MOV      r0,r7
000036  f7fffffe          BL       WM__Invalidate1Abs
;;;560      }
;;;561      /* Invalidate siblings up to hStop */
;;;562      for (hi = pParent->hFirstChild; hi; hi = pi->hNext) {
00003a  bf00              NOP      
                  |L26.60|
00003c  f9b44018          LDRSH    r4,[r4,#0x18]
000040  e012              B        |L26.104|
                  |L26.66|
000042  f9b4201a          LDRSH    r2,[r4,#0x1a]         ;557
000046  f9b41016          LDRSH    r1,[r4,#0x16]         ;557
00004a  4668              MOV      r0,sp                 ;557
00004c  f7fffffe          BL       WM__InvalidateRectEx
000050  e7f4              B        |L26.60|
                  |L26.82|
;;;563        if (hi == hStop) {
000052  42b4              CMP      r4,r6
000054  d00a              BEQ      |L26.108|
;;;564          break;
;;;565        }
;;;566        WM_InvalidateWindowAndDescsEx(hi, &Rect);
000056  4669              MOV      r1,sp
000058  4620              MOV      r0,r4
00005a  f7fffffe          BL       WM_InvalidateWindowAndDescsEx
;;;567        pi = WM_H2P(hi);
00005e  4620              MOV      r0,r4
000060  f7fffffe          BL       GUI_ALLOC_h2p
000064  f9b0401a          LDRSH    r4,[r0,#0x1a]         ;562
                  |L26.104|
000068  2c00              CMP      r4,#0                 ;562
00006a  d1f2              BNE      |L26.82|
                  |L26.108|
;;;568      }
;;;569    }
00006c  e8bd81fc          POP      {r2-r8,pc}
;;;570    
                          ENDP


                          AREA ||i.WM__IsWindow||, CODE, READONLY, ALIGN=2

                  WM__IsWindow PROC
;;;470    */
;;;471    int WM__IsWindow(WM_HWIN hWin) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;472      WM_HWIN iWin;
;;;473      for (iWin = WM__FirstWin; iWin; iWin = WM_H2P(iWin)->hNextLin) {
000004  4807              LDR      r0,|L27.36|
000006  f9b00008          LDRSH    r0,[r0,#8]  ; WM__FirstWin
00000a  e007              B        |L27.28|
                  |L27.12|
;;;474        if (iWin == hWin) {
00000c  42a0              CMP      r0,r4
00000e  d101              BNE      |L27.20|
;;;475          return 1;
000010  2001              MOVS     r0,#1
;;;476        }
;;;477      }
;;;478      return 0;
;;;479    }
000012  bd10              POP      {r4,pc}
                  |L27.20|
000014  f7fffffe          BL       GUI_ALLOC_h2p
000018  f9b00014          LDRSH    r0,[r0,#0x14]         ;473
                  |L27.28|
00001c  2800              CMP      r0,#0                 ;473
00001e  d1f5              BNE      |L27.12|
000020  bd10              POP      {r4,pc}
;;;480    
                          ENDP

000022  0000              DCW      0x0000
                  |L27.36|
                          DCD      ||.data||

                          AREA ||i.WM__Paint||, CODE, READONLY, ALIGN=2

                  WM__Paint PROC
;;;1584   */
;;;1585   int WM__Paint(WM_HWIN hWin, WM_Obj* pWin) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
;;;1586     int Ret = 0;
;;;1587     if (pWin->Status & WM_SF_INVALID) {
000004  7f08              LDRB     r0,[r1,#0x1c]
000006  2500              MOVS     r5,#0                 ;1586
000008  b086              SUB      sp,sp,#0x18           ;1585
00000a  460c              MOV      r4,r1                 ;1585
00000c  0680              LSLS     r0,r0,#26
00000e  d536              BPL      |L28.126|
;;;1588       if (pWin->cb) {
000010  6920              LDR      r0,[r4,#0x10]
000012  b308              CBZ      r0,|L28.88|
;;;1589         if (WM__ClipAtParentBorders(&pWin->InvalidRect, hWin)) {
000014  4631              MOV      r1,r6
000016  f1040008          ADD      r0,r4,#8
00001a  f7fffffe          BL       WM__ClipAtParentBorders
00001e  b1d8              CBZ      r0,|L28.88|
;;;1590           WM_PAINTINFO Info;
;;;1591           Info.hWin = hWin;
000020  f8ad6004          STRH     r6,[sp,#4]
;;;1592           WM_SelectWindow(hWin);
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       WM_SelectWindow
;;;1593           #if GUI_SUPPORT_MEMDEV
;;;1594             Info.pWin = NULL; /* 'Invalidate' the window pointer, because it can 
00002a  2000              MOVS     r0,#0
;;;1595                                   become invalid through the creation of a memory device
;;;1596                               */
;;;1597             if (pWin->Status & WM_SF_MEMDEV) {
00002c  9002              STR      r0,[sp,#8]
00002e  7f20              LDRB     r0,[r4,#0x1c]
000030  0740              LSLS     r0,r0,#29
000032  d512              BPL      |L28.90|
000034  e9d40102          LDRD     r0,r1,[r4,#8]
000038  e9cd0103          STRD     r0,r1,[sp,#0xc]
;;;1598               int Flags;
;;;1599               GUI_RECT r = pWin->InvalidRect;
;;;1600               Flags = (pWin->Status & WM_SF_HASTRANS) ? GUI_MEMDEV_HASTRANS : GUI_MEMDEV_NOTRANS;
00003c  7f20              LDRB     r0,[r4,#0x1c]
;;;1601               /*
;;;1602                * Currently we treat a desktop window as transparent, because per default it does not repaint itself.
;;;1603                */
;;;1604               if (pWin->hParent == 0) {
00003e  8ae1              LDRH     r1,[r4,#0x16]
000040  f3400000          SBFX     r0,r0,#0,#1           ;1600
000044  1c40              ADDS     r0,r0,#1
000046  b901              CBNZ     r1,|L28.74|
;;;1605                 Flags = GUI_MEMDEV_HASTRANS;
000048  2000              MOVS     r0,#0
                  |L28.74|
;;;1606               }
;;;1607               GUI_MEMDEV_Draw(&r, _cbPaintMemDev, &Info, 0, Flags);
00004a  9000              STR      r0,[sp,#0]
00004c  2300              MOVS     r3,#0
00004e  aa01              ADD      r2,sp,#4
000050  490c              LDR      r1,|L28.132|
000052  a803              ADD      r0,sp,#0xc
000054  f7fffffe          BL       GUI_MEMDEV_Draw
                  |L28.88|
;;;1608             } else
000058  e004              B        |L28.100|
                  |L28.90|
;;;1609           #endif
;;;1610           {
;;;1611             Info.pWin = pWin;
;;;1612             WM__PaintWinAndOverlays(&Info);
00005a  a801              ADD      r0,sp,#4
00005c  9402              STR      r4,[sp,#8]
00005e  f7fffffe          BL       WM__PaintWinAndOverlays
;;;1613             Ret = 1;    /* Something has been done */
000062  2501              MOVS     r5,#1
                  |L28.100|
;;;1614           }
;;;1615         }
;;;1616       }
;;;1617       /* We purposly clear the invalid flag after painting so we can still query the invalid rectangle while painting */
;;;1618       pWin->Status &=  ~WM_SF_INVALID; /* Clear invalid flag */
000064  8ba0              LDRH     r0,[r4,#0x1c]
000066  f0200020          BIC      r0,r0,#0x20
00006a  83a0              STRH     r0,[r4,#0x1c]
;;;1619       if (pWin->Status & WM_CF_MEMDEV_ON_REDRAW) {
00006c  0481              LSLS     r1,r0,#18
00006e  d502              BPL      |L28.118|
;;;1620         pWin->Status |= WM_CF_MEMDEV;
000070  f0400004          ORR      r0,r0,#4
000074  83a0              STRH     r0,[r4,#0x1c]
                  |L28.118|
;;;1621       }
;;;1622       WM__NumInvalidWindows--;
000076  4904              LDR      r1,|L28.136|
000078  88c8              LDRH     r0,[r1,#6]  ; WM__NumInvalidWindows
00007a  1e40              SUBS     r0,r0,#1
00007c  80c8              STRH     r0,[r1,#6]
                  |L28.126|
;;;1623     }
;;;1624     return Ret;      /* Nothing done */
;;;1625   }
00007e  b006              ADD      sp,sp,#0x18
000080  4628              MOV      r0,r5                 ;1624
000082  bd70              POP      {r4-r6,pc}
;;;1626   
                          ENDP

                  |L28.132|
                          DCD      _cbPaintMemDev
                  |L28.136|
                          DCD      ||.data||

                          AREA ||i.WM__PaintWinAndOverlays||, CODE, READONLY, ALIGN=2

                  WM__PaintWinAndOverlays PROC
;;;1518   */
;;;1519   void WM__PaintWinAndOverlays(WM_PAINTINFO* pInfo) {
000000  b570              PUSH     {r4-r6,lr}
;;;1520     WM_HWIN hWin;
;;;1521     WM_Obj* pWin;
;;;1522     hWin = pInfo->hWin;
000002  f9b04000          LDRSH    r4,[r0,#0]
000006  6841              LDR      r1,[r0,#4]            ;1519
000008  b919              CBNZ     r1,|L29.18|
;;;1523     pWin = pInfo->pWin;
;;;1524     if (!pWin) {
;;;1525       pWin = WM_H2P(hWin);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       GUI_ALLOC_h2p
000010  4601              MOV      r1,r0
                  |L29.18|
;;;1526     }
;;;1527     #if WM_SUPPORT_TRANSPARENCY
;;;1528       /* Transparent windows without const outline are drawn as part of the background and can be skipped. */
;;;1529       if ((pWin->Status & (WM_SF_HASTRANS | WM_SF_CONST_OUTLINE)) != WM_SF_HASTRANS) {
000012  f6400201          MOV      r2,#0x801
000016  8b88              LDRH     r0,[r1,#0x1c]
000018  4010              ANDS     r0,r0,r2
00001a  2801              CMP      r0,#1
00001c  d006              BEQ      |L29.44|
;;;1530     #endif
;;;1531     _Paint1(hWin, pWin);    /* Draw the window itself */
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       _Paint1
;;;1532     #if GUI_SUPPORT_MEMDEV
;;;1533       /* Within the paint event the application is alowed to deal with memory devices.
;;;1534          So the pointer(s) could be invalid after the last function call and needs
;;;1535          to be restored.
;;;1536       */
;;;1537       pWin = WM_H2P(hWin);
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       GUI_ALLOC_h2p
00002a  4601              MOV      r1,r0
                  |L29.44|
;;;1538     #endif
;;;1539     #if WM_SUPPORT_TRANSPARENCY
;;;1540       }
;;;1541       if (WM__TransWindowCnt != 0) {
00002c  4818              LDR      r0,|L29.144|
00002e  6a40              LDR      r0,[r0,#0x24]  ; WM__TransWindowCnt
000030  2800              CMP      r0,#0
000032  d02b              BEQ      |L29.140|
;;;1542         _PaintTransChildren(hWin, pWin);             /* Draw all transparent children */
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       _PaintTransChildren
;;;1543         #if GUI_SUPPORT_MEMDEV
;;;1544           /* Within the paint event the application is alowed to deal with memory devices.
;;;1545              So the pointer(s) could be invalid after the last function call and needs
;;;1546              to be restored.
;;;1547           */
;;;1548           pWin = WM_H2P(hWin);
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       GUI_ALLOC_h2p
000040  f9b05016          LDRSH    r5,[r0,#0x16]
000044  f9b0601a          LDRSH    r6,[r0,#0x1a]
;;;1549         #endif
;;;1550         _PaintTransTopSiblings(hWin, pWin);    /* Draw all transparent top level siblings */
000048  e01e              B        |L29.136|
                  |L29.74|
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       GUI_ALLOC_h2p
000050  4604              MOV      r4,r0
000052  7f00              LDRB     r0,[r0,#0x1c]
000054  43c0              MVNS     r0,r0
000056  0780              LSLS     r0,r0,#30
000058  d107              BNE      |L29.106|
00005a  4621              MOV      r1,r4
00005c  4630              MOV      r0,r6
00005e  f7fffffe          BL       _Paint1Trans
000062  4630              MOV      r0,r6
000064  f7fffffe          BL       GUI_ALLOC_h2p
000068  4604              MOV      r4,r0
                  |L29.106|
00006a  4621              MOV      r1,r4
00006c  4630              MOV      r0,r6
00006e  f7fffffe          BL       _PaintTransChildren
000072  f9b4601a          LDRSH    r6,[r4,#0x1a]
                  |L29.118|
000076  2e00              CMP      r6,#0
000078  d1e7              BNE      |L29.74|
00007a  4628              MOV      r0,r5
00007c  f7fffffe          BL       GUI_ALLOC_h2p
000080  f9b0601a          LDRSH    r6,[r0,#0x1a]
000084  f9b05016          LDRSH    r5,[r0,#0x16]
                  |L29.136|
000088  2d00              CMP      r5,#0
00008a  d1f4              BNE      |L29.118|
                  |L29.140|
;;;1551       }
;;;1552     #endif
;;;1553   }
00008c  bd70              POP      {r4-r6,pc}
;;;1554   
                          ENDP

00008e  0000              DCW      0x0000
                  |L29.144|
                          DCD      ||.data||

                          AREA ||i.WM__RectIsNZ||, CODE, READONLY, ALIGN=1

                  WM__RectIsNZ PROC
;;;613    */
;;;614    int WM__RectIsNZ(const GUI_RECT* pr) {
000000  f9b01000          LDRSH    r1,[r0,#0]
;;;615      if (pr->x0 > pr->x1)
000004  f9b02004          LDRSH    r2,[r0,#4]
000008  4291              CMP      r1,r2
00000a  dc05              BGT      |L30.24|
;;;616        return 0;
;;;617      if (pr->y0 > pr->y1)
00000c  f9b01002          LDRSH    r1,[r0,#2]
000010  f9b00006          LDRSH    r0,[r0,#6]
000014  4281              CMP      r1,r0
000016  dd01              BLE      |L30.28|
                  |L30.24|
;;;618        return 0;
000018  2000              MOVS     r0,#0
;;;619      return 1;
;;;620    }
00001a  4770              BX       lr
                  |L30.28|
00001c  2001              MOVS     r0,#1                 ;619
00001e  4770              BX       lr
;;;621    
                          ENDP


                          AREA ||i.WM__RemoveFromLinList||, CODE, READONLY, ALIGN=2

                  WM__RemoveFromLinList PROC
;;;574    */
;;;575    void WM__RemoveFromLinList(WM_HWIN hWin) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;576      WM_Obj* piWin;
;;;577      WM_HWIN hiWin;
;;;578      WM_HWIN hNext;
;;;579      for (hiWin = WM__FirstWin; hiWin; ) {
000004  4809              LDR      r0,|L31.44|
000006  f9b00008          LDRSH    r0,[r0,#8]  ; WM__FirstWin
00000a  e00c              B        |L31.38|
                  |L31.12|
;;;580        piWin = WM_H2P(hiWin);
00000c  f7fffffe          BL       GUI_ALLOC_h2p
000010  4604              MOV      r4,r0
;;;581        hNext = piWin->hNextLin;
000012  f9b00014          LDRSH    r0,[r0,#0x14]
;;;582        if (hNext == hWin) {
000016  42a8              CMP      r0,r5
000018  d105              BNE      |L31.38|
;;;583          piWin->hNextLin = WM_H2P(hWin)->hNextLin;
00001a  4628              MOV      r0,r5
00001c  f7fffffe          BL       GUI_ALLOC_h2p
000020  8a80              LDRH     r0,[r0,#0x14]
000022  82a0              STRH     r0,[r4,#0x14]
;;;584          break;
;;;585        }
;;;586        hiWin = hNext;
;;;587      }
;;;588    }
000024  bd70              POP      {r4-r6,pc}
                  |L31.38|
000026  2800              CMP      r0,#0                 ;579
000028  d1f0              BNE      |L31.12|
00002a  bd70              POP      {r4-r6,pc}
;;;589    
                          ENDP

                  |L31.44|
                          DCD      ||.data||

                          AREA ||i.WM__RemoveWindowFromList||, CODE, READONLY, ALIGN=2

                  WM__RemoveWindowFromList PROC
;;;397    */
;;;398    void WM__RemoveWindowFromList(WM_HWIN hWin) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
;;;399      WM_HWIN hi, hParent;
;;;400      WM_Obj * pWin, * pParent, * pi;
;;;401      
;;;402      pWin = WM_H2P(hWin);
000004  f7fffffe          BL       GUI_ALLOC_h2p
000008  4605              MOV      r5,r0
;;;403      hParent = pWin->hParent;
00000a  f9b00016          LDRSH    r0,[r0,#0x16]
;;;404      if (hParent) {
00000e  2800              CMP      r0,#0
000010  d00a              BEQ      |L32.40|
;;;405        pParent = WM_H2P(hParent);
000012  f7fffffe          BL       GUI_ALLOC_h2p
000016  4604              MOV      r4,r0
;;;406        hi = pParent->hFirstChild;
000018  f9b00018          LDRSH    r0,[r0,#0x18]
;;;407        if (hi == hWin) {
00001c  42b0              CMP      r0,r6
00001e  d10f              BNE      |L32.64|
;;;408          pi = WM_H2P(hi);
000020  f7fffffe          BL       GUI_ALLOC_h2p
;;;409          pParent->hFirstChild = pi->hNext;
000024  8b40              LDRH     r0,[r0,#0x1a]
000026  8320              STRH     r0,[r4,#0x18]
                  |L32.40|
;;;410        } else {
;;;411          while (hi) {
;;;412            pi = WM_H2P(hi);
;;;413            if (pi->hNext == hWin) {
;;;414              pi->hNext = pWin->hNext;
;;;415              break;
;;;416            }
;;;417            hi = pi->hNext;
;;;418          }
;;;419        }
;;;420      }
;;;421    }
000028  bd70              POP      {r4-r6,pc}
00002a  bf00              NOP                            ;412
                  |L32.44|
00002c  f7fffffe          BL       GUI_ALLOC_h2p
000030  4601              MOV      r1,r0                 ;412
000032  f9b0001a          LDRSH    r0,[r0,#0x1a]         ;413
000036  42b0              CMP      r0,r6                 ;413
000038  d102              BNE      |L32.64|
00003a  8b68              LDRH     r0,[r5,#0x1a]         ;414
00003c  8348              STRH     r0,[r1,#0x1a]         ;414
00003e  bd70              POP      {r4-r6,pc}
                  |L32.64|
000040  2800              CMP      r0,#0                 ;411
000042  d1f3              BNE      |L32.44|
000044  bd70              POP      {r4-r6,pc}
;;;422    
                          ENDP


                          AREA ||i.WM__SendMsgNoData||, CODE, READONLY, ALIGN=1

                  WM__SendMsgNoData PROC
;;;753    */
;;;754    void WM__SendMsgNoData(WM_HWIN hWin, U8 MsgId) {
000000  b50e              PUSH     {r1-r3,lr}
;;;755      WM_MESSAGE Msg;
;;;756      Msg.hWin  = hWin;
;;;757      Msg.MsgId = MsgId;
;;;758      WM__SendMessage(hWin, &Msg);
000002  9100              STR      r1,[sp,#0]
000004  f8ad0004          STRH     r0,[sp,#4]            ;756
000008  4669              MOV      r1,sp
00000a  f7fffffe          BL       WM__SendMessage
;;;759    }
00000e  bd0e              POP      {r1-r3,pc}
;;;760    
                          ENDP


                          AREA ||i._DeleteAllChildren||, CODE, READONLY, ALIGN=1

                  _DeleteAllChildren PROC
;;;446    */
;;;447    static void _DeleteAllChildren(WM_Obj * pParent) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
                  |L34.4|
;;;448      do {
;;;449        WM_DeleteWindow(pParent->hFirstChild);
000004  f9b40018          LDRSH    r0,[r4,#0x18]
000008  f7fffffe          BL       WM_DeleteWindow
;;;450      } while (pParent->hFirstChild);
00000c  8b20              LDRH     r0,[r4,#0x18]
00000e  2800              CMP      r0,#0
000010  d1f8              BNE      |L34.4|
;;;451    }
000012  bd10              POP      {r4,pc}
;;;452    
                          ENDP


                          AREA ||i._FindNext_IVR||, CODE, READONLY, ALIGN=2

                  _FindNext_IVR PROC
;;;1071   #if WM_SUPPORT_OBSTRUCT
;;;1072   static int _FindNext_IVR(void) {
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;1073     WM_HMEM hParent;
;;;1074     GUI_RECT r;
;;;1075     WM_Obj* pAWin;
;;;1076     WM_Obj* pParent;
;;;1077     r = _ClipContext.CurRect;  /* temps  so we do not have to work with pointers too much */
000004  4c4d              LDR      r4,|L35.316|
000006  e9d40102          LDRD     r0,r1,[r4,#8]
00000a  e9cd0100          STRD     r0,r1,[sp,#0]
00000e  6920              LDR      r0,[r4,#0x10]         ;1072  ; _ClipContext
000010  b368              CBZ      r0,|L35.110|
;;;1078     /*
;;;1079        STEP 1:
;;;1080          Set the next position which could be part of the next IVR
;;;1081          This will be the first unhandle pixel in reading order, i.e. next one to the right
;;;1082          or next one down if we are at the right border.
;;;1083     */
;;;1084     if (_ClipContext.Cnt == 0) {       /* First IVR starts in upper left */
;;;1085       r.x0 = _ClipContext.ClientRect.x0;
;;;1086       r.y0 = _ClipContext.ClientRect.y0;
;;;1087     } else {
;;;1088       r.x0 = _ClipContext.CurRect.x1+1;
000012  89a0              LDRH     r0,[r4,#0xc]  ; _ClipContext
000014  1c40              ADDS     r0,r0,#1
000016  b200              SXTH     r0,r0
000018  f8ad0000          STRH     r0,[sp,#0]
;;;1089       r.y0 = _ClipContext.CurRect.y0;
00001c  8961              LDRH     r1,[r4,#0xa]  ; _ClipContext
00001e  f8ad1002          STRH     r1,[sp,#2]
;;;1090       if (r.x0 > _ClipContext.ClientRect.x1) {
000022  f9b41004          LDRSH    r1,[r4,#4]  ; _ClipContext
000026  4288              CMP      r0,r1
000028  dd06              BLE      |L35.56|
                  |L35.42|
;;;1091   NextStripe:  /* go down to next stripe */
;;;1092         r.x0 = _ClipContext.ClientRect.x0;
00002a  8820              LDRH     r0,[r4,#0]  ; _ClipContext
00002c  f8ad0000          STRH     r0,[sp,#0]
;;;1093         r.y0 = _ClipContext.CurRect.y1+1;
000030  89e0              LDRH     r0,[r4,#0xe]  ; _ClipContext
000032  1c40              ADDS     r0,r0,#1
                  |L35.52|
000034  f8ad0002          STRH     r0,[sp,#2]
                  |L35.56|
;;;1094       }
;;;1095     }
;;;1096     /*
;;;1097        STEP 2:
;;;1098          Check if we are done completely.
;;;1099     */
;;;1100     if (r.y0 >_ClipContext.ClientRect.y1) {
000038  f9bd0002          LDRSH    r0,[sp,#2]
00003c  f9b41006          LDRSH    r1,[r4,#6]  ; _ClipContext
000040  4288              CMP      r0,r1
000042  dc71              BGT      |L35.296|
;;;1101       return 0;
;;;1102     }
;;;1103     /* STEP 3:
;;;1104          Find out the max. height (r.y1) if we are at the left border.
;;;1105          Since we are using the same height for all IVRs at the same y0,
;;;1106          we do this only for the leftmost one.
;;;1107     */
;;;1108     pAWin = WM_H2P(GUI_Context.hAWin);
000044  4e3e              LDR      r6,|L35.320|
000046  f9b60040          LDRSH    r0,[r6,#0x40]  ; GUI_Context
00004a  f7fffffe          BL       GUI_ALLOC_h2p
00004e  4605              MOV      r5,r0
;;;1109     if (r.x0 == _ClipContext.ClientRect.x0) {
000050  f9bd0000          LDRSH    r0,[sp,#0]
000054  f9b41000          LDRSH    r1,[r4,#0]  ; _ClipContext
000058  4288              CMP      r0,r1
00005a  d120              BNE      |L35.158|
;;;1110       r.y1 = _ClipContext.ClientRect.y1;
00005c  88e0              LDRH     r0,[r4,#6]  ; _ClipContext
00005e  f8ad0006          STRH     r0,[sp,#6]
;;;1111       r.x1 = _ClipContext.ClientRect.x1;
000062  88a0              LDRH     r0,[r4,#4]  ; _ClipContext
000064  f8ad0004          STRH     r0,[sp,#4]
;;;1112       /* Iterate over all windows which are above */
;;;1113       /* Check all siblings above (Iterate over Parents and top siblings (hNext) */
;;;1114       for (hParent = GUI_Context.hAWin; hParent; hParent = pParent->hParent) {
000068  f9b60040          LDRSH    r0,[r6,#0x40]  ; GUI_Context
00006c  e00f              B        |L35.142|
                  |L35.110|
00006e  8820              LDRH     r0,[r4,#0]            ;1085  ; _ClipContext
000070  f8ad0000          STRH     r0,[sp,#0]            ;1085
000074  8860              LDRH     r0,[r4,#2]            ;1086  ; _ClipContext
000076  e7dd              B        |L35.52|
                  |L35.120|
;;;1115         pParent = WM_H2P(hParent);
000078  f7fffffe          BL       GUI_ALLOC_h2p
00007c  4607              MOV      r7,r0
;;;1116         _Findy1(pParent->hNext, &r, NULL);
00007e  f9b0001a          LDRSH    r0,[r0,#0x1a]
000082  2200              MOVS     r2,#0
000084  4669              MOV      r1,sp
000086  f7fffffe          BL       _Findy1
00008a  f9b70016          LDRSH    r0,[r7,#0x16]         ;1114
                  |L35.142|
00008e  2800              CMP      r0,#0                 ;1114
000090  d1f2              BNE      |L35.120|
;;;1117       }
;;;1118       /* Check all children */
;;;1119       _Findy1(pAWin->hFirstChild, &r, NULL);
000092  f9b50018          LDRSH    r0,[r5,#0x18]
000096  2200              MOVS     r2,#0
000098  4669              MOV      r1,sp
00009a  f7fffffe          BL       _Findy1
                  |L35.158|
;;;1120     }
;;;1121     /* 
;;;1122       STEP 4
;;;1123         Find out x0 for the given y0, y1 by iterating over windows above.
;;;1124         if we find one that intersects, adjust x0 to the right.
;;;1125     */
;;;1126   Find_x0:
;;;1127     r.x1 = r.x0;
00009e  f8bd0000          LDRH     r0,[sp,#0]
0000a2  f8ad0004          STRH     r0,[sp,#4]
;;;1128     /* Iterate over all windows which are above */
;;;1129     /* Check all siblings above (siblings of window, siblings of parents, etc ...) */
;;;1130     #if 0   /* This is a planned, but not yet released optimization */
;;;1131       if (Status & WM_SF_DONT_CLIP_SIBLINGS)
;;;1132       {
;;;1133         hParent = pAWin->hParent;
;;;1134       } else
;;;1135     #endif
;;;1136     {
;;;1137       hParent = GUI_Context.hAWin;
0000a6  f9b60040          LDRSH    r0,[r6,#0x40]  ; GUI_Context
;;;1138     }
;;;1139     for (; hParent; hParent = pParent->hParent) {
0000aa  e00c              B        |L35.198|
                  |L35.172|
;;;1140       pParent = WM_H2P(hParent);
0000ac  f7fffffe          BL       GUI_ALLOC_h2p
0000b0  4607              MOV      r7,r0
;;;1141       if (_Findx0(pParent->hNext, &r, NULL)) {
0000b2  f9b0001a          LDRSH    r0,[r0,#0x1a]
0000b6  2200              MOVS     r2,#0
0000b8  4669              MOV      r1,sp
0000ba  f7fffffe          BL       _Findx0
0000be  2800              CMP      r0,#0
0000c0  d1ed              BNE      |L35.158|
0000c2  f9b70016          LDRSH    r0,[r7,#0x16]         ;1139
                  |L35.198|
0000c6  2800              CMP      r0,#0                 ;1139
0000c8  d1f0              BNE      |L35.172|
;;;1142         goto Find_x0;
;;;1143       }
;;;1144     }
;;;1145     /* Check all children */
;;;1146     if (_Findx0(pAWin->hFirstChild, &r, NULL)) {
0000ca  f9b50018          LDRSH    r0,[r5,#0x18]
0000ce  2200              MOVS     r2,#0
0000d0  4669              MOV      r1,sp
0000d2  f7fffffe          BL       _Findx0
0000d6  2800              CMP      r0,#0
0000d8  d1e1              BNE      |L35.158|
;;;1147       goto Find_x0;
;;;1148     }
;;;1149     /* 
;;;1150      STEP 5:
;;;1151        If r.x0 out of right border, this stripe is done. Set next stripe and goto STEP 2
;;;1152        Find out x1 for the given x0, y0, y1
;;;1153     */
;;;1154     r.x1 = _ClipContext.ClientRect.x1;
0000da  f9b40004          LDRSH    r0,[r4,#4]  ; _ClipContext
;;;1155     if (r.x1 < r.x0) {/* horizontal border reached ? */
0000de  f9bd1000          LDRSH    r1,[sp,#0]
0000e2  f8ad0004          STRH     r0,[sp,#4]            ;1154
0000e6  4288              CMP      r0,r1
0000e8  da04              BGE      |L35.244|
0000ea  e9dd0100          LDRD     r0,r1,[sp,#0]
0000ee  e9c40102          STRD     r0,r1,[r4,#8]
;;;1156       _ClipContext.CurRect = r;
;;;1157       goto NextStripe;
0000f2  e79a              B        |L35.42|
                  |L35.244|
;;;1158     }    
;;;1159     /* 
;;;1160      STEP 6:
;;;1161        Find r.x1. We have to Iterate over all windows which are above
;;;1162     */
;;;1163     /* Check all siblings above (Iterate over Parents and top siblings (hNext) */
;;;1164     #if 0   /* This is a planned, but not yet released optimization */
;;;1165       if (Status & WM_SF_DONT_CLIP_SIBLINGS)
;;;1166       {
;;;1167         hParent = pAWin->hParent;
;;;1168       } else
;;;1169     #endif
;;;1170     {
;;;1171       hParent = GUI_Context.hAWin;
0000f4  f9b60040          LDRSH    r0,[r6,#0x40]  ; GUI_Context
;;;1172     }
;;;1173     for (; hParent; hParent = pParent->hParent) {
0000f8  e00b              B        |L35.274|
;;;1174       pParent = WM_H2P(hParent);
0000fa  bf00              NOP      
                  |L35.252|
0000fc  f7fffffe          BL       GUI_ALLOC_h2p
000100  4606              MOV      r6,r0
;;;1175       _Findx1(pParent->hNext, &r, NULL);
000102  f9b0001a          LDRSH    r0,[r0,#0x1a]
000106  2200              MOVS     r2,#0
000108  4669              MOV      r1,sp
00010a  f7fffffe          BL       _Findx1
00010e  f9b60016          LDRSH    r0,[r6,#0x16]         ;1173
                  |L35.274|
000112  2800              CMP      r0,#0                 ;1173
000114  d1f2              BNE      |L35.252|
;;;1176     }
;;;1177     /* Check all children */
;;;1178     _Findx1(pAWin->hFirstChild, &r, NULL);
000116  f9b50018          LDRSH    r0,[r5,#0x18]
00011a  2200              MOVS     r2,#0
00011c  4669              MOV      r1,sp
00011e  f7fffffe          BL       _Findx1
;;;1179     /* We are done. Return the rectangle we found in the _ClipContext. */
;;;1180     if (_ClipContext.Cnt >200) {
000122  6920              LDR      r0,[r4,#0x10]  ; _ClipContext
000124  28c8              CMP      r0,#0xc8
000126  dd02              BLE      |L35.302|
                  |L35.296|
;;;1181       return 0;  /* error !!! This should not happen !*/
000128  2000              MOVS     r0,#0
                  |L35.298|
;;;1182     }
;;;1183     _ClipContext.CurRect = r;
;;;1184     return 1;  /* IVR is valid ! */
;;;1185   }
00012a  e8bd81fc          POP      {r2-r8,pc}
                  |L35.302|
00012e  e9dd0100          LDRD     r0,r1,[sp,#0]
000132  e9c40102          STRD     r0,r1,[r4,#8]
000136  2001              MOVS     r0,#1                 ;1184
000138  e7f7              B        |L35.298|
;;;1186   
                          ENDP

00013a  0000              DCW      0x0000
                  |L35.316|
                          DCD      ||area_number.47||
                  |L35.320|
                          DCD      GUI_Context

                          AREA ||i._Findx0||, CODE, READONLY, ALIGN=1

                  _Findx0 PROC
;;;664    */
;;;665    static int _Findx0(WM_HWIN hWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
000000  e92d47fc          PUSH     {r2-r10,lr}
000004  4690              MOV      r8,r2
000006  4689              MOV      r9,r1
;;;666      WM_Obj* pWin;
;;;667      int r = 0;
000008  2500              MOVS     r5,#0
00000a  e034              B        |L36.118|
                  |L36.12|
;;;668      for (; hWin; hWin = pWin->hNext) { 
;;;669        int Status = (pWin = WM_H2P(hWin))->Status;
00000c  f7fffffe          BL       GUI_ALLOC_h2p
000010  8b86              LDRH     r6,[r0,#0x1c]
000012  4604              MOV      r4,r0
;;;670        if (Status & WM_SF_ISVIS) {           /* If window is not visible, it can be safely ignored */
000014  07b0              LSLS     r0,r6,#30
000016  d52c              BPL      |L36.114|
;;;671          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;672          if (pParentRect) {
000018  ea5f0008          MOVS     r0,r8
00001c  d005              BEQ      |L36.42|
;;;673            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
00001e  4602              MOV      r2,r0
000020  4621              MOV      r1,r4
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       GUI__IntersectRects
000028  e003              B        |L36.50|
                  |L36.42|
00002a  e9d40100          LDRD     r0,r1,[r4,#0]
00002e  e9cd0100          STRD     r0,r1,[sp,#0]
                  |L36.50|
;;;674          } else {
;;;675            rWinClipped = pWin->Rect;
;;;676          }
;;;677          /* Check if this window affects us at all */    
;;;678          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
000032  4669              MOV      r1,sp
000034  4648              MOV      r0,r9
000036  f7fffffe          BL       GUI_RectsIntersect
00003a  b1d0              CBZ      r0,|L36.114|
;;;679            if ((Status & WM_SF_HASTRANS) == 0) {
00003c  07f0              LSLS     r0,r6,#31
00003e  d002              BEQ      |L36.70|
;;;680              pRect->x0 = rWinClipped.x1+1;
;;;681              r = 1;
;;;682            } else {
;;;683              /* Check all children */
;;;684              WM_HWIN hChild;
;;;685              WM_Obj* pChild;
;;;686              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
000040  f9b46018          LDRSH    r6,[r4,#0x18]
000044  e013              B        |L36.110|
                  |L36.70|
000046  f8bd0004          LDRH     r0,[sp,#4]            ;680
00004a  1c40              ADDS     r0,r0,#1              ;680
00004c  f8a90000          STRH     r0,[r9,#0]            ;680
000050  2501              MOVS     r5,#1                 ;681
000052  e00e              B        |L36.114|
                  |L36.84|
;;;687                pChild = WM_H2P(hChild);
000054  4630              MOV      r0,r6
000056  f7fffffe          BL       GUI_ALLOC_h2p
00005a  4607              MOV      r7,r0
;;;688                if (_Findx0(hChild, pRect, &rWinClipped)) {
00005c  466a              MOV      r2,sp
00005e  4649              MOV      r1,r9
000060  4630              MOV      r0,r6
000062  f7fffffe          BL       _Findx0
000066  b100              CBZ      r0,|L36.106|
;;;689                  r = 1;
000068  2501              MOVS     r5,#1
                  |L36.106|
00006a  f9b7601a          LDRSH    r6,[r7,#0x1a]         ;686
                  |L36.110|
00006e  2e00              CMP      r6,#0                 ;686
000070  d1f0              BNE      |L36.84|
                  |L36.114|
000072  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;668
                  |L36.118|
000076  2800              CMP      r0,#0                 ;668
000078  d1c8              BNE      |L36.12|
;;;690                }
;;;691              }
;;;692            }
;;;693          }
;;;694        }
;;;695      }
;;;696      return r;
00007a  4628              MOV      r0,r5
;;;697    }
00007c  e8bd87fc          POP      {r2-r10,pc}
;;;698    
                          ENDP


                          AREA ||i._Findx1||, CODE, READONLY, ALIGN=2

                  _Findx1 PROC
;;;702    */
;;;703    static void _Findx1(WM_HWIN hWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4616              MOV      r6,r2
000006  4688              MOV      r8,r1
;;;704      WM_Obj* pWin;
;;;705      for (; hWin; hWin = pWin->hNext) { 
000008  e030              B        |L37.108|
;;;706        int Status = (pWin = WM_H2P(hWin))->Status;
00000a  bf00              NOP      
                  |L37.12|
00000c  f7fffffe          BL       GUI_ALLOC_h2p
000010  8b85              LDRH     r5,[r0,#0x1c]
000012  4604              MOV      r4,r0
;;;707        if (Status & WM_SF_ISVIS) {           /* If window is not visible, it can be safely ignored */
000014  07a8              LSLS     r0,r5,#30
000016  d527              BPL      |L37.104|
;;;708          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;709          if (pParentRect) {
000018  b12e              CBZ      r6,|L37.38|
;;;710            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
00001a  4632              MOV      r2,r6
00001c  4621              MOV      r1,r4
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       GUI__IntersectRects
000024  e003              B        |L37.46|
                  |L37.38|
000026  e9d40100          LDRD     r0,r1,[r4,#0]
00002a  e9cd0100          STRD     r0,r1,[sp,#0]
                  |L37.46|
;;;711          } else {
;;;712            rWinClipped = pWin->Rect;
;;;713          }
;;;714          /* Check if this window affects us at all */    
;;;715          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
00002e  4669              MOV      r1,sp
000030  4640              MOV      r0,r8
000032  f7fffffe          BL       GUI_RectsIntersect
000036  b1b8              CBZ      r0,|L37.104|
;;;716            if ((Status & WM_SF_HASTRANS) == 0) {
000038  07e8              LSLS     r0,r5,#31
00003a  d002              BEQ      |L37.66|
;;;717              pRect->x1 = rWinClipped.x0-1;
;;;718            } else {
;;;719              /* Check all children */
;;;720              WM_HWIN hChild;
;;;721              WM_Obj* pChild;
;;;722              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
00003c  f9b45018          LDRSH    r5,[r4,#0x18]
000040  e010              B        |L37.100|
                  |L37.66|
000042  f8bd0000          LDRH     r0,[sp,#0]            ;717
000046  1e40              SUBS     r0,r0,#1              ;717
000048  f8a80004          STRH     r0,[r8,#4]            ;717
00004c  e00c              B        |L37.104|
                  |L37.78|
;;;723                pChild = WM_H2P(hChild);
00004e  4628              MOV      r0,r5
000050  f7fffffe          BL       GUI_ALLOC_h2p
000054  4607              MOV      r7,r0
;;;724                _Findx1(hChild, pRect, &rWinClipped);
000056  466a              MOV      r2,sp
000058  4641              MOV      r1,r8
00005a  4628              MOV      r0,r5
00005c  f7fffffe          BL       _Findx1
000060  f9b7501a          LDRSH    r5,[r7,#0x1a]         ;722
                  |L37.100|
000064  2d00              CMP      r5,#0                 ;722
000066  d1f2              BNE      |L37.78|
                  |L37.104|
000068  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;705
                  |L37.108|
00006c  2800              CMP      r0,#0                 ;705
00006e  d1cd              BNE      |L37.12|
;;;725              }
;;;726            }
;;;727          }
;;;728        }
;;;729      }
;;;730    }
000070  e8bd81fc          POP      {r2-r8,pc}
;;;731    
                          ENDP


                          AREA ||i._Findy1||, CODE, READONLY, ALIGN=2

                  _Findy1 PROC
;;;626    */
;;;627    static void _Findy1(WM_HWIN iWin, GUI_RECT* pRect, GUI_RECT* pParentRect) {
000000  e92d41fc          PUSH     {r2-r8,lr}
000004  4616              MOV      r6,r2
000006  4688              MOV      r8,r1
;;;628      WM_Obj* pWin;
;;;629      for (; iWin; iWin = pWin->hNext) { 
000008  e041              B        |L38.142|
;;;630        int Status = (pWin = WM_H2P(iWin))->Status;
00000a  bf00              NOP      
                  |L38.12|
00000c  f7fffffe          BL       GUI_ALLOC_h2p
000010  8b85              LDRH     r5,[r0,#0x1c]
000012  4604              MOV      r4,r0
;;;631        /* Check if this window affects us at all */    
;;;632        if (Status & WM_SF_ISVIS) {
000014  07a8              LSLS     r0,r5,#30
000016  d538              BPL      |L38.138|
;;;633          GUI_RECT rWinClipped;               /* Window rect, clipped to part inside of ancestors */
;;;634          if (pParentRect) {
000018  b12e              CBZ      r6,|L38.38|
;;;635            GUI__IntersectRects(&rWinClipped, &pWin->Rect, pParentRect);
00001a  4632              MOV      r2,r6
00001c  4621              MOV      r1,r4
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       GUI__IntersectRects
000024  e003              B        |L38.46|
                  |L38.38|
000026  e9d40100          LDRD     r0,r1,[r4,#0]
00002a  e9cd0100          STRD     r0,r1,[sp,#0]
                  |L38.46|
;;;636          } else {
;;;637            rWinClipped = pWin->Rect;
;;;638          }
;;;639          /* Check if this window affects us at all */    
;;;640          if (GUI_RectsIntersect(pRect, &rWinClipped)) {
00002e  4669              MOV      r1,sp
000030  4640              MOV      r0,r8
000032  f7fffffe          BL       GUI_RectsIntersect
000036  b340              CBZ      r0,|L38.138|
;;;641            if ((Status & WM_SF_HASTRANS) == 0) {
000038  07e8              LSLS     r0,r5,#31
00003a  d002              BEQ      |L38.66|
;;;642              if (pWin->Rect.y0 > pRect->y0) {
;;;643                ASSIGN_IF_LESS(pRect->y1, rWinClipped.y0 - 1);      /* Check upper border of window */
;;;644              } else {
;;;645                ASSIGN_IF_LESS(pRect->y1, rWinClipped.y1);        /* Check lower border of window */
;;;646              }
;;;647            } else {
;;;648              /* Check all children*/ 
;;;649              WM_HWIN hChild;
;;;650              WM_Obj* pChild;
;;;651              for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
00003c  f9b45018          LDRSH    r5,[r4,#0x18]
000040  e021              B        |L38.134|
                  |L38.66|
000042  f9b41002          LDRSH    r1,[r4,#2]            ;642
000046  f9b80002          LDRSH    r0,[r8,#2]            ;642
00004a  4281              CMP      r1,r0                 ;642
00004c  dd09              BLE      |L38.98|
00004e  f9bd0002          LDRSH    r0,[sp,#2]            ;643
000052  f9b81006          LDRSH    r1,[r8,#6]            ;643
000056  1e40              SUBS     r0,r0,#1              ;643
000058  e007              B        |L38.106|
00005a  bf00              NOP                            ;643
                  |L38.92|
00005c  f8a80006          STRH     r0,[r8,#6]            ;643
000060  e013              B        |L38.138|
                  |L38.98|
000062  f9bd0006          LDRSH    r0,[sp,#6]            ;645
000066  f9b81006          LDRSH    r1,[r8,#6]            ;645
                  |L38.106|
00006a  4288              CMP      r0,r1                 ;643
00006c  dbf6              BLT      |L38.92|
00006e  e00c              B        |L38.138|
                  |L38.112|
;;;652                pChild = WM_H2P(hChild);
000070  4628              MOV      r0,r5
000072  f7fffffe          BL       GUI_ALLOC_h2p
000076  4607              MOV      r7,r0
;;;653                _Findy1(hChild, pRect, &rWinClipped);
000078  466a              MOV      r2,sp
00007a  4641              MOV      r1,r8
00007c  4628              MOV      r0,r5
00007e  f7fffffe          BL       _Findy1
000082  f9b7501a          LDRSH    r5,[r7,#0x1a]         ;651
                  |L38.134|
000086  2d00              CMP      r5,#0                 ;651
000088  d1f2              BNE      |L38.112|
                  |L38.138|
00008a  f9b4001a          LDRSH    r0,[r4,#0x1a]         ;629
                  |L38.142|
00008e  2800              CMP      r0,#0                 ;629
000090  d1bc              BNE      |L38.12|
;;;654              }
;;;655            }
;;;656          }
;;;657        }
;;;658      }
;;;659    }
000092  e8bd81fc          POP      {r2-r8,pc}
;;;660    
                          ENDP


                          AREA ||i._Paint1||, CODE, READONLY, ALIGN=2

                  _Paint1 PROC
;;;1335   */
;;;1336   static void _Paint1(WM_HWIN hWin, WM_Obj* pWin) {
000000  b5fe              PUSH     {r1-r7,lr}
000002  4606              MOV      r6,r0
000004  690a              LDR      r2,[r1,#0x10]
;;;1337     int Status = pWin->Status;
000006  8b88              LDRH     r0,[r1,#0x1c]
000008  2a00              CMP      r2,#0                 ;1336
00000a  d02c              BEQ      |L39.102|
;;;1338     /* Send WM_PAINT if window is visible and a callback is defined */
;;;1339     if ((pWin->cb != NULL)  && (Status & WM_SF_ISVIS)) {
00000c  0782              LSLS     r2,r0,#30
00000e  d52a              BPL      |L39.102|
;;;1340       WM_MESSAGE Msg;
;;;1341       WM__PaintCallbackCnt++;
000010  4d15              LDR      r5,|L39.104|
;;;1342       if (Status & WM_SF_LATE_CLIP) {
;;;1343         Msg.hWin   = hWin;
;;;1344         Msg.MsgId  = WM_PAINT;
000012  f04f070f          MOV      r7,#0xf
;;;1345         Msg.Data.p = (GUI_RECT*)&pWin->InvalidRect;
000016  f1010408          ADD      r4,r1,#8
00001a  78aa              LDRB     r2,[r5,#2]            ;1341  ; WM__PaintCallbackCnt
00001c  1c52              ADDS     r2,r2,#1              ;1341
00001e  70aa              STRB     r2,[r5,#2]            ;1341
000020  04c0              LSLS     r0,r0,#19             ;1342
000022  d50a              BPL      |L39.58|
000024  f8ad6004          STRH     r6,[sp,#4]            ;1343
;;;1346         WM_SetDefault();
000028  9700              STR      r7,[sp,#0]
00002a  9402              STR      r4,[sp,#8]
00002c  f7fffffe          BL       WM_SetDefault
;;;1347         WM__SendMessage(hWin, &Msg);
000030  4669              MOV      r1,sp
000032  4630              MOV      r0,r6
000034  f7fffffe          BL       WM__SendMessage
000038  e012              B        |L39.96|
                  |L39.58|
00003a  4620              MOV      r0,r4
;;;1348       } else {
;;;1349         WM_ITERATE_START(&pWin->InvalidRect) {
00003c  f7fffffe          BL       WM__InitIVRSearch
000040  e00c              B        |L39.92|
;;;1350           Msg.hWin   = hWin;
000042  bf00              NOP      
                  |L39.68|
000044  f8ad6004          STRH     r6,[sp,#4]
;;;1351           Msg.MsgId  = WM_PAINT;
;;;1352           Msg.Data.p = (GUI_RECT*)&pWin->InvalidRect;
;;;1353           WM_SetDefault();
000048  9700              STR      r7,[sp,#0]
00004a  9402              STR      r4,[sp,#8]
00004c  f7fffffe          BL       WM_SetDefault
;;;1354           WM__SendMessage(hWin, &Msg);
000050  4669              MOV      r1,sp
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       WM__SendMessage
;;;1355         } WM_ITERATE_END();
000058  f7fffffe          BL       WM__GetNextIVR
                  |L39.92|
00005c  2800              CMP      r0,#0
00005e  d1f1              BNE      |L39.68|
                  |L39.96|
;;;1356       }
;;;1357       WM__PaintCallbackCnt--;
000060  78a8              LDRB     r0,[r5,#2]  ; WM__PaintCallbackCnt
000062  1e40              SUBS     r0,r0,#1
000064  70a8              STRB     r0,[r5,#2]
                  |L39.102|
;;;1358     }
;;;1359   }
000066  bdfe              POP      {r1-r7,pc}
;;;1360   /*********************************************************************
                          ENDP

                  |L39.104|
                          DCD      ||.data||

                          AREA ||i._Paint1Trans||, CODE, READONLY, ALIGN=2

                  _Paint1Trans PROC
;;;1382   #if WM_SUPPORT_TRANSPARENCY
;;;1383   static int _Paint1Trans(WM_HWIN hWin, WM_Obj* pWin) {
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1384     int xPrev, yPrev;
;;;1385     WM_Obj* pAWin = WM_H2P(GUI_Context.hAWin);
000004  4c15              LDR      r4,|L40.92|
000006  4681              MOV      r9,r0                 ;1383
000008  460d              MOV      r5,r1                 ;1383
00000a  f9b40040          LDRSH    r0,[r4,#0x40]  ; GUI_Context
00000e  f7fffffe          BL       GUI_ALLOC_h2p
;;;1386     /* Check if we need to do any drawing */
;;;1387     if (GUI_RectsIntersect(&pAWin->InvalidRect, &pWin->Rect)) {
000012  3008              ADDS     r0,r0,#8
000014  4629              MOV      r1,r5
000016  4680              MOV      r8,r0
000018  f7fffffe          BL       GUI_RectsIntersect
00001c  2800              CMP      r0,#0
00001e  d01b              BEQ      |L40.88|
;;;1388       /* Save old values */
;;;1389       xPrev = GUI_Context.xOff;
;;;1390       yPrev = GUI_Context.yOff;
;;;1391       /* Set values for the current (transparent) window, rather than the one below */
;;;1392       GUI__IntersectRects(&pWin->InvalidRect, &pWin->Rect, &pAWin->InvalidRect);
000020  e9d46711          LDRD     r6,r7,[r4,#0x44]
000024  4642              MOV      r2,r8                 ;1387
000026  4629              MOV      r1,r5
000028  f1050008          ADD      r0,r5,#8
00002c  f7fffffe          BL       GUI__IntersectRects
;;;1393       WM__hATransWindow = hWin;
000030  f8df802c          LDR      r8,|L40.96|
;;;1394       GUI_Context.xOff = pWin->Rect.x0;
;;;1395       GUI_Context.yOff = pWin->Rect.y0;
;;;1396       /* Do the actual drawing ... */
;;;1397       _Paint1(hWin, pWin);
000034  4629              MOV      r1,r5
000036  f8a89012          STRH     r9,[r8,#0x12]         ;1393
00003a  f9b50000          LDRSH    r0,[r5,#0]            ;1394
00003e  6460              STR      r0,[r4,#0x44]         ;1395  ; GUI_Context
000040  f9b50002          LDRSH    r0,[r5,#2]            ;1395
000044  64a0              STR      r0,[r4,#0x48]  ; GUI_Context
000046  4648              MOV      r0,r9
000048  f7fffffe          BL       _Paint1
;;;1398       /* Restore settings */
;;;1399       WM__hATransWindow = 0;
00004c  2100              MOVS     r1,#0
00004e  f8a81012          STRH     r1,[r8,#0x12]
000052  e9c46711          STRD     r6,r7,[r4,#0x44]
;;;1400       GUI_Context.xOff = xPrev;
;;;1401       GUI_Context.yOff = yPrev;
;;;1402       return 1;                       /* Some drawing took place */
000056  2001              MOVS     r0,#1
                  |L40.88|
;;;1403     }
;;;1404     return 0;                         /* No invalid area, so nothing was drawn */
;;;1405   }
000058  e8bd87f0          POP      {r4-r10,pc}
;;;1406   #endif
                          ENDP

                  |L40.92|
                          DCD      GUI_Context
                  |L40.96|
                          DCD      ||.data||

                          AREA ||i._PaintTransChildren||, CODE, READONLY, ALIGN=1

                  _PaintTransChildren PROC
;;;1419   #if WM_SUPPORT_TRANSPARENCY
;;;1420   static void _PaintTransChildren(WM_HWIN hWin, WM_Obj* pWin) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4681              MOV      r9,r0
;;;1421     WM_HWIN hChild;
;;;1422     WM_Obj* pChild;
;;;1423     if (pWin->Status & WM_SF_ISVIS) {
000006  7f08              LDRB     r0,[r1,#0x1c]
000008  460c              MOV      r4,r1                 ;1420
00000a  0780              LSLS     r0,r0,#30
00000c  d52d              BPL      |L41.106|
;;;1424       for (hChild = pWin->hFirstChild; hChild; hChild = pChild->hNext) {
00000e  f9b46018          LDRSH    r6,[r4,#0x18]
000012  e028              B        |L41.102|
                  |L41.20|
;;;1425         pChild = WM_H2P(hChild);
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       GUI_ALLOC_h2p
00001a  4605              MOV      r5,r0
;;;1426         if ((pChild->Status & (WM_SF_HASTRANS | WM_SF_ISVIS))   /* Transparent & visible ? */
00001c  7f00              LDRB     r0,[r0,#0x1c]
00001e  43c0              MVNS     r0,r0
000020  0780              LSLS     r0,r0,#30
000022  d11e              BNE      |L41.98|
;;;1427   		                ==  (WM_SF_HASTRANS | WM_SF_ISVIS)) {
;;;1428           /* Set invalid area of the window to draw */
;;;1429           if (GUI_RectsIntersect(&pChild->Rect, &pWin->InvalidRect)) {
000024  f1040108          ADD      r1,r4,#8
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       GUI_RectsIntersect
00002e  b1c0              CBZ      r0,|L41.98|
000030  e9d47002          LDRD     r7,r0,[r4,#8]
;;;1430             GUI_RECT InvalidRectPrev;
;;;1431             InvalidRectPrev = pWin->InvalidRect;
000034  4680              MOV      r8,r0
;;;1432             if(_Paint1Trans(hChild, pChild)) {
000036  4629              MOV      r1,r5
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       _Paint1Trans
00003e  b170              CBZ      r0,|L41.94|
;;;1433               #if GUI_SUPPORT_MEMDEV
;;;1434                 /* Within the paint event the application is alowed to deal with memory devices.
;;;1435                    So the pointer(s) could be invalid after the last function call and needs
;;;1436                    to be restored.
;;;1437                 */
;;;1438                 pChild = WM_H2P(hChild);
000040  4630              MOV      r0,r6
000042  f7fffffe          BL       GUI_ALLOC_h2p
000046  4601              MOV      r1,r0
;;;1439               #endif
;;;1440               _PaintTransChildren(hChild, pChild);
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       _PaintTransChildren
;;;1441               #if GUI_SUPPORT_MEMDEV
;;;1442                 /* Within the paint event the application is alowed to deal with memory devices.
;;;1443                    So the pointer(s) could be invalid after the last function call and needs
;;;1444                    to be restored.
;;;1445                 */
;;;1446                 pChild = WM_H2P(hChild);
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       GUI_ALLOC_h2p
000054  4605              MOV      r5,r0
;;;1447                 pWin   = WM_H2P(hWin);
000056  4648              MOV      r0,r9
000058  f7fffffe          BL       GUI_ALLOC_h2p
00005c  4604              MOV      r4,r0
                  |L41.94|
00005e  e9c47802          STRD     r7,r8,[r4,#8]
                  |L41.98|
000062  f9b5601a          LDRSH    r6,[r5,#0x1a]         ;1424
                  |L41.102|
000066  2e00              CMP      r6,#0                 ;1424
000068  d1d4              BNE      |L41.20|
                  |L41.106|
;;;1448               #endif
;;;1449             }
;;;1450             pWin->InvalidRect = InvalidRectPrev;
;;;1451           }
;;;1452         }
;;;1453       }
;;;1454     }
;;;1455   }
00006a  e8bd87f0          POP      {r4-r10,pc}
;;;1456   #endif
                          ENDP


                          AREA ||i._SetClipRectUserIntersect||, CODE, READONLY, ALIGN=2

                  _SetClipRectUserIntersect PROC
;;;184    */
;;;185    static void _SetClipRectUserIntersect(const GUI_RECT* prSrc) {
000000  b51c              PUSH     {r2-r4,lr}
;;;186      if (GUI_Context.WM__pUserClipRect == NULL) {
000002  4910              LDR      r1,|L42.68|
000004  4604              MOV      r4,r0                 ;185
000006  6bc8              LDR      r0,[r1,#0x3c]         ;185  ; GUI_Context
000008  b140              CBZ      r0,|L42.28|
;;;187        LCD_SetClipRectEx(prSrc);
;;;188      } else {
;;;189        GUI_RECT r;
;;;190        r = *GUI_Context.WM__pUserClipRect;             
00000a  6802              LDR      r2,[r0,#0]
00000c  9200              STR      r2,[sp,#0]
00000e  6840              LDR      r0,[r0,#4]
000010  9001              STR      r0,[sp,#4]
000012  480d              LDR      r0,|L42.72|
000014  f9b00012          LDRSH    r0,[r0,#0x12]  ; WM__hATransWindow
000018  b938              CBNZ     r0,|L42.42|
00001a  e004              B        |L42.38|
                  |L42.28|
00001c  4620              MOV      r0,r4                 ;187
00001e  e8bd401c          POP      {r2-r4,lr}            ;187
000022  f7ffbffe          B.W      LCD_SetClipRectEx
                  |L42.38|
000026  f9b10040          LDRSH    r0,[r1,#0x40]         ;187  ; GUI_Context
                  |L42.42|
;;;191        WM__Client2Screen(WM_H2P(_GethDrawWin()), &r);     /* Convert User ClipRect into screen coordinates */
00002a  f7fffffe          BL       GUI_ALLOC_h2p
00002e  4669              MOV      r1,sp
000030  f7fffffe          BL       WM__Client2Screen
;;;192        /* Set intersection as clip rect */    
;;;193        GUI__IntersectRect(&r, prSrc);
000034  4621              MOV      r1,r4
000036  4668              MOV      r0,sp
000038  f7fffffe          BL       GUI__IntersectRect
;;;194        LCD_SetClipRectEx(&r);
00003c  4668              MOV      r0,sp
00003e  f7fffffe          BL       LCD_SetClipRectEx
;;;195      }
;;;196    }
000042  bd1c              POP      {r2-r4,pc}
;;;197    
                          ENDP

                  |L42.68|
                          DCD      GUI_Context
                  |L42.72|
                          DCD      ||.data||

                          AREA ||i._cbPaintMemDev||, CODE, READONLY, ALIGN=2

                  _cbPaintMemDev PROC
;;;1567   #if GUI_SUPPORT_MEMDEV
;;;1568   static void _cbPaintMemDev(void* p) {
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1569     GUI_RECT Rect;
;;;1570     WM_Obj* pWin = WM_H2P(GUI_Context.hAWin);
000004  4c09              LDR      r4,|L43.44|
000006  4680              MOV      r8,r0                 ;1568
000008  f9b40040          LDRSH    r0,[r4,#0x40]  ; GUI_Context
00000c  f7fffffe          BL       GUI_ALLOC_h2p
000010  4607              MOV      r7,r0
000012  e9d75602          LDRD     r5,r6,[r7,#8]
000016  e9d40102          LDRD     r0,r1,[r4,#8]
00001a  e9c70102          STRD     r0,r1,[r7,#8]
;;;1571     Rect = pWin->InvalidRect;
;;;1572     pWin->InvalidRect = GUI_Context.ClipRect;
;;;1573     WM__PaintWinAndOverlays((WM_PAINTINFO*)p);
00001e  4640              MOV      r0,r8
000020  f7fffffe          BL       WM__PaintWinAndOverlays
000024  e9c75602          STRD     r5,r6,[r7,#8]
;;;1574     pWin->InvalidRect = Rect;
;;;1575   }
000028  e8bd81f0          POP      {r4-r8,pc}
;;;1576   #endif
                          ENDP

                  |L43.44|
                          DCD      GUI_Context

                          AREA ||i.cbBackWin||, CODE, READONLY, ALIGN=2

                  cbBackWin PROC
;;;1699   */
;;;1700   static void cbBackWin( WM_MESSAGE* pMsg) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;1701     const WM_KEY_INFO* pKeyInfo;
;;;1702     switch (pMsg->MsgId) {
000004  6800              LDR      r0,[r0,#0]
000006  280e              CMP      r0,#0xe
000008  d002              BEQ      |L44.16|
00000a  280f              CMP      r0,#0xf
00000c  d113              BNE      |L44.54|
00000e  e008              B        |L44.34|
                  |L44.16|
;;;1703     case WM_KEY:
;;;1704       pKeyInfo = (const WM_KEY_INFO*)pMsg->Data.p;
;;;1705       if (pKeyInfo->PressedCnt == 1) {
000010  68a0              LDR      r0,[r4,#8]
000012  6841              LDR      r1,[r0,#4]
000014  2901              CMP      r1,#1
000016  d113              BNE      |L44.64|
;;;1706         GUI_StoreKey(pKeyInfo->Key);
000018  6800              LDR      r0,[r0,#0]
00001a  e8bd4010          POP      {r4,lr}
00001e  f7ffbffe          B.W      GUI_StoreKey
                  |L44.34|
;;;1707       }
;;;1708       break;
;;;1709     case WM_PAINT:
;;;1710       {
;;;1711         int LayerIndex;
;;;1712         #if GUI_NUM_LAYERS > 1
;;;1713           LayerIndex = _DesktopHandle2Index(pMsg->hWin);
;;;1714         #else
;;;1715           LayerIndex = 0;
;;;1716         #endif
;;;1717         if (WM__aBkColor[LayerIndex] != GUI_INVALID_COLOR) {
000022  4808              LDR      r0,|L44.68|
000024  f06f4170          MVN      r1,#0xf0000000
000028  6800              LDR      r0,[r0,#0]
00002a  4288              CMP      r0,r1
00002c  d003              BEQ      |L44.54|
;;;1718           GUI_SetBkColor(WM__aBkColor[LayerIndex]);
00002e  f7fffffe          BL       GUI_SetBkColor
;;;1719           GUI_Clear();
000032  f7fffffe          BL       GUI_Clear
                  |L44.54|
;;;1720         }
;;;1721       }
;;;1722     default:
;;;1723       WM_DefaultProc(pMsg);
000036  4620              MOV      r0,r4
000038  e8bd4010          POP      {r4,lr}
00003c  f7ffbffe          B.W      WM_DefaultProc
                  |L44.64|
;;;1724     }
;;;1725   }
000040  bd10              POP      {r4,pc}
;;;1726   
                          ENDP

000042  0000              DCW      0x0000
                  |L44.68|
                          DCD      ||.data||+0x1c

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  WM_PID__StateLast
                          %        12

                          AREA ||area_number.47||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.47||, ||.bss||
                  _ClipContext
                          %        24

                          AREA ||.data||, DATA, ALIGN=2

                  _CursorHidden
000000  00                DCB      0x00
                  WM_IsActive
000001  00                DCB      0x00
                  WM__PaintCallbackCnt
000002  00                DCB      0x00
                  _IsInited
000003  00                DCB      0x00
                  WM__NumWindows
000004  0000              DCB      0x00,0x00
                  WM__NumInvalidWindows
000006  0000              DCB      0x00,0x00
                  WM__FirstWin
000008  0000              DCB      0x00,0x00
                  WM__ahDesktopWin
00000a  0000              DCB      0x00,0x00
                  WM__CreateFlags
00000c  0000              DCB      0x00,0x00
                  WM__hCapture
00000e  0000              DCB      0x00,0x00
                  WM__hWinFocus
000010  0000              DCB      0x00,0x00
                  WM__hATransWindow
000012  0000              DCB      0x00,0x00
                  NextDrawWin
000014  00000000          DCB      0x00,0x00,0x00,0x00
                  WM__pFirstCriticalHandle
                          DCD      0x00000000
                  WM__aBkColor
                          DCD      0x00000000
                  WM_pfPollPID
                          DCD      0x00000000
                  WM__TransWindowCnt
                          DCD      0x00000000

                          AREA ||area_number.50||, DATA, ALIGN=0

                          EXPORTAS ||area_number.50||, ||.data||
                  WM__CaptureReleaseAuto
000000  00                DCB      0x00
