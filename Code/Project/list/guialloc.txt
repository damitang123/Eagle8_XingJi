; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\guialloc.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\guialloc.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\Core\GUIAlloc.c]
                          THUMB

                          AREA ||i.GUI_ALLOC_AllocNoInit||, CODE, READONLY, ALIGN=1

                  GUI_ALLOC_AllocNoInit PROC
;;;362    */
;;;363    GUI_HMEM GUI_ALLOC_AllocNoInit(GUI_ALLOC_DATATYPE Size) {
000000  2800              CMP      r0,#0
000002  d001              BEQ      |L1.8|
;;;364      GUI_HMEM hMem;
;;;365      if (Size == 0) {
;;;366        return (GUI_HMEM)0;
;;;367      }
;;;368      GUI_LOCK();
;;;369      GUI_DEBUG_LOG2("\nGUI_ALLOC_AllocNoInit... requesting %d, %d avail", Size, GUI_ALLOC.NumFreeBytes);
;;;370      hMem = _Alloc(Size);
000004  f7ffbffe          B.W      _Alloc
                  |L1.8|
;;;371      GUI_DEBUG_LOG1("\nGUI_ALLOC_AllocNoInit : Handle", hMem);
;;;372      GUI_UNLOCK();
;;;373      return hMem;
;;;374    }
000008  4770              BX       lr
;;;375    
                          ENDP


                          AREA ||i.GUI_ALLOC_Free||, CODE, READONLY, ALIGN=1

                  GUI_ALLOC_Free PROC
;;;614    */
;;;615    void GUI_ALLOC_Free(GUI_HMEM hMem) {
000000  2800              CMP      r0,#0
000002  d001              BEQ      |L2.8|
;;;616      if (hMem == GUI_HMEM_NULL) { /* Note: This is not an error, it is permitted */
;;;617        return;
;;;618      }
;;;619      GUI_LOCK();
;;;620      GUI_DEBUG_LOG1("\nGUI_ALLOC_Free(%d)", hMem);
;;;621      _Free(hMem);
000004  f7ffbffe          B.W      _Free
                  |L2.8|
;;;622      GUI_UNLOCK();
;;;623    }
000008  4770              BX       lr
;;;624    
                          ENDP


                          AREA ||i.GUI_ALLOC_FreePtr||, CODE, READONLY, ALIGN=1

                  GUI_ALLOC_FreePtr PROC
;;;629    */
;;;630    void GUI_ALLOC_FreePtr(GUI_HMEM *ph) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;631      GUI_LOCK();
;;;632      GUI_ALLOC_Free(*ph);
000004  f9b00000          LDRSH    r0,[r0,#0]
000008  f7fffffe          BL       GUI_ALLOC_Free
;;;633      *ph =0;
00000c  2000              MOVS     r0,#0
00000e  8020              STRH     r0,[r4,#0]
;;;634      GUI_UNLOCK();
;;;635    }
000010  bd10              POP      {r4,pc}
;;;636    
                          ENDP


                          AREA ||i.GUI_ALLOC_FreePtrArray||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_FreePtrArray PROC
;;;640    */
;;;641    void GUI_ALLOC_FreePtrArray(GUI_HMEM * pArray, int NumElems) {
000000  b570              PUSH     {r4-r6,lr}
000002  460d              MOV      r5,r1
000004  4606              MOV      r6,r0
;;;642      int i;
;;;643      for (i = 0; i < NumElems; i++) {
000006  2400              MOVS     r4,#0
000008  e005              B        |L4.22|
;;;644        GUI_ALLOC_FreePtr(&pArray[i]);
00000a  bf00              NOP      
                  |L4.12|
00000c  eb060044          ADD      r0,r6,r4,LSL #1
000010  f7fffffe          BL       GUI_ALLOC_FreePtr
000014  1c64              ADDS     r4,r4,#1
                  |L4.22|
000016  42ac              CMP      r4,r5                 ;643
000018  dbf8              BLT      |L4.12|
;;;645      }
;;;646    }
00001a  bd70              POP      {r4-r6,pc}
;;;647    
                          ENDP


                          AREA ||i.GUI_ALLOC_GetMaxSize||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_GetMaxSize PROC
;;;437    */
;;;438    GUI_ALLOC_DATATYPE GUI_ALLOC_GetMaxSize(void) {
000000  b510              PUSH     {r4,lr}
;;;439      GUI_ALLOC_DATATYPE r = 0;
000002  2400              MOVS     r4,#0
;;;440      GUI_ALLOC_DATATYPE NumFreeBytes;
;;;441      int i, iNext;
;;;442    
;;;443      GUI_LOCK();
;;;444      _CheckInit();
000004  f7fffffe          BL       _CheckInit
;;;445      for (i=0; (iNext =aBlock[i].Next) !=0; i= iNext) {
000008  2100              MOVS     r1,#0
;;;446        NumFreeBytes = aBlock[iNext].Off- (aBlock[i].Off+aBlock[i].Size);
00000a  4811              LDR      r0,|L5.80|
00000c  e00c              B        |L5.40|
00000e  bf00              NOP      
                  |L5.16|
000010  f8301031          LDRH     r1,[r0,r1,LSL #3]
000014  885b              LDRH     r3,[r3,#2]
000016  4419              ADD      r1,r1,r3
000018  f8303032          LDRH     r3,[r0,r2,LSL #3]
00001c  1a59              SUBS     r1,r3,r1
00001e  b209              SXTH     r1,r1
;;;447        if (NumFreeBytes > r) {
000020  42a1              CMP      r1,r4
000022  dd00              BLE      |L5.38|
;;;448          r = NumFreeBytes;
000024  460c              MOV      r4,r1
                  |L5.38|
000026  4611              MOV      r1,r2                 ;445
                  |L5.40|
000028  eb0003c1          ADD      r3,r0,r1,LSL #3       ;445
00002c  889a              LDRH     r2,[r3,#4]            ;445
00002e  2a00              CMP      r2,#0                 ;445
000030  d1ee              BNE      |L5.16|
;;;449        }
;;;450      }
;;;451      /* Check last block */
;;;452      NumFreeBytes = (GUI_ALLOC_SIZE - (aBlock[i].Off+aBlock[i].Size));
000032  f9302031          LDRSH    r2,[r0,r1,LSL #3]
000036  eb0000c1          ADD      r0,r0,r1,LSL #3
00003a  f9b00002          LDRSH    r0,[r0,#2]
00003e  4410              ADD      r0,r0,r2
000040  f5c040f0          RSB      r0,r0,#0x7800
000044  b200              SXTH     r0,r0
;;;453      if (NumFreeBytes > r) {
000046  42a0              CMP      r0,r4
000048  dd00              BLE      |L5.76|
;;;454        r = NumFreeBytes;
00004a  4604              MOV      r4,r0
                  |L5.76|
;;;455      }
;;;456      GUI_UNLOCK();
;;;457      return r;
00004c  4620              MOV      r0,r4
;;;458    }
00004e  bd10              POP      {r4,pc}
;;;459    
                          ENDP

                  |L5.80|
                          DCD      ccmram+0x7800

                          AREA ||i.GUI_ALLOC_GetNumFreeBlocks||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_GetNumFreeBlocks PROC
;;;407    */
;;;408    GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBlocks(void) {
000000  b510              PUSH     {r4,lr}
;;;409      _CheckInit();
000002  f7fffffe          BL       _CheckInit
;;;410      return GUI_ALLOC.NumFreeBlocks;
000006  4802              LDR      r0,|L6.16|
000008  8880              LDRH     r0,[r0,#4]  ; GUI_ALLOC
00000a  b200              SXTH     r0,r0
;;;411    }
00000c  bd10              POP      {r4,pc}
;;;412    
                          ENDP

00000e  0000              DCW      0x0000
                  |L6.16|
                          DCD      ||.bss||

                          AREA ||i.GUI_ALLOC_GetNumFreeBytes||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_GetNumFreeBytes PROC
;;;398    */
;;;399    GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumFreeBytes(void) {
000000  b510              PUSH     {r4,lr}
;;;400      _CheckInit();
000002  f7fffffe          BL       _CheckInit
;;;401      return GUI_ALLOC.NumFreeBytes;
000006  4802              LDR      r0,|L7.16|
000008  f9b0000e          LDRSH    r0,[r0,#0xe]  ; GUI_ALLOC
;;;402    }
00000c  bd10              POP      {r4,pc}
;;;403    
                          ENDP

00000e  0000              DCW      0x0000
                  |L7.16|
                          DCD      ||.bss||

                          AREA ||i.GUI_ALLOC_GetNumUsedBlocks||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_GetNumUsedBlocks PROC
;;;425    */
;;;426    GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBlocks(void) {
000000  b510              PUSH     {r4,lr}
;;;427      _CheckInit();
000002  f7fffffe          BL       _CheckInit
;;;428      return GUI_ALLOC.NumUsedBlocks;
000006  4802              LDR      r0,|L8.16|
000008  8800              LDRH     r0,[r0,#0]  ; GUI_ALLOC
00000a  b200              SXTH     r0,r0
;;;429    }
00000c  bd10              POP      {r4,pc}
;;;430    
                          ENDP

00000e  0000              DCW      0x0000
                  |L8.16|
                          DCD      ||.bss||

                          AREA ||i.GUI_ALLOC_GetNumUsedBytes||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_GetNumUsedBytes PROC
;;;416    */
;;;417    GUI_ALLOC_DATATYPE GUI_ALLOC_GetNumUsedBytes(void) {
000000  b510              PUSH     {r4,lr}
;;;418      _CheckInit();
000002  f7fffffe          BL       _CheckInit
;;;419      return GUI_ALLOC.NumUsedBytes;
000006  4802              LDR      r0,|L9.16|
000008  f9b0000c          LDRSH    r0,[r0,#0xc]  ; GUI_ALLOC
;;;420    }
00000c  bd10              POP      {r4,pc}
;;;421    
                          ENDP

00000e  0000              DCW      0x0000
                  |L9.16|
                          DCD      ||.bss||

                          AREA ||i.GUI_ALLOC_GetSize||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_GetSize PROC
;;;600    */
;;;601    GUI_ALLOC_DATATYPE GUI_ALLOC_GetSize(GUI_HMEM  hMem) {
000000  2100              MOVS     r1,#0
000002  b120              CBZ      r0,|L10.14|
000004  4903              LDR      r1,|L10.20|
000006  eb0100c0          ADD      r0,r1,r0,LSL #3
00000a  f9b01002          LDRSH    r1,[r0,#2]
                  |L10.14|
;;;602      GUI_ALLOC_DATATYPE r;
;;;603    
;;;604      r = 0;
;;;605      if (hMem) {
;;;606        r = _GetSize(hMem);
;;;607      }
;;;608      return r;
00000e  4608              MOV      r0,r1
;;;609    }
000010  4770              BX       lr
;;;610    
                          ENDP

000012  0000              DCW      0x0000
                  |L10.20|
                          DCD      ccmram+0x7800

                          AREA ||i.GUI_ALLOC_Init||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_Init PROC
;;;346    */
;;;347    void GUI_ALLOC_Init(void) {
000000  480a              LDR      r0,|L11.44|
;;;348      GUI_DEBUG_LOG("\nGUI_ALLOC_Init...");
;;;349      GUI_ALLOC.NumFreeBlocksMin = GUI_ALLOC.NumFreeBlocks = GUI_MAXBLOCKS-1;
000002  f24031c1          MOV      r1,#0x3c1
;;;350      GUI_ALLOC.NumFreeBytesMin  = GUI_ALLOC.NumFreeBytes  = GUI_ALLOC_SIZE;
;;;351      GUI_ALLOC.NumUsedBlocks = 0;
;;;352      GUI_ALLOC.NumUsedBytes = 0;
;;;353      aBlock[0].Size = (1<<GUI_BLOCK_ALIGN);  /* occupy minimum for a block */
000006  2204              MOVS     r2,#4
000008  6041              STR      r1,[r0,#4]            ;349  ; GUI_ALLOC
00000a  6081              STR      r1,[r0,#8]            ;350  ; GUI_ALLOC
00000c  f44f41f0          MOV      r1,#0x7800            ;350
000010  81c1              STRH     r1,[r0,#0xe]          ;350
000012  8201              STRH     r1,[r0,#0x10]         ;350
000014  2100              MOVS     r1,#0                 ;351
000016  6001              STR      r1,[r0,#0]            ;352  ; GUI_ALLOC
000018  8181              STRH     r1,[r0,#0xc]          ;352
00001a  4805              LDR      r0,|L11.48|
00001c  8042              STRH     r2,[r0,#2]
;;;354      aBlock[0].Off  = 0;
00001e  8001              STRH     r1,[r0,#0]
;;;355      aBlock[0].Next = 0;
000020  8081              STRH     r1,[r0,#4]
;;;356      IsInitialized =1;
000022  4904              LDR      r1,|L11.52|
000024  2001              MOVS     r0,#1
000026  7008              STRB     r0,[r1,#0]
;;;357    }
000028  4770              BX       lr
;;;358    
                          ENDP

00002a  0000              DCW      0x0000
                  |L11.44|
                          DCD      ||.bss||
                  |L11.48|
                          DCD      ccmram+0x7800
                  |L11.52|
                          DCD      ||.data||

                          AREA ||i.GUI_ALLOC_Lock||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_Lock PROC
;;;467    */
;;;468    void GUI_ALLOC_Lock(void) {
000000  4802              LDR      r0,|L12.12|
;;;469      _LockCnt++;
000002  6881              LDR      r1,[r0,#8]  ; _LockCnt
000004  1c49              ADDS     r1,r1,#1
000006  6081              STR      r1,[r0,#8]  ; _LockCnt
;;;470    }
000008  4770              BX       lr
;;;471    
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      ||.data||

                          AREA ||i.GUI_ALLOC_Unlock||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_Unlock PROC
;;;479    */
;;;480    void GUI_ALLOC_Unlock(void) {
000000  4802              LDR      r0,|L13.12|
;;;481      _LockCnt--;
000002  6881              LDR      r1,[r0,#8]  ; _LockCnt
000004  1e49              SUBS     r1,r1,#1
000006  6081              STR      r1,[r0,#8]  ; _LockCnt
;;;482    }
000008  4770              BX       lr
;;;483    
                          ENDP

00000a  0000              DCW      0x0000
                  |L13.12|
                          DCD      ||.data||

                          AREA ||i.GUI_ALLOC_h2p||, CODE, READONLY, ALIGN=2

                  GUI_ALLOC_h2p PROC
;;;379    */
;;;380    void* GUI_ALLOC_h2p(GUI_HMEM  hMem) {
000000  2800              CMP      r0,#0
000002  d005              BEQ      |L14.16|
;;;381      GUI_ASSERT_LOCK();
;;;382      #if GUI_DEBUG_LEVEL > 0
;;;383        if (!hMem) {
;;;384          GUI_DEBUG_ERROROUT("\n"__FILE__ " GUI_ALLOC_h2p: illegal argument (0 handle)");
;;;385          return 0;
;;;386        }
;;;387        if (aBlock[hMem].Size == 0) {
;;;388          GUI_DEBUG_ERROROUT("Dereferencing free block");
;;;389        }
;;;390    
;;;391      #endif
;;;392      return HMEM2PTR(hMem);
000004  4903              LDR      r1,|L14.20|
000006  f9310030          LDRSH    r0,[r1,r0,LSL #3]
00000a  f5a141f0          SUB      r1,r1,#0x7800
00000e  4408              ADD      r0,r0,r1
                  |L14.16|
;;;393    }
000010  4770              BX       lr
;;;394    
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      ccmram+0x7800

                          AREA ||i._Alloc||, CODE, READONLY, ALIGN=2

                  _Alloc PROC
;;;284    */
;;;285    static GUI_HMEM _Alloc(GUI_ALLOC_DATATYPE size) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
;;;286      GUI_HMEM hMemNew, hMemIns;
;;;287      _CheckInit();
000006  f7fffffe          BL       _CheckInit
00000a  1ce4              ADDS     r4,r4,#3
00000c  4f40              LDR      r7,|L15.272|
;;;288      size = _Size2LegalSize(size);
00000e  f0240003          BIC      r0,r4,#3
000012  b205              SXTH     r5,r0
000014  f8df80fc          LDR      r8,|L15.276|
000018  68b8              LDR      r0,[r7,#8]  ; _LockCnt
00001a  b110              CBZ      r0,|L15.34|
00001c  f7fffffe          BL       GUI_ALLOC_GetMaxSize
000020  e001              B        |L15.38|
                  |L15.34|
000022  f9b8000e          LDRSH    r0,[r8,#0xe]  ; GUI_ALLOC
                  |L15.38|
;;;289      /* Check if memory is available at all ...*/
;;;290      if (size > _GetNumFreeBytes()) {
000026  42a8              CMP      r0,r5
000028  db6f              BLT      |L15.266|
00002a  4c3b              LDR      r4,|L15.280|
00002c  f24031c2          MOV      r1,#0x3c2
000030  6878              LDR      r0,[r7,#4]  ; _FirstFreeHandle
000032  e004              B        |L15.62|
                  |L15.52|
000034  eb0402c0          ADD      r2,r4,r0,LSL #3
000038  8852              LDRH     r2,[r2,#2]
00003a  b11a              CBZ      r2,|L15.68|
00003c  1c40              ADDS     r0,r0,#1
                  |L15.62|
00003e  4288              CMP      r0,r1
000040  dbf8              BLT      |L15.52|
000042  e062              B        |L15.266|
                  |L15.68|
000044  b206              SXTH     r6,r0
000046  6078              STR      r0,[r7,#4]  ; _FirstFreeHandle
000048  b3f6              CBZ      r6,|L15.200|
00004a  2000              MOVS     r0,#0
;;;291        GUI_DEBUG_WARN1("GUI_ALLOC_Alloc: Insufficient memory configured (Trying to alloc % bytes)", size);
;;;292        return 0;
;;;293      }
;;;294      /* Locate free handle */
;;;295      if ((hMemNew = _FindFreeHandle()) == 0) {
;;;296        return 0;
;;;297      }
;;;298      /* Locate or Create hole of sufficient size */
;;;299      hMemIns = _FindHole(size);
00004c  e00b              B        |L15.102|
00004e  bf00              NOP      
                  |L15.80|
000050  f8343030          LDRH     r3,[r4,r0,LSL #3]
000054  8852              LDRH     r2,[r2,#2]
000056  441a              ADD      r2,r2,r3
000058  f8343031          LDRH     r3,[r4,r1,LSL #3]
00005c  1a9a              SUBS     r2,r3,r2
00005e  b212              SXTH     r2,r2
000060  42aa              CMP      r2,r5
000062  da10              BGE      |L15.134|
000064  4608              MOV      r0,r1
                  |L15.102|
000066  eb0402c0          ADD      r2,r4,r0,LSL #3
00006a  8891              LDRH     r1,[r2,#4]
00006c  2900              CMP      r1,#0
00006e  d1ef              BNE      |L15.80|
000070  eb0402c0          ADD      r2,r4,r0,LSL #3
000074  f9341030          LDRSH    r1,[r4,r0,LSL #3]
000078  f9b22002          LDRSH    r2,[r2,#2]
00007c  4411              ADD      r1,r1,r2
00007e  f5c142f0          RSB      r2,r1,#0x7800
000082  42aa              CMP      r2,r5
000084  db03              BLT      |L15.142|
                  |L15.134|
000086  b200              SXTH     r0,r0
;;;300      #if GUI_ALLOC_AUTDEFRAG
;;;301        if (hMemIns == -1) {
000088  1c41              ADDS     r1,r0,#1
00008a  d002              BEQ      |L15.146|
00008c  e008              B        |L15.160|
                  |L15.142|
00008e  f04f30ff          MOV      r0,#0xffffffff
                  |L15.146|
;;;302          if (_LockCnt == 0) {
000092  68b9              LDR      r1,[r7,#8]  ; _LockCnt
000094  b911              CBNZ     r1,|L15.156|
;;;303            hMemIns = _CreateHole(size);
000096  4628              MOV      r0,r5
000098  f7fffffe          BL       _CreateHole
                  |L15.156|
;;;304          }
;;;305        }
;;;306      #endif
;;;307      /* Occupy hole */
;;;308      if (hMemIns==-1) {
00009c  1c41              ADDS     r1,r0,#1
00009e  d034              BEQ      |L15.266|
                  |L15.160|
;;;309        GUI_DEBUG_ERROROUT1("GUI_ALLOC_Alloc: Could not allocate %d bytes",size);
;;;310        return 0;
;;;311    	}
;;;312      {
;;;313        GUI_ALLOC_DATATYPE Off = aBlock[hMemIns].Off + aBlock[hMemIns].Size;
0000a0  eb0402c0          ADD      r2,r4,r0,LSL #3
0000a4  f8341030          LDRH     r1,[r4,r0,LSL #3]
0000a8  8853              LDRH     r3,[r2,#2]
0000aa  18cf              ADDS     r7,r1,r3
;;;314        int Next = aBlock[hMemIns].Next;
;;;315        aBlock[hMemNew].Size  = size;
0000ac  eb0403c6          ADD      r3,r4,r6,LSL #3
0000b0  8891              LDRH     r1,[r2,#4]            ;314
0000b2  805d              STRH     r5,[r3,#2]
;;;316        aBlock[hMemNew].Off   = Off;
0000b4  f8247036          STRH     r7,[r4,r6,LSL #3]
;;;317        if ((aBlock[hMemNew].Next  = Next) >0) {
0000b8  8099              STRH     r1,[r3,#4]
0000ba  b111              CBZ      r1,|L15.194|
;;;318          aBlock[Next].Prev = hMemNew;  
0000bc  eb0401c1          ADD      r1,r4,r1,LSL #3
0000c0  80ce              STRH     r6,[r1,#6]
                  |L15.194|
;;;319        }
;;;320        aBlock[hMemNew].Prev  = hMemIns;
0000c2  80d8              STRH     r0,[r3,#6]
;;;321        aBlock[hMemIns].Next  = hMemNew;
0000c4  8096              STRH     r6,[r2,#4]
;;;322      }
;;;323      /* Keep track of number of blocks and av. memory */
;;;324      GUI_ALLOC.NumUsedBlocks++;
0000c6  e000              B        |L15.202|
                  |L15.200|
0000c8  e01f              B        |L15.266|
                  |L15.202|
0000ca  f8d81000          LDR      r1,[r8,#0]  ; GUI_ALLOC
0000ce  4640              MOV      r0,r8
0000d0  1c49              ADDS     r1,r1,#1
;;;325      GUI_ALLOC.NumFreeBlocks--;
0000d2  f8c81000          STR      r1,[r8,#0]  ; GUI_ALLOC
0000d6  f8d81004          LDR      r1,[r8,#4]  ; GUI_ALLOC
0000da  1e49              SUBS     r1,r1,#1
;;;326      if (GUI_ALLOC.NumFreeBlocksMin > GUI_ALLOC.NumFreeBlocks) {
0000dc  f8c81004          STR      r1,[r8,#4]  ; GUI_ALLOC
0000e0  f8d82008          LDR      r2,[r8,#8]  ; GUI_ALLOC
0000e4  428a              CMP      r2,r1
0000e6  dd00              BLE      |L15.234|
;;;327        GUI_ALLOC.NumFreeBlocksMin = GUI_ALLOC.NumFreeBlocks;
0000e8  6081              STR      r1,[r0,#8]  ; GUI_ALLOC
                  |L15.234|
;;;328      }
;;;329      GUI_ALLOC.NumUsedBytes += size;
0000ea  8981              LDRH     r1,[r0,#0xc]  ; GUI_ALLOC
0000ec  4429              ADD      r1,r1,r5
0000ee  8181              STRH     r1,[r0,#0xc]
;;;330      GUI_ALLOC.NumFreeBytes -= size;
0000f0  89c1              LDRH     r1,[r0,#0xe]  ; GUI_ALLOC
0000f2  1b49              SUBS     r1,r1,r5
0000f4  b209              SXTH     r1,r1
0000f6  81c1              STRH     r1,[r0,#0xe]
;;;331      if (GUI_ALLOC.NumFreeBytesMin > GUI_ALLOC.NumFreeBytes) {
0000f8  f9b02010          LDRSH    r2,[r0,#0x10]  ; GUI_ALLOC
0000fc  428a              CMP      r2,r1
0000fe  dd01              BLE      |L15.260|
;;;332        GUI_ALLOC.NumFreeBytesMin = GUI_ALLOC.NumFreeBytes;
000100  f8a81010          STRH     r1,[r8,#0x10]
                  |L15.260|
;;;333      }
;;;334      return hMemNew;
000104  4630              MOV      r0,r6
                  |L15.262|
;;;335    }
000106  e8bd81f0          POP      {r4-r8,pc}
                  |L15.266|
00010a  2000              MOVS     r0,#0                 ;310
00010c  e7fb              B        |L15.262|
;;;336    
                          ENDP

00010e  0000              DCW      0x0000
                  |L15.272|
                          DCD      ||.data||
                  |L15.276|
                          DCD      ||.bss||
                  |L15.280|
                          DCD      ccmram+0x7800

                          AREA ||i._CheckInit||, CODE, READONLY, ALIGN=2

                  _CheckInit PROC
;;;262    */
;;;263    static void _CheckInit(void) {
000000  4803              LDR      r0,|L16.16|
;;;264      if (!IsInitialized) {
000002  7800              LDRB     r0,[r0,#0]  ; IsInitialized
000004  2800              CMP      r0,#0                 ;263
000006  d101              BNE      |L16.12|
;;;265        GUI_ALLOC_Init();
000008  f7ffbffe          B.W      GUI_ALLOC_Init
                  |L16.12|
;;;266      }
;;;267    }
00000c  4770              BX       lr
;;;268    
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      ||.data||

                          AREA ||i._CreateHole||, CODE, READONLY, ALIGN=2

                  _CreateHole PROC
;;;237    */
;;;238    static GUI_HMEM _CreateHole(GUI_ALLOC_DATATYPE Size) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
;;;239      int i, iNext;
;;;240      int r = -1;
000006  f04f36ff          MOV      r6,#0xffffffff
;;;241      for (i=0; (iNext =aBlock[i].Next) !=0; i= iNext) {
00000a  2000              MOVS     r0,#0
;;;242        GUI_ALLOC_DATATYPE NumFreeBytes = aBlock[iNext].Off- (aBlock[i].Off+aBlock[i].Size);
00000c  4c19              LDR      r4,|L17.116|
00000e  e01d              B        |L17.76|
                  |L17.16|
000010  f8340030          LDRH     r0,[r4,r0,LSL #3]
000014  8849              LDRH     r1,[r1,#2]
000016  4408              ADD      r0,r0,r1
000018  f9341035          LDRSH    r1,[r4,r5,LSL #3]
00001c  1a08              SUBS     r0,r1,r0
00001e  b200              SXTH     r0,r0
;;;243        if (NumFreeBytes < Size) {
000020  42b8              CMP      r0,r7
000022  da12              BGE      |L17.74|
;;;244          GUI_ALLOC_DATATYPE NumBytesBeforeBlock = aBlock[iNext].Off - (aBlock[i].Off+aBlock[i].Size);
000024  ea5f0800          MOVS     r8,r0
;;;245          if (NumBytesBeforeBlock) {
000028  d00f              BEQ      |L17.74|
;;;246            U8* pData = &GUI_Heap.abHeap[aBlock[iNext].Off];
00002a  4813              LDR      r0,|L17.120|
00002c  4401              ADD      r1,r1,r0
;;;247            memmove(pData-NumBytesBeforeBlock, pData, aBlock[iNext].Size);
00002e  eb0400c5          ADD      r0,r4,r5,LSL #3
000032  f9b02002          LDRSH    r2,[r0,#2]
000036  eba10008          SUB      r0,r1,r8
00003a  f7fffffe          BL       __aeabi_memmove
;;;248            aBlock[iNext].Off -=NumBytesBeforeBlock;
00003e  f8341035          LDRH     r1,[r4,r5,LSL #3]
000042  eba10008          SUB      r0,r1,r8
000046  f8240035          STRH     r0,[r4,r5,LSL #3]
                  |L17.74|
00004a  4628              MOV      r0,r5                 ;241
                  |L17.76|
00004c  eb0401c0          ADD      r1,r4,r0,LSL #3       ;241
000050  888d              LDRH     r5,[r1,#4]            ;241
000052  2d00              CMP      r5,#0                 ;241
000054  d1dc              BNE      |L17.16|
;;;249          }
;;;250        }
;;;251      }
;;;252      /* Check last block */
;;;253      if (GUI_ALLOC_SIZE - (aBlock[i].Off+aBlock[i].Size) >= Size) {
000056  eb0402c0          ADD      r2,r4,r0,LSL #3
00005a  f9341030          LDRSH    r1,[r4,r0,LSL #3]
00005e  f9b22002          LDRSH    r2,[r2,#2]
000062  4411              ADD      r1,r1,r2
000064  f5c141f0          RSB      r1,r1,#0x7800
000068  42b9              CMP      r1,r7
00006a  db00              BLT      |L17.110|
;;;254        r = i;
00006c  4606              MOV      r6,r0
                  |L17.110|
;;;255      }
;;;256      return r;
00006e  b230              SXTH     r0,r6
;;;257    }
000070  e8bd81f0          POP      {r4-r8,pc}
;;;258    
                          ENDP

                  |L17.116|
                          DCD      ccmram+0x7800
                  |L17.120|
                          DCD      ccmram

                          AREA ||i._Free||, CODE, READONLY, ALIGN=2

                  _Free PROC
;;;154    */
;;;155    static void _Free(GUI_HMEM hMem) {
000000  b530              PUSH     {r4,r5,lr}
;;;156      GUI_ALLOC_DATATYPE Size;
;;;157      GUI_DEBUG_LOG1("\nGUI_ALLOC_Free(%d)", hMem);
;;;158      /* Do some error checking ... */
;;;159      #if GUI_DEBUG_LEVEL>0
;;;160        /* Block not allocated ? */
;;;161        if (aBlock[hMem].Size == 0) {
000002  4912              LDR      r1,|L18.76|
000004  eb0104c0          ADD      r4,r1,r0,LSL #3
000008  f9b43002          LDRSH    r3,[r4,#2]
00000c  2b00              CMP      r3,#0                 ;155
00000e  d01c              BEQ      |L18.74|
;;;162          GUI_DEBUG_ERROROUT("GUI_ALLOC_Free(): Invalid hMem");
;;;163          return;
;;;164        }
;;;165      #endif
;;;166      Size = aBlock[hMem].Size;
;;;167      #ifdef WIN32
;;;168        GUI_MEMSET(&GUI_Heap.abHeap[aBlock[hMem].Off], 0xcc, Size);
;;;169      #endif
;;;170      GUI_ALLOC.NumFreeBytes += Size;
000010  4a0f              LDR      r2,|L18.80|
000012  89d5              LDRH     r5,[r2,#0xe]  ; GUI_ALLOC
000014  441d              ADD      r5,r5,r3
000016  81d5              STRH     r5,[r2,#0xe]
;;;171      GUI_ALLOC.NumUsedBytes -= Size;
000018  8995              LDRH     r5,[r2,#0xc]  ; GUI_ALLOC
00001a  1aeb              SUBS     r3,r5,r3
00001c  8193              STRH     r3,[r2,#0xc]
;;;172      aBlock[hMem].Size = 0;
00001e  2300              MOVS     r3,#0
000020  8063              STRH     r3,[r4,#2]
;;;173      if (_FirstFreeHandle > hMem) {
000022  4b0c              LDR      r3,|L18.84|
000024  685d              LDR      r5,[r3,#4]  ; _FirstFreeHandle
000026  4285              CMP      r5,r0
000028  dd00              BLE      |L18.44|
;;;174        _FirstFreeHandle = hMem;
00002a  6058              STR      r0,[r3,#4]  ; _FirstFreeHandle
                  |L18.44|
;;;175      }
;;;176      {
;;;177        int Next = aBlock[hMem].Next;
;;;178        int Prev = aBlock[hMem].Prev;
00002c  88e3              LDRH     r3,[r4,#6]
00002e  88a0              LDRH     r0,[r4,#4]            ;177
;;;179        aBlock[Prev].Next = Next;
000030  eb0104c3          ADD      r4,r1,r3,LSL #3
000034  80a0              STRH     r0,[r4,#4]
;;;180        if (Next) {
000036  b110              CBZ      r0,|L18.62|
;;;181          aBlock[Next].Prev = Prev;
000038  eb0100c0          ADD      r0,r1,r0,LSL #3
00003c  80c3              STRH     r3,[r0,#6]
                  |L18.62|
;;;182        }
;;;183      }  
;;;184      GUI_ALLOC.NumFreeBlocks++;
00003e  6850              LDR      r0,[r2,#4]  ; GUI_ALLOC
000040  1c40              ADDS     r0,r0,#1
;;;185      GUI_ALLOC.NumUsedBlocks--;
000042  6050              STR      r0,[r2,#4]  ; GUI_ALLOC
000044  6810              LDR      r0,[r2,#0]  ; GUI_ALLOC
000046  1e40              SUBS     r0,r0,#1
000048  6010              STR      r0,[r2,#0]  ; GUI_ALLOC
                  |L18.74|
;;;186    }
00004a  bd30              POP      {r4,r5,pc}
;;;187    
                          ENDP

                  |L18.76|
                          DCD      ccmram+0x7800
                  |L18.80|
                          DCD      ||.bss||
                  |L18.84|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  GUI_ALLOC
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  IsInitialized
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  _FirstFreeHandle
                          DCD      0x00000001
                  _LockCnt
                          DCD      0x00000000

                          AREA ccmram, DATA, ALIGN=2

                  GUI_Heap
                          %        30720
                  aBlock
                          %        7696
