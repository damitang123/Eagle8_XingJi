; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\printer.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\printer.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\Board_Support_Package\printer.c]
                          THUMB

                          AREA ||i.BlueTooth_MasterSlaveConfig||, CODE, READONLY, ALIGN=1

                  BlueTooth_MasterSlaveConfig PROC
;;;56     
;;;57     void BlueTooth_MasterSlaveConfig(bool bMaster)
000000  b510              PUSH     {r4,lr}
;;;58     {
000002  4604              MOV      r4,r0
;;;59     	Printer_Uart_Send(0x01);
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       Printer_Uart_Send
;;;60     	Printer_Uart_Send(0xFC);
00000a  20fc              MOVS     r0,#0xfc
00000c  f7fffffe          BL       Printer_Uart_Send
;;;61     	Printer_Uart_Send(0x0D);
000010  200d              MOVS     r0,#0xd
000012  f7fffffe          BL       Printer_Uart_Send
;;;62     	Printer_Uart_Send(0x01);
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       Printer_Uart_Send
;;;63     	if(bMaster)
00001c  b10c              CBZ      r4,|L1.34|
;;;64     	{
;;;65     		Printer_Uart_Send(0x01);
00001e  2001              MOVS     r0,#1
000020  e000              B        |L1.36|
                  |L1.34|
;;;66     	}
;;;67     	else
;;;68     	{
;;;69     		Printer_Uart_Send(0x00);
000022  2000              MOVS     r0,#0
                  |L1.36|
000024  e8bd4010          POP      {r4,lr}
000028  f7ffbffe          B.W      Printer_Uart_Send
;;;70     	}
;;;71     }
;;;72     
                          ENDP


                          AREA ||i.Get_Uart_Data||, CODE, READONLY, ALIGN=2

                  Get_Uart_Data PROC
;;;31     
;;;32     static unsigned char Get_Uart_Data(void)
000000  4907              LDR      r1,|L2.32|
;;;33     {
;;;34     	unsigned char nTemp;
;;;35     	nTemp = g_aUartCmdRevBuffer[s_nUartOutCnt];
000002  4806              LDR      r0,|L2.28|
000004  88ca              LDRH     r2,[r1,#6]  ; s_nUartOutCnt
000006  5c80              LDRB     r0,[r0,r2]
;;;36     	if(++s_nUartOutCnt >= UART_BUFFER_SIZE)
000008  88ca              LDRH     r2,[r1,#6]  ; s_nUartOutCnt
00000a  1c52              ADDS     r2,r2,#1
00000c  b292              UXTH     r2,r2
00000e  80ca              STRH     r2,[r1,#6]
000010  f5b27ffa          CMP      r2,#0x1f4
000014  d301              BCC      |L2.26|
;;;37     	{
;;;38     		s_nUartOutCnt = 0;
000016  2200              MOVS     r2,#0
000018  80ca              STRH     r2,[r1,#6]
                  |L2.26|
;;;39     	}
;;;40     	return nTemp;
;;;41     }
00001a  4770              BX       lr
;;;42     
                          ENDP

                  |L2.28|
                          DCD      ||.bss||
                  |L2.32|
                          DCD      ||.data||

                          AREA ||i.Printer_Init||, CODE, READONLY, ALIGN=2

                  Printer_Init PROC
;;;123    
;;;124    void Printer_Init(void)
000000  b510              PUSH     {r4,lr}
;;;125    {
;;;126    	Printer_Uart_Init();
000002  f7fffffe          BL       Printer_Uart_Init
;;;127    	memset(&g_sPrinter, 0 ,sizeof(g_sPrinter));
000006  4804              LDR      r0,|L3.24|
000008  2100              MOVS     r1,#0
00000a  8181              STRH     r1,[r0,#0xc]
00000c  7381              STRB     r1,[r0,#0xe]
;;;128    	IO_EX_Printer_Power_On();
00000e  4903              LDR      r1,|L3.28|
000010  2004              MOVS     r0,#4
000012  6008              STR      r0,[r1,#0]
;;;129    }
000014  bd10              POP      {r4,pc}
;;;130    
                          ENDP

000016  0000              DCW      0x0000
                  |L3.24|
                          DCD      ||.data||
                  |L3.28|
                          DCD      0x40011810

                          AREA ||i.Printer_Process_Command||, CODE, READONLY, ALIGN=2

                  Printer_Process_Command PROC
;;;186    
;;;187    void Printer_Process_Command(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;188    {
000004  f8df9160          LDR      r9,|L4.360|
;;;189    	static unsigned char nCheckSum;
;;;190    	static unsigned short nDataLength;
;;;191    	
;;;192    	while(s_nUartOutCnt != s_nUartInCnt)
;;;193    	{
;;;194    		switch(s_eUARTRecievePhase)
000008  2701              MOVS     r7,#1
00000a  f04f0805          MOV      r8,#5
;;;195    		{
;;;196    		case eUARTPhaseHead0:
;;;197    			if(Get_Uart_Data() == 0xBC)
;;;198    			{
;;;199    				s_bStartRevCmd = true;
;;;200    				s_nCmdProcessBufferCnt = 0;
;;;201    				g_nStartRevCmdTime = Get_System_Time();
;;;202    				s_eUARTRecievePhase = eUARTPhaseHead1;
;;;203    			}
;;;204    			break;
;;;205    
;;;206    		case eUARTPhaseHead1:
;;;207    			if(Get_Uart_Data() == 0xFD)
;;;208    			{
;;;209    				s_eUARTRecievePhase = eUARTPhaseCmd;
;;;210    			}
;;;211    			break;
;;;212    
;;;213    		case eUARTPhaseCmd:
;;;214    			s_aCmdProcessBuffer[s_nCmdProcessBufferCnt++] = Get_Uart_Data();
00000e  4d55              LDR      r5,|L4.356|
000010  2600              MOVS     r6,#0
000012  f1a9040c          SUB      r4,r9,#0xc            ;194
000016  e08d              B        |L4.308|
                  |L4.24|
000018  7820              LDRB     r0,[r4,#0]            ;194  ; s_eUARTRecievePhase
00001a  2808              CMP      r0,#8                 ;194
00001c  d20f              BCS      |L4.62|
00001e  e8dff000          TBB      [pc,r0]               ;194
000022  040f              DCB      0x04,0x0f
000024  151f314a          DCB      0x15,0x1f,0x31,0x4a
000028  5768              DCB      0x57,0x68
00002a  f7fffffe          BL       Get_Uart_Data
00002e  28bc              CMP      r0,#0xbc              ;197
000030  d105              BNE      |L4.62|
000032  7067              STRB     r7,[r4,#1]            ;199
000034  8166              STRH     r6,[r4,#0xa]          ;200
000036  f7fffffe          BL       Get_System_Time
00003a  6120              STR      r0,[r4,#0x10]         ;201  ; g_nStartRevCmdTime
00003c  7027              STRB     r7,[r4,#0]            ;202
                  |L4.62|
00003e  e079              B        |L4.308|
000040  f7fffffe          BL       Get_Uart_Data
000044  28fd              CMP      r0,#0xfd              ;207
000046  d175              BNE      |L4.308|
000048  2002              MOVS     r0,#2                 ;209
00004a  e050              B        |L4.238|
00004c  f7fffffe          BL       Get_Uart_Data
000050  8961              LDRH     r1,[r4,#0xa]  ; s_nCmdProcessBufferCnt
000052  5468              STRB     r0,[r5,r1]
000054  1c49              ADDS     r1,r1,#1
000056  8161              STRH     r1,[r4,#0xa]
;;;215    			nDataLength = 0;
000058  8126              STRH     r6,[r4,#8]
;;;216    			nCheckSum = 0;
00005a  70a6              STRB     r6,[r4,#2]
;;;217    			s_eUARTRecievePhase = eUARTPhaseDataLength;
00005c  2003              MOVS     r0,#3
;;;218    			break;
00005e  e046              B        |L4.238|
;;;219    
;;;220    		case eUARTPhaseDataLength:
;;;221    			nDataLength = Get_Uart_Data();
000060  f7fffffe          BL       Get_Uart_Data
000064  8120              STRH     r0,[r4,#8]
;;;222    			s_aCmdProcessBuffer[s_nCmdProcessBufferCnt++] = nDataLength;
000066  8961              LDRH     r1,[r4,#0xa]  ; s_nCmdProcessBufferCnt
000068  5468              STRB     r0,[r5,r1]
00006a  1c49              ADDS     r1,r1,#1
00006c  8161              STRH     r1,[r4,#0xa]
;;;223    			
;;;224    			if(nDataLength >= UART_BUFFER_SIZE)
00006e  f5b07ffa          CMP      r0,#0x1f4
000072  d301              BCC      |L4.120|
;;;225    			{
;;;226    				Uart_Recieve_Error_Handle(__LINE__);
000074  20e2              MOVS     r0,#0xe2
000076  e036              B        |L4.230|
                  |L4.120|
;;;227    			}
;;;228    			else if(nDataLength)
000078  b108              CBZ      r0,|L4.126|
;;;229    			{
;;;230    				s_eUARTRecievePhase = eUARTPhaseData;
00007a  2004              MOVS     r0,#4
00007c  e037              B        |L4.238|
                  |L4.126|
;;;231    			}
;;;232    			else
;;;233    			{
;;;234    				s_eUARTRecievePhase = eUARTPhaseCrc1;
00007e  f8848000          STRB     r8,[r4,#0]
000082  e057              B        |L4.308|
;;;235    			}
;;;236    			break;
;;;237    
;;;238    		case eUARTPhaseData:
;;;239    			s_aCmdProcessBuffer[s_nCmdProcessBufferCnt++] = Get_Uart_Data();
000084  f7fffffe          BL       Get_Uart_Data
000088  8961              LDRH     r1,[r4,#0xa]  ; s_nCmdProcessBufferCnt
00008a  5468              STRB     r0,[r5,r1]
00008c  1c49              ADDS     r1,r1,#1
00008e  b288              UXTH     r0,r1
000090  8160              STRH     r0,[r4,#0xa]
;;;240    			nCheckSum += s_aCmdProcessBuffer[s_nCmdProcessBufferCnt - 1];
000092  1829              ADDS     r1,r5,r0
000094  78a2              LDRB     r2,[r4,#2]  ; nCheckSum
000096  f8111c01          LDRB     r1,[r1,#-1]
;;;241    			if(s_nCmdProcessBufferCnt >= UART_CMD_BUFFER_SIZE)
00009a  28c8              CMP      r0,#0xc8
00009c  4411              ADD      r1,r1,r2              ;240
00009e  70a1              STRB     r1,[r4,#2]            ;240
0000a0  d302              BCC      |L4.168|
;;;242    			{
;;;243    				Uart_Recieve_Error_Handle(__LINE__);
0000a2  20f3              MOVS     r0,#0xf3
0000a4  f7fffffe          BL       Uart_Recieve_Error_Handle
                  |L4.168|
;;;244    			}
;;;245    			if(--nDataLength == 0)
0000a8  8920              LDRH     r0,[r4,#8]  ; nDataLength
0000aa  1e40              SUBS     r0,r0,#1
0000ac  0400              LSLS     r0,r0,#16
0000ae  0c00              LSRS     r0,r0,#16
0000b0  8120              STRH     r0,[r4,#8]
0000b2  d13f              BNE      |L4.308|
0000b4  e7e3              B        |L4.126|
;;;246    			{
;;;247    				s_eUARTRecievePhase = eUARTPhaseCrc1;
;;;248    			}
;;;249    			break;
;;;250    
;;;251    		case eUARTPhaseCrc1:
;;;252    			s_aCmdProcessBuffer[s_nCmdProcessBufferCnt++] = Get_Uart_Data();
0000b6  f7fffffe          BL       Get_Uart_Data
0000ba  8961              LDRH     r1,[r4,#0xa]  ; s_nCmdProcessBufferCnt
0000bc  5468              STRB     r0,[r5,r1]
0000be  1c49              ADDS     r1,r1,#1
0000c0  b288              UXTH     r0,r1
0000c2  8160              STRH     r0,[r4,#0xa]
;;;253    			if(s_nCmdProcessBufferCnt >= UART_CMD_BUFFER_SIZE)
0000c4  28c8              CMP      r0,#0xc8
0000c6  d301              BCC      |L4.204|
;;;254    			{
;;;255    				Uart_Recieve_Error_Handle(__LINE__);
0000c8  20ff              MOVS     r0,#0xff
;;;256    				break;
0000ca  e00c              B        |L4.230|
                  |L4.204|
;;;257    			}
;;;258    			s_eUARTRecievePhase = eUARTPhaseCrc2;
0000cc  2006              MOVS     r0,#6
;;;259    			break;
0000ce  e00e              B        |L4.238|
;;;260    
;;;261    		case eUARTPhaseCrc2:
;;;262    			s_aCmdProcessBuffer[s_nCmdProcessBufferCnt++] = Get_Uart_Data();
0000d0  f7fffffe          BL       Get_Uart_Data
0000d4  8961              LDRH     r1,[r4,#0xa]  ; s_nCmdProcessBufferCnt
0000d6  5468              STRB     r0,[r5,r1]
0000d8  1c49              ADDS     r1,r1,#1
0000da  b288              UXTH     r0,r1
0000dc  8160              STRH     r0,[r4,#0xa]
;;;263    			if(s_nCmdProcessBufferCnt >= UART_CMD_BUFFER_SIZE)
0000de  28c8              CMP      r0,#0xc8
0000e0  d304              BCC      |L4.236|
;;;264    			{
;;;265    				Uart_Recieve_Error_Handle(__LINE__);
0000e2  f2401009          MOV      r0,#0x109
                  |L4.230|
0000e6  f7fffffe          BL       Uart_Recieve_Error_Handle
0000ea  e023              B        |L4.308|
                  |L4.236|
;;;266    				break;
;;;267    			}
;;;268    			s_eUARTRecievePhase = eUARTPhaseEnd;
0000ec  2007              MOVS     r0,#7
                  |L4.238|
0000ee  7020              STRB     r0,[r4,#0]
0000f0  e020              B        |L4.308|
;;;269    			break;
;;;270    
;;;271    		case eUARTPhaseEnd:
;;;272    			if(Get_Uart_Data() == 0xAE)
0000f2  f7fffffe          BL       Get_Uart_Data
0000f6  28ae              CMP      r0,#0xae
0000f8  d11c              BNE      |L4.308|
0000fa  481a              LDR      r0,|L4.356|
0000fc  7801              LDRB     r1,[r0,#0]
0000fe  7880              LDRB     r0,[r0,#2]
000100  2980              CMP      r1,#0x80
000102  d010              BEQ      |L4.294|
000104  2981              CMP      r1,#0x81
000106  d10e              BNE      |L4.294|
000108  2801              CMP      r0,#1
00010a  d004              BEQ      |L4.278|
00010c  2803              CMP      r0,#3
00010e  d005              BEQ      |L4.284|
000110  2804              CMP      r0,#4
000112  d006              BEQ      |L4.290|
000114  e007              B        |L4.294|
                  |L4.278|
000116  f8897000          STRB     r7,[r9,#0]
00011a  e004              B        |L4.294|
                  |L4.284|
00011c  f8897001          STRB     r7,[r9,#1]
000120  e001              B        |L4.294|
                  |L4.290|
000122  f8897002          STRB     r7,[r9,#2]
                  |L4.294|
;;;273    			{
;;;274    				Uart_Cmd_Parser_Sub();
;;;275    				pApp->nStartIdleTime = Get_System_Time();
000126  f7fffffe          BL       Get_System_Time
00012a  4910              LDR      r1,|L4.364|
00012c  6809              LDR      r1,[r1,#0]  ; pApp
;;;276    				s_bStartRevCmd = false;
00012e  6048              STR      r0,[r1,#4]
000130  7066              STRB     r6,[r4,#1]
;;;277    				s_eUARTRecievePhase = eUARTPhaseHead0;
000132  7026              STRB     r6,[r4,#0]
                  |L4.308|
000134  88e0              LDRH     r0,[r4,#6]            ;192  ; s_nUartOutCnt
000136  88a1              LDRH     r1,[r4,#4]            ;192  ; s_nUartInCnt
000138  4288              CMP      r0,r1                 ;192
00013a  f47faf6d          BNE      |L4.24|
;;;278    			}
;;;279    			break;
;;;280    		}
;;;281    	}
;;;282    
;;;283    	if(s_bStartRevCmd && Get_System_Time()  > g_nStartRevCmdTime +  UART_CMD_TIMOUT)
00013e  7860              LDRB     r0,[r4,#1]  ; s_bStartRevCmd
000140  2800              CMP      r0,#0
000142  d00c              BEQ      |L4.350|
000144  f7fffffe          BL       Get_System_Time
000148  6921              LDR      r1,[r4,#0x10]  ; g_nStartRevCmdTime
00014a  f50171fa          ADD      r1,r1,#0x1f4
00014e  4288              CMP      r0,r1
000150  d905              BLS      |L4.350|
;;;284    	{
;;;285    		Uart_Recieve_Error_Handle(__LINE__);
000152  e8bd47f0          POP      {r4-r10,lr}
000156  f240101d          MOV      r0,#0x11d
00015a  f7ffbffe          B.W      Uart_Recieve_Error_Handle
                  |L4.350|
;;;286    	}
;;;287    }
00015e  e8bd87f0          POP      {r4-r10,pc}
;;;288    
                          ENDP

000162  0000              DCW      0x0000
                  |L4.356|
                          DCD      ||.bss||+0x1f4
                  |L4.360|
                          DCD      ||.data||+0xc
                  |L4.364|
                          DCD      pApp

                          AREA ||i.Printer_SetPWD||, CODE, READONLY, ALIGN=1

                  Printer_SetPWD PROC
;;;72     
;;;73     void Printer_SetPWD(char *pPWD)
000000  b510              PUSH     {r4,lr}
;;;74     {
000002  4604              MOV      r4,r0
;;;75     	Printer_Uart_Send(0x01);
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       Printer_Uart_Send
;;;76     	Printer_Uart_Send(0xFC);
00000a  20fc              MOVS     r0,#0xfc
00000c  f7fffffe          BL       Printer_Uart_Send
;;;77     	Printer_Uart_Send(0x05);
000010  2005              MOVS     r0,#5
000012  f7fffffe          BL       Printer_Uart_Send
;;;78     	Printer_Uart_Send(4);
000016  2004              MOVS     r0,#4
;;;79     
;;;80     	while(*pPWD != 0)
000018  e000              B        |L5.28|
                  |L5.26|
00001a  1c64              ADDS     r4,r4,#1
                  |L5.28|
00001c  f7fffffe          BL       Printer_Uart_Send
000020  7820              LDRB     r0,[r4,#0]
000022  2800              CMP      r0,#0
000024  d1f9              BNE      |L5.26|
;;;81     	{
;;;82     		Printer_Uart_Send(*pPWD++);
;;;83     	}
;;;84     }
000026  bd10              POP      {r4,pc}
;;;85     
                          ENDP


                          AREA ||i.Printer_Shutdown||, CODE, READONLY, ALIGN=2

                  Printer_Shutdown PROC
;;;130    
;;;131    void Printer_Shutdown(void)
000000  4907              LDR      r1,|L6.32|
;;;132    {
000002  b510              PUSH     {r4,lr}
;;;133    	IO_EX_Printer_Power_Off();
000004  2004              MOVS     r0,#4
000006  6008              STR      r0,[r1,#0]
;;;134    	USART_Cmd(USART3, DISABLE);
000008  2100              MOVS     r1,#0
00000a  4806              LDR      r0,|L6.36|
00000c  f7fffffe          BL       USART_Cmd
;;;135    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, DISABLE);
000010  e8bd4010          POP      {r4,lr}
000014  2100              MOVS     r1,#0
000016  f44f2080          MOV      r0,#0x40000
00001a  f7ffbffe          B.W      RCC_APB1PeriphClockCmd
;;;136    }
;;;137    
                          ENDP

00001e  0000              DCW      0x0000
                  |L6.32|
                          DCD      0x40011814
                  |L6.36|
                          DCD      0x40004800

                          AREA ||i.Printer_Uart_Init||, CODE, READONLY, ALIGN=2

                  Printer_Uart_Init PROC
;;;85     
;;;86     static void Printer_Uart_Init(void)
000000  b510              PUSH     {r4,lr}
;;;87     {
;;;88     	GPIO_InitTypeDef GPIO_InitStructure;
;;;89     	USART_InitTypeDef USART_InitStructure;
;;;90     
;;;91     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
000002  2101              MOVS     r1,#1
000004  b086              SUB      sp,sp,#0x18           ;87
000006  0488              LSLS     r0,r1,#18
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;92     
;;;93     	/* Configure USARTx_Tx as alternate function push-pull */
;;;94     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
00000c  f44f6080          MOV      r0,#0x400
000010  f8ad0010          STRH     r0,[sp,#0x10]
;;;95     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000014  2003              MOVS     r0,#3
000016  f88d0012          STRB     r0,[sp,#0x12]
;;;96     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001a  2018              MOVS     r0,#0x18
;;;97     	GPIO_Init(GPIOB, &GPIO_InitStructure);
00001c  4c1a              LDR      r4,|L7.136|
00001e  f88d0013          STRB     r0,[sp,#0x13]         ;96
000022  a904              ADD      r1,sp,#0x10
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       GPIO_Init
;;;98     
;;;99     	/* Configure USARTx_Rx as input floating */
;;;100    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
00002a  14e0              ASRS     r0,r4,#19
00002c  f8ad0010          STRH     r0,[sp,#0x10]
;;;101    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
000030  2004              MOVS     r0,#4
000032  f88d0013          STRB     r0,[sp,#0x13]
;;;102    	GPIO_Init(GPIOB, &GPIO_InitStructure);
000036  a904              ADD      r1,sp,#0x10
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       GPIO_Init
;;;103    
;;;104    	USART_InitStructure.USART_BaudRate = 115200;
00003e  f44f30e1          MOV      r0,#0x1c200
;;;105    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000042  9000              STR      r0,[sp,#0]
000044  2000              MOVS     r0,#0
000046  f8ad0004          STRH     r0,[sp,#4]
;;;106    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00004a  f8ad0006          STRH     r0,[sp,#6]
;;;107    	USART_InitStructure.USART_Parity = USART_Parity_No ;
00004e  f8ad0008          STRH     r0,[sp,#8]
;;;108    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000052  f8ad000c          STRH     r0,[sp,#0xc]
;;;109    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000056  200c              MOVS     r0,#0xc
;;;110    
;;;111    	/* Configure the USARTx */ 
;;;112    	USART_Init(USART3, &USART_InitStructure);
000058  4c0c              LDR      r4,|L7.140|
00005a  f8ad000a          STRH     r0,[sp,#0xa]          ;109
00005e  4669              MOV      r1,sp
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       USART_Init
;;;113    
;;;114    	//串口接收中断开启
;;;115    	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE); 
000066  2201              MOVS     r2,#1
000068  f2405125          MOV      r1,#0x525
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       USART_ITConfig
;;;116    
;;;117    	/* Enable the USARTx */
;;;118    	USART_Cmd(USART3, ENABLE);
000072  2101              MOVS     r1,#1
000074  4620              MOV      r0,r4
000076  f7fffffe          BL       USART_Cmd
;;;119    
;;;120    	USART_ClearFlag(USART3, USART_FLAG_TC);
00007a  2140              MOVS     r1,#0x40
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       USART_ClearFlag
;;;121    }
000082  b006              ADD      sp,sp,#0x18
000084  bd10              POP      {r4,pc}
;;;122    
                          ENDP

000086  0000              DCW      0x0000
                  |L7.136|
                          DCD      0x40010c00
                  |L7.140|
                          DCD      0x40004800

                          AREA ||i.Printer_Uart_Send||, CODE, READONLY, ALIGN=2

                  Printer_Uart_Send PROC
;;;50     
;;;51     void Printer_Uart_Send(unsigned char ch)
000000  b510              PUSH     {r4,lr}
;;;52     {
;;;53     	USART_SendData(USART3, ch);
000002  4c06              LDR      r4,|L8.28|
000004  4601              MOV      r1,r0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       USART_SendData
                  |L8.12|
;;;54     	while(USART_GetFlagStatus(USART3, USART_FLAG_TC) == RESET);
00000c  2140              MOVS     r1,#0x40
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       USART_GetFlagStatus
000014  2800              CMP      r0,#0
000016  d0f9              BEQ      |L8.12|
;;;55     }
000018  bd10              POP      {r4,pc}
;;;56     
                          ENDP

00001a  0000              DCW      0x0000
                  |L8.28|
                          DCD      0x40004800

                          AREA ||i.Receive_Data_From_UART||, CODE, READONLY, ALIGN=2

                  Receive_Data_From_UART PROC
;;;22     /*此函数要被中断调用*/
;;;23     void Receive_Data_From_UART(unsigned char RevData)
000000  4907              LDR      r1,|L9.32|
;;;24     {
;;;25     	g_aUartCmdRevBuffer[s_nUartInCnt] = RevData;
000002  4a06              LDR      r2,|L9.28|
000004  888b              LDRH     r3,[r1,#4]  ; s_nUartInCnt
000006  54d0              STRB     r0,[r2,r3]
;;;26     	if(++s_nUartInCnt >= UART_BUFFER_SIZE)
000008  8888              LDRH     r0,[r1,#4]  ; s_nUartInCnt
00000a  1c40              ADDS     r0,r0,#1
00000c  b280              UXTH     r0,r0
00000e  8088              STRH     r0,[r1,#4]
000010  f5b07ffa          CMP      r0,#0x1f4
000014  d301              BCC      |L9.26|
;;;27     	{
;;;28     		s_nUartInCnt = 0;
000016  2000              MOVS     r0,#0
000018  8088              STRH     r0,[r1,#4]
                  |L9.26|
;;;29     	}
;;;30     }
00001a  4770              BX       lr
;;;31     
                          ENDP

                  |L9.28|
                          DCD      ||.bss||
                  |L9.32|
                          DCD      ||.data||

                          AREA ||i.USART3_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART3_IRQHandler PROC
;;;42     
;;;43     void USART3_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;44     {
;;;45     	if(USART_GetFlagStatus(USART3, USART_IT_RXNE) == SET)
000002  4c08              LDR      r4,|L10.36|
000004  f2405125          MOV      r1,#0x525
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       USART_GetFlagStatus
00000e  2801              CMP      r0,#1
000010  d107              BNE      |L10.34|
;;;46     	{
;;;47     		Receive_Data_From_UART(USART_ReceiveData(USART3));
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       USART_ReceiveData
000018  e8bd4010          POP      {r4,lr}
00001c  b2c0              UXTB     r0,r0
00001e  f7ffbffe          B.W      Receive_Data_From_UART
                  |L10.34|
;;;48     	}
;;;49     }
000022  bd10              POP      {r4,pc}
;;;50     
                          ENDP

                  |L10.36|
                          DCD      0x40004800

                          AREA ||i.Uart_Recieve_Error_Handle||, CODE, READONLY, ALIGN=2

                  Uart_Recieve_Error_Handle PROC
;;;137    
;;;138    static void  Uart_Recieve_Error_Handle(int nLine)
000000  4a03              LDR      r2,|L11.16|
;;;139    {
;;;140    	s_bStartRevCmd = false;
000002  2100              MOVS     r1,#0
000004  7051              STRB     r1,[r2,#1]
;;;141    	s_eUARTRecievePhase = eUARTPhaseHead0;
000006  7011              STRB     r1,[r2,#0]
;;;142    
;;;143    	TRACE_PRINTF("Uart_Recieve_Error_Handle( Line = %d)\r\n",nLine);
000008  4601              MOV      r1,r0
00000a  a002              ADR      r0,|L11.20|
00000c  f7ffbffe          B.W      User_Debug_Printf
;;;144    }
;;;145    
                          ENDP

                  |L11.16|
                          DCD      ||.data||
                  |L11.20|
000014  55617274          DCB      "Uart_Recieve_Error_Handle( Line = %d)\r\n",0
000018  5f526563
00001c  69657665
000020  5f457272
000024  6f725f48
000028  616e646c
00002c  6528204c
000030  696e6520
000034  3d202564
000038  290d0a00

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_aUartCmdRevBuffer
                          %        500
                  s_aCmdProcessBuffer
                          %        200

                          AREA ||.data||, DATA, ALIGN=2

                  s_eUARTRecievePhase
000000  00                DCB      0x00
                  s_bStartRevCmd
000001  00                DCB      0x00
                  nCheckSum
000002  0000              DCB      0x00,0x00
                  s_nUartInCnt
000004  0000              DCW      0x0000
                  s_nUartOutCnt
000006  0000              DCW      0x0000
                  nDataLength
000008  0000              DCB      0x00,0x00
                  s_nCmdProcessBufferCnt
00000a  0000              DCB      0x00,0x00
                  g_sPrinter
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  g_nStartRevCmdTime
                          DCD      0x00000000
