; generated by Component: ARM Compiler 5.05 (build 41) Tool: ArmCC [4d0eb9]
; commandline ArmCC [--list --split_sections -c --asm --interleave -o.\obj\gui_jpeg.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\gui_jpeg.d --cpu=Cortex-M3 --apcs=interwork -O3 -I..\Board_Support_Package -I..\Config -I..\GUI\Core -I..\GUI\JPEG -I..\GUI\LCDDriver -I..\GUI\MultiLayer -I..\GUI\Widget -I..\GUI\WM -I..\Libraries\CMSIS\CM3\CoreSupport -I..\Libraries\CMSIS\CM3\DeviceSupport\ST\STM32F10x -I..\Libraries\CMSIS\Include -I..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\User\Res -I..\User\UserWindow -I..\User -I..\USB\inc -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -IC:\Keil_v5\ARM\Inc\ST\STM32F10x -D__MICROLIB -DSTM32F10X_HD -DVECT_TAB_FLASH -DUSE_STDPERIPH_DRIVER --no_multibyte_chars ..\GUI\JPEG\GUI_JPEG.c]
                          THUMB

                          AREA ||i.GUI_JPEG_Draw||, CODE, READONLY, ALIGN=2

                  GUI_JPEG_Draw PROC
;;;355    */
;;;356    int GUI_JPEG_Draw(const void * pFileData, int DataSize, int x0, int y0) {
000000  e92d4fff          PUSH     {r0-r11,lr}
000004  f5ad7d19          SUB      sp,sp,#0x264
000008  461d              MOV      r5,r3
00000a  4614              MOV      r4,r2
;;;357      #if (GUI_WINSUPPORT)
;;;358        GUI_RECT r;
;;;359      #endif
;;;360      int Ret = 0;
;;;361      GUI_HMEM hBuffer = 0;
00000c  e9dd2399          LDRD     r2,r3,[sp,#0x264]
000010  f04f0a00          MOV      r10,#0                ;360
000014  46d1              MOV      r9,r10
;;;362    	struct jpeg_decompress_struct cinfo;
;;;363    	struct jpeg_error_mgr jerr;
;;;364      GUI_LOCK();
;;;365      _Init(&jerr, &cinfo, pFileData, DataSize);
000016  4669              MOV      r1,sp
000018  a874              ADD      r0,sp,#0x1d0
00001a  f7fffffe          BL       _Init
;;;366      #if (GUI_WINSUPPORT)
;;;367        WM_ADDORG(x0,y0);
00001e  4844              LDR      r0,|L1.304|
000020  6c41              LDR      r1,[r0,#0x44]  ; GUI_Context
000022  6c80              LDR      r0,[r0,#0x48]  ; GUI_Context
000024  440c              ADD      r4,r4,r1
000026  eb000805          ADD      r8,r0,r5
;;;368        r.x1 = (r.x0 = x0) + cinfo.image_width - 1;
00002a  9907              LDR      r1,[sp,#0x1c]
00002c  1e60              SUBS     r0,r4,#1
00002e  4408              ADD      r0,r0,r1
000030  f8ad0258          STRH     r0,[sp,#0x258]
;;;369        r.y1 = (r.y0 = y0) + cinfo.image_height - 1;
000034  9908              LDR      r1,[sp,#0x20]
000036  f1a80001          SUB      r0,r8,#1
00003a  4408              ADD      r0,r0,r1
00003c  f8ad4254          STRH     r4,[sp,#0x254]        ;368
000040  f8ad025a          STRH     r0,[sp,#0x25a]
000044  f8ad8256          STRH     r8,[sp,#0x256]
;;;370        WM_ITERATE_START(&r) {
000048  a895              ADD      r0,sp,#0x254
00004a  f7fffffe          BL       WM__InitIVRSearch
00004e  b970              CBNZ     r0,|L1.110|
000050  e066              B        |L1.288|
;;;371      #endif
;;;372        if (hBuffer) {
000052  bf00              NOP      
                  |L1.84|
000054  f1b90f00          CMP      r9,#0
000058  d009              BEQ      |L1.110|
00005a  e9dd2399          LDRD     r2,r3,[sp,#0x264]
;;;373          _Init(&jerr, &cinfo, pFileData, DataSize);
00005e  4669              MOV      r1,sp
000060  a874              ADD      r0,sp,#0x1d0
000062  f7fffffe          BL       _Init
;;;374        }
;;;375        /* 4. Set up parameters for decompression (optional ...) */
;;;376        /* 5. jpeg_start_decompress(...); Should normally return quickly */
;;;377    	  jpeg_start_decompress(&cinfo);
000066  4668              MOV      r0,sp
000068  f7fffffe          BL       jpeg_start_decompress
00006c  e04a              B        |L1.260|
                  |L1.110|
00006e  4668              MOV      r0,sp
000070  f7fffffe          BL       jpeg_start_decompress
;;;378        /* 6. while (scan lines remain to be read) */
;;;379    	  /*     jpeg_read_scanlines(...); */
;;;380        if (!hBuffer) {
;;;381          hBuffer = GUI_ALLOC_AllocNoInit(cinfo.image_width * 3);
000074  9807              LDR      r0,[sp,#0x1c]
000076  eb000040          ADD      r0,r0,r0,LSL #1
00007a  b200              SXTH     r0,r0
00007c  f7fffffe          BL       GUI_ALLOC_AllocNoInit
000080  4681              MOV      r9,r0
000082  e03f              B        |L1.260|
                  |L1.132|
;;;382        }
;;;383        while (cinfo.output_scanline < cinfo.output_height) {
;;;384          U8* p;
;;;385          p = (U8*)GUI_ALLOC_h2p(hBuffer);
000084  4648              MOV      r0,r9
000086  f7fffffe          BL       GUI_ALLOC_h2p
;;;386          jpeg_read_scanlines(&cinfo, &p, 1);
00008a  9097              STR      r0,[sp,#0x25c]
00008c  2201              MOVS     r2,#1
00008e  a997              ADD      r1,sp,#0x25c
000090  4668              MOV      r0,sp
000092  f7fffffe          BL       jpeg_read_scanlines
;;;387          if (cinfo.jpeg_color_space == JCS_GRAYSCALE) {
000096  f89d0028          LDRB     r0,[sp,#0x28]
00009a  2801              CMP      r0,#1
00009c  d006              BEQ      |L1.172|
;;;388            _WritePixelsGray(p, x0, y0 + cinfo.output_scanline, cinfo.image_width);
;;;389          } else {
;;;390            _WritePixelsRGB(p, x0, y0 + cinfo.output_scanline, cinfo.image_width);
00009e  9923              LDR      r1,[sp,#0x8c]
0000a0  4626              MOV      r6,r4
0000a2  eb010b08          ADD      r11,r1,r8
0000a6  9f07              LDR      r7,[sp,#0x1c]
0000a8  9d97              LDR      r5,[sp,#0x25c]
0000aa  e029              B        |L1.256|
                  |L1.172|
0000ac  9923              LDR      r1,[sp,#0x8c]         ;388
0000ae  4627              MOV      r7,r4                 ;388
0000b0  eb010b08          ADD      r11,r1,r8             ;388
0000b4  9e97              LDR      r6,[sp,#0x25c]        ;388
0000b6  9d07              LDR      r5,[sp,#0x1c]         ;388
0000b8  e00e              B        |L1.216|
0000ba  bf00              NOP                            ;388
                  |L1.188|
0000bc  f8160b01          LDRB     r0,[r6],#1            ;388
0000c0  eb002100          ADD      r1,r0,r0,LSL #8       ;388
0000c4  eb014000          ADD      r0,r1,r0,LSL #16      ;388
0000c8  f7fffffe          BL       LCD_SetColor
0000cc  4638              MOV      r0,r7                 ;388
0000ce  1c7f              ADDS     r7,r7,#1              ;388
0000d0  4659              MOV      r1,r11                ;388
0000d2  f7fffffe          BL       LCD_DrawPixel
0000d6  1e6d              SUBS     r5,r5,#1              ;388
                  |L1.216|
0000d8  b1a5              CBZ      r5,|L1.260|
0000da  e7ef              B        |L1.188|
                  |L1.220|
0000dc  f8150b01          LDRB     r0,[r5],#1            ;388
0000e0  f8151b01          LDRB     r1,[r5],#1            ;388
0000e4  f8152b01          LDRB     r2,[r5],#1            ;388
0000e8  ea402001          ORR      r0,r0,r1,LSL #8       ;388
0000ec  ea404002          ORR      r0,r0,r2,LSL #16      ;388
0000f0  f7fffffe          BL       LCD_SetColor
0000f4  4630              MOV      r0,r6                 ;388
0000f6  1c76              ADDS     r6,r6,#1              ;388
0000f8  4659              MOV      r1,r11                ;388
0000fa  f7fffffe          BL       LCD_DrawPixel
0000fe  1e7f              SUBS     r7,r7,#1              ;388
                  |L1.256|
000100  2f00              CMP      r7,#0                 ;388
000102  d1eb              BNE      |L1.220|
                  |L1.260|
000104  991d              LDR      r1,[sp,#0x74]         ;383
000106  9823              LDR      r0,[sp,#0x8c]         ;383
000108  4288              CMP      r0,r1                 ;383
00010a  d3bb              BCC      |L1.132|
;;;391          }
;;;392        }
;;;393        /* 7. jpeg_finish_decompress(...); */
;;;394        /*    Complete the decompression cycle.  This causes working memory associated */
;;;395        /*    with the JPEG object to be released. */
;;;396    	  jpeg_finish_decompress(&cinfo);
00010c  4668              MOV      r0,sp
00010e  f7fffffe          BL       jpeg_finish_decompress
;;;397        /* 8. Release the JPEG decompression object. */
;;;398        jpeg_destroy_decompress(&cinfo);
000112  4668              MOV      r0,sp
000114  f7fffffe          BL       jpeg_destroy_decompress
;;;399      #if (GUI_WINSUPPORT)
;;;400        } WM_ITERATE_END();
000118  f7fffffe          BL       WM__GetNextIVR
00011c  2800              CMP      r0,#0
00011e  d199              BNE      |L1.84|
                  |L1.288|
;;;401      #endif
;;;402      GUI_ALLOC_Free(hBuffer);
000120  4648              MOV      r0,r9
000122  f7fffffe          BL       GUI_ALLOC_Free
;;;403      GUI_UNLOCK();
;;;404      return Ret;
;;;405    }
000126  f50d7d1d          ADD      sp,sp,#0x274
00012a  4650              MOV      r0,r10                ;404
00012c  e8bd8ff0          POP      {r4-r11,pc}
;;;406    
                          ENDP

                  |L1.304|
                          DCD      GUI_Context

                          AREA ||i.GUI_JPEG_GetInfo||, CODE, READONLY, ALIGN=1

                  GUI_JPEG_GetInfo PROC
;;;335    */
;;;336    int GUI_JPEG_GetInfo(const void * pFileData, int DataSize, GUI_JPEG_INFO* pInfo) {
000000  b510              PUSH     {r4,lr}
000002  f5ad7d16          SUB      sp,sp,#0x258
000006  4614              MOV      r4,r2
;;;337    	struct jpeg_decompress_struct cinfo;
;;;338    	struct jpeg_error_mgr jerr;
;;;339      _Init(&jerr, &cinfo, pFileData, DataSize);
000008  460b              MOV      r3,r1
00000a  4602              MOV      r2,r0
00000c  4669              MOV      r1,sp
00000e  a874              ADD      r0,sp,#0x1d0
000010  f7fffffe          BL       _Init
;;;340      /*
;;;341       * Release the JPEG decompression object.
;;;342       */
;;;343      jpeg_destroy_decompress(&cinfo);
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       jpeg_destroy_decompress
;;;344      if (pInfo) {
00001a  b11c              CBZ      r4,|L2.36|
;;;345        pInfo->XSize = cinfo.image_width;
00001c  9807              LDR      r0,[sp,#0x1c]
;;;346        pInfo->YSize = cinfo.image_height;
00001e  6020              STR      r0,[r4,#0]
000020  9808              LDR      r0,[sp,#0x20]
000022  6060              STR      r0,[r4,#4]
                  |L2.36|
;;;347      }
;;;348      return 0;
;;;349    }
000024  f50d7d16          ADD      sp,sp,#0x258
000028  2000              MOVS     r0,#0                 ;348
00002a  bd10              POP      {r4,pc}
;;;350    
                          ENDP


                          AREA ||i._FillInputBuffer||, CODE, READONLY, ALIGN=2

                  _FillInputBuffer PROC
;;;104    
;;;105    static boolean _FillInputBuffer(j_decompress_ptr cinfo) {
000000  b570              PUSH     {r4-r6,lr}
;;;106      SOURCE_MANAGER* pSrc = (SOURCE_MANAGER*) cinfo->src;
000002  6984              LDR      r4,[r0,#0x18]
000004  4605              MOV      r5,r0                 ;105
000006  e9d41008          LDRD     r1,r0,[r4,#0x20]
;;;107      size_t nbytes;
;;;108      int RemBytes = pSrc->FileSize - pSrc->Off;
00000a  1a09              SUBS     r1,r1,r0
;;;109      if (RemBytes > 0) {
00000c  2900              CMP      r1,#0
00000e  dd0b              BLE      |L3.40|
;;;110        nbytes = (RemBytes > INPUT_BUF_SIZE) ? INPUT_BUF_SIZE : RemBytes;
000010  f44f5280          MOV      r2,#0x1000
000014  4291              CMP      r1,r2
000016  dd00              BLE      |L3.26|
000018  4611              MOV      r1,r2
                  |L3.26|
;;;111        pSrc->pub.next_input_byte = pSrc->pFileData + pSrc->Off;
00001a  69e2              LDR      r2,[r4,#0x1c]
00001c  4410              ADD      r0,r0,r2
;;;112        pSrc->Off += nbytes;
00001e  6020              STR      r0,[r4,#0]
000020  6a60              LDR      r0,[r4,#0x24]
000022  4408              ADD      r0,r0,r1
000024  6260              STR      r0,[r4,#0x24]
000026  e014              B        |L3.82|
                  |L3.40|
;;;113      } else {
;;;114        if (pSrc->start_of_file)	/* Treat empty input file as fatal error */
000028  6aa0              LDR      r0,[r4,#0x28]
00002a  b130              CBZ      r0,|L3.58|
;;;115          ERREXIT(cinfo, JERR_INPUT_EMPTY);
00002c  6829              LDR      r1,[r5,#0]
00002e  202a              MOVS     r0,#0x2a
000030  6148              STR      r0,[r1,#0x14]
000032  6828              LDR      r0,[r5,#0]
000034  6801              LDR      r1,[r0,#0]
000036  4628              MOV      r0,r5
000038  4788              BLX      r1
                  |L3.58|
;;;116        WARNMS(cinfo, JWRN_JPEG_EOF);
00003a  6829              LDR      r1,[r5,#0]
00003c  2078              MOVS     r0,#0x78
00003e  6148              STR      r0,[r1,#0x14]
000040  6828              LDR      r0,[r5,#0]
000042  f04f31ff          MOV      r1,#0xffffffff
000046  6842              LDR      r2,[r0,#4]
000048  4628              MOV      r0,r5
00004a  4790              BLX      r2
;;;117        /* Insert a fake EOI marker */
;;;118        nbytes = 2;
;;;119        pSrc->pub.next_input_byte = _abEnd;
00004c  4803              LDR      r0,|L3.92|
00004e  2102              MOVS     r1,#2                 ;118
000050  6020              STR      r0,[r4,#0]
                  |L3.82|
;;;120      }
;;;121    
;;;122      pSrc->pub.bytes_in_buffer = nbytes;
;;;123      pSrc->start_of_file = FALSE;
000052  2000              MOVS     r0,#0
;;;124      return TRUE;
000054  6061              STR      r1,[r4,#4]
000056  62a0              STR      r0,[r4,#0x28]
000058  2001              MOVS     r0,#1
;;;125    }
00005a  bd70              POP      {r4-r6,pc}
;;;126    
                          ENDP

                  |L3.92|
                          DCD      ||.constdata||

                          AREA ||i._Init||, CODE, READONLY, ALIGN=2

                  _Init PROC
;;;285    */
;;;286    static void _Init(struct jpeg_error_mgr* pjerr, struct jpeg_decompress_struct *pcinfo, const void * pFileData, int DataSize) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  461e              MOV      r6,r3
000006  4617              MOV      r7,r2
000008  460d              MOV      r5,r1
;;;287      /* 1. Allocate and initialize a JPEG decompression object. */
;;;288      pcinfo->err = jpeg_std_error(pjerr);
00000a  f7fffffe          BL       jpeg_std_error
;;;289    	jpeg_create_decompress(pcinfo);
00000e  6028              STR      r0,[r5,#0]
000010  f44f72e8          MOV      r2,#0x1d0
000014  213e              MOVS     r1,#0x3e
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       jpeg_CreateDecompress
00001c  69a8              LDR      r0,[r5,#0x18]
00001e  b930              CBNZ     r0,|L4.46|
000020  6868              LDR      r0,[r5,#4]
000022  222c              MOVS     r2,#0x2c
000024  2100              MOVS     r1,#0
000026  6803              LDR      r3,[r0,#0]
000028  4628              MOV      r0,r5
00002a  4798              BLX      r3
00002c  61a8              STR      r0,[r5,#0x18]
                  |L4.46|
00002e  69ac              LDR      r4,[r5,#0x18]
000030  480a              LDR      r0,|L4.92|
000032  60a0              STR      r0,[r4,#8]
000034  480a              LDR      r0,|L4.96|
000036  60e0              STR      r0,[r4,#0xc]
000038  480a              LDR      r0,|L4.100|
00003a  6120              STR      r0,[r4,#0x10]
00003c  480a              LDR      r0,|L4.104|
00003e  6160              STR      r0,[r4,#0x14]
000040  480a              LDR      r0,|L4.108|
000042  61a0              STR      r0,[r4,#0x18]
000044  2000              MOVS     r0,#0
000046  6060              STR      r0,[r4,#4]
000048  61e7              STR      r7,[r4,#0x1c]
00004a  6020              STR      r0,[r4,#0]
00004c  e9c46008          STRD     r6,r0,[r4,#0x20]
;;;290      /* 2. Init the source manager so the library can retrieve data via methods */
;;;291      _InitSrc(pcinfo, (const U8*)pFileData, DataSize);
;;;292      /* 3. Call jpeg_read_header() to obtain image info. */
;;;293    	jpeg_read_header(pcinfo, TRUE);
000050  4628              MOV      r0,r5
000052  e8bd41f0          POP      {r4-r8,lr}
000056  2101              MOVS     r1,#1
000058  f7ffbffe          B.W      jpeg_read_header
;;;294    }
;;;295    
                          ENDP

                  |L4.92|
                          DCD      _InitSource
                  |L4.96|
                          DCD      _FillInputBuffer
                  |L4.100|
                          DCD      _SkipInputData
                  |L4.104|
                          DCD      jpeg_resync_to_restart
                  |L4.108|
                          DCD      _TermSource

                          AREA ||i._InitSource||, CODE, READONLY, ALIGN=1

                  _InitSource PROC
;;;61     
;;;62     static void _InitSource (j_decompress_ptr cinfo) {
000000  6980              LDR      r0,[r0,#0x18]
;;;63       SOURCE_MANAGER* pSrc = (SOURCE_MANAGER*) cinfo->src;
;;;64     
;;;65       /* We reset the empty-input-file flag for each image,
;;;66        * but we don't clear the input buffer.
;;;67        * This is correct behavior for reading a series of images from one source.
;;;68        */
;;;69       pSrc->start_of_file = TRUE;
000002  2101              MOVS     r1,#1
000004  6281              STR      r1,[r0,#0x28]
;;;70     }
000006  4770              BX       lr
;;;71     
                          ENDP


                          AREA ||i._SkipInputData||, CODE, READONLY, ALIGN=1

                  _SkipInputData PROC
;;;138    
;;;139    static void _SkipInputData (j_decompress_ptr cinfo, long num_bytes) {
000000  b570              PUSH     {r4-r6,lr}
000002  6985              LDR      r5,[r0,#0x18]
000004  1e0c              SUBS     r4,r1,#0
000006  4606              MOV      r6,r0
000008  dc04              BGT      |L6.20|
;;;140      SOURCE_MANAGER* pSrc = (SOURCE_MANAGER*) cinfo->src;
;;;141      /* Just a dumb implementation for now.  Could use fseek() except
;;;142       * it doesn't work on pipes.  Not clear that being smart is worth
;;;143       * any trouble anyway --- large skips are infrequent.
;;;144       */
;;;145      if (num_bytes > 0) {
;;;146        while (num_bytes > (long) pSrc->pub.bytes_in_buffer) {
;;;147          num_bytes -= (long) pSrc->pub.bytes_in_buffer;
;;;148          (void) _FillInputBuffer(cinfo);
;;;149          /* note we assume that fill_input_buffer will never return FALSE,
;;;150           * so suspension need not be handled.
;;;151           */
;;;152        }
;;;153        pSrc->pub.next_input_byte += (size_t) num_bytes;
;;;154        pSrc->pub.bytes_in_buffer -= (size_t) num_bytes;
;;;155      }
;;;156    }
00000a  bd70              POP      {r4-r6,pc}
                  |L6.12|
00000c  1a24              SUBS     r4,r4,r0              ;147
00000e  4630              MOV      r0,r6                 ;148
000010  f7fffffe          BL       _FillInputBuffer
                  |L6.20|
000014  6868              LDR      r0,[r5,#4]            ;146
000016  42a0              CMP      r0,r4                 ;146
000018  dbf8              BLT      |L6.12|
00001a  6828              LDR      r0,[r5,#0]            ;153
00001c  4420              ADD      r0,r0,r4              ;153
00001e  6028              STR      r0,[r5,#0]            ;154
000020  6868              LDR      r0,[r5,#4]            ;154
000022  1b00              SUBS     r0,r0,r4              ;154
000024  6068              STR      r0,[r5,#4]            ;154
000026  bd70              POP      {r4-r6,pc}
;;;157    /*
                          ENDP


                          AREA ||i._TermSource||, CODE, READONLY, ALIGN=1

                  _TermSource PROC
;;;174    
;;;175    static void _TermSource(j_decompress_ptr cinfo) {
000000  4770              BX       lr
;;;176      /* no work necessary here */
;;;177      GUI_USE_PARA(cinfo);
;;;178    }
;;;179    
                          ENDP


                          AREA ||i.jpeg_free_small||, CODE, READONLY, ALIGN=2

                  jpeg_free_small PROC
;;;230    
;;;231    GLOBAL(void) jpeg_free_small (j_common_ptr cinfo, void * object, size_t sizeofobject) {
000000  4a04              LDR      r2,|L8.20|
000002  4608              MOV      r0,r1
;;;232      GUI_USE_PARA(cinfo);
;;;233      GUI_USE_PARA(sizeofobject);
;;;234      if (--AllocCnt) {
000004  6811              LDR      r1,[r2,#0]  ; AllocCnt
000006  1e49              SUBS     r1,r1,#1
000008  6011              STR      r1,[r2,#0]            ;231  ; AllocCnt
00000a  d001              BEQ      |L8.16|
;;;235        TotalSize = 0;
00000c  2100              MOVS     r1,#0
00000e  6051              STR      r1,[r2,#4]  ; TotalSize
                  |L8.16|
;;;236      }
;;;237      free(object);
000010  f7ffbffe          B.W      free
;;;238    }
;;;239    
                          ENDP

                  |L8.20|
                          DCD      ||.data||

                          AREA ||i.jpeg_get_small||, CODE, READONLY, ALIGN=2

                  jpeg_get_small PROC
;;;223    
;;;224    GLOBAL(void *) jpeg_get_small (j_common_ptr cinfo, size_t sizeofobject) {
000000  4a04              LDR      r2,|L9.20|
000002  4608              MOV      r0,r1
;;;225      GUI_USE_PARA(cinfo);
;;;226      AllocCnt++;
000004  6811              LDR      r1,[r2,#0]  ; AllocCnt
000006  1c49              ADDS     r1,r1,#1
;;;227      TotalSize += sizeofobject;
000008  6011              STR      r1,[r2,#0]  ; AllocCnt
00000a  6851              LDR      r1,[r2,#4]  ; TotalSize
00000c  4401              ADD      r1,r1,r0
;;;228      return (void *) malloc(sizeofobject);
00000e  6051              STR      r1,[r2,#4]  ; TotalSize
000010  f7ffbffe          B.W      malloc
;;;229    }
;;;230    
                          ENDP

                  |L9.20|
                          DCD      ||.data||

                          AREA ||i.jpeg_mem_available||, CODE, READONLY, ALIGN=1

                  jpeg_mem_available PROC
;;;244    
;;;245    GLOBAL(long) jpeg_mem_available (j_common_ptr cinfo, long min_bytes_needed, long max_bytes_needed, long already_allocated) {
000000  4610              MOV      r0,r2
;;;246      GUI_USE_PARA(cinfo);
;;;247      GUI_USE_PARA(min_bytes_needed);
;;;248      GUI_USE_PARA(already_allocated);
;;;249      return max_bytes_needed;
;;;250    }
000002  4770              BX       lr
;;;251    
                          ENDP


                          AREA ||i.jpeg_mem_init||, CODE, READONLY, ALIGN=1

                  jpeg_mem_init PROC
;;;258    
;;;259    GLOBAL(long) jpeg_mem_init (j_common_ptr cinfo) { 
000000  2000              MOVS     r0,#0
;;;260      GUI_USE_PARA(cinfo);
;;;261      return 0;
;;;262    }
000002  4770              BX       lr
;;;263    
                          ENDP


                          AREA ||i.jpeg_mem_term||, CODE, READONLY, ALIGN=1

                  jpeg_mem_term PROC
;;;263    
;;;264    GLOBAL(void) jpeg_mem_term (j_common_ptr cinfo) {
000000  4770              BX       lr
;;;265      GUI_USE_PARA(cinfo);
;;;266    }
;;;267    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  _abEnd
000000  ffd9              DCB      0xff,0xd9

                          AREA ||.data||, DATA, ALIGN=2

                  AllocCnt
                          DCD      0x00000000
                  TotalSize
                          DCD      0x00000000
